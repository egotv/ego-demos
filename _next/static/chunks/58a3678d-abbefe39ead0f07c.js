"use strict";
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
  [2918],
  {
    62249: function (_, I, R) {
      let B,
        z,
        k,
        V,
        j,
        G,
        q,
        X,
        Q,
        $,
        et,
        er,
        es,
        ea,
        en,
        eo,
        el,
        eh,
        ec,
        ed,
        ep,
        ef,
        em,
        ey,
        ex,
        eb,
        ew,
        e_,
        eS,
        eA,
        eC,
        eT,
        eP,
        eI,
        eR,
        eB,
        ez,
        eF,
        ek,
        eU,
        eV,
        ej,
        eH,
        eW,
        eq,
        eX,
        eQ,
        eZ,
        eK,
        eJ,
        e$,
        e0,
        e3,
        e4,
        e5,
        e6,
        e8,
        e9,
        e7,
        te,
        tt,
        tr,
        ts,
        ta,
        tn,
        to,
        tl,
        th,
        tc,
        td,
        tu,
        tp,
        tf,
        tm,
        tg,
        tx,
        tb,
        tw,
        t_,
        tS,
        tA,
        tT,
        tP,
        tD,
        tI,
        tR,
        tB,
        tz,
        tF,
        tN,
        tk,
        tU,
        tV,
        tj,
        tH,
        tW,
        tq,
        tX,
        tQ,
        tZ,
        tK,
        tJ,
        t$,
        t0,
        t2,
        t3,
        t4,
        t5,
        t6,
        t8,
        t9,
        t7,
        it,
        ii,
        ir,
        is,
        il,
        ih,
        ic,
        id,
        iu,
        ip,
        im,
        iy,
        ix,
        ib;
      R.d(I, {
        M: function () {
          return Rl;
        },
      });
      var iw,
        i_,
        iS = R(83454),
        iA = R(48764).lW,
        iM = Object.create,
        iT = Object.defineProperty,
        iP = Object.getOwnPropertyDescriptor,
        iD = Object.getOwnPropertyNames,
        iB = Object.getPrototypeOf,
        iL = Object.prototype.hasOwnProperty,
        iF = (_, I, R) =>
          I in _
            ? iT(_, I, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: R,
              })
            : (_[I] = R),
        zi = (_, I) => () => (
          I || _((I = { exports: {} }).exports, I), I.exports
        ),
        sF = (_, I, R, B) => {
          if ((I && "object" == typeof I) || "function" == typeof I)
            for (let z of iD(I))
              iL.call(_, z) ||
                z === R ||
                iT(_, z, {
                  get: () => I[z],
                  enumerable: !(B = iP(I, z)) || B.enumerable,
                });
          return _;
        },
        pi = (_, I, R) => (
          (R = null != _ ? iM(iB(_)) : {}),
          sF(
            !I && _ && _.__esModule
              ? R
              : iT(R, "default", { value: _, enumerable: !0 }),
            _
          )
        ),
        Ui = (_, I, R) => (iF(_, "symbol" != typeof I ? I + "" : I, R), R),
        iz = zi((_, I) => {
          var R;
          (R = function () {
            return (
              (n.importState = function (_) {
                var I = new n();
                return I.importState(_), I;
              }),
              n
            );
            function n() {
              return (function (_) {
                var I,
                  R,
                  B = 0,
                  z = 0,
                  k = 0,
                  V = 1;
                0 == _.length && (_ = [+new Date()]);
                var j =
                  ((I = 4022871197),
                  ((R = function (_) {
                    _ = _.toString();
                    for (var R = 0; R < _.length; R++) {
                      var B = 0.02519603282416938 * (I += _.charCodeAt(R));
                      (I = B >>> 0),
                        (B -= I),
                        (B *= I),
                        (I = B >>> 0),
                        (B -= I),
                        (I += 4294967296 * B);
                    }
                    return (I >>> 0) * 23283064365386963e-26;
                  }).version = "Mash 0.9"),
                  R);
                (B = j(" ")), (z = j(" ")), (k = j(" "));
                for (var G = 0; G < _.length; G++)
                  (B -= j(_[G])) < 0 && (B += 1),
                    (z -= j(_[G])) < 0 && (z += 1),
                    (k -= j(_[G])) < 0 && (k += 1);
                j = null;
                var u = function () {
                  var _ = 2091639 * B + 23283064365386963e-26 * V;
                  return (B = z), (z = k), (k = _ - (V = 0 | _));
                };
                return (
                  (u.next = u),
                  (u.uint32 = function () {
                    return 4294967296 * u();
                  }),
                  (u.fract53 = function () {
                    return u() + ((2097152 * u()) | 0) * 11102230246251565e-32;
                  }),
                  (u.version = "Alea 0.9"),
                  (u.args = _),
                  (u.exportState = function () {
                    return [B, z, k, V];
                  }),
                  (u.importState = function (_) {
                    (B = +_[0] || 0),
                      (z = +_[1] || 0),
                      (k = +_[2] || 0),
                      (V = +_[3] || 0);
                  }),
                  u
                );
              })(Array.prototype.slice.call(arguments));
            }
          }),
            "object" == typeof _
              ? (I.exports = R())
              : "function" == typeof define && define.amd
              ? define(R)
              : (_.Alea = R());
        }),
        iN = zi((_, I) => {
          var R, B;
          (R = _),
            (B = function (_) {
              (_.SVD = function (_, I, R, B, z) {
                if (
                  ((I = void 0 === I || I),
                  (R = void 0 === R || R),
                  (z = 1e-64 / (B = B || 2220446049250313e-31)),
                  !_)
                )
                  throw TypeError("Matrix a is not defined");
                var k,
                  V,
                  j,
                  G,
                  q,
                  X,
                  Q,
                  $,
                  et,
                  er,
                  es,
                  ea,
                  en = _[0].length,
                  eo = _.length;
                if (eo < en) throw TypeError("Invalid matrix: m < n");
                for (
                  var el = [],
                    eh = [],
                    ec = [],
                    ed = "f" === I ? eo : en,
                    ep = (er = Q = 0);
                  ep < eo;
                  ep++
                )
                  eh[ep] = Array(ed).fill(0);
                for (ep = 0; ep < en; ep++) ec[ep] = Array(en).fill(0);
                var ef,
                  em = Array(en).fill(0);
                for (ep = 0; ep < eo; ep++)
                  for (k = 0; k < en; k++) eh[ep][k] = _[ep][k];
                for (ep = 0; ep < en; ep++) {
                  for (el[ep] = Q, et = 0, j = ep + 1, k = ep; k < eo; k++)
                    et += Math.pow(eh[k][ep], 2);
                  if (et < z) Q = 0;
                  else
                    for (
                      $ =
                        (X = eh[ep][ep]) *
                          (Q = X < 0 ? Math.sqrt(et) : -Math.sqrt(et)) -
                        et,
                        eh[ep][ep] = X - Q,
                        k = j;
                      k < en;
                      k++
                    ) {
                      for (et = 0, V = ep; V < eo; V++)
                        et += eh[V][ep] * eh[V][k];
                      for (X = et / $, V = ep; V < eo; V++)
                        eh[V][k] = eh[V][k] + X * eh[V][ep];
                    }
                  for (em[ep] = Q, et = 0, k = j; k < en; k++)
                    et += Math.pow(eh[ep][k], 2);
                  if (et < z) Q = 0;
                  else {
                    for (
                      $ =
                        (X = eh[ep][ep + 1]) *
                          (Q = X < 0 ? Math.sqrt(et) : -Math.sqrt(et)) -
                        et,
                        eh[ep][ep + 1] = X - Q,
                        k = j;
                      k < en;
                      k++
                    )
                      el[k] = eh[ep][k] / $;
                    for (k = j; k < eo; k++) {
                      for (et = 0, V = j; V < en; V++)
                        et += eh[k][V] * eh[ep][V];
                      for (V = j; V < en; V++) eh[k][V] = eh[k][V] + et * el[V];
                    }
                  }
                  er < (es = Math.abs(em[ep]) + Math.abs(el[ep])) && (er = es);
                }
                if (R)
                  for (ep = en - 1; 0 <= ep; ep--) {
                    if (0 !== Q) {
                      for ($ = eh[ep][ep + 1] * Q, k = j; k < en; k++)
                        ec[k][ep] = eh[ep][k] / $;
                      for (k = j; k < en; k++) {
                        for (et = 0, V = j; V < en; V++)
                          et += eh[ep][V] * ec[V][k];
                        for (V = j; V < en; V++)
                          ec[V][k] = ec[V][k] + et * ec[V][ep];
                      }
                    }
                    for (k = j; k < en; k++) (ec[ep][k] = 0), (ec[k][ep] = 0);
                    (ec[ep][ep] = 1), (Q = el[ep]), (j = ep);
                  }
                if (I) {
                  if ("f" === I)
                    for (ep = en; ep < eo; ep++) {
                      for (k = en; k < eo; k++) eh[ep][k] = 0;
                      eh[ep][ep] = 1;
                    }
                  for (ep = en - 1; 0 <= ep; ep--) {
                    for (j = ep + 1, Q = em[ep], k = j; k < ed; k++)
                      eh[ep][k] = 0;
                    if (0 !== Q) {
                      for ($ = eh[ep][ep] * Q, k = j; k < ed; k++) {
                        for (et = 0, V = j; V < eo; V++)
                          et += eh[V][ep] * eh[V][k];
                        for (X = et / $, V = ep; V < eo; V++)
                          eh[V][k] = eh[V][k] + X * eh[V][ep];
                      }
                      for (k = ep; k < eo; k++) eh[k][ep] = eh[k][ep] / Q;
                    } else for (k = ep; k < eo; k++) eh[k][ep] = 0;
                    eh[ep][ep] = eh[ep][ep] + 1;
                  }
                }
                for (B *= er, V = en - 1; 0 <= V; V--)
                  for (var ey = 0; ey < 50; ey++) {
                    for (ef = !1, j = V; 0 <= j; j--) {
                      if (Math.abs(el[j]) <= B) {
                        ef = !0;
                        break;
                      }
                      if (Math.abs(em[j - 1]) <= B) break;
                    }
                    if (!ef) {
                      for (
                        q = 0, G = j - (et = 1), ep = j;
                        ep < V + 1 &&
                        ((X = et * el[ep]),
                        (el[ep] = q * el[ep]),
                        !(Math.abs(X) <= B));
                        ep++
                      )
                        if (
                          ((Q = em[ep]),
                          (em[ep] = Math.sqrt(X * X + Q * Q)),
                          (q = Q / ($ = em[ep])),
                          (et = -X / $),
                          I)
                        )
                          for (k = 0; k < eo; k++)
                            (es = eh[k][G]),
                              (ea = eh[k][ep]),
                              (eh[k][G] = es * q + ea * et),
                              (eh[k][ep] = -es * et + ea * q);
                    }
                    if (((ea = em[V]), j === V)) {
                      if (ea < 0 && ((em[V] = -ea), R))
                        for (k = 0; k < en; k++) ec[k][V] = -ec[k][V];
                      break;
                    }
                    for (
                      er = em[j],
                        Q = Math.sqrt(
                          (X =
                            (((es = em[V - 1]) - ea) * (es + ea) +
                              ((Q = el[V - 1]) - ($ = el[V])) * (Q + $)) /
                            (2 * $ * es)) *
                            X +
                            1
                        ),
                        X =
                          ((er - ea) * (er + ea) +
                            $ * (es / (X < 0 ? X - Q : X + Q) - $)) /
                          er,
                        ep = j + (et = q = 1);
                      ep < V + 1;
                      ep++
                    ) {
                      if (
                        ((Q = el[ep]),
                        (es = em[ep]),
                        ($ = et * Q),
                        (Q *= q),
                        (ea = Math.sqrt(X * X + $ * $)),
                        (X =
                          er * (q = X / (el[ep - 1] = ea)) + Q * (et = $ / ea)),
                        (Q = -er * et + Q * q),
                        ($ = es * et),
                        (es *= q),
                        R)
                      )
                        for (k = 0; k < en; k++)
                          (er = ec[k][ep - 1]),
                            (ea = ec[k][ep]),
                            (ec[k][ep - 1] = er * q + ea * et),
                            (ec[k][ep] = -er * et + ea * q);
                      if (
                        ((ea = Math.sqrt(X * X + $ * $)),
                        (X =
                          (q = X / (em[ep - 1] = ea)) * Q + (et = $ / ea) * es),
                        (er = -et * Q + q * es),
                        I)
                      )
                        for (k = 0; k < eo; k++)
                          (es = eh[k][ep - 1]),
                            (ea = eh[k][ep]),
                            (eh[k][ep - 1] = es * q + ea * et),
                            (eh[k][ep] = -es * et + ea * q);
                    }
                    (el[j] = 0), (el[V] = X), (em[V] = er);
                  }
                for (ep = 0; ep < en; ep++) em[ep] < B && (em[ep] = 0);
                return { u: eh, q: em, v: ec };
              }),
                (_.VERSION = "1.1.1"),
                Object.defineProperty(_, "__esModule", { value: !0 });
            }),
            "object" == typeof _ && "u" > typeof I
              ? B(_)
              : "function" == typeof define && define.amd
              ? define(["exports"], B)
              : B(
                  ((R =
                    "u" > typeof globalThis ? globalThis : R || self).SVDJS =
                    {})
                );
        }),
        ik = zi((_, I) => {
          var R, B;
          (R = _),
            (B = function () {
              var n = function (_, I) {
                if (
                  (void 0 === _ && (_ = []),
                  void 0 === I && (I = t),
                  (this.data = _),
                  (this.length = this.data.length),
                  (this.compare = I),
                  this.length > 0)
                )
                  for (var R = (this.length >> 1) - 1; R >= 0; R--)
                    this._down(R);
              };
              function t(_, I) {
                return _ < I ? -1 : _ > I ? 1 : 0;
              }
              return (
                (n.prototype.push = function (_) {
                  this.data.push(_), this.length++, this._up(this.length - 1);
                }),
                (n.prototype.pop = function () {
                  if (0 !== this.length) {
                    var _ = this.data[0],
                      I = this.data.pop();
                    return (
                      this.length--,
                      this.length > 0 && ((this.data[0] = I), this._down(0)),
                      _
                    );
                  }
                }),
                (n.prototype.peek = function () {
                  return this.data[0];
                }),
                (n.prototype._up = function (_) {
                  for (var I = this.data, R = this.compare, B = I[_]; _ > 0; ) {
                    var z = (_ - 1) >> 1,
                      k = I[z];
                    if (R(B, k) >= 0) break;
                    (I[_] = k), (_ = z);
                  }
                  I[_] = B;
                }),
                (n.prototype._down = function (_) {
                  for (
                    var I = this.data,
                      R = this.compare,
                      B = this.length >> 1,
                      z = I[_];
                    _ < B;

                  ) {
                    var k = (_ << 1) + 1,
                      V = I[k],
                      j = k + 1;
                    if (
                      (j < this.length &&
                        0 > R(I[j], V) &&
                        ((k = j), (V = I[j])),
                      R(V, z) >= 0)
                    )
                      break;
                    (I[_] = V), (_ = k);
                  }
                  I[_] = z;
                }),
                n
              );
            }),
            "object" == typeof _ && "u" > typeof I
              ? (I.exports = B())
              : "function" == typeof define && define.amd
              ? define(B)
              : ((R = R || self).TinyQueue = B());
        }),
        iU = zi((_, I) => {
          var R = ik();
          function oI(_, I, B) {
            I = I || 1;
            for (var z, k, V, j, G = 0; G < _[0].length; G++) {
              var q = _[0][G];
              (!G || q[0] < z) && (z = q[0]),
                (!G || q[1] < k) && (k = q[1]),
                (!G || q[0] > V) && (V = q[0]),
                (!G || q[1] > j) && (j = q[1]);
            }
            var X = V - z,
              Q = j - k,
              $ = Math.min(X, Q),
              et = $ / 2;
            if (0 === $) {
              var er = [z, k];
              return (er.distance = 0), er;
            }
            for (var es = new R(void 0, b7), ea = z; ea < V; ea += $)
              for (var en = k; en < j; en += $)
                es.push(new jl(ea + et, en + et, et, _));
            var eo = (function (_) {
                for (
                  var I = 0,
                    R = 0,
                    B = 0,
                    z = _[0],
                    k = 0,
                    V = z.length,
                    j = V - 1;
                  k < V;
                  j = k++
                ) {
                  var G = z[k],
                    q = z[j],
                    X = G[0] * q[1] - q[0] * G[1];
                  (R += (G[0] + q[0]) * X),
                    (B += (G[1] + q[1]) * X),
                    (I += 3 * X);
                }
                return 0 === I
                  ? new jl(z[0][0], z[0][1], 0, _)
                  : new jl(R / I, B / I, 0, _);
              })(_),
              el = new jl(z + X / 2, k + Q / 2, 0, _);
            el.d > eo.d && (eo = el);
            for (var eh = es.length; es.length; ) {
              var ec = es.pop();
              ec.d > eo.d &&
                ((eo = ec),
                B &&
                  console.log(
                    "found best %d after %d probes",
                    Math.round(1e4 * ec.d) / 1e4,
                    eh
                  )),
                ec.max - eo.d <= I ||
                  ((et = ec.h / 2),
                  es.push(new jl(ec.x - et, ec.y - et, et, _)),
                  es.push(new jl(ec.x + et, ec.y - et, et, _)),
                  es.push(new jl(ec.x - et, ec.y + et, et, _)),
                  es.push(new jl(ec.x + et, ec.y + et, et, _)),
                  (eh += 4));
            }
            B &&
              (console.log("num probes: " + eh),
              console.log("best distance: " + eo.d));
            var ed = [eo.x, eo.y];
            return (ed.distance = eo.d), ed;
          }
          function b7(_, I) {
            return I.max - _.max;
          }
          function jl(_, I, R, B) {
            (this.x = _),
              (this.y = I),
              (this.h = R),
              (this.d = (function (_, I, R) {
                for (var B = !1, z = 1 / 0, k = 0; k < R.length; k++)
                  for (
                    var V = R[k], j = 0, G = V.length, q = G - 1;
                    j < G;
                    q = j++
                  ) {
                    var X = V[j],
                      Q = V[q];
                    X[1] > I != Q[1] > I &&
                      _ < ((Q[0] - X[0]) * (I - X[1])) / (Q[1] - X[1]) + X[0] &&
                      (B = !B),
                      (z = Math.min(
                        z,
                        (function (_, I, R, B) {
                          var z = R[0],
                            k = R[1],
                            V = B[0] - z,
                            j = B[1] - k;
                          if (0 !== V || 0 !== j) {
                            var G =
                              ((_ - z) * V + (I - k) * j) / (V * V + j * j);
                            G > 1
                              ? ((z = B[0]), (k = B[1]))
                              : G > 0 && ((z += V * G), (k += j * G));
                          }
                          return (V = _ - z) * V + (j = I - k) * j;
                        })(_, I, X, Q)
                      ));
                  }
                return 0 === z ? 0 : (B ? 1 : -1) * Math.sqrt(z);
              })(_, I, B)),
              (this.max = this.d + this.h * Math.SQRT2);
          }
          R.default && (R = R.default),
            (I.exports = oI),
            (I.exports.default = oI);
        }),
        iV = zi((_, I) => {
          Object.defineProperty(_, "__esModule", { value: !0 }),
            (_.default = function (_) {
              if (null === _ || !0 === _ || !1 === _) return NaN;
              var I = Number(_);
              return isNaN(I) ? I : I < 0 ? Math.ceil(I) : Math.floor(I);
            }),
            (I.exports = _.default);
        }),
        ij = zi((_, I) => {
          Object.defineProperty(_, "__esModule", { value: !0 }),
            (_.default = function (_) {
              var I = new Date(
                Date.UTC(
                  _.getFullYear(),
                  _.getMonth(),
                  _.getDate(),
                  _.getHours(),
                  _.getMinutes(),
                  _.getSeconds(),
                  _.getMilliseconds()
                )
              );
              return (
                I.setUTCFullYear(_.getFullYear()), _.getTime() - I.getTime()
              );
            }),
            (I.exports = _.default);
        }),
        iH = zi((_) => {
          var I, R, B, z, k, V, j, G, q, X, Q, $, et, er;
          ((I = function () {
            this.init();
          }).prototype = {
            init: function () {
              var _ = this || R;
              return (
                (_._counter = 1e3),
                (_._html5AudioPool = []),
                (_.html5PoolSize = 10),
                (_._codecs = {}),
                (_._howls = []),
                (_._muted = !1),
                (_._volume = 1),
                (_._canPlayEvent = "canplaythrough"),
                (_._navigator =
                  "u" > typeof window && window.navigator
                    ? window.navigator
                    : null),
                (_.masterGain = null),
                (_.noAudio = !1),
                (_.usingWebAudio = !0),
                (_.autoSuspend = !0),
                (_.ctx = null),
                (_.autoUnlock = !0),
                _._setup(),
                _
              );
            },
            volume: function (_) {
              var I = this || R;
              if (
                ((_ = parseFloat(_)),
                I.ctx || X(),
                "u" > typeof _ && _ >= 0 && _ <= 1)
              ) {
                if (((I._volume = _), I._muted)) return I;
                I.usingWebAudio &&
                  I.masterGain.gain.setValueAtTime(_, R.ctx.currentTime);
                for (var B = 0; B < I._howls.length; B++)
                  if (!I._howls[B]._webAudio)
                    for (
                      var z = I._howls[B]._getSoundIds(), k = 0;
                      k < z.length;
                      k++
                    ) {
                      var V = I._howls[B]._soundById(z[k]);
                      V && V._node && (V._node.volume = V._volume * _);
                    }
                return I;
              }
              return I._volume;
            },
            mute: function (_) {
              var I = this || R;
              I.ctx || X(),
                (I._muted = _),
                I.usingWebAudio &&
                  I.masterGain.gain.setValueAtTime(
                    _ ? 0 : I._volume,
                    R.ctx.currentTime
                  );
              for (var B = 0; B < I._howls.length; B++)
                if (!I._howls[B]._webAudio)
                  for (
                    var z = I._howls[B]._getSoundIds(), k = 0;
                    k < z.length;
                    k++
                  ) {
                    var V = I._howls[B]._soundById(z[k]);
                    V && V._node && (V._node.muted = !!_ || V._muted);
                  }
              return I;
            },
            stop: function () {
              for (var _ = this || R, I = 0; I < _._howls.length; I++)
                _._howls[I].stop();
              return _;
            },
            unload: function () {
              for (var _ = this || R, I = _._howls.length - 1; I >= 0; I--)
                _._howls[I].unload();
              return (
                _.usingWebAudio &&
                  _.ctx &&
                  "u" > typeof _.ctx.close &&
                  (_.ctx.close(), (_.ctx = null), X()),
                _
              );
            },
            codecs: function (_) {
              return (this || R)._codecs[_.replace(/^x-/, "")];
            },
            _setup: function () {
              var _ = this || R;
              if (
                ((_.state = (_.ctx && _.ctx.state) || "suspended"),
                _._autoSuspend(),
                !_.usingWebAudio)
              ) {
                if ("u" > typeof Audio)
                  try {
                    var I = new Audio();
                    typeof I.oncanplaythrough > "u" &&
                      (_._canPlayEvent = "canplay");
                  } catch {
                    _.noAudio = !0;
                  }
                else _.noAudio = !0;
              }
              try {
                var I = new Audio();
                I.muted && (_.noAudio = !0);
              } catch {}
              return _.noAudio || _._setupCodecs(), _;
            },
            _setupCodecs: function () {
              var _ = this || R,
                I = null;
              try {
                I = "u" > typeof Audio ? new Audio() : null;
              } catch {
                return _;
              }
              if (!I || "function" != typeof I.canPlayType) return _;
              var B = I.canPlayType("audio/mpeg;").replace(/^no$/, ""),
                z = _._navigator ? _._navigator.userAgent : "",
                k = z.match(/OPR\/([0-6].)/g),
                V = k && 33 > parseInt(k[0].split("/")[1], 10),
                j = -1 !== z.indexOf("Safari") && -1 === z.indexOf("Chrome"),
                G = z.match(/Version\/(.*?) /),
                q = j && G && 15 > parseInt(G[1], 10);
              return (
                (_._codecs = {
                  mp3: !!(
                    !V &&
                    (B || I.canPlayType("audio/mp3;").replace(/^no$/, ""))
                  ),
                  mpeg: !!B,
                  opus: !!I.canPlayType('audio/ogg; codecs="opus"').replace(
                    /^no$/,
                    ""
                  ),
                  ogg: !!I.canPlayType('audio/ogg; codecs="vorbis"').replace(
                    /^no$/,
                    ""
                  ),
                  oga: !!I.canPlayType('audio/ogg; codecs="vorbis"').replace(
                    /^no$/,
                    ""
                  ),
                  wav: !!(
                    I.canPlayType('audio/wav; codecs="1"') ||
                    I.canPlayType("audio/wav")
                  ).replace(/^no$/, ""),
                  aac: !!I.canPlayType("audio/aac;").replace(/^no$/, ""),
                  caf: !!I.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                  m4a: !!(
                    I.canPlayType("audio/x-m4a;") ||
                    I.canPlayType("audio/m4a;") ||
                    I.canPlayType("audio/aac;")
                  ).replace(/^no$/, ""),
                  m4b: !!(
                    I.canPlayType("audio/x-m4b;") ||
                    I.canPlayType("audio/m4b;") ||
                    I.canPlayType("audio/aac;")
                  ).replace(/^no$/, ""),
                  mp4: !!(
                    I.canPlayType("audio/x-mp4;") ||
                    I.canPlayType("audio/mp4;") ||
                    I.canPlayType("audio/aac;")
                  ).replace(/^no$/, ""),
                  weba: !!(
                    !q &&
                    I.canPlayType('audio/webm; codecs="vorbis"').replace(
                      /^no$/,
                      ""
                    )
                  ),
                  webm: !!(
                    !q &&
                    I.canPlayType('audio/webm; codecs="vorbis"').replace(
                      /^no$/,
                      ""
                    )
                  ),
                  dolby: !!I.canPlayType('audio/mp4; codecs="ec-3"').replace(
                    /^no$/,
                    ""
                  ),
                  flac: !!(
                    I.canPlayType("audio/x-flac;") ||
                    I.canPlayType("audio/flac;")
                  ).replace(/^no$/, ""),
                }),
                _
              );
            },
            _unlockAudio: function () {
              var _ = this || R;
              if (!(_._audioUnlocked || !_.ctx)) {
                (_._audioUnlocked = !1),
                  (_.autoUnlock = !1),
                  _._mobileUnloaded ||
                    44100 === _.ctx.sampleRate ||
                    ((_._mobileUnloaded = !0), _.unload()),
                  (_._scratchBuffer = _.ctx.createBuffer(1, 1, 22050));
                var h = function (I) {
                  for (; _._html5AudioPool.length < _.html5PoolSize; )
                    try {
                      var R = new Audio();
                      (R._unlocked = !0), _._releaseHtml5Audio(R);
                    } catch {
                      _.noAudio = !0;
                      break;
                    }
                  for (var B = 0; B < _._howls.length; B++)
                    if (!_._howls[B]._webAudio)
                      for (
                        var z = _._howls[B]._getSoundIds(), k = 0;
                        k < z.length;
                        k++
                      ) {
                        var V = _._howls[B]._soundById(z[k]);
                        V &&
                          V._node &&
                          !V._node._unlocked &&
                          ((V._node._unlocked = !0), V._node.load());
                      }
                  _._autoResume();
                  var j = _.ctx.createBufferSource();
                  (j.buffer = _._scratchBuffer),
                    j.connect(_.ctx.destination),
                    typeof j.start > "u" ? j.noteOn(0) : j.start(0),
                    "function" == typeof _.ctx.resume && _.ctx.resume(),
                    (j.onended = function () {
                      j.disconnect(0),
                        (_._audioUnlocked = !0),
                        document.removeEventListener("touchstart", h, !0),
                        document.removeEventListener("touchend", h, !0),
                        document.removeEventListener("click", h, !0),
                        document.removeEventListener("keydown", h, !0);
                      for (var I = 0; I < _._howls.length; I++)
                        _._howls[I]._emit("unlock");
                    });
                };
                return (
                  document.addEventListener("touchstart", h, !0),
                  document.addEventListener("touchend", h, !0),
                  document.addEventListener("click", h, !0),
                  document.addEventListener("keydown", h, !0),
                  _
                );
              }
            },
            _obtainHtml5Audio: function () {
              var _ = this || R;
              if (_._html5AudioPool.length) return _._html5AudioPool.pop();
              var I = new Audio().play();
              return (
                I &&
                  "u" > typeof Promise &&
                  (I instanceof Promise || "function" == typeof I.then) &&
                  I.catch(function () {
                    console.warn(
                      "HTML5 Audio pool exhausted, returning potentially locked audio object."
                    );
                  }),
                new Audio()
              );
            },
            _releaseHtml5Audio: function (_) {
              var I = this || R;
              return _._unlocked && I._html5AudioPool.push(_), I;
            },
            _autoSuspend: function () {
              var _ = this;
              if (
                !(
                  !_.autoSuspend ||
                  !_.ctx ||
                  typeof _.ctx.suspend > "u" ||
                  !R.usingWebAudio
                )
              ) {
                for (var I = 0; I < _._howls.length; I++)
                  if (_._howls[I]._webAudio) {
                    for (var B = 0; B < _._howls[I]._sounds.length; B++)
                      if (!_._howls[I]._sounds[B]._paused) return _;
                  }
                return (
                  _._suspendTimer && clearTimeout(_._suspendTimer),
                  (_._suspendTimer = setTimeout(function () {
                    if (_.autoSuspend) {
                      (_._suspendTimer = null), (_.state = "suspending");
                      var f = function () {
                        (_.state = "suspended"),
                          _._resumeAfterSuspend &&
                            (delete _._resumeAfterSuspend, _._autoResume());
                      };
                      _.ctx.suspend().then(f, f);
                    }
                  }, 3e4)),
                  _
                );
              }
            },
            _autoResume: function () {
              var _ = this;
              if (!(!_.ctx || typeof _.ctx.resume > "u" || !R.usingWebAudio))
                return (
                  "running" === _.state &&
                  "interrupted" !== _.ctx.state &&
                  _._suspendTimer
                    ? (clearTimeout(_._suspendTimer), (_._suspendTimer = null))
                    : "suspended" === _.state ||
                      ("running" === _.state && "interrupted" === _.ctx.state)
                    ? (_.ctx.resume().then(function () {
                        _.state = "running";
                        for (var I = 0; I < _._howls.length; I++)
                          _._howls[I]._emit("resume");
                      }),
                      _._suspendTimer &&
                        (clearTimeout(_._suspendTimer),
                        (_._suspendTimer = null)))
                    : "suspending" === _.state && (_._resumeAfterSuspend = !0),
                  _
                );
            },
          }),
            (R = new I()),
            ((B = function (_) {
              if (!_.src || 0 === _.src.length) {
                console.error(
                  "An array of source files must be passed with any new Howl."
                );
                return;
              }
              this.init(_);
            }).prototype = {
              init: function (_) {
                var I = this;
                return (
                  R.ctx || X(),
                  (I._autoplay = _.autoplay || !1),
                  (I._format =
                    "string" != typeof _.format ? _.format : [_.format]),
                  (I._html5 = _.html5 || !1),
                  (I._muted = _.mute || !1),
                  (I._loop = _.loop || !1),
                  (I._pool = _.pool || 5),
                  (I._preload =
                    ("boolean" != typeof _.preload &&
                      "metadata" !== _.preload) ||
                    _.preload),
                  (I._rate = _.rate || 1),
                  (I._sprite = _.sprite || {}),
                  (I._src = "string" != typeof _.src ? _.src : [_.src]),
                  (I._volume = void 0 !== _.volume ? _.volume : 1),
                  (I._xhr = {
                    method: _.xhr && _.xhr.method ? _.xhr.method : "GET",
                    headers: _.xhr && _.xhr.headers ? _.xhr.headers : null,
                    withCredentials:
                      !!_.xhr &&
                      !!_.xhr.withCredentials &&
                      _.xhr.withCredentials,
                  }),
                  (I._duration = 0),
                  (I._state = "unloaded"),
                  (I._sounds = []),
                  (I._endTimers = {}),
                  (I._queue = []),
                  (I._playLock = !1),
                  (I._onend = _.onend ? [{ fn: _.onend }] : []),
                  (I._onfade = _.onfade ? [{ fn: _.onfade }] : []),
                  (I._onload = _.onload ? [{ fn: _.onload }] : []),
                  (I._onloaderror = _.onloaderror
                    ? [{ fn: _.onloaderror }]
                    : []),
                  (I._onplayerror = _.onplayerror
                    ? [{ fn: _.onplayerror }]
                    : []),
                  (I._onpause = _.onpause ? [{ fn: _.onpause }] : []),
                  (I._onplay = _.onplay ? [{ fn: _.onplay }] : []),
                  (I._onstop = _.onstop ? [{ fn: _.onstop }] : []),
                  (I._onmute = _.onmute ? [{ fn: _.onmute }] : []),
                  (I._onvolume = _.onvolume ? [{ fn: _.onvolume }] : []),
                  (I._onrate = _.onrate ? [{ fn: _.onrate }] : []),
                  (I._onseek = _.onseek ? [{ fn: _.onseek }] : []),
                  (I._onunlock = _.onunlock ? [{ fn: _.onunlock }] : []),
                  (I._onresume = []),
                  (I._webAudio = R.usingWebAudio && !I._html5),
                  "u" > typeof R.ctx &&
                    R.ctx &&
                    R.autoUnlock &&
                    R._unlockAudio(),
                  R._howls.push(I),
                  I._autoplay &&
                    I._queue.push({
                      event: "play",
                      action: function () {
                        I.play();
                      },
                    }),
                  I._preload && "none" !== I._preload && I.load(),
                  I
                );
              },
              load: function () {
                var _,
                  I,
                  B = null;
                if (R.noAudio) {
                  this._emit("loaderror", null, "No audio support.");
                  return;
                }
                "string" == typeof this._src && (this._src = [this._src]);
                for (var k = 0; k < this._src.length; k++) {
                  if (this._format && this._format[k]) _ = this._format[k];
                  else {
                    if ("string" != typeof (I = this._src[k])) {
                      this._emit(
                        "loaderror",
                        null,
                        "Non-string found in selected audio sources - ignoring."
                      );
                      continue;
                    }
                    (_ = /^data:audio\/([^;,]+);/i.exec(I)) ||
                      (_ = /\.([^.]+)$/.exec(I.split("?", 1)[0])),
                      _ && (_ = _[1].toLowerCase());
                  }
                  if (
                    (_ ||
                      console.warn(
                        'No file extension was found. Consider using the "format" property or specify an extension.'
                      ),
                    _ && R.codecs(_))
                  ) {
                    B = this._src[k];
                    break;
                  }
                }
                if (!B) {
                  this._emit(
                    "loaderror",
                    null,
                    "No codec support for selected audio sources."
                  );
                  return;
                }
                return (
                  (this._src = B),
                  (this._state = "loading"),
                  "https:" === window.location.protocol &&
                    "http:" === B.slice(0, 5) &&
                    ((this._html5 = !0), (this._webAudio = !1)),
                  new z(this),
                  this._webAudio && V(this),
                  this
                );
              },
              play: function (_, I) {
                var B = this,
                  z = null;
                if ("number" == typeof _) (z = _), (_ = null);
                else {
                  if (
                    "string" == typeof _ &&
                    "loaded" === B._state &&
                    !B._sprite[_]
                  )
                    return null;
                  if (typeof _ > "u" && ((_ = "__default"), !B._playLock)) {
                    for (var k = 0, V = 0; V < B._sounds.length; V++)
                      B._sounds[V]._paused &&
                        !B._sounds[V]._ended &&
                        (k++, (z = B._sounds[V]._id));
                    1 === k ? (_ = null) : (z = null);
                  }
                }
                var j = z ? B._soundById(z) : B._inactiveSound();
                if (!j) return null;
                if (
                  (z && !_ && (_ = j._sprite || "__default"),
                  "loaded" !== B._state)
                ) {
                  (j._sprite = _), (j._ended = !1);
                  var G = j._id;
                  return (
                    B._queue.push({
                      event: "play",
                      action: function () {
                        B.play(G);
                      },
                    }),
                    G
                  );
                }
                if (z && !j._paused) return I || B._loadQueue("play"), j._id;
                B._webAudio && R._autoResume();
                var q = Math.max(
                    0,
                    j._seek > 0 ? j._seek : B._sprite[_][0] / 1e3
                  ),
                  X = Math.max(
                    0,
                    (B._sprite[_][0] + B._sprite[_][1]) / 1e3 - q
                  ),
                  Q = (1e3 * X) / Math.abs(j._rate),
                  $ = B._sprite[_][0] / 1e3,
                  et = (B._sprite[_][0] + B._sprite[_][1]) / 1e3;
                (j._sprite = _), (j._ended = !1);
                var E = function () {
                  (j._paused = !1),
                    (j._seek = q),
                    (j._start = $),
                    (j._stop = et),
                    (j._loop = !!(j._loop || B._sprite[_][2]));
                };
                if (q >= et) {
                  B._ended(j);
                  return;
                }
                var er = j._node;
                if (B._webAudio) {
                  var T = function () {
                    (B._playLock = !1), E(), B._refreshBuffer(j);
                    var _ = j._muted || B._muted ? 0 : j._volume;
                    er.gain.setValueAtTime(_, R.ctx.currentTime),
                      (j._playStart = R.ctx.currentTime),
                      typeof er.bufferSource.start > "u"
                        ? j._loop
                          ? er.bufferSource.noteGrainOn(0, q, 86400)
                          : er.bufferSource.noteGrainOn(0, q, X)
                        : j._loop
                        ? er.bufferSource.start(0, q, 86400)
                        : er.bufferSource.start(0, q, X),
                      Q !== 1 / 0 &&
                        (B._endTimers[j._id] = setTimeout(
                          B._ended.bind(B, j),
                          Q
                        )),
                      I ||
                        setTimeout(function () {
                          B._emit("play", j._id), B._loadQueue();
                        }, 0);
                  };
                  "running" === R.state && "interrupted" !== R.ctx.state
                    ? T()
                    : ((B._playLock = !0),
                      B.once("resume", T),
                      B._clearTimer(j._id));
                } else {
                  var M = function () {
                    (er.currentTime = q),
                      (er.muted = j._muted || B._muted || R._muted || er.muted),
                      (er.volume = j._volume * R.volume()),
                      (er.playbackRate = j._rate);
                    try {
                      var z = er.play();
                      if (
                        (z &&
                        "u" > typeof Promise &&
                        (z instanceof Promise || "function" == typeof z.then)
                          ? ((B._playLock = !0),
                            E(),
                            z
                              .then(function () {
                                (B._playLock = !1),
                                  (er._unlocked = !0),
                                  I ? B._loadQueue() : B._emit("play", j._id);
                              })
                              .catch(function () {
                                (B._playLock = !1),
                                  B._emit(
                                    "playerror",
                                    j._id,
                                    "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                                  ),
                                  (j._ended = !0),
                                  (j._paused = !0);
                              }))
                          : I ||
                            ((B._playLock = !1), E(), B._emit("play", j._id)),
                        (er.playbackRate = j._rate),
                        er.paused)
                      ) {
                        B._emit(
                          "playerror",
                          j._id,
                          "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                        );
                        return;
                      }
                      "__default" !== _ || j._loop
                        ? (B._endTimers[j._id] = setTimeout(
                            B._ended.bind(B, j),
                            Q
                          ))
                        : ((B._endTimers[j._id] = function () {
                            B._ended(j),
                              er.removeEventListener(
                                "ended",
                                B._endTimers[j._id],
                                !1
                              );
                          }),
                          er.addEventListener(
                            "ended",
                            B._endTimers[j._id],
                            !1
                          ));
                    } catch (_) {
                      B._emit("playerror", j._id, _);
                    }
                  };
                  "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" ===
                    er.src && ((er.src = B._src), er.load());
                  var es =
                    (window && window.ejecta) ||
                    (!er.readyState && R._navigator.isCocoonJS);
                  if (er.readyState >= 3 || es) M();
                  else {
                    (B._playLock = !0), (B._state = "loading");
                    var P = function () {
                      (B._state = "loaded"),
                        M(),
                        er.removeEventListener(R._canPlayEvent, P, !1);
                    };
                    er.addEventListener(R._canPlayEvent, P, !1),
                      B._clearTimer(j._id);
                  }
                }
                return j._id;
              },
              pause: function (_) {
                var I = this;
                if ("loaded" !== I._state || I._playLock)
                  return (
                    I._queue.push({
                      event: "pause",
                      action: function () {
                        I.pause(_);
                      },
                    }),
                    I
                  );
                for (var R = I._getSoundIds(_), B = 0; B < R.length; B++) {
                  I._clearTimer(R[B]);
                  var z = I._soundById(R[B]);
                  if (
                    z &&
                    !z._paused &&
                    ((z._seek = I.seek(R[B])),
                    (z._rateSeek = 0),
                    (z._paused = !0),
                    I._stopFade(R[B]),
                    z._node)
                  ) {
                    if (I._webAudio) {
                      if (!z._node.bufferSource) continue;
                      typeof z._node.bufferSource.stop > "u"
                        ? z._node.bufferSource.noteOff(0)
                        : z._node.bufferSource.stop(0),
                        I._cleanBuffer(z._node);
                    } else
                      (isNaN(z._node.duration) && z._node.duration !== 1 / 0) ||
                        z._node.pause();
                  }
                  arguments[1] || I._emit("pause", z ? z._id : null);
                }
                return I;
              },
              stop: function (_, I) {
                var R = this;
                if ("loaded" !== R._state || R._playLock)
                  return (
                    R._queue.push({
                      event: "stop",
                      action: function () {
                        R.stop(_);
                      },
                    }),
                    R
                  );
                for (var B = R._getSoundIds(_), z = 0; z < B.length; z++) {
                  R._clearTimer(B[z]);
                  var k = R._soundById(B[z]);
                  k &&
                    ((k._seek = k._start || 0),
                    (k._rateSeek = 0),
                    (k._paused = !0),
                    (k._ended = !0),
                    R._stopFade(B[z]),
                    k._node &&
                      (R._webAudio
                        ? k._node.bufferSource &&
                          (typeof k._node.bufferSource.stop > "u"
                            ? k._node.bufferSource.noteOff(0)
                            : k._node.bufferSource.stop(0),
                          R._cleanBuffer(k._node))
                        : (isNaN(k._node.duration) &&
                            k._node.duration !== 1 / 0) ||
                          ((k._node.currentTime = k._start || 0),
                          k._node.pause(),
                          k._node.duration === 1 / 0 &&
                            R._clearSound(k._node))),
                    I || R._emit("stop", k._id));
                }
                return R;
              },
              mute: function (_, I) {
                var B = this;
                if ("loaded" !== B._state || B._playLock)
                  return (
                    B._queue.push({
                      event: "mute",
                      action: function () {
                        B.mute(_, I);
                      },
                    }),
                    B
                  );
                if (typeof I > "u") {
                  if ("boolean" != typeof _) return B._muted;
                  B._muted = _;
                }
                for (var z = B._getSoundIds(I), k = 0; k < z.length; k++) {
                  var V = B._soundById(z[k]);
                  V &&
                    ((V._muted = _),
                    V._interval && B._stopFade(V._id),
                    B._webAudio && V._node
                      ? V._node.gain.setValueAtTime(
                          _ ? 0 : V._volume,
                          R.ctx.currentTime
                        )
                      : V._node && (V._node.muted = !!R._muted || _),
                    B._emit("mute", V._id));
                }
                return B;
              },
              volume: function () {
                var _,
                  I,
                  B,
                  z = this,
                  k = arguments;
                if (0 === k.length) return z._volume;
                if (
                  (1 === k.length || (2 === k.length && typeof k[1] > "u")
                    ? z._getSoundIds().indexOf(k[0]) >= 0
                      ? (B = parseInt(k[0], 10))
                      : (I = parseFloat(k[0]))
                    : k.length >= 2 &&
                      ((I = parseFloat(k[0])), (B = parseInt(k[1], 10))),
                  !("u" > typeof I) || !(I >= 0) || !(I <= 1))
                )
                  return (_ = B ? z._soundById(B) : z._sounds[0])
                    ? _._volume
                    : 0;
                if ("loaded" !== z._state || z._playLock)
                  return (
                    z._queue.push({
                      event: "volume",
                      action: function () {
                        z.volume.apply(z, k);
                      },
                    }),
                    z
                  );
                typeof B > "u" && (z._volume = I), (B = z._getSoundIds(B));
                for (var V = 0; V < B.length; V++)
                  (_ = z._soundById(B[V])) &&
                    ((_._volume = I),
                    k[2] || z._stopFade(B[V]),
                    z._webAudio && _._node && !_._muted
                      ? _._node.gain.setValueAtTime(I, R.ctx.currentTime)
                      : _._node &&
                        !_._muted &&
                        (_._node.volume = I * R.volume()),
                    z._emit("volume", _._id));
                return z;
              },
              fade: function (_, I, B, z) {
                var k = this;
                if ("loaded" !== k._state || k._playLock)
                  return (
                    k._queue.push({
                      event: "fade",
                      action: function () {
                        k.fade(_, I, B, z);
                      },
                    }),
                    k
                  );
                (_ = Math.min(Math.max(0, parseFloat(_)), 1)),
                  (I = Math.min(Math.max(0, parseFloat(I)), 1)),
                  (B = parseFloat(B)),
                  k.volume(_, z);
                for (var V = k._getSoundIds(z), j = 0; j < V.length; j++) {
                  var G = k._soundById(V[j]);
                  if (G) {
                    if ((z || k._stopFade(V[j]), k._webAudio && !G._muted)) {
                      var q = R.ctx.currentTime,
                        X = q + B / 1e3;
                      (G._volume = _),
                        G._node.gain.setValueAtTime(_, q),
                        G._node.gain.linearRampToValueAtTime(I, X);
                    }
                    k._startFadeInterval(G, _, I, B, V[j], typeof z > "u");
                  }
                }
                return k;
              },
              _startFadeInterval: function (_, I, R, B, z, k) {
                var V = this,
                  j = I,
                  G = R - I,
                  q = Math.abs(G / 0.01),
                  X = Math.max(4, q > 0 ? B / q : B),
                  Q = Date.now();
                (_._fadeTo = R),
                  (_._interval = setInterval(function () {
                    var z = (Date.now() - Q) / B;
                    (Q = Date.now()),
                      (j += G * z),
                      (j = Math.round(100 * j) / 100),
                      (j = G < 0 ? Math.max(R, j) : Math.min(R, j)),
                      V._webAudio ? (_._volume = j) : V.volume(j, _._id, !0),
                      k && (V._volume = j),
                      ((R < I && j <= R) || (R > I && j >= R)) &&
                        (clearInterval(_._interval),
                        (_._interval = null),
                        (_._fadeTo = null),
                        V.volume(R, _._id),
                        V._emit("fade", _._id));
                  }, X));
              },
              _stopFade: function (_) {
                var I = this._soundById(_);
                return (
                  I &&
                    I._interval &&
                    (this._webAudio &&
                      I._node.gain.cancelScheduledValues(R.ctx.currentTime),
                    clearInterval(I._interval),
                    (I._interval = null),
                    this.volume(I._fadeTo, _),
                    (I._fadeTo = null),
                    this._emit("fade", _)),
                  this
                );
              },
              loop: function () {
                var _,
                  I,
                  R,
                  B = arguments;
                if (0 === B.length) return this._loop;
                if (1 === B.length) {
                  if ("boolean" != typeof B[0])
                    return (
                      !!(R = this._soundById(parseInt(B[0], 10))) && R._loop
                    );
                  (_ = B[0]), (this._loop = _);
                } else 2 === B.length && ((_ = B[0]), (I = parseInt(B[1], 10)));
                for (var z = this._getSoundIds(I), k = 0; k < z.length; k++)
                  (R = this._soundById(z[k])) &&
                    ((R._loop = _),
                    this._webAudio &&
                      R._node &&
                      R._node.bufferSource &&
                      ((R._node.bufferSource.loop = _),
                      _ &&
                        ((R._node.bufferSource.loopStart = R._start || 0),
                        (R._node.bufferSource.loopEnd = R._stop),
                        this.playing(z[k]) &&
                          (this.pause(z[k], !0), this.play(z[k], !0)))));
                return this;
              },
              rate: function () {
                var _,
                  I,
                  B,
                  z = this,
                  k = arguments;
                if (
                  (0 === k.length
                    ? (B = z._sounds[0]._id)
                    : 1 === k.length
                    ? z._getSoundIds().indexOf(k[0]) >= 0
                      ? (B = parseInt(k[0], 10))
                      : (I = parseFloat(k[0]))
                    : 2 === k.length &&
                      ((I = parseFloat(k[0])), (B = parseInt(k[1], 10))),
                  "number" != typeof I)
                )
                  return (_ = z._soundById(B)) ? _._rate : z._rate;
                if ("loaded" !== z._state || z._playLock)
                  return (
                    z._queue.push({
                      event: "rate",
                      action: function () {
                        z.rate.apply(z, k);
                      },
                    }),
                    z
                  );
                typeof B > "u" && (z._rate = I), (B = z._getSoundIds(B));
                for (var V = 0; V < B.length; V++)
                  if ((_ = z._soundById(B[V]))) {
                    z.playing(B[V]) &&
                      ((_._rateSeek = z.seek(B[V])),
                      (_._playStart = z._webAudio
                        ? R.ctx.currentTime
                        : _._playStart)),
                      (_._rate = I),
                      z._webAudio && _._node && _._node.bufferSource
                        ? _._node.bufferSource.playbackRate.setValueAtTime(
                            I,
                            R.ctx.currentTime
                          )
                        : _._node && (_._node.playbackRate = I);
                    var j = z.seek(B[V]),
                      G =
                        (1e3 *
                          ((z._sprite[_._sprite][0] + z._sprite[_._sprite][1]) /
                            1e3 -
                            j)) /
                        Math.abs(_._rate);
                    (z._endTimers[B[V]] || !_._paused) &&
                      (z._clearTimer(B[V]),
                      (z._endTimers[B[V]] = setTimeout(
                        z._ended.bind(z, _),
                        G
                      ))),
                      z._emit("rate", _._id);
                  }
                return z;
              },
              seek: function () {
                var _,
                  I,
                  B = this,
                  z = arguments;
                if (
                  (0 === z.length
                    ? B._sounds.length && (I = B._sounds[0]._id)
                    : 1 === z.length
                    ? B._getSoundIds().indexOf(z[0]) >= 0
                      ? (I = parseInt(z[0], 10))
                      : B._sounds.length &&
                        ((I = B._sounds[0]._id), (_ = parseFloat(z[0])))
                    : 2 === z.length &&
                      ((_ = parseFloat(z[0])), (I = parseInt(z[1], 10))),
                  typeof I > "u")
                )
                  return 0;
                if (
                  "number" == typeof _ &&
                  ("loaded" !== B._state || B._playLock)
                )
                  return (
                    B._queue.push({
                      event: "seek",
                      action: function () {
                        B.seek.apply(B, z);
                      },
                    }),
                    B
                  );
                var k = B._soundById(I);
                if (k) {
                  if ("number" == typeof _ && _ >= 0) {
                    var V = B.playing(I);
                    V && B.pause(I, !0),
                      (k._seek = _),
                      (k._ended = !1),
                      B._clearTimer(I),
                      B._webAudio ||
                        !k._node ||
                        isNaN(k._node.duration) ||
                        (k._node.currentTime = _);
                    var v = function () {
                      V && B.play(I, !0), B._emit("seek", I);
                    };
                    if (V && !B._webAudio) {
                      var x = function () {
                        B._playLock ? setTimeout(x, 0) : v();
                      };
                      setTimeout(x, 0);
                    } else v();
                  } else {
                    if (!B._webAudio) return k._node.currentTime;
                    var j = B.playing(I) ? R.ctx.currentTime - k._playStart : 0,
                      G = k._rateSeek ? k._rateSeek - k._seek : 0;
                    return k._seek + (G + j * Math.abs(k._rate));
                  }
                }
                return B;
              },
              playing: function (_) {
                if ("number" == typeof _) {
                  var I = this._soundById(_);
                  return !!I && !I._paused;
                }
                for (var R = 0; R < this._sounds.length; R++)
                  if (!this._sounds[R]._paused) return !0;
                return !1;
              },
              duration: function (_) {
                var I = this._duration,
                  R = this._soundById(_);
                return R && (I = this._sprite[R._sprite][1] / 1e3), I;
              },
              state: function () {
                return this._state;
              },
              unload: function () {
                for (var _ = this, I = _._sounds, B = 0; B < I.length; B++)
                  I[B]._paused || _.stop(I[B]._id),
                    _._webAudio ||
                      (_._clearSound(I[B]._node),
                      I[B]._node.removeEventListener(
                        "error",
                        I[B]._errorFn,
                        !1
                      ),
                      I[B]._node.removeEventListener(
                        R._canPlayEvent,
                        I[B]._loadFn,
                        !1
                      ),
                      I[B]._node.removeEventListener("ended", I[B]._endFn, !1),
                      R._releaseHtml5Audio(I[B]._node)),
                    delete I[B]._node,
                    _._clearTimer(I[B]._id);
                var z = R._howls.indexOf(_);
                z >= 0 && R._howls.splice(z, 1);
                var V = !0;
                for (B = 0; B < R._howls.length; B++)
                  if (
                    R._howls[B]._src === _._src ||
                    _._src.indexOf(R._howls[B]._src) >= 0
                  ) {
                    V = !1;
                    break;
                  }
                return (
                  k && V && delete k[_._src],
                  (R.noAudio = !1),
                  (_._state = "unloaded"),
                  (_._sounds = []),
                  (_ = null),
                  null
                );
              },
              on: function (_, I, R, B) {
                var z = this["_on" + _];
                return (
                  "function" == typeof I &&
                    z.push(B ? { id: R, fn: I, once: B } : { id: R, fn: I }),
                  this
                );
              },
              off: function (_, I, R) {
                var B = this["_on" + _],
                  z = 0;
                if (("number" == typeof I && ((R = I), (I = null)), I || R))
                  for (z = 0; z < B.length; z++) {
                    var k = R === B[z].id;
                    if ((I === B[z].fn && k) || (!I && k)) {
                      B.splice(z, 1);
                      break;
                    }
                  }
                else if (_) this["_on" + _] = [];
                else {
                  var V = Object.keys(this);
                  for (z = 0; z < V.length; z++)
                    0 === V[z].indexOf("_on") &&
                      Array.isArray(this[V[z]]) &&
                      (this[V[z]] = []);
                }
                return this;
              },
              once: function (_, I, R) {
                return this.on(_, I, R, 1), this;
              },
              _emit: function (_, I, R) {
                for (var B = this["_on" + _], z = B.length - 1; z >= 0; z--)
                  (!B[z].id || B[z].id === I || "load" === _) &&
                    (setTimeout(
                      function (_) {
                        _.call(this, I, R);
                      }.bind(this, B[z].fn),
                      0
                    ),
                    B[z].once && this.off(_, B[z].fn, B[z].id));
                return this._loadQueue(_), this;
              },
              _loadQueue: function (_) {
                if (this._queue.length > 0) {
                  var I = this._queue[0];
                  I.event === _ && (this._queue.shift(), this._loadQueue()),
                    _ || I.action();
                }
                return this;
              },
              _ended: function (_) {
                var I = _._sprite;
                if (
                  !this._webAudio &&
                  _._node &&
                  !_._node.paused &&
                  !_._node.ended &&
                  _._node.currentTime < _._stop
                )
                  return setTimeout(this._ended.bind(this, _), 100), this;
                var B = !!(_._loop || this._sprite[I][2]);
                if (
                  (this._emit("end", _._id),
                  !this._webAudio && B && this.stop(_._id, !0).play(_._id),
                  this._webAudio && B)
                ) {
                  this._emit("play", _._id),
                    (_._seek = _._start || 0),
                    (_._rateSeek = 0),
                    (_._playStart = R.ctx.currentTime);
                  var z = ((_._stop - _._start) * 1e3) / Math.abs(_._rate);
                  this._endTimers[_._id] = setTimeout(
                    this._ended.bind(this, _),
                    z
                  );
                }
                return (
                  this._webAudio &&
                    !B &&
                    ((_._paused = !0),
                    (_._ended = !0),
                    (_._seek = _._start || 0),
                    (_._rateSeek = 0),
                    this._clearTimer(_._id),
                    this._cleanBuffer(_._node),
                    R._autoSuspend()),
                  this._webAudio || B || this.stop(_._id, !0),
                  this
                );
              },
              _clearTimer: function (_) {
                if (this._endTimers[_]) {
                  if ("function" != typeof this._endTimers[_])
                    clearTimeout(this._endTimers[_]);
                  else {
                    var I = this._soundById(_);
                    I &&
                      I._node &&
                      I._node.removeEventListener(
                        "ended",
                        this._endTimers[_],
                        !1
                      );
                  }
                  delete this._endTimers[_];
                }
                return this;
              },
              _soundById: function (_) {
                for (var I = 0; I < this._sounds.length; I++)
                  if (_ === this._sounds[I]._id) return this._sounds[I];
                return null;
              },
              _inactiveSound: function () {
                this._drain();
                for (var _ = 0; _ < this._sounds.length; _++)
                  if (this._sounds[_]._ended) return this._sounds[_].reset();
                return new z(this);
              },
              _drain: function () {
                var _ = this._pool,
                  I = 0,
                  R = 0;
                if (!(this._sounds.length < _)) {
                  for (R = 0; R < this._sounds.length; R++)
                    this._sounds[R]._ended && I++;
                  for (R = this._sounds.length - 1; R >= 0; R--) {
                    if (I <= _) return;
                    this._sounds[R]._ended &&
                      (this._webAudio &&
                        this._sounds[R]._node &&
                        this._sounds[R]._node.disconnect(0),
                      this._sounds.splice(R, 1),
                      I--);
                  }
                }
              },
              _getSoundIds: function (_) {
                if (!(typeof _ > "u")) return [_];
                for (var I = [], R = 0; R < this._sounds.length; R++)
                  I.push(this._sounds[R]._id);
                return I;
              },
              _refreshBuffer: function (_) {
                return (
                  (_._node.bufferSource = R.ctx.createBufferSource()),
                  (_._node.bufferSource.buffer = k[this._src]),
                  _._panner
                    ? _._node.bufferSource.connect(_._panner)
                    : _._node.bufferSource.connect(_._node),
                  (_._node.bufferSource.loop = _._loop),
                  _._loop &&
                    ((_._node.bufferSource.loopStart = _._start || 0),
                    (_._node.bufferSource.loopEnd = _._stop || 0)),
                  _._node.bufferSource.playbackRate.setValueAtTime(
                    _._rate,
                    R.ctx.currentTime
                  ),
                  this
                );
              },
              _cleanBuffer: function (_) {
                var I =
                  R._navigator && R._navigator.vendor.indexOf("Apple") >= 0;
                if (
                  R._scratchBuffer &&
                  _.bufferSource &&
                  ((_.bufferSource.onended = null),
                  _.bufferSource.disconnect(0),
                  I)
                )
                  try {
                    _.bufferSource.buffer = R._scratchBuffer;
                  } catch {}
                return (_.bufferSource = null), this;
              },
              _clearSound: function (_) {
                /MSIE |Trident\//.test(
                  R._navigator && R._navigator.userAgent
                ) ||
                  (_.src =
                    "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
              },
            }),
            ((z = function (_) {
              (this._parent = _), this.init();
            }).prototype = {
              init: function () {
                var _ = this._parent;
                return (
                  (this._muted = _._muted),
                  (this._loop = _._loop),
                  (this._volume = _._volume),
                  (this._rate = _._rate),
                  (this._seek = 0),
                  (this._paused = !0),
                  (this._ended = !0),
                  (this._sprite = "__default"),
                  (this._id = ++R._counter),
                  _._sounds.push(this),
                  this.create(),
                  this
                );
              },
              create: function () {
                var _ = this._parent,
                  I =
                    R._muted || this._muted || this._parent._muted
                      ? 0
                      : this._volume;
                return (
                  _._webAudio
                    ? ((this._node =
                        typeof R.ctx.createGain > "u"
                          ? R.ctx.createGainNode()
                          : R.ctx.createGain()),
                      this._node.gain.setValueAtTime(I, R.ctx.currentTime),
                      (this._node.paused = !0),
                      this._node.connect(R.masterGain))
                    : R.noAudio ||
                      ((this._node = R._obtainHtml5Audio()),
                      (this._errorFn = this._errorListener.bind(this)),
                      this._node.addEventListener("error", this._errorFn, !1),
                      (this._loadFn = this._loadListener.bind(this)),
                      this._node.addEventListener(
                        R._canPlayEvent,
                        this._loadFn,
                        !1
                      ),
                      (this._endFn = this._endListener.bind(this)),
                      this._node.addEventListener("ended", this._endFn, !1),
                      (this._node.src = _._src),
                      (this._node.preload =
                        !0 === _._preload ? "auto" : _._preload),
                      (this._node.volume = I * R.volume()),
                      this._node.load()),
                  this
                );
              },
              reset: function () {
                var _ = this._parent;
                return (
                  (this._muted = _._muted),
                  (this._loop = _._loop),
                  (this._volume = _._volume),
                  (this._rate = _._rate),
                  (this._seek = 0),
                  (this._rateSeek = 0),
                  (this._paused = !0),
                  (this._ended = !0),
                  (this._sprite = "__default"),
                  (this._id = ++R._counter),
                  this
                );
              },
              _errorListener: function () {
                this._parent._emit(
                  "loaderror",
                  this._id,
                  this._node.error ? this._node.error.code : 0
                ),
                  this._node.removeEventListener("error", this._errorFn, !1);
              },
              _loadListener: function () {
                var _ = this._parent;
                (_._duration = Math.ceil(10 * this._node.duration) / 10),
                  0 === Object.keys(_._sprite).length &&
                    (_._sprite = { __default: [0, 1e3 * _._duration] }),
                  "loaded" !== _._state &&
                    ((_._state = "loaded"), _._emit("load"), _._loadQueue()),
                  this._node.removeEventListener(
                    R._canPlayEvent,
                    this._loadFn,
                    !1
                  );
              },
              _endListener: function () {
                var _ = this._parent;
                _._duration === 1 / 0 &&
                  ((_._duration = Math.ceil(10 * this._node.duration) / 10),
                  _._sprite.__default[1] === 1 / 0 &&
                    (_._sprite.__default[1] = 1e3 * _._duration),
                  _._ended(this)),
                  this._node.removeEventListener("ended", this._endFn, !1);
              },
            }),
            (k = {}),
            (V = function (_) {
              var I = _._src;
              if (k[I]) {
                (_._duration = k[I].duration), q(_);
                return;
              }
              if (/^data:[^;]+;base64,/.test(I)) {
                for (
                  var R = atob(I.split(",")[1]),
                    B = new Uint8Array(R.length),
                    z = 0;
                  z < R.length;
                  ++z
                )
                  B[z] = R.charCodeAt(z);
                G(B.buffer, _);
              } else {
                var V = new XMLHttpRequest();
                V.open(_._xhr.method, I, !0),
                  (V.withCredentials = _._xhr.withCredentials),
                  (V.responseType = "arraybuffer"),
                  _._xhr.headers &&
                    Object.keys(_._xhr.headers).forEach(function (I) {
                      V.setRequestHeader(I, _._xhr.headers[I]);
                    }),
                  (V.onload = function () {
                    var I = (V.status + "")[0];
                    if ("0" !== I && "2" !== I && "3" !== I) {
                      _._emit(
                        "loaderror",
                        null,
                        "Failed loading audio file with status: " +
                          V.status +
                          "."
                      );
                      return;
                    }
                    G(V.response, _);
                  }),
                  (V.onerror = function () {
                    _._webAudio &&
                      ((_._html5 = !0),
                      (_._webAudio = !1),
                      (_._sounds = []),
                      delete k[I],
                      _.load());
                  }),
                  j(V);
              }
            }),
            (j = function (_) {
              try {
                _.send();
              } catch {
                _.onerror();
              }
            }),
            (G = function (_, I) {
              var d = function () {
                  I._emit("loaderror", null, "Decoding audio data failed.");
                },
                f = function (_) {
                  _ && I._sounds.length > 0 ? ((k[I._src] = _), q(I, _)) : d();
                };
              "u" > typeof Promise && 1 === R.ctx.decodeAudioData.length
                ? R.ctx.decodeAudioData(_).then(f).catch(d)
                : R.ctx.decodeAudioData(_, f, d);
            }),
            (q = function (_, I) {
              I && !_._duration && (_._duration = I.duration),
                0 === Object.keys(_._sprite).length &&
                  (_._sprite = { __default: [0, 1e3 * _._duration] }),
                "loaded" !== _._state &&
                  ((_._state = "loaded"), _._emit("load"), _._loadQueue());
            }),
            (X = function () {
              if (R.usingWebAudio) {
                try {
                  "u" > typeof AudioContext
                    ? (R.ctx = new AudioContext())
                    : "u" > typeof webkitAudioContext
                    ? (R.ctx = new webkitAudioContext())
                    : (R.usingWebAudio = !1);
                } catch {
                  R.usingWebAudio = !1;
                }
                R.ctx || (R.usingWebAudio = !1);
                var _ = /iP(hone|od|ad)/.test(
                    R._navigator && R._navigator.platform
                  ),
                  I =
                    R._navigator &&
                    R._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                  B = I ? parseInt(I[1], 10) : null;
                if (_ && B && B < 9) {
                  var z = /safari/.test(
                    R._navigator && R._navigator.userAgent.toLowerCase()
                  );
                  R._navigator && !z && (R.usingWebAudio = !1);
                }
                R.usingWebAudio &&
                  ((R.masterGain =
                    typeof R.ctx.createGain > "u"
                      ? R.ctx.createGainNode()
                      : R.ctx.createGain()),
                  R.masterGain.gain.setValueAtTime(
                    R._muted ? 0 : R._volume,
                    R.ctx.currentTime
                  ),
                  R.masterGain.connect(R.ctx.destination)),
                  R._setup();
              }
            }),
            "function" == typeof define &&
              define.amd &&
              define([], function () {
                return { Howler: R, Howl: B };
              }),
            "u" > typeof _ && ((_.Howler = R), (_.Howl = B)),
            "u" > typeof global
              ? ((global.HowlerGlobal = I),
                (global.Howler = R),
                (global.Howl = B),
                (global.Sound = z))
              : "u" > typeof window &&
                ((window.HowlerGlobal = I),
                (window.Howler = R),
                (window.Howl = B),
                (window.Sound = z)),
            (HowlerGlobal.prototype._pos = [0, 0, 0]),
            (HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0]),
            (HowlerGlobal.prototype.stereo = function (_) {
              if (!this.ctx || !this.ctx.listener) return this;
              for (var I = this._howls.length - 1; I >= 0; I--)
                this._howls[I].stereo(_);
              return this;
            }),
            (HowlerGlobal.prototype.pos = function (_, I, R) {
              return this.ctx && this.ctx.listener
                ? ((I = "number" != typeof I ? this._pos[1] : I),
                  (R = "number" != typeof R ? this._pos[2] : R),
                  "number" != typeof _)
                  ? this._pos
                  : ((this._pos = [_, I, R]),
                    "u" > typeof this.ctx.listener.positionX
                      ? (this.ctx.listener.positionX.setTargetAtTime(
                          this._pos[0],
                          Howler.ctx.currentTime,
                          0.1
                        ),
                        this.ctx.listener.positionY.setTargetAtTime(
                          this._pos[1],
                          Howler.ctx.currentTime,
                          0.1
                        ),
                        this.ctx.listener.positionZ.setTargetAtTime(
                          this._pos[2],
                          Howler.ctx.currentTime,
                          0.1
                        ))
                      : this.ctx.listener.setPosition(
                          this._pos[0],
                          this._pos[1],
                          this._pos[2]
                        ),
                    this)
                : this;
            }),
            (HowlerGlobal.prototype.orientation = function (_, I, R, B, z, k) {
              if (!this.ctx || !this.ctx.listener) return this;
              var V = this._orientation;
              return ((I = "number" != typeof I ? V[1] : I),
              (R = "number" != typeof R ? V[2] : R),
              (B = "number" != typeof B ? V[3] : B),
              (z = "number" != typeof z ? V[4] : z),
              (k = "number" != typeof k ? V[5] : k),
              "number" != typeof _)
                ? V
                : ((this._orientation = [_, I, R, B, z, k]),
                  "u" > typeof this.ctx.listener.forwardX
                    ? (this.ctx.listener.forwardX.setTargetAtTime(
                        _,
                        Howler.ctx.currentTime,
                        0.1
                      ),
                      this.ctx.listener.forwardY.setTargetAtTime(
                        I,
                        Howler.ctx.currentTime,
                        0.1
                      ),
                      this.ctx.listener.forwardZ.setTargetAtTime(
                        R,
                        Howler.ctx.currentTime,
                        0.1
                      ),
                      this.ctx.listener.upX.setTargetAtTime(
                        B,
                        Howler.ctx.currentTime,
                        0.1
                      ),
                      this.ctx.listener.upY.setTargetAtTime(
                        z,
                        Howler.ctx.currentTime,
                        0.1
                      ),
                      this.ctx.listener.upZ.setTargetAtTime(
                        k,
                        Howler.ctx.currentTime,
                        0.1
                      ))
                    : this.ctx.listener.setOrientation(_, I, R, B, z, k),
                  this);
            }),
            (Howl.prototype.init =
              ((Q = Howl.prototype.init),
              function (_) {
                return (
                  (this._orientation = _.orientation || [1, 0, 0]),
                  (this._stereo = _.stereo || null),
                  (this._pos = _.pos || null),
                  (this._pannerAttr = {
                    coneInnerAngle:
                      "u" > typeof _.coneInnerAngle ? _.coneInnerAngle : 360,
                    coneOuterAngle:
                      "u" > typeof _.coneOuterAngle ? _.coneOuterAngle : 360,
                    coneOuterGain:
                      "u" > typeof _.coneOuterGain ? _.coneOuterGain : 0,
                    distanceModel:
                      "u" > typeof _.distanceModel
                        ? _.distanceModel
                        : "inverse",
                    maxDistance:
                      "u" > typeof _.maxDistance ? _.maxDistance : 1e4,
                    panningModel:
                      "u" > typeof _.panningModel ? _.panningModel : "HRTF",
                    refDistance: "u" > typeof _.refDistance ? _.refDistance : 1,
                    rolloffFactor:
                      "u" > typeof _.rolloffFactor ? _.rolloffFactor : 1,
                  }),
                  (this._onstereo = _.onstereo ? [{ fn: _.onstereo }] : []),
                  (this._onpos = _.onpos ? [{ fn: _.onpos }] : []),
                  (this._onorientation = _.onorientation
                    ? [{ fn: _.onorientation }]
                    : []),
                  Q.call(this, _)
                );
              })),
            (Howl.prototype.stereo = function (_, I) {
              var R = this;
              if (!R._webAudio) return R;
              if ("loaded" !== R._state)
                return (
                  R._queue.push({
                    event: "stereo",
                    action: function () {
                      R.stereo(_, I);
                    },
                  }),
                  R
                );
              var B =
                typeof Howler.ctx.createStereoPanner > "u"
                  ? "spatial"
                  : "stereo";
              if (typeof I > "u") {
                if ("number" != typeof _) return R._stereo;
                (R._stereo = _), (R._pos = [_, 0, 0]);
              }
              for (var z = R._getSoundIds(I), k = 0; k < z.length; k++) {
                var V = R._soundById(z[k]);
                if (V) {
                  if ("number" != typeof _) return V._stereo;
                  (V._stereo = _),
                    (V._pos = [_, 0, 0]),
                    V._node &&
                      ((V._pannerAttr.panningModel = "equalpower"),
                      (V._panner && V._panner.pan) || er(V, B),
                      "spatial" === B
                        ? "u" > typeof V._panner.positionX
                          ? (V._panner.positionX.setValueAtTime(
                              _,
                              Howler.ctx.currentTime
                            ),
                            V._panner.positionY.setValueAtTime(
                              0,
                              Howler.ctx.currentTime
                            ),
                            V._panner.positionZ.setValueAtTime(
                              0,
                              Howler.ctx.currentTime
                            ))
                          : V._panner.setPosition(_, 0, 0)
                        : V._panner.pan.setValueAtTime(
                            _,
                            Howler.ctx.currentTime
                          )),
                    R._emit("stereo", V._id);
                }
              }
              return R;
            }),
            (Howl.prototype.pos = function (_, I, R, B) {
              var z = this;
              if (!z._webAudio) return z;
              if ("loaded" !== z._state)
                return (
                  z._queue.push({
                    event: "pos",
                    action: function () {
                      z.pos(_, I, R, B);
                    },
                  }),
                  z
                );
              if (
                ((I = "number" != typeof I ? 0 : I),
                (R = "number" != typeof R ? -0.5 : R),
                typeof B > "u")
              ) {
                if ("number" != typeof _) return z._pos;
                z._pos = [_, I, R];
              }
              for (var k = z._getSoundIds(B), V = 0; V < k.length; V++) {
                var j = z._soundById(k[V]);
                if (j) {
                  if ("number" != typeof _) return j._pos;
                  (j._pos = [_, I, R]),
                    j._node &&
                      ((!j._panner || j._panner.pan) && er(j, "spatial"),
                      "u" > typeof j._panner.positionX
                        ? (j._panner.positionX.setValueAtTime(
                            _,
                            Howler.ctx.currentTime
                          ),
                          j._panner.positionY.setValueAtTime(
                            I,
                            Howler.ctx.currentTime
                          ),
                          j._panner.positionZ.setValueAtTime(
                            R,
                            Howler.ctx.currentTime
                          ))
                        : j._panner.setPosition(_, I, R)),
                    z._emit("pos", j._id);
                }
              }
              return z;
            }),
            (Howl.prototype.orientation = function (_, I, R, B) {
              var z = this;
              if (!z._webAudio) return z;
              if ("loaded" !== z._state)
                return (
                  z._queue.push({
                    event: "orientation",
                    action: function () {
                      z.orientation(_, I, R, B);
                    },
                  }),
                  z
                );
              if (
                ((I = "number" != typeof I ? z._orientation[1] : I),
                (R = "number" != typeof R ? z._orientation[2] : R),
                typeof B > "u")
              ) {
                if ("number" != typeof _) return z._orientation;
                z._orientation = [_, I, R];
              }
              for (var k = z._getSoundIds(B), V = 0; V < k.length; V++) {
                var j = z._soundById(k[V]);
                if (j) {
                  if ("number" != typeof _) return j._orientation;
                  (j._orientation = [_, I, R]),
                    j._node &&
                      (j._panner ||
                        (j._pos || (j._pos = z._pos || [0, 0, -0.5]),
                        er(j, "spatial")),
                      "u" > typeof j._panner.orientationX
                        ? (j._panner.orientationX.setValueAtTime(
                            _,
                            Howler.ctx.currentTime
                          ),
                          j._panner.orientationY.setValueAtTime(
                            I,
                            Howler.ctx.currentTime
                          ),
                          j._panner.orientationZ.setValueAtTime(
                            R,
                            Howler.ctx.currentTime
                          ))
                        : j._panner.setOrientation(_, I, R)),
                    z._emit("orientation", j._id);
                }
              }
              return z;
            }),
            (Howl.prototype.pannerAttr = function () {
              var _,
                I,
                R,
                B = arguments;
              if (!this._webAudio) return this;
              if (0 === B.length) return this._pannerAttr;
              if (1 === B.length) {
                if ("object" != typeof B[0])
                  return (R = this._soundById(parseInt(B[0], 10)))
                    ? R._pannerAttr
                    : this._pannerAttr;
                (_ = B[0]),
                  typeof I > "u" &&
                    (_.pannerAttr ||
                      (_.pannerAttr = {
                        coneInnerAngle: _.coneInnerAngle,
                        coneOuterAngle: _.coneOuterAngle,
                        coneOuterGain: _.coneOuterGain,
                        distanceModel: _.distanceModel,
                        maxDistance: _.maxDistance,
                        refDistance: _.refDistance,
                        rolloffFactor: _.rolloffFactor,
                        panningModel: _.panningModel,
                      }),
                    (this._pannerAttr = {
                      coneInnerAngle:
                        "u" > typeof _.pannerAttr.coneInnerAngle
                          ? _.pannerAttr.coneInnerAngle
                          : this._coneInnerAngle,
                      coneOuterAngle:
                        "u" > typeof _.pannerAttr.coneOuterAngle
                          ? _.pannerAttr.coneOuterAngle
                          : this._coneOuterAngle,
                      coneOuterGain:
                        "u" > typeof _.pannerAttr.coneOuterGain
                          ? _.pannerAttr.coneOuterGain
                          : this._coneOuterGain,
                      distanceModel:
                        "u" > typeof _.pannerAttr.distanceModel
                          ? _.pannerAttr.distanceModel
                          : this._distanceModel,
                      maxDistance:
                        "u" > typeof _.pannerAttr.maxDistance
                          ? _.pannerAttr.maxDistance
                          : this._maxDistance,
                      refDistance:
                        "u" > typeof _.pannerAttr.refDistance
                          ? _.pannerAttr.refDistance
                          : this._refDistance,
                      rolloffFactor:
                        "u" > typeof _.pannerAttr.rolloffFactor
                          ? _.pannerAttr.rolloffFactor
                          : this._rolloffFactor,
                      panningModel:
                        "u" > typeof _.pannerAttr.panningModel
                          ? _.pannerAttr.panningModel
                          : this._panningModel,
                    }));
              } else 2 === B.length && ((_ = B[0]), (I = parseInt(B[1], 10)));
              for (var z = this._getSoundIds(I), k = 0; k < z.length; k++)
                if ((R = this._soundById(z[k]))) {
                  var V = R._pannerAttr;
                  V = {
                    coneInnerAngle:
                      "u" > typeof _.coneInnerAngle
                        ? _.coneInnerAngle
                        : V.coneInnerAngle,
                    coneOuterAngle:
                      "u" > typeof _.coneOuterAngle
                        ? _.coneOuterAngle
                        : V.coneOuterAngle,
                    coneOuterGain:
                      "u" > typeof _.coneOuterGain
                        ? _.coneOuterGain
                        : V.coneOuterGain,
                    distanceModel:
                      "u" > typeof _.distanceModel
                        ? _.distanceModel
                        : V.distanceModel,
                    maxDistance:
                      "u" > typeof _.maxDistance
                        ? _.maxDistance
                        : V.maxDistance,
                    refDistance:
                      "u" > typeof _.refDistance
                        ? _.refDistance
                        : V.refDistance,
                    rolloffFactor:
                      "u" > typeof _.rolloffFactor
                        ? _.rolloffFactor
                        : V.rolloffFactor,
                    panningModel:
                      "u" > typeof _.panningModel
                        ? _.panningModel
                        : V.panningModel,
                  };
                  var j = R._panner;
                  j
                    ? ((j.coneInnerAngle = V.coneInnerAngle),
                      (j.coneOuterAngle = V.coneOuterAngle),
                      (j.coneOuterGain = V.coneOuterGain),
                      (j.distanceModel = V.distanceModel),
                      (j.maxDistance = V.maxDistance),
                      (j.refDistance = V.refDistance),
                      (j.rolloffFactor = V.rolloffFactor),
                      (j.panningModel = V.panningModel))
                    : (R._pos || (R._pos = this._pos || [0, 0, -0.5]),
                      er(R, "spatial"));
                }
              return this;
            }),
            (Sound.prototype.init =
              (($ = Sound.prototype.init),
              function () {
                var _ = this._parent;
                (this._orientation = _._orientation),
                  (this._stereo = _._stereo),
                  (this._pos = _._pos),
                  (this._pannerAttr = _._pannerAttr),
                  $.call(this),
                  this._stereo
                    ? _.stereo(this._stereo)
                    : this._pos &&
                      _.pos(this._pos[0], this._pos[1], this._pos[2], this._id);
              })),
            (Sound.prototype.reset =
              ((et = Sound.prototype.reset),
              function () {
                var _ = this._parent;
                return (
                  (this._orientation = _._orientation),
                  (this._stereo = _._stereo),
                  (this._pos = _._pos),
                  (this._pannerAttr = _._pannerAttr),
                  this._stereo
                    ? _.stereo(this._stereo)
                    : this._pos
                    ? _.pos(this._pos[0], this._pos[1], this._pos[2], this._id)
                    : this._panner &&
                      (this._panner.disconnect(0),
                      (this._panner = void 0),
                      _._refreshBuffer(this)),
                  et.call(this)
                );
              })),
            (er = function (_, I) {
              "spatial" === (I = I || "spatial")
                ? ((_._panner = Howler.ctx.createPanner()),
                  (_._panner.coneInnerAngle = _._pannerAttr.coneInnerAngle),
                  (_._panner.coneOuterAngle = _._pannerAttr.coneOuterAngle),
                  (_._panner.coneOuterGain = _._pannerAttr.coneOuterGain),
                  (_._panner.distanceModel = _._pannerAttr.distanceModel),
                  (_._panner.maxDistance = _._pannerAttr.maxDistance),
                  (_._panner.refDistance = _._pannerAttr.refDistance),
                  (_._panner.rolloffFactor = _._pannerAttr.rolloffFactor),
                  (_._panner.panningModel = _._pannerAttr.panningModel),
                  "u" > typeof _._panner.positionX
                    ? (_._panner.positionX.setValueAtTime(
                        _._pos[0],
                        Howler.ctx.currentTime
                      ),
                      _._panner.positionY.setValueAtTime(
                        _._pos[1],
                        Howler.ctx.currentTime
                      ),
                      _._panner.positionZ.setValueAtTime(
                        _._pos[2],
                        Howler.ctx.currentTime
                      ))
                    : _._panner.setPosition(_._pos[0], _._pos[1], _._pos[2]),
                  "u" > typeof _._panner.orientationX
                    ? (_._panner.orientationX.setValueAtTime(
                        _._orientation[0],
                        Howler.ctx.currentTime
                      ),
                      _._panner.orientationY.setValueAtTime(
                        _._orientation[1],
                        Howler.ctx.currentTime
                      ),
                      _._panner.orientationZ.setValueAtTime(
                        _._orientation[2],
                        Howler.ctx.currentTime
                      ))
                    : _._panner.setOrientation(
                        _._orientation[0],
                        _._orientation[1],
                        _._orientation[2]
                      ))
                : ((_._panner = Howler.ctx.createStereoPanner()),
                  _._panner.pan.setValueAtTime(
                    _._stereo,
                    Howler.ctx.currentTime
                  )),
                _._panner.connect(_._node),
                _._paused || _._parent.pause(_._id, !0).play(_._id, !0);
            });
        }),
        iW = zi((_, I) => {
          function au(_, I, R, B) {
            (this.message = _),
              (this.expected = I),
              (this.found = R),
              (this.location = B),
              (this.name = "SyntaxError"),
              "function" == typeof Error.captureStackTrace &&
                Error.captureStackTrace(this, au);
          }
          !(function (_, I) {
            function e() {
              this.constructor = _;
            }
            (e.prototype = I.prototype), (_.prototype = new e());
          })(au, Error),
            (au.buildMessage = function (_, I) {
              var R = {
                literal: function (_) {
                  return '"' + i(_.text) + '"';
                },
                class: function (_) {
                  var I,
                    R = "";
                  for (I = 0; I < _.parts.length; I++)
                    R +=
                      _.parts[I] instanceof Array
                        ? s(_.parts[I][0]) + "-" + s(_.parts[I][1])
                        : s(_.parts[I]);
                  return "[" + (_.inverted ? "^" : "") + R + "]";
                },
                any: function (_) {
                  return "any character";
                },
                end: function (_) {
                  return "end of input";
                },
                other: function (_) {
                  return _.description;
                },
              };
              function r(_) {
                return _.charCodeAt(0).toString(16).toUpperCase();
              }
              function i(_) {
                return _.replace(/\\/g, "\\\\")
                  .replace(/"/g, '\\"')
                  .replace(/\0/g, "\\0")
                  .replace(/\t/g, "\\t")
                  .replace(/\n/g, "\\n")
                  .replace(/\r/g, "\\r")
                  .replace(/[\x00-\x0F]/g, function (_) {
                    return "\\x0" + r(_);
                  })
                  .replace(/[\x10-\x1F\x7F-\x9F]/g, function (_) {
                    return "\\x" + r(_);
                  });
              }
              function s(_) {
                return _.replace(/\\/g, "\\\\")
                  .replace(/\]/g, "\\]")
                  .replace(/\^/g, "\\^")
                  .replace(/-/g, "\\-")
                  .replace(/\0/g, "\\0")
                  .replace(/\t/g, "\\t")
                  .replace(/\n/g, "\\n")
                  .replace(/\r/g, "\\r")
                  .replace(/[\x00-\x0F]/g, function (_) {
                    return "\\x0" + r(_);
                  })
                  .replace(/[\x10-\x1F\x7F-\x9F]/g, function (_) {
                    return "\\x" + r(_);
                  });
              }
              return (
                "Expected " +
                (function (_) {
                  var I,
                    B,
                    z,
                    k = Array(_.length);
                  for (B = 0; B < _.length; B++) k[B] = R[(I = _[B]).type](I);
                  if ((k.sort(), k.length > 0)) {
                    for (B = 1, z = 1; B < k.length; B++)
                      k[B - 1] !== k[B] && ((k[z] = k[B]), z++);
                    k.length = z;
                  }
                  switch (k.length) {
                    case 1:
                      return k[0];
                    case 2:
                      return k[0] + " or " + k[1];
                    default:
                      return (
                        k.slice(0, -1).join(", ") + ", or " + k[k.length - 1]
                      );
                  }
                })(_) +
                " but " +
                (I ? '"' + i(I) + '"' : "end of input") +
                " found."
              );
            }),
            (I.exports = {
              SyntaxError: au,
              parse: function (_, I) {
                I = void 0 !== I ? I : {};
                var R,
                  B,
                  z,
                  k,
                  V,
                  j,
                  G,
                  q,
                  X = {},
                  Q = { svg_path: je },
                  $ = je,
                  s = function (_) {
                    if (!_) return [];
                    for (var I = [], R = 0; R < _.length; R++)
                      I = I.concat.apply(I, _[R]);
                    var B = I[0];
                    return (
                      B && "m" == B.code && (delete B.relative, (B.code = "M")),
                      I
                    );
                  },
                  o = function (_, I) {
                    return (function (_, I) {
                      if (!I) return [_];
                      for (var R = [_], B = 0, z = I.length; B < z; B++)
                        R[B + 1] = I[B][1];
                      return R;
                    })(_, I);
                  },
                  et = /^[Mm]/,
                  er = Be(["M", "m"], !1, !1),
                  u = function (_, I, R) {
                    var B = fi(_, [I]);
                    return (
                      R && (B = B.concat(fi("M" == _ ? "L" : "l", R[1]))), B
                    );
                  },
                  es = /^[Zz]/,
                  ea = Be(["Z", "z"], !1, !1),
                  en = /^[Ll]/,
                  eo = Be(["L", "l"], !1, !1),
                  m = function (_, I) {
                    return fi(_, I);
                  },
                  el = /^[Hh]/,
                  eh = Be(["H", "h"], !1, !1),
                  ec = /^[Vv]/,
                  ed = Be(["V", "v"], !1, !1),
                  ep = /^[Cc]/,
                  ef = Be(["C", "c"], !1, !1),
                  em = /^[Ss]/,
                  ey = Be(["S", "s"], !1, !1),
                  ex = /^[Qq]/,
                  eb = Be(["Q", "q"], !1, !1),
                  ew = /^[Tt]/,
                  e_ = Be(["T", "t"], !1, !1),
                  eS = /^[Aa]/,
                  eA = Be(["A", "a"], !1, !1),
                  eC = /^[01]/,
                  eT = Be(["0", "1"], !1, !1),
                  W = function () {
                    return "";
                  },
                  eP = Ge(",", !1),
                  re = function (_) {
                    return _.join("");
                  },
                  eI = Ge(".", !1),
                  eR = /^[eE]/,
                  eB = Be(["e", "E"], !1, !1),
                  ez = /^[+\-]/,
                  eF = Be(["+", "-"], !1, !1),
                  ek = /^[0-9]/,
                  eU = Be([["0", "9"]], !1, !1),
                  eV = /^[ \t\n\r]/,
                  ej = Be(
                    [
                      " ",
                      "	",
                      `
`,
                      "\r",
                    ],
                    !1,
                    !1
                  ),
                  eH = 0,
                  eW = [{ line: 1, column: 1 }],
                  eq = 0,
                  eX = [];
                if ("startRule" in I) {
                  if (!(I.startRule in Q))
                    throw Error(
                      "Can't start parsing from rule \"" + I.startRule + '".'
                    );
                  $ = Q[I.startRule];
                }
                function Ge(_, I) {
                  return { type: "literal", text: _, ignoreCase: I };
                }
                function Be(_, I, R) {
                  return {
                    type: "class",
                    parts: _,
                    inverted: I,
                    ignoreCase: R,
                  };
                }
                function fr(I) {
                  var R,
                    B = eW[I];
                  if (B) return B;
                  for (R = I - 1; !eW[R]; ) R--;
                  for (
                    B = { line: (B = eW[R]).line, column: B.column };
                    R < I;

                  )
                    10 === _.charCodeAt(R)
                      ? (B.line++, (B.column = 1))
                      : B.column++,
                      R++;
                  return (eW[I] = B), B;
                }
                function K(_) {
                  eH < eq || (eH > eq && ((eq = eH), (eX = [])), eX.push(_));
                }
                function je() {
                  var _, I, R, B, z;
                  for (_ = eH, I = [], R = At(); R !== X; )
                    I.push(R), (R = At());
                  if (I !== X) {
                    if (
                      ((R = (function () {
                        var _, I, R, B, z, k;
                        if (((_ = eH), (I = Ct()) !== X)) {
                          for (R = [], B = eH, z = [], k = At(); k !== X; )
                            z.push(k), (k = At());
                          for (
                            z !== X && (k = Ct()) !== X
                              ? (B = z = [z, k])
                              : ((eH = B), (B = X));
                            B !== X;

                          ) {
                            for (R.push(B), B = eH, z = [], k = At(); k !== X; )
                              z.push(k), (k = At());
                            z !== X && (k = Ct()) !== X
                              ? (B = z = [z, k])
                              : ((eH = B), (B = X));
                          }
                          R !== X ? (_ = I = o(I, R)) : ((eH = _), (_ = X));
                        } else (eH = _), (_ = X);
                        return _;
                      })()) === X && (R = null),
                      R !== X)
                    ) {
                      for (B = [], z = At(); z !== X; ) B.push(z), (z = At());
                      B !== X ? (_ = I = s(R)) : ((eH = _), (_ = X));
                    } else (eH = _), (_ = X);
                  } else (eH = _), (_ = X);
                  return _;
                }
                function Ct() {
                  var I, R, B, z, k, V;
                  if (
                    ((I = eH),
                    (R = (function () {
                      var I, R, B, z, k, V, j;
                      if (
                        ((I = eH),
                        et.test(_.charAt(eH))
                          ? ((R = _.charAt(eH)), eH++)
                          : ((R = X), K(er)),
                        R !== X)
                      ) {
                        for (B = [], z = At(); z !== X; ) B.push(z), (z = At());
                        B !== X && (z = kt()) !== X
                          ? ((k = eH),
                            (V = yt()) === X && (V = null),
                            V !== X && (j = hs()) !== X
                              ? (k = V = [V, j])
                              : ((eH = k), (k = X)),
                            k === X && (k = null),
                            k !== X
                              ? (I = R = u(R, z, k))
                              : ((eH = I), (I = X)))
                          : ((eH = I), (I = X));
                      } else (eH = I), (I = X);
                      return I;
                    })()) !== X)
                  ) {
                    for (B = [], z = eH, k = [], V = At(); V !== X; )
                      k.push(V), (V = At());
                    for (
                      k !== X && (V = Ur()) !== X
                        ? (z = k = [k, V])
                        : ((eH = z), (z = X));
                      z !== X;

                    ) {
                      for (B.push(z), z = eH, k = [], V = At(); V !== X; )
                        k.push(V), (V = At());
                      k !== X && (V = Ur()) !== X
                        ? (z = k = [k, V])
                        : ((eH = z), (z = X));
                    }
                    B !== X ? (I = R = o(R, B)) : ((eH = I), (I = X));
                  } else (eH = I), (I = X);
                  return I;
                }
                function Ur() {
                  var I, R;
                  return (
                    es.test(_.charAt(eH))
                      ? ((R = _.charAt(eH)), eH++)
                      : ((R = X), K(ea)),
                    R !== X && (R = fi("Z")),
                    (I = R) === X &&
                      (I = (function () {
                        var I, R, B, z;
                        if (
                          ((I = eH),
                          en.test(_.charAt(eH))
                            ? ((R = _.charAt(eH)), eH++)
                            : ((R = X), K(eo)),
                          R !== X)
                        ) {
                          for (B = [], z = At(); z !== X; )
                            B.push(z), (z = At());
                          B !== X && (z = hs()) !== X
                            ? (I = R = m(R, z))
                            : ((eH = I), (I = X));
                        } else (eH = I), (I = X);
                        return I;
                      })()) === X &&
                      (I = (function () {
                        var I, R, B, z;
                        if (
                          ((I = eH),
                          el.test(_.charAt(eH))
                            ? ((R = _.charAt(eH)), eH++)
                            : ((R = X), K(eh)),
                          R !== X)
                        ) {
                          for (B = [], z = At(); z !== X; )
                            B.push(z), (z = At());
                          B !== X && (z = sp()) !== X
                            ? (I = R =
                                fi(
                                  R,
                                  z.map(function (_) {
                                    return { x: _ };
                                  })
                                ))
                            : ((eH = I), (I = X));
                        } else (eH = I), (I = X);
                        return I;
                      })()) === X &&
                      (I = (function () {
                        var I, R, B, z;
                        if (
                          ((I = eH),
                          ec.test(_.charAt(eH))
                            ? ((R = _.charAt(eH)), eH++)
                            : ((R = X), K(ed)),
                          R !== X)
                        ) {
                          for (B = [], z = At(); z !== X; )
                            B.push(z), (z = At());
                          B !== X && (z = sp()) !== X
                            ? (I = R =
                                fi(
                                  R,
                                  z.map(function (_) {
                                    return { y: _ };
                                  })
                                ))
                            : ((eH = I), (I = X));
                        } else (eH = I), (I = X);
                        return I;
                      })()) === X &&
                      (I = (function () {
                        var I, R, B, z;
                        if (
                          ((I = eH),
                          ep.test(_.charAt(eH))
                            ? ((R = _.charAt(eH)), eH++)
                            : ((R = X), K(ef)),
                          R !== X)
                        ) {
                          for (B = [], z = At(); z !== X; )
                            B.push(z), (z = At());
                          B !== X &&
                          (z = (function () {
                            var _, I, R, B, z, k;
                            if (((_ = eH), (I = U()) !== X)) {
                              for (
                                R = [],
                                  B = eH,
                                  (z = yt()) === X && (z = null),
                                  z !== X && (k = U()) !== X
                                    ? (B = z = [z, k])
                                    : ((eH = B), (B = X));
                                B !== X;

                              )
                                R.push(B),
                                  (B = eH),
                                  (z = yt()) === X && (z = null),
                                  z !== X && (k = U()) !== X
                                    ? (B = z = [z, k])
                                    : ((eH = B), (B = X));
                              R !== X ? (_ = I = o(I, R)) : ((eH = _), (_ = X));
                            } else (eH = _), (_ = X);
                            return _;
                          })()) !== X
                            ? (I = R = m(R, z))
                            : ((eH = I), (I = X));
                        } else (eH = I), (I = X);
                        return I;
                      })()) === X &&
                      (I = (function () {
                        var I, R, B, z;
                        if (
                          ((I = eH),
                          em.test(_.charAt(eH))
                            ? ((R = _.charAt(eH)), eH++)
                            : ((R = X), K(ey)),
                          R !== X)
                        ) {
                          for (B = [], z = At(); z !== X; )
                            B.push(z), (z = At());
                          B !== X &&
                          (z = (function () {
                            var _, I, R, B, z, k;
                            if (((_ = eH), (I = oe()) !== X)) {
                              for (
                                R = [],
                                  B = eH,
                                  (z = yt()) === X && (z = null),
                                  z !== X && (k = oe()) !== X
                                    ? (B = z = [z, k])
                                    : ((eH = B), (B = X));
                                B !== X;

                              )
                                R.push(B),
                                  (B = eH),
                                  (z = yt()) === X && (z = null),
                                  z !== X && (k = oe()) !== X
                                    ? (B = z = [z, k])
                                    : ((eH = B), (B = X));
                              R !== X ? (_ = I = o(I, R)) : ((eH = _), (_ = X));
                            } else (eH = _), (_ = X);
                            return _;
                          })()) !== X
                            ? (I = R = m(R, z))
                            : ((eH = I), (I = X));
                        } else (eH = I), (I = X);
                        return I;
                      })()) === X &&
                      (I = (function () {
                        var I, R, B, z;
                        if (
                          ((I = eH),
                          ex.test(_.charAt(eH))
                            ? ((R = _.charAt(eH)), eH++)
                            : ((R = X), K(eb)),
                          R !== X)
                        ) {
                          for (B = [], z = At(); z !== X; )
                            B.push(z), (z = At());
                          B !== X &&
                          (z = (function () {
                            var _, I, R, B, z, k;
                            if (((_ = eH), (I = gt()) !== X)) {
                              for (
                                R = [],
                                  B = eH,
                                  (z = yt()) === X && (z = null),
                                  z !== X && (k = gt()) !== X
                                    ? (B = z = [z, k])
                                    : ((eH = B), (B = X));
                                B !== X;

                              )
                                R.push(B),
                                  (B = eH),
                                  (z = yt()) === X && (z = null),
                                  z !== X && (k = gt()) !== X
                                    ? (B = z = [z, k])
                                    : ((eH = B), (B = X));
                              R !== X ? (_ = I = o(I, R)) : ((eH = _), (_ = X));
                            } else (eH = _), (_ = X);
                            return _;
                          })()) !== X
                            ? (I = R = m(R, z))
                            : ((eH = I), (I = X));
                        } else (eH = I), (I = X);
                        return I;
                      })()) === X &&
                      (I = (function () {
                        var I, R, B, z;
                        if (
                          ((I = eH),
                          ew.test(_.charAt(eH))
                            ? ((R = _.charAt(eH)), eH++)
                            : ((R = X), K(e_)),
                          R !== X)
                        ) {
                          for (B = [], z = At(); z !== X; )
                            B.push(z), (z = At());
                          B !== X &&
                          (z = (function () {
                            var _, I, R, B, z, k;
                            if (((_ = eH), (I = kt()) !== X)) {
                              for (
                                R = [],
                                  B = eH,
                                  (z = yt()) === X && (z = null),
                                  z !== X && (k = kt()) !== X
                                    ? (B = z = [z, k])
                                    : ((eH = B), (B = X));
                                B !== X;

                              )
                                R.push(B),
                                  (B = eH),
                                  (z = yt()) === X && (z = null),
                                  z !== X && (k = kt()) !== X
                                    ? (B = z = [z, k])
                                    : ((eH = B), (B = X));
                              R !== X ? (_ = I = o(I, R)) : ((eH = _), (_ = X));
                            } else (eH = _), (_ = X);
                            return _;
                          })()) !== X
                            ? (I = R = m(R, z))
                            : ((eH = I), (I = X));
                        } else (eH = I), (I = X);
                        return I;
                      })()) === X &&
                      (I = (function () {
                        var I, R, B, z;
                        if (
                          ((I = eH),
                          eS.test(_.charAt(eH))
                            ? ((R = _.charAt(eH)), eH++)
                            : ((R = X), K(eA)),
                          R !== X)
                        ) {
                          for (B = [], z = At(); z !== X; )
                            B.push(z), (z = At());
                          B !== X &&
                          (z = (function () {
                            var _, I, R, B, z, k;
                            if (((_ = eH), (I = Pt()) !== X)) {
                              for (
                                R = [],
                                  B = eH,
                                  (z = yt()) === X && (z = null),
                                  z !== X && (k = Pt()) !== X
                                    ? (B = z = [z, k])
                                    : ((eH = B), (B = X));
                                B !== X;

                              )
                                R.push(B),
                                  (B = eH),
                                  (z = yt()) === X && (z = null),
                                  z !== X && (k = Pt()) !== X
                                    ? (B = z = [z, k])
                                    : ((eH = B), (B = X));
                              R !== X ? (_ = I = o(I, R)) : ((eH = _), (_ = X));
                            } else (eH = _), (_ = X);
                            return _;
                          })()) !== X
                            ? (I = R = m(R, z))
                            : ((eH = I), (I = X));
                        } else (eH = I), (I = X);
                        return I;
                      })()),
                    I
                  );
                }
                function hs() {
                  var _, I, R, B, z, k;
                  if (((_ = eH), (I = kt()) !== X)) {
                    for (
                      R = [],
                        B = eH,
                        (z = yt()) === X && (z = null),
                        z !== X && (k = kt()) !== X
                          ? (B = z = [z, k])
                          : ((eH = B), (B = X));
                      B !== X;

                    )
                      R.push(B),
                        (B = eH),
                        (z = yt()) === X && (z = null),
                        z !== X && (k = kt()) !== X
                          ? (B = z = [z, k])
                          : ((eH = B), (B = X));
                    R !== X ? (_ = I = o(I, R)) : ((eH = _), (_ = X));
                  } else (eH = _), (_ = X);
                  return _;
                }
                function sp() {
                  var _, I, R, B, z, k;
                  if (((_ = eH), (I = hn()) !== X)) {
                    for (
                      R = [],
                        B = eH,
                        (z = yt()) === X && (z = null),
                        z !== X && (k = hn()) !== X
                          ? (B = z = [z, k])
                          : ((eH = B), (B = X));
                      B !== X;

                    )
                      R.push(B),
                        (B = eH),
                        (z = yt()) === X && (z = null),
                        z !== X && (k = hn()) !== X
                          ? (B = z = [z, k])
                          : ((eH = B), (B = X));
                    R !== X ? (_ = I = o(I, R)) : ((eH = _), (_ = X));
                  } else (eH = _), (_ = X);
                  return _;
                }
                function U() {
                  var _, I, R, B, z, k, V, j, G;
                  return (
                    (_ = eH),
                    (I = kt()) !== X
                      ? ((R = yt()) === X && (R = null),
                        R !== X && (B = kt()) !== X
                          ? ((z = yt()) === X && (z = null),
                            z !== X && (k = kt()) !== X
                              ? ((V = I),
                                (j = B),
                                (G = k),
                                (_ = I =
                                  {
                                    x1: V.x,
                                    y1: V.y,
                                    x2: j.x,
                                    y2: j.y,
                                    x: G.x,
                                    y: G.y,
                                  }))
                              : ((eH = _), (_ = X)))
                          : ((eH = _), (_ = X)))
                      : ((eH = _), (_ = X)),
                    _
                  );
                }
                function oe() {
                  var _, I, R, B, z, k;
                  return (
                    (_ = eH),
                    (I = kt()) !== X
                      ? ((R = yt()) === X && (R = null),
                        R !== X && (B = kt()) !== X
                          ? ((z = I),
                            (k = B),
                            (_ = I = { x2: z.x, y2: z.y, x: k.x, y: k.y }))
                          : ((eH = _), (_ = X)))
                      : ((eH = _), (_ = X)),
                    _
                  );
                }
                function gt() {
                  var _, I, R, B, z, k;
                  return (
                    (_ = eH),
                    (I = kt()) !== X
                      ? ((R = yt()) === X && (R = null),
                        R !== X && (B = kt()) !== X
                          ? ((z = I),
                            (k = B),
                            (_ = I = { x1: z.x, y1: z.y, x: k.x, y: k.y }))
                          : ((eH = _), (_ = X)))
                      : ((eH = _), (_ = X)),
                    _
                  );
                }
                function Pt() {
                  var _, I, R, B, z, k, V, j, G, q, Q, $;
                  return (
                    (_ = eH),
                    (I = un()) !== X
                      ? ((R = yt()) === X && (R = null),
                        R !== X && (B = un()) !== X
                          ? ((z = yt()) === X && (z = null),
                            z !== X &&
                            (k = hn()) !== X &&
                            yt() !== X &&
                            (V = So()) !== X
                              ? ((j = yt()) === X && (j = null),
                                j !== X && (G = So()) !== X
                                  ? ((q = yt()) === X && (q = null),
                                    q !== X && (Q = kt()) !== X
                                      ? (_ = I =
                                          {
                                            rx: I,
                                            ry: B,
                                            xAxisRotation: k,
                                            largeArc: V,
                                            sweep: G,
                                            x: ($ = Q).x,
                                            y: $.y,
                                          })
                                      : ((eH = _), (_ = X)))
                                  : ((eH = _), (_ = X)))
                              : ((eH = _), (_ = X)))
                          : ((eH = _), (_ = X)))
                      : ((eH = _), (_ = X)),
                    _
                  );
                }
                function kt() {
                  var _, I, R, B;
                  return (
                    (_ = eH),
                    (I = hn()) !== X
                      ? ((R = yt()) === X && (R = null),
                        R !== X && (B = hn()) !== X
                          ? (_ = I = { x: I, y: B })
                          : ((eH = _), (_ = X)))
                      : ((eH = _), (_ = X)),
                    _
                  );
                }
                function un() {
                  var _;
                  return (_ = vu()) === X && (_ = Zn()), _ !== X && (_ *= 1), _;
                }
                function hn() {
                  var _, I, R;
                  return (
                    (_ = eH),
                    (I = xu()) === X && (I = null),
                    I !== X && (R = vu()) !== X
                      ? (_ = I = [I, R])
                      : ((eH = _), (_ = X)),
                    _ === X &&
                      ((_ = eH),
                      (I = xu()) === X && (I = null),
                      I !== X && (R = Zn()) !== X
                        ? (_ = I = [I, R])
                        : ((eH = _), (_ = X))),
                    _ !== X && (_ = 1 * _.join("")),
                    _
                  );
                }
                function So() {
                  var I;
                  return (
                    eC.test(_.charAt(eH))
                      ? ((I = _.charAt(eH)), eH++)
                      : ((I = X), K(eT)),
                    I !== X && (I = "1" == I),
                    I
                  );
                }
                function yt() {
                  var _, I, R, B, z;
                  if (((_ = eH), (I = []), (R = At()) !== X))
                    for (; R !== X; ) I.push(R), (R = At());
                  else I = X;
                  if (I !== X) {
                    if (((R = It()) === X && (R = null), R !== X)) {
                      for (B = [], z = At(); z !== X; ) B.push(z), (z = At());
                      B !== X ? (_ = I = [I, R, B]) : ((eH = _), (_ = X));
                    } else (eH = _), (_ = X);
                  } else (eH = _), (_ = X);
                  if (_ === X) {
                    if (((_ = eH), (I = eH), (R = It()) !== X)) {
                      for (B = [], z = At(); z !== X; ) B.push(z), (z = At());
                      B !== X ? (I = R = [R, B]) : ((eH = I), (I = X));
                    } else (eH = I), (I = X);
                    I !== X && (I = W()), (_ = I);
                  }
                  return _;
                }
                function It() {
                  var I;
                  return (
                    44 === _.charCodeAt(eH)
                      ? ((I = ","), eH++)
                      : ((I = X), K(eP)),
                    I
                  );
                }
                function vu() {
                  var I, R, B, z, k, V, j;
                  return (
                    (I = eH),
                    ((z = eH),
                    (k = Zn()) === X && (k = null),
                    k !== X
                      ? (46 === _.charCodeAt(eH)
                          ? ((V = "."), eH++)
                          : ((V = X), K(eI)),
                        V !== X && (j = Zn()) !== X
                          ? (z = k = [k, V, j])
                          : ((eH = z), (z = X)))
                      : ((eH = z), (z = X)),
                    z === X &&
                      ((z = eH),
                      (k = Zn()) !== X
                        ? (46 === _.charCodeAt(eH)
                            ? ((V = "."), eH++)
                            : ((V = X), K(eI)),
                          V !== X ? (z = k = [k, V]) : ((eH = z), (z = X)))
                        : ((eH = z), (z = X))),
                    z !== X && (z = re(z)),
                    (R = z) !== X)
                      ? ((B = wo()) === X && (B = null),
                        B !== X ? (I = R = [R, B]) : ((eH = I), (I = X)))
                      : ((eH = I), (I = X)),
                    I === X &&
                      ((I = eH),
                      (R = Zn()) !== X && (B = wo()) !== X
                        ? (I = R = [R, B])
                        : ((eH = I), (I = X))),
                    I !== X && (I = re(I)),
                    I
                  );
                }
                function wo() {
                  var I, R, B, z;
                  return (
                    (I = eH),
                    eR.test(_.charAt(eH))
                      ? ((R = _.charAt(eH)), eH++)
                      : ((R = X), K(eB)),
                    R !== X
                      ? ((B = xu()) === X && (B = null),
                        B !== X && (z = Zn()) !== X
                          ? (I = R = [R, B, z])
                          : ((eH = I), (I = X)))
                      : ((eH = I), (I = X)),
                    I !== X && (I = re(I)),
                    I
                  );
                }
                function xu() {
                  var I;
                  return (
                    ez.test(_.charAt(eH))
                      ? ((I = _.charAt(eH)), eH++)
                      : ((I = X), K(eF)),
                    I
                  );
                }
                function Zn() {
                  var I, R;
                  if (
                    ((I = []),
                    ek.test(_.charAt(eH))
                      ? ((R = _.charAt(eH)), eH++)
                      : ((R = X), K(eU)),
                    R !== X)
                  )
                    for (; R !== X; )
                      I.push(R),
                        ek.test(_.charAt(eH))
                          ? ((R = _.charAt(eH)), eH++)
                          : ((R = X), K(eU));
                  else I = X;
                  return I !== X && (I = I.join("")), I;
                }
                function At() {
                  var I;
                  return (
                    eV.test(_.charAt(eH))
                      ? ((I = _.charAt(eH)), eH++)
                      : ((I = X), K(ej)),
                    I !== X && (I = W()),
                    I
                  );
                }
                var eQ = {
                  m: "moveto",
                  l: "lineto",
                  h: "horizontal lineto",
                  v: "vertical lineto",
                  c: "curveto",
                  s: "smooth curveto",
                  q: "quadratic curveto",
                  t: "smooth quadratic curveto",
                  a: "elliptical arc",
                  z: "closepath",
                };
                for (var eZ in eQ) eQ[eZ.toUpperCase()] = eQ[eZ];
                function fi(_, I) {
                  I || (I = [{}]);
                  for (var R = I.length; R--; ) {
                    var B = { code: _, command: eQ[_] };
                    for (var z in (_ == _.toLowerCase() && (B.relative = !0),
                    I[R]))
                      B[z] = I[R][z];
                    I[R] = B;
                  }
                  return I;
                }
                if ((q = $()) !== X && eH === _.length) return q;
                throw (
                  (q !== X && eH < _.length && K({ type: "end" }),
                  (V = eX),
                  (j = eq < _.length ? _.charAt(eq) : null),
                  (R = eq),
                  (B = eq < _.length ? eq + 1 : eq),
                  (z = fr(R)),
                  (k = fr(B)),
                  (G = {
                    start: { offset: R, line: z.line, column: z.column },
                    end: { offset: B, line: k.line, column: k.column },
                  }),
                  new au(au.buildMessage(V, j), V, j, G))
                );
              },
            });
        }),
        iq = zi((_, I) => {
          var R = iW().parse;
          (R.parseSVG = R),
            (R.makeAbsolute = function (_) {
              var I,
                R = { x: 0, y: 0 },
                B = {
                  x: "x0",
                  y: "y0",
                  x1: "x0",
                  y1: "y0",
                  x2: "x0",
                  y2: "y0",
                };
              return (
                _.forEach(function (_) {
                  for (var z in ("moveto" === _.command && (I = _),
                  (_.x0 = R.x),
                  (_.y0 = R.y),
                  B))
                    z in _ && (_[z] += _.relative ? _[B[z]] : 0);
                  "x" in _ || (_.x = R.x),
                    "y" in _ || (_.y = R.y),
                    (_.relative = !1),
                    (_.code = _.code.toUpperCase()),
                    "closepath" == _.command && ((_.x = I.x), (_.y = I.y)),
                    (R = _);
                }),
                _
              );
            }),
            (I.exports = R);
        }),
        iX = zi((_, I) => {
          I.exports = function (_) {
            for (var I = Array(_), R = 0; R < _; ++R) I[R] = R;
            return I;
          };
        }),
        iQ = zi((_, I) => {
          function PL(_) {
            return (
              !!_.constructor &&
              "function" == typeof _.constructor.isBuffer &&
              _.constructor.isBuffer(_)
            );
          }
          I.exports = function (_) {
            return (
              null != _ &&
              (PL(_) ||
                ("function" == typeof _.readFloatLE &&
                  "function" == typeof _.slice &&
                  PL(_.slice(0, 0))) ||
                !!_._isBuffer)
            );
          };
        }),
        iZ = zi((_, I) => {
          var R = iX(),
            B = iQ(),
            z = "u" > typeof Float64Array;
          function yK(_, I) {
            return _[0] - I[0];
          }
          function vK() {
            var _,
              I = this.stride,
              R = Array(I.length);
            for (_ = 0; _ < R.length; ++_) R[_] = [Math.abs(I[_]), _];
            R.sort(yK);
            var B = Array(R.length);
            for (_ = 0; _ < B.length; ++_) B[_] = R[_][1];
            return B;
          }
          var k = {
            float32: [],
            float64: [],
            int8: [],
            int16: [],
            int32: [],
            uint8: [],
            uint16: [],
            uint32: [],
            array: [],
            uint8_clamped: [],
            bigint64: [],
            biguint64: [],
            buffer: [],
            generic: [],
          };
          I.exports = function (_, I, V, j) {
            if (void 0 === _) {
              var G = k.array[0];
              return G([]);
            }
            "number" == typeof _ && (_ = [_]), void 0 === I && (I = [_.length]);
            var q = I.length;
            if (void 0 === V) {
              V = Array(q);
              for (var X = q - 1, Q = 1; X >= 0; --X) (V[X] = Q), (Q *= I[X]);
            }
            if (void 0 === j) {
              j = 0;
              for (var X = 0; X < q; ++X) V[X] < 0 && (j -= (I[X] - 1) * V[X]);
            }
            for (
              var $ = (function (_) {
                  if (B(_)) return "buffer";
                  if (z)
                    switch (Object.prototype.toString.call(_)) {
                      case "[object Float64Array]":
                        return "float64";
                      case "[object Float32Array]":
                        return "float32";
                      case "[object Int8Array]":
                        return "int8";
                      case "[object Int16Array]":
                        return "int16";
                      case "[object Int32Array]":
                        return "int32";
                      case "[object Uint8Array]":
                        return "uint8";
                      case "[object Uint16Array]":
                        return "uint16";
                      case "[object Uint32Array]":
                        return "uint32";
                      case "[object Uint8ClampedArray]":
                        return "uint8_clamped";
                      case "[object BigInt64Array]":
                        return "bigint64";
                      case "[object BigUint64Array]":
                        return "biguint64";
                    }
                  return Array.isArray(_) ? "array" : "generic";
                })(_),
                et = k[$];
              et.length <= q + 1;

            )
              et.push(
                (function (_, I) {
                  var B = ["View", I, "d", _].join("");
                  I < 0 && (B = "View_Nil" + _);
                  var z = "generic" === _;
                  if (-1 === I) {
                    var V =
                        "function " +
                        B +
                        "(a){this.data=a;};var proto=" +
                        B +
                        ".prototype;proto.dtype='" +
                        _ +
                        "';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new " +
                        B +
                        "(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_" +
                        B +
                        "(a){return new " +
                        B +
                        "(a);}",
                      j = Function(V);
                    return j();
                  }
                  if (0 === I) {
                    var V =
                        "function " +
                        B +
                        "(a,d) {this.data = a;this.offset = d};var proto=" +
                        B +
                        ".prototype;proto.dtype='" +
                        _ +
                        "';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function " +
                        B +
                        "_copy() {return new " +
                        B +
                        "(this.data,this.offset)};proto.pick=function " +
                        B +
                        "_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function " +
                        B +
                        "_get(){return " +
                        (z
                          ? "this.data.get(this.offset)"
                          : "this.data[this.offset]") +
                        "};proto.set=function " +
                        B +
                        "_set(v){return " +
                        (z
                          ? "this.data.set(this.offset,v)"
                          : "this.data[this.offset]=v") +
                        "};return function construct_" +
                        B +
                        "(a,b,c,d){return new " +
                        B +
                        "(a,d)}",
                      j = Function("TrivialArray", V);
                    return j(k[_][0]);
                  }
                  var V = ["'use strict'"],
                    G = R(I),
                    q = G.map(function (_) {
                      return "i" + _;
                    }),
                    X =
                      "this.offset+" +
                      G.map(function (_) {
                        return "this.stride[" + _ + "]*i" + _;
                      }).join("+"),
                    Q = G.map(function (_) {
                      return "b" + _;
                    }).join(","),
                    $ = G.map(function (_) {
                      return "c" + _;
                    }).join(",");
                  V.push(
                    "function " + B + "(a," + Q + "," + $ + ",d){this.data=a",
                    "this.shape=[" + Q + "]",
                    "this.stride=[" + $ + "]",
                    "this.offset=d|0}",
                    "var proto=" + B + ".prototype",
                    "proto.dtype='" + _ + "'",
                    "proto.dimension=" + I
                  ),
                    V.push(
                      "Object.defineProperty(proto,'size',{get:function " +
                        B +
                        "_size(){return " +
                        G.map(function (_) {
                          return "this.shape[" + _ + "]";
                        }).join("*"),
                      "}})"
                    ),
                    1 === I
                      ? V.push("proto.order=[0]")
                      : (V.push("Object.defineProperty(proto,'order',{get:"),
                        I < 4
                          ? (V.push("function " + B + "_order(){"),
                            2 === I
                              ? V.push(
                                  "return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})"
                                )
                              : 3 === I &&
                                V.push(
                                  "var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})"
                                ))
                          : V.push("ORDER})")),
                    V.push(
                      "proto.set=function " + B + "_set(" + q.join(",") + ",v){"
                    ),
                    z
                      ? V.push("return this.data.set(" + X + ",v)}")
                      : V.push("return this.data[" + X + "]=v}"),
                    V.push(
                      "proto.get=function " + B + "_get(" + q.join(",") + "){"
                    ),
                    z
                      ? V.push("return this.data.get(" + X + ")}")
                      : V.push("return this.data[" + X + "]}"),
                    V.push(
                      "proto.index=function " + B + "_index(",
                      q.join(),
                      "){return " + X + "}"
                    ),
                    V.push(
                      "proto.hi=function " +
                        B +
                        "_hi(" +
                        q.join(",") +
                        "){return new " +
                        B +
                        "(this.data," +
                        G.map(function (_) {
                          return [
                            "(typeof i",
                            _,
                            "!=='number'||i",
                            _,
                            "<0)?this.shape[",
                            _,
                            "]:i",
                            _,
                            "|0",
                          ].join("");
                        }).join(",") +
                        "," +
                        G.map(function (_) {
                          return "this.stride[" + _ + "]";
                        }).join(",") +
                        ",this.offset)}"
                    );
                  var et = G.map(function (_) {
                      return "a" + _ + "=this.shape[" + _ + "]";
                    }),
                    er = G.map(function (_) {
                      return "c" + _ + "=this.stride[" + _ + "]";
                    });
                  V.push(
                    "proto.lo=function " +
                      B +
                      "_lo(" +
                      q.join(",") +
                      "){var b=this.offset,d=0," +
                      et.join(",") +
                      "," +
                      er.join(",")
                  );
                  for (var es = 0; es < I; ++es)
                    V.push(
                      "if(typeof i" +
                        es +
                        "==='number'&&i" +
                        es +
                        ">=0){d=i" +
                        es +
                        "|0;b+=c" +
                        es +
                        "*d;a" +
                        es +
                        "-=d}"
                    );
                  V.push(
                    "return new " +
                      B +
                      "(this.data," +
                      G.map(function (_) {
                        return "a" + _;
                      }).join(",") +
                      "," +
                      G.map(function (_) {
                        return "c" + _;
                      }).join(",") +
                      ",b)}"
                  ),
                    V.push(
                      "proto.step=function " +
                        B +
                        "_step(" +
                        q.join(",") +
                        "){var " +
                        G.map(function (_) {
                          return "a" + _ + "=this.shape[" + _ + "]";
                        }).join(",") +
                        "," +
                        G.map(function (_) {
                          return "b" + _ + "=this.stride[" + _ + "]";
                        }).join(",") +
                        ",c=this.offset,d=0,ceil=Math.ceil"
                    );
                  for (var es = 0; es < I; ++es)
                    V.push(
                      "if(typeof i" +
                        es +
                        "==='number'){d=i" +
                        es +
                        "|0;if(d<0){c+=b" +
                        es +
                        "*(a" +
                        es +
                        "-1);a" +
                        es +
                        "=ceil(-a" +
                        es +
                        "/d)}else{a" +
                        es +
                        "=ceil(a" +
                        es +
                        "/d)}b" +
                        es +
                        "*=d}"
                    );
                  V.push(
                    "return new " +
                      B +
                      "(this.data," +
                      G.map(function (_) {
                        return "a" + _;
                      }).join(",") +
                      "," +
                      G.map(function (_) {
                        return "b" + _;
                      }).join(",") +
                      ",c)}"
                  );
                  for (var ea = Array(I), en = Array(I), es = 0; es < I; ++es)
                    (ea[es] = "a[i" + es + "]"), (en[es] = "b[i" + es + "]");
                  V.push(
                    "proto.transpose=function " +
                      B +
                      "_transpose(" +
                      q +
                      "){" +
                      q
                        .map(function (_, I) {
                          return (
                            _ + "=(" + _ + "===undefined?" + I + ":" + _ + "|0)"
                          );
                        })
                        .join(";"),
                    "var a=this.shape,b=this.stride;return new " +
                      B +
                      "(this.data," +
                      ea.join(",") +
                      "," +
                      en.join(",") +
                      ",this.offset)}"
                  ),
                    V.push(
                      "proto.pick=function " +
                        B +
                        "_pick(" +
                        q +
                        "){var a=[],b=[],c=this.offset"
                    );
                  for (var es = 0; es < I; ++es)
                    V.push(
                      "if(typeof i" +
                        es +
                        "==='number'&&i" +
                        es +
                        ">=0){c=(c+this.stride[" +
                        es +
                        "]*i" +
                        es +
                        ")|0}else{a.push(this.shape[" +
                        es +
                        "]);b.push(this.stride[" +
                        es +
                        "])}"
                    );
                  V.push(
                    "var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}"
                  ),
                    V.push(
                      "return function construct_" +
                        B +
                        "(data,shape,stride,offset){return new " +
                        B +
                        "(data," +
                        G.map(function (_) {
                          return "shape[" + _ + "]";
                        }).join(",") +
                        "," +
                        G.map(function (_) {
                          return "stride[" + _ + "]";
                        }).join(",") +
                        ",offset)}"
                    );
                  var j = Function(
                    "CTOR_LIST",
                    "ORDER",
                    V.join(`
`)
                  );
                  return j(k[_], vK);
                })($, et.length - 1)
              );
            var G = et[q + 1];
            return G(_, I, V, j);
          };
        }),
        iK = zi((_, I) => {
          I.exports = function (_, I, R) {
            return 0 === _.length
              ? _
              : I
              ? (R || _.sort(I),
                (function (_, I) {
                  for (
                    var R = 1, B = _.length, z = _[0], k = _[0], V = 1;
                    V < B;
                    ++V
                  )
                    if (((k = z), I((z = _[V]), k))) {
                      if (V === R) {
                        R++;
                        continue;
                      }
                      _[R++] = z;
                    }
                  return (_.length = R), _;
                })(_, I))
              : (R || _.sort(),
                (function (_) {
                  for (
                    var I = 1, R = _.length, B = _[0], z = _[0], k = 1;
                    k < R;
                    ++k, z = B
                  )
                    if (((z = B), (B = _[k]) !== z)) {
                      if (k === I) {
                        I++;
                        continue;
                      }
                      _[I++] = B;
                    }
                  return (_.length = I), _;
                })(_));
          };
        }),
        iJ = zi((_, I) => {
          var R = iK();
          function BL(_, I, R) {
            var B,
              z,
              k = _.length,
              V = I.arrayArgs.length,
              j = I.indexArgs.length > 0,
              G = [],
              q = [],
              X = 0,
              Q = 0;
            for (B = 0; B < k; ++B) q.push(["i", B, "=0"].join(""));
            for (z = 0; z < V; ++z)
              for (B = 0; B < k; ++B)
                (Q = X),
                  (X = _[B]),
                  0 === B
                    ? q.push(["d", z, "s", B, "=t", z, "p", X].join(""))
                    : q.push(
                        [
                          "d",
                          z,
                          "s",
                          B,
                          "=(t",
                          z,
                          "p",
                          X,
                          "-s",
                          Q,
                          "*t",
                          z,
                          "p",
                          Q,
                          ")",
                        ].join("")
                      );
            for (
              q.length > 0 && G.push("var " + q.join(",")), B = k - 1;
              B >= 0;
              --B
            )
              (X = _[B]),
                G.push(
                  ["for(i", B, "=0;i", B, "<s", X, ";++i", B, "){"].join("")
                );
            for (G.push(R), B = 0; B < k; ++B) {
              for (Q = X, X = _[B], z = 0; z < V; ++z)
                G.push(["p", z, "+=d", z, "s", B].join(""));
              j &&
                (B > 0 && G.push(["index[", Q, "]-=s", Q].join("")),
                G.push(["++index[", X, "]"].join(""))),
                G.push("}");
            }
            return G.join(`
`);
          }
          function eE(_, I, R) {
            for (
              var B = _.body, z = [], k = [], V = 0;
              V < _.args.length;
              ++V
            ) {
              var j = _.args[V];
              if (!(j.count <= 0)) {
                var G = RegExp(j.name, "g"),
                  q = "",
                  X = I.arrayArgs.indexOf(V);
                switch (I.argTypes[V]) {
                  case "offset":
                    var Q = I.offsetArgIndex.indexOf(V);
                    (X = I.offsetArgs[Q].array), (q = "+q" + Q);
                  case "array":
                    q = "p" + X + q;
                    var $ = "l" + V,
                      et = "a" + X;
                    if (0 === I.arrayBlockIndices[X])
                      1 === j.count
                        ? "generic" === R[X]
                          ? j.lvalue
                            ? (z.push(
                                ["var ", $, "=", et, ".get(", q, ")"].join("")
                              ),
                              (B = B.replace(G, $)),
                              k.push([et, ".set(", q, ",", $, ")"].join("")))
                            : (B = B.replace(G, [et, ".get(", q, ")"].join("")))
                          : (B = B.replace(G, [et, "[", q, "]"].join("")))
                        : "generic" === R[X]
                        ? (z.push(
                            ["var ", $, "=", et, ".get(", q, ")"].join("")
                          ),
                          (B = B.replace(G, $)),
                          j.lvalue &&
                            k.push([et, ".set(", q, ",", $, ")"].join("")))
                        : (z.push(["var ", $, "=", et, "[", q, "]"].join("")),
                          (B = B.replace(G, $)),
                          j.lvalue && k.push([et, "[", q, "]=", $].join("")));
                    else {
                      for (
                        var er = [j.name], es = [q], ea = 0;
                        ea < Math.abs(I.arrayBlockIndices[X]);
                        ea++
                      )
                        er.push("\\s*\\[([^\\]]+)\\]"),
                          es.push("$" + (ea + 1) + "*t" + X + "b" + ea);
                      if (
                        ((G = RegExp(er.join(""), "g")),
                        (q = es.join("+")),
                        "generic" === R[X])
                      )
                        throw Error(
                          "cwise: Generic arrays not supported in combination with blocks!"
                        );
                      B = B.replace(G, [et, "[", q, "]"].join(""));
                    }
                    break;
                  case "scalar":
                    B = B.replace(G, "Y" + I.scalarArgs.indexOf(V));
                    break;
                  case "index":
                    B = B.replace(G, "index");
                    break;
                  case "shape":
                    B = B.replace(G, "shape");
                }
              }
            }
            return [
              z.join(`
`),
              B,
              k.join(`
`),
            ]
              .join(
                `
`
              )
              .trim();
          }
          I.exports = function (_, I) {
            for (
              var B = (I[1].length - Math.abs(_.arrayBlockIndices[0])) | 0,
                z = Array(_.arrayArgs.length),
                k = Array(_.arrayArgs.length),
                V = 0;
              V < _.arrayArgs.length;
              ++V
            )
              (k[V] = I[2 * V]), (z[V] = I[2 * V + 1]);
            for (
              var j = [], G = [], q = [], X = [], Q = [], V = 0;
              V < _.arrayArgs.length;
              ++V
            ) {
              _.arrayBlockIndices[V] < 0
                ? (q.push(0),
                  X.push(B),
                  j.push(B),
                  G.push(B + _.arrayBlockIndices[V]))
                : (q.push(_.arrayBlockIndices[V]),
                  X.push(_.arrayBlockIndices[V] + B),
                  j.push(0),
                  G.push(_.arrayBlockIndices[V]));
              for (var $ = [], et = 0; et < z[V].length; et++)
                q[V] <= z[V][et] && z[V][et] < X[V] && $.push(z[V][et] - q[V]);
              Q.push($);
            }
            for (
              var er = ["SS"], es = ["'use strict'"], ea = [], et = 0;
              et < B;
              ++et
            )
              ea.push(["s", et, "=SS[", et, "]"].join(""));
            for (var V = 0; V < _.arrayArgs.length; ++V) {
              er.push("a" + V), er.push("t" + V), er.push("p" + V);
              for (var et = 0; et < B; ++et)
                ea.push(
                  ["t", V, "p", et, "=t", V, "[", q[V] + et, "]"].join("")
                );
              for (var et = 0; et < Math.abs(_.arrayBlockIndices[V]); ++et)
                ea.push(
                  ["t", V, "b", et, "=t", V, "[", j[V] + et, "]"].join("")
                );
            }
            for (var V = 0; V < _.scalarArgs.length; ++V) er.push("Y" + V);
            if (
              (_.shapeArgs.length > 0 && ea.push("shape=SS.slice(0)"),
              _.indexArgs.length > 0)
            ) {
              for (var en = Array(B), V = 0; V < B; ++V) en[V] = "0";
              ea.push(["index=[", en.join(","), "]"].join(""));
            }
            for (var V = 0; V < _.offsetArgs.length; ++V) {
              for (
                var eo = _.offsetArgs[V], el = [], et = 0;
                et < eo.offset.length;
                ++et
              )
                0 !== eo.offset[et] &&
                  (1 === eo.offset[et]
                    ? el.push(["t", eo.array, "p", et].join(""))
                    : el.push(
                        [eo.offset[et], "*t", eo.array, "p", et].join("")
                      ));
              0 === el.length
                ? ea.push("q" + V + "=0")
                : ea.push(["q", V, "=", el.join("+")].join(""));
            }
            var eh = R(
              []
                .concat(_.pre.thisVars)
                .concat(_.body.thisVars)
                .concat(_.post.thisVars)
            );
            (ea = ea.concat(eh)).length > 0 && es.push("var " + ea.join(","));
            for (var V = 0; V < _.arrayArgs.length; ++V)
              es.push("p" + V + "|=0");
            _.pre.body.length > 3 && es.push(eE(_.pre, _, k));
            var ec = eE(_.body, _, k),
              ed = (function (_) {
                for (var I = 0, R = _[0].length; I < R; ) {
                  for (var B = 1; B < _.length; ++B)
                    if (_[B][I] !== _[0][I]) return I;
                  ++I;
                }
                return I;
              })(Q);
            ed < B
              ? es.push(
                  (function (_, I, R, B) {
                    for (
                      var z = I.length,
                        k = R.arrayArgs.length,
                        V = R.blockSize,
                        j = R.indexArgs.length > 0,
                        G = [],
                        q = 0;
                      q < k;
                      ++q
                    )
                      G.push(["var offset", q, "=p", q].join(""));
                    for (var q = _; q < z; ++q)
                      G.push(
                        [
                          "for(var j" + q + "=SS[",
                          I[q],
                          "]|0;j",
                          q,
                          ">0;){",
                        ].join("")
                      ),
                        G.push(["if(j", q, "<", V, "){"].join("")),
                        G.push(["s", I[q], "=j", q].join("")),
                        G.push(["j", q, "=0"].join("")),
                        G.push(["}else{s", I[q], "=", V].join("")),
                        G.push(["j", q, "-=", V, "}"].join("")),
                        j && G.push(["index[", I[q], "]=j", q].join(""));
                    for (var q = 0; q < k; ++q) {
                      for (var X = ["offset" + q], Q = _; Q < z; ++Q)
                        X.push(["j", Q, "*t", q, "p", I[Q]].join(""));
                      G.push(["p", q, "=(", X.join("+"), ")"].join(""));
                    }
                    G.push(BL(I, R, B));
                    for (var q = _; q < z; ++q) G.push("}");
                    return G.join(`
`);
                  })(ed, Q[0], _, ec)
                )
              : es.push(BL(Q[0], _, ec)),
              _.post.body.length > 3 && es.push(eE(_.post, _, k)),
              _.debug &&
                console.log(
                  "-----Generated cwise routine for ",
                  I,
                  `:
` +
                    es.join(`
`) +
                    `
----------`
                );
            var ep = [
              _.funcName || "unnamed",
              "_cwise_loop_",
              z[0].join("s"),
              "m",
              ed,
              (function (_) {
                for (
                  var I = Array(_.length), R = !0, B = 0;
                  B < _.length;
                  ++B
                ) {
                  var z = _[B],
                    k = z.match(/\d+/);
                  (k = k ? k[0] : ""),
                    0 === z.charAt(0)
                      ? (I[B] = "u" + z.charAt(1) + k)
                      : (I[B] = z.charAt(0) + k),
                    B > 0 && (R = R && I[B] === I[B - 1]);
                }
                return R ? I[0] : I.join("");
              })(k),
            ].join("");
            return Function(
              [
                "function ",
                ep,
                "(",
                er.join(","),
                "){",
                es.join(`
`),
                "} return ",
                ep,
              ].join("")
            )();
          };
        }),
        i$ = zi((_, I) => {
          var R = iJ();
          I.exports = function (_) {
            var I = ["'use strict'", "var CACHED={}"],
              B = [];
            I.push(
              [
                "return function ",
                _.funcName + "_cwise_thunk",
                "(",
                _.shimArgs.join(","),
                "){",
              ].join("")
            );
            for (
              var z = [],
                k = [],
                V = [
                  [
                    "array",
                    _.arrayArgs[0],
                    ".shape.slice(",
                    Math.max(0, _.arrayBlockIndices[0]),
                    _.arrayBlockIndices[0] < 0
                      ? "," + _.arrayBlockIndices[0] + ")"
                      : ")",
                  ].join(""),
                ],
                j = [],
                G = [],
                q = 0;
              q < _.arrayArgs.length;
              ++q
            ) {
              var X = _.arrayArgs[q];
              B.push(
                [
                  "t",
                  X,
                  "=array",
                  X,
                  ".dtype,",
                  "r",
                  X,
                  "=array",
                  X,
                  ".order",
                ].join("")
              ),
                z.push("t" + X),
                z.push("r" + X),
                k.push("t" + X),
                k.push("r" + X + ".join()"),
                V.push("array" + X + ".data"),
                V.push("array" + X + ".stride"),
                V.push("array" + X + ".offset|0"),
                q > 0 &&
                  (j.push(
                    "array" +
                      _.arrayArgs[0] +
                      ".shape.length===array" +
                      X +
                      ".shape.length+" +
                      (Math.abs(_.arrayBlockIndices[0]) -
                        Math.abs(_.arrayBlockIndices[q]))
                  ),
                  G.push(
                    "array" +
                      _.arrayArgs[0] +
                      ".shape[shapeIndex+" +
                      Math.max(0, _.arrayBlockIndices[0]) +
                      "]===array" +
                      X +
                      ".shape[shapeIndex+" +
                      Math.max(0, _.arrayBlockIndices[q]) +
                      "]"
                  ));
            }
            _.arrayArgs.length > 1 &&
              (I.push(
                "if (!(" +
                  j.join(" && ") +
                  ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')"
              ),
              I.push(
                "for(var shapeIndex=array" +
                  _.arrayArgs[0] +
                  ".shape.length-" +
                  Math.abs(_.arrayBlockIndices[0]) +
                  "; shapeIndex-->0;) {"
              ),
              I.push(
                "if (!(" +
                  G.join(" && ") +
                  ")) throw new Error('cwise: Arrays do not all have the same shape!')"
              ),
              I.push("}"));
            for (var q = 0; q < _.scalarArgs.length; ++q)
              V.push("scalar" + _.scalarArgs[q]);
            return (
              B.push(["type=[", k.join(","), "].join()"].join("")),
              B.push("proc=CACHED[type]"),
              I.push("var " + B.join(",")),
              I.push(
                [
                  "if(!proc){",
                  "CACHED[type]=proc=compile([",
                  z.join(","),
                  "])}",
                  "return proc(",
                  V.join(","),
                  ")}",
                ].join("")
              ),
              _.debug &&
                console.log(
                  `-----Generated thunk:
` +
                    I.join(`
`) +
                    `
----------`
                ),
              Function(
                "compile",
                I.join(`
`)
              )(R.bind(void 0, _))
            );
          };
        }),
        i0 = zi((_, I) => {
          var R = i$();
          function RK() {
            (this.argTypes = []),
              (this.shimArgs = []),
              (this.arrayArgs = []),
              (this.arrayBlockIndices = []),
              (this.scalarArgs = []),
              (this.offsetArgs = []),
              (this.offsetArgIndex = []),
              (this.indexArgs = []),
              (this.shapeArgs = []),
              (this.funcName = ""),
              (this.pre = null),
              (this.body = null),
              (this.post = null),
              (this.debug = !1);
          }
          I.exports = function (_) {
            var I = new RK();
            (I.pre = _.pre), (I.body = _.body), (I.post = _.post);
            var B = _.args.slice(0);
            I.argTypes = B;
            for (var z = 0; z < B.length; ++z) {
              var k = B[z];
              if ("array" === k || ("object" == typeof k && k.blockIndices)) {
                if (
                  ((I.argTypes[z] = "array"),
                  I.arrayArgs.push(z),
                  I.arrayBlockIndices.push(k.blockIndices ? k.blockIndices : 0),
                  I.shimArgs.push("array" + z),
                  z < I.pre.args.length && I.pre.args[z].count > 0)
                )
                  throw Error(
                    "cwise: pre() block may not reference array args"
                  );
                if (z < I.post.args.length && I.post.args[z].count > 0)
                  throw Error(
                    "cwise: post() block may not reference array args"
                  );
              } else if ("scalar" === k)
                I.scalarArgs.push(z), I.shimArgs.push("scalar" + z);
              else if ("index" === k) {
                if (
                  (I.indexArgs.push(z),
                  z < I.pre.args.length && I.pre.args[z].count > 0)
                )
                  throw Error(
                    "cwise: pre() block may not reference array index"
                  );
                if (z < I.body.args.length && I.body.args[z].lvalue)
                  throw Error(
                    "cwise: body() block may not write to array index"
                  );
                if (z < I.post.args.length && I.post.args[z].count > 0)
                  throw Error(
                    "cwise: post() block may not reference array index"
                  );
              } else if ("shape" === k) {
                if (
                  (I.shapeArgs.push(z),
                  z < I.pre.args.length && I.pre.args[z].lvalue)
                )
                  throw Error(
                    "cwise: pre() block may not write to array shape"
                  );
                if (z < I.body.args.length && I.body.args[z].lvalue)
                  throw Error(
                    "cwise: body() block may not write to array shape"
                  );
                if (z < I.post.args.length && I.post.args[z].lvalue)
                  throw Error(
                    "cwise: post() block may not write to array shape"
                  );
              } else if ("object" == typeof k && k.offset)
                (I.argTypes[z] = "offset"),
                  I.offsetArgs.push({ array: k.array, offset: k.offset }),
                  I.offsetArgIndex.push(z);
              else throw Error("cwise: Unknown argument type " + B[z]);
            }
            if (I.arrayArgs.length <= 0)
              throw Error("cwise: No array arguments specified");
            if (I.pre.args.length > B.length)
              throw Error("cwise: Too many arguments in pre() block");
            if (I.body.args.length > B.length)
              throw Error("cwise: Too many arguments in body() block");
            if (I.post.args.length > B.length)
              throw Error("cwise: Too many arguments in post() block");
            return (
              (I.debug = !!_.printCode || !!_.debug),
              (I.funcName = _.funcName || "cwise"),
              (I.blockSize = _.blockSize || 64),
              R(I)
            );
          };
        }),
        i1 = zi((_) => {
          var I = i0(),
            R = { body: "", args: [], thisVars: [], localVars: [] };
          function tE(_) {
            if (!_) return R;
            for (var I = 0; I < _.args.length; ++I) {
              var B = _.args[I];
              0 === I
                ? (_.args[I] = {
                    name: B,
                    lvalue: !0,
                    rvalue: !!_.rvalue,
                    count: _.count || 1,
                  })
                : (_.args[I] = { name: B, lvalue: !1, rvalue: !0, count: 1 });
            }
            return (
              _.thisVars || (_.thisVars = []),
              _.localVars || (_.localVars = []),
              _
            );
          }
          function Yr(_) {
            for (var R = [], B = 0; B < _.args.length; ++B) R.push("a" + B);
            return Function(
              "P",
              [
                "return function ",
                _.funcName,
                "_ndarrayops(",
                R.join(","),
                ") {P(",
                R.join(","),
                ");return a0}",
              ].join("")
            )(
              I({
                args: _.args,
                pre: tE(_.pre),
                body: tE(_.body),
                post: tE(_.proc),
                funcName: _.funcName,
              })
            );
          }
          var B = {
            add: "+",
            sub: "-",
            mul: "*",
            div: "/",
            mod: "%",
            band: "&",
            bor: "|",
            bxor: "^",
            lshift: "<<",
            rshift: ">>",
            rrshift: ">>>",
          };
          !(function () {
            for (var I in B) {
              var R = B[I];
              (_[I] = Yr({
                args: ["array", "array", "array"],
                body: { args: ["a", "b", "c"], body: "a=b" + R + "c" },
                funcName: I,
              })),
                (_[I + "eq"] = Yr({
                  args: ["array", "array"],
                  body: { args: ["a", "b"], body: "a" + R + "=b" },
                  rvalue: !0,
                  funcName: I + "eq",
                })),
                (_[I + "s"] = Yr({
                  args: ["array", "array", "scalar"],
                  body: { args: ["a", "b", "s"], body: "a=b" + R + "s" },
                  funcName: I + "s",
                })),
                (_[I + "seq"] = Yr({
                  args: ["array", "scalar"],
                  body: { args: ["a", "s"], body: "a" + R + "=s" },
                  rvalue: !0,
                  funcName: I + "seq",
                }));
            }
          })();
          var z = { not: "!", bnot: "~", neg: "-", recip: "1.0/" };
          !(function () {
            for (var I in z) {
              var R = z[I];
              (_[I] = Yr({
                args: ["array", "array"],
                body: { args: ["a", "b"], body: "a=" + R + "b" },
                funcName: I,
              })),
                (_[I + "eq"] = Yr({
                  args: ["array"],
                  body: { args: ["a"], body: "a=" + R + "a" },
                  rvalue: !0,
                  count: 2,
                  funcName: I + "eq",
                }));
            }
          })();
          var k = {
            and: "&&",
            or: "||",
            eq: "===",
            neq: "!==",
            lt: "<",
            gt: ">",
            leq: "<=",
            geq: ">=",
          };
          !(function () {
            for (var I in k) {
              var R = k[I];
              (_[I] = Yr({
                args: ["array", "array", "array"],
                body: { args: ["a", "b", "c"], body: "a=b" + R + "c" },
                funcName: I,
              })),
                (_[I + "s"] = Yr({
                  args: ["array", "array", "scalar"],
                  body: { args: ["a", "b", "s"], body: "a=b" + R + "s" },
                  funcName: I + "s",
                })),
                (_[I + "eq"] = Yr({
                  args: ["array", "array"],
                  body: { args: ["a", "b"], body: "a=a" + R + "b" },
                  rvalue: !0,
                  count: 2,
                  funcName: I + "eq",
                })),
                (_[I + "seq"] = Yr({
                  args: ["array", "scalar"],
                  body: { args: ["a", "s"], body: "a=a" + R + "s" },
                  rvalue: !0,
                  count: 2,
                  funcName: I + "seq",
                }));
            }
          })();
          var V = [
            "abs",
            "acos",
            "asin",
            "atan",
            "ceil",
            "cos",
            "exp",
            "floor",
            "log",
            "round",
            "sin",
            "sqrt",
            "tan",
          ];
          !(function () {
            for (var I = 0; I < V.length; ++I) {
              var R = V[I];
              (_[R] = Yr({
                args: ["array", "array"],
                pre: {
                  args: [],
                  body: "this_f=Math." + R,
                  thisVars: ["this_f"],
                },
                body: {
                  args: ["a", "b"],
                  body: "a=this_f(b)",
                  thisVars: ["this_f"],
                },
                funcName: R,
              })),
                (_[R + "eq"] = Yr({
                  args: ["array"],
                  pre: {
                    args: [],
                    body: "this_f=Math." + R,
                    thisVars: ["this_f"],
                  },
                  body: {
                    args: ["a"],
                    body: "a=this_f(a)",
                    thisVars: ["this_f"],
                  },
                  rvalue: !0,
                  count: 2,
                  funcName: R + "eq",
                }));
            }
          })();
          var j = ["max", "min", "atan2", "pow"];
          !(function () {
            for (var I = 0; I < j.length; ++I) {
              var R = j[I];
              (_[R] = Yr({
                args: ["array", "array", "array"],
                pre: {
                  args: [],
                  body: "this_f=Math." + R,
                  thisVars: ["this_f"],
                },
                body: {
                  args: ["a", "b", "c"],
                  body: "a=this_f(b,c)",
                  thisVars: ["this_f"],
                },
                funcName: R,
              })),
                (_[R + "s"] = Yr({
                  args: ["array", "array", "scalar"],
                  pre: {
                    args: [],
                    body: "this_f=Math." + R,
                    thisVars: ["this_f"],
                  },
                  body: {
                    args: ["a", "b", "c"],
                    body: "a=this_f(b,c)",
                    thisVars: ["this_f"],
                  },
                  funcName: R + "s",
                })),
                (_[R + "eq"] = Yr({
                  args: ["array", "array"],
                  pre: {
                    args: [],
                    body: "this_f=Math." + R,
                    thisVars: ["this_f"],
                  },
                  body: {
                    args: ["a", "b"],
                    body: "a=this_f(a,b)",
                    thisVars: ["this_f"],
                  },
                  rvalue: !0,
                  count: 2,
                  funcName: R + "eq",
                })),
                (_[R + "seq"] = Yr({
                  args: ["array", "scalar"],
                  pre: {
                    args: [],
                    body: "this_f=Math." + R,
                    thisVars: ["this_f"],
                  },
                  body: {
                    args: ["a", "b"],
                    body: "a=this_f(a,b)",
                    thisVars: ["this_f"],
                  },
                  rvalue: !0,
                  count: 2,
                  funcName: R + "seq",
                }));
            }
          })();
          var G = ["atan2", "pow"];
          !(function () {
            for (var I = 0; I < G.length; ++I) {
              var R = G[I];
              (_[R + "op"] = Yr({
                args: ["array", "array", "array"],
                pre: {
                  args: [],
                  body: "this_f=Math." + R,
                  thisVars: ["this_f"],
                },
                body: {
                  args: ["a", "b", "c"],
                  body: "a=this_f(c,b)",
                  thisVars: ["this_f"],
                },
                funcName: R + "op",
              })),
                (_[R + "ops"] = Yr({
                  args: ["array", "array", "scalar"],
                  pre: {
                    args: [],
                    body: "this_f=Math." + R,
                    thisVars: ["this_f"],
                  },
                  body: {
                    args: ["a", "b", "c"],
                    body: "a=this_f(c,b)",
                    thisVars: ["this_f"],
                  },
                  funcName: R + "ops",
                })),
                (_[R + "opeq"] = Yr({
                  args: ["array", "array"],
                  pre: {
                    args: [],
                    body: "this_f=Math." + R,
                    thisVars: ["this_f"],
                  },
                  body: {
                    args: ["a", "b"],
                    body: "a=this_f(b,a)",
                    thisVars: ["this_f"],
                  },
                  rvalue: !0,
                  count: 2,
                  funcName: R + "opeq",
                })),
                (_[R + "opseq"] = Yr({
                  args: ["array", "scalar"],
                  pre: {
                    args: [],
                    body: "this_f=Math." + R,
                    thisVars: ["this_f"],
                  },
                  body: {
                    args: ["a", "b"],
                    body: "a=this_f(b,a)",
                    thisVars: ["this_f"],
                  },
                  rvalue: !0,
                  count: 2,
                  funcName: R + "opseq",
                }));
            }
          })(),
            (_.any = I({
              args: ["array"],
              pre: R,
              body: {
                args: [{ name: "a", lvalue: !1, rvalue: !0, count: 1 }],
                body: "if(a){return true}",
                localVars: [],
                thisVars: [],
              },
              post: {
                args: [],
                localVars: [],
                thisVars: [],
                body: "return false",
              },
              funcName: "any",
            })),
            (_.all = I({
              args: ["array"],
              pre: R,
              body: {
                args: [{ name: "x", lvalue: !1, rvalue: !0, count: 1 }],
                body: "if(!x){return false}",
                localVars: [],
                thisVars: [],
              },
              post: {
                args: [],
                localVars: [],
                thisVars: [],
                body: "return true",
              },
              funcName: "all",
            })),
            (_.sum = I({
              args: ["array"],
              pre: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "this_s=0",
              },
              body: {
                args: [{ name: "a", lvalue: !1, rvalue: !0, count: 1 }],
                body: "this_s+=a",
                localVars: [],
                thisVars: ["this_s"],
              },
              post: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "return this_s",
              },
              funcName: "sum",
            })),
            (_.prod = I({
              args: ["array"],
              pre: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "this_s=1",
              },
              body: {
                args: [{ name: "a", lvalue: !1, rvalue: !0, count: 1 }],
                body: "this_s*=a",
                localVars: [],
                thisVars: ["this_s"],
              },
              post: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "return this_s",
              },
              funcName: "prod",
            })),
            (_.norm2squared = I({
              args: ["array"],
              pre: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "this_s=0",
              },
              body: {
                args: [{ name: "a", lvalue: !1, rvalue: !0, count: 2 }],
                body: "this_s+=a*a",
                localVars: [],
                thisVars: ["this_s"],
              },
              post: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "return this_s",
              },
              funcName: "norm2squared",
            })),
            (_.norm2 = I({
              args: ["array"],
              pre: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "this_s=0",
              },
              body: {
                args: [{ name: "a", lvalue: !1, rvalue: !0, count: 2 }],
                body: "this_s+=a*a",
                localVars: [],
                thisVars: ["this_s"],
              },
              post: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "return Math.sqrt(this_s)",
              },
              funcName: "norm2",
            })),
            (_.norminf = I({
              args: ["array"],
              pre: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "this_s=0",
              },
              body: {
                args: [{ name: "a", lvalue: !1, rvalue: !0, count: 4 }],
                body: "if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}",
                localVars: [],
                thisVars: ["this_s"],
              },
              post: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "return this_s",
              },
              funcName: "norminf",
            })),
            (_.norm1 = I({
              args: ["array"],
              pre: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "this_s=0",
              },
              body: {
                args: [{ name: "a", lvalue: !1, rvalue: !0, count: 3 }],
                body: "this_s+=a<0?-a:a",
                localVars: [],
                thisVars: ["this_s"],
              },
              post: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "return this_s",
              },
              funcName: "norm1",
            })),
            (_.sup = I({
              args: ["array"],
              pre: {
                body: "this_h=-Infinity",
                args: [],
                thisVars: ["this_h"],
                localVars: [],
              },
              body: {
                body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
                args: [
                  { name: "_inline_1_arg0_", lvalue: !1, rvalue: !0, count: 2 },
                ],
                thisVars: ["this_h"],
                localVars: [],
              },
              post: {
                body: "return this_h",
                args: [],
                thisVars: ["this_h"],
                localVars: [],
              },
            })),
            (_.inf = I({
              args: ["array"],
              pre: {
                body: "this_h=Infinity",
                args: [],
                thisVars: ["this_h"],
                localVars: [],
              },
              body: {
                body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
                args: [
                  { name: "_inline_1_arg0_", lvalue: !1, rvalue: !0, count: 2 },
                ],
                thisVars: ["this_h"],
                localVars: [],
              },
              post: {
                body: "return this_h",
                args: [],
                thisVars: ["this_h"],
                localVars: [],
              },
            })),
            (_.argmin = I({
              args: ["index", "array", "shape"],
              pre: {
                body: "{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
                args: [
                  { name: "_inline_0_arg0_", lvalue: !1, rvalue: !1, count: 0 },
                  { name: "_inline_0_arg1_", lvalue: !1, rvalue: !1, count: 0 },
                  { name: "_inline_0_arg2_", lvalue: !1, rvalue: !0, count: 1 },
                ],
                thisVars: ["this_i", "this_v"],
                localVars: [],
              },
              body: {
                body: "{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
                args: [
                  { name: "_inline_1_arg0_", lvalue: !1, rvalue: !0, count: 2 },
                  { name: "_inline_1_arg1_", lvalue: !1, rvalue: !0, count: 2 },
                ],
                thisVars: ["this_i", "this_v"],
                localVars: ["_inline_1_k"],
              },
              post: {
                body: "{return this_i}",
                args: [],
                thisVars: ["this_i"],
                localVars: [],
              },
            })),
            (_.argmax = I({
              args: ["index", "array", "shape"],
              pre: {
                body: "{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
                args: [
                  { name: "_inline_0_arg0_", lvalue: !1, rvalue: !1, count: 0 },
                  { name: "_inline_0_arg1_", lvalue: !1, rvalue: !1, count: 0 },
                  { name: "_inline_0_arg2_", lvalue: !1, rvalue: !0, count: 1 },
                ],
                thisVars: ["this_i", "this_v"],
                localVars: [],
              },
              body: {
                body: "{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
                args: [
                  { name: "_inline_1_arg0_", lvalue: !1, rvalue: !0, count: 2 },
                  { name: "_inline_1_arg1_", lvalue: !1, rvalue: !0, count: 2 },
                ],
                thisVars: ["this_i", "this_v"],
                localVars: ["_inline_1_k"],
              },
              post: {
                body: "{return this_i}",
                args: [],
                thisVars: ["this_i"],
                localVars: [],
              },
            })),
            (_.random = Yr({
              args: ["array"],
              pre: {
                args: [],
                body: "this_f=Math.random",
                thisVars: ["this_f"],
              },
              body: { args: ["a"], body: "a=this_f()", thisVars: ["this_f"] },
              funcName: "random",
            })),
            (_.assign = Yr({
              args: ["array", "array"],
              body: { args: ["a", "b"], body: "a=b" },
              funcName: "assign",
            })),
            (_.assigns = Yr({
              args: ["array", "scalar"],
              body: { args: ["a", "b"], body: "a=b" },
              funcName: "assigns",
            })),
            (_.equals = I({
              args: ["array", "array"],
              pre: R,
              body: {
                args: [
                  { name: "x", lvalue: !1, rvalue: !0, count: 1 },
                  { name: "y", lvalue: !1, rvalue: !0, count: 1 },
                ],
                body: "if(x!==y){return false}",
                localVars: [],
                thisVars: [],
              },
              post: {
                args: [],
                localVars: [],
                thisVars: [],
                body: "return true",
              },
              funcName: "equals",
            }));
        }),
        i2 = zi((_, I) => {
          I.exports = function (_, I) {
            for (var R = _.split("."), B = I.split("."), z = 0; z < 3; z++) {
              var k = Number(R[z]),
                V = Number(B[z]);
              if (k > V) return 1;
              if (V > k) return -1;
              if (!isNaN(k) && isNaN(V)) return 1;
              if (isNaN(k) && !isNaN(V)) return -1;
            }
            return 0;
          };
        }),
        i3 = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
        i4 = "srgb",
        i5 = "srgb-linear",
        i6 = "300 es",
        i8 = class {
          addEventListener(_, I) {
            void 0 === this._listeners && (this._listeners = {});
            let R = this._listeners;
            void 0 === R[_] && (R[_] = []),
              -1 === R[_].indexOf(I) && R[_].push(I);
          }
          hasEventListener(_, I) {
            if (void 0 === this._listeners) return !1;
            let R = this._listeners;
            return void 0 !== R[_] && -1 !== R[_].indexOf(I);
          }
          removeEventListener(_, I) {
            if (void 0 === this._listeners) return;
            let R = this._listeners[_];
            if (void 0 !== R) {
              let _ = R.indexOf(I);
              -1 !== _ && R.splice(_, 1);
            }
          }
          dispatchEvent(_) {
            if (void 0 === this._listeners) return;
            let I = this._listeners[_.type];
            if (void 0 !== I) {
              _.target = this;
              let R = I.slice(0);
              for (let I = 0, B = R.length; I < B; I++) R[I].call(this, _);
              _.target = null;
            }
          }
        },
        i9 = [
          "00",
          "01",
          "02",
          "03",
          "04",
          "05",
          "06",
          "07",
          "08",
          "09",
          "0a",
          "0b",
          "0c",
          "0d",
          "0e",
          "0f",
          "10",
          "11",
          "12",
          "13",
          "14",
          "15",
          "16",
          "17",
          "18",
          "19",
          "1a",
          "1b",
          "1c",
          "1d",
          "1e",
          "1f",
          "20",
          "21",
          "22",
          "23",
          "24",
          "25",
          "26",
          "27",
          "28",
          "29",
          "2a",
          "2b",
          "2c",
          "2d",
          "2e",
          "2f",
          "30",
          "31",
          "32",
          "33",
          "34",
          "35",
          "36",
          "37",
          "38",
          "39",
          "3a",
          "3b",
          "3c",
          "3d",
          "3e",
          "3f",
          "40",
          "41",
          "42",
          "43",
          "44",
          "45",
          "46",
          "47",
          "48",
          "49",
          "4a",
          "4b",
          "4c",
          "4d",
          "4e",
          "4f",
          "50",
          "51",
          "52",
          "53",
          "54",
          "55",
          "56",
          "57",
          "58",
          "59",
          "5a",
          "5b",
          "5c",
          "5d",
          "5e",
          "5f",
          "60",
          "61",
          "62",
          "63",
          "64",
          "65",
          "66",
          "67",
          "68",
          "69",
          "6a",
          "6b",
          "6c",
          "6d",
          "6e",
          "6f",
          "70",
          "71",
          "72",
          "73",
          "74",
          "75",
          "76",
          "77",
          "78",
          "79",
          "7a",
          "7b",
          "7c",
          "7d",
          "7e",
          "7f",
          "80",
          "81",
          "82",
          "83",
          "84",
          "85",
          "86",
          "87",
          "88",
          "89",
          "8a",
          "8b",
          "8c",
          "8d",
          "8e",
          "8f",
          "90",
          "91",
          "92",
          "93",
          "94",
          "95",
          "96",
          "97",
          "98",
          "99",
          "9a",
          "9b",
          "9c",
          "9d",
          "9e",
          "9f",
          "a0",
          "a1",
          "a2",
          "a3",
          "a4",
          "a5",
          "a6",
          "a7",
          "a8",
          "a9",
          "aa",
          "ab",
          "ac",
          "ad",
          "ae",
          "af",
          "b0",
          "b1",
          "b2",
          "b3",
          "b4",
          "b5",
          "b6",
          "b7",
          "b8",
          "b9",
          "ba",
          "bb",
          "bc",
          "bd",
          "be",
          "bf",
          "c0",
          "c1",
          "c2",
          "c3",
          "c4",
          "c5",
          "c6",
          "c7",
          "c8",
          "c9",
          "ca",
          "cb",
          "cc",
          "cd",
          "ce",
          "cf",
          "d0",
          "d1",
          "d2",
          "d3",
          "d4",
          "d5",
          "d6",
          "d7",
          "d8",
          "d9",
          "da",
          "db",
          "dc",
          "dd",
          "de",
          "df",
          "e0",
          "e1",
          "e2",
          "e3",
          "e4",
          "e5",
          "e6",
          "e7",
          "e8",
          "e9",
          "ea",
          "eb",
          "ec",
          "ed",
          "ee",
          "ef",
          "f0",
          "f1",
          "f2",
          "f3",
          "f4",
          "f5",
          "f6",
          "f7",
          "f8",
          "f9",
          "fa",
          "fb",
          "fc",
          "fd",
          "fe",
          "ff",
        ],
        i7 = 1234567,
        rt = Math.PI / 180,
        ri = 180 / Math.PI;
      function ms() {
        let _ = (4294967295 * Math.random()) | 0,
          I = (4294967295 * Math.random()) | 0,
          R = (4294967295 * Math.random()) | 0,
          B = (4294967295 * Math.random()) | 0;
        return (
          i9[255 & _] +
          i9[(_ >> 8) & 255] +
          i9[(_ >> 16) & 255] +
          i9[(_ >> 24) & 255] +
          "-" +
          i9[255 & I] +
          i9[(I >> 8) & 255] +
          "-" +
          i9[((I >> 16) & 15) | 64] +
          i9[(I >> 24) & 255] +
          "-" +
          i9[(63 & R) | 128] +
          i9[(R >> 8) & 255] +
          "-" +
          i9[(R >> 16) & 255] +
          i9[(R >> 24) & 255] +
          i9[255 & B] +
          i9[(B >> 8) & 255] +
          i9[(B >> 16) & 255] +
          i9[(B >> 24) & 255]
        ).toLowerCase();
      }
      function gi(_, I, R) {
        return Math.max(I, Math.min(R, _));
      }
      function Cw(_, I) {
        return ((_ % I) + I) % I;
      }
      function vp(_, I, R) {
        return (1 - R) * _ + R * I;
      }
      function YS(_) {
        return (_ & (_ - 1)) == 0 && 0 !== _;
      }
      function qM(_) {
        return Math.pow(2, Math.ceil(Math.log(_) / Math.LN2));
      }
      function my(_) {
        return Math.pow(2, Math.floor(Math.log(_) / Math.LN2));
      }
      function ya(_, I) {
        switch (I.constructor) {
          case Float32Array:
            return _;
          case Uint16Array:
            return _ / 65535;
          case Uint8Array:
            return _ / 255;
          case Int16Array:
            return Math.max(_ / 32767, -1);
          case Int8Array:
            return Math.max(_ / 127, -1);
          default:
            throw Error("Invalid component type.");
        }
      }
      function br(_, I) {
        switch (I.constructor) {
          case Float32Array:
            return _;
          case Uint16Array:
            return Math.round(65535 * _);
          case Uint8Array:
            return Math.round(255 * _);
          case Int16Array:
            return Math.round(32767 * _);
          case Int8Array:
            return Math.round(127 * _);
          default:
            throw Error("Invalid component type.");
        }
      }
      var rr = Object.freeze({
          __proto__: null,
          DEG2RAD: rt,
          RAD2DEG: ri,
          ceilPowerOfTwo: qM,
          clamp: gi,
          damp: function (_, I, R, B) {
            return vp(_, I, 1 - Math.exp(-R * B));
          },
          degToRad: function (_) {
            return _ * rt;
          },
          denormalize: ya,
          euclideanModulo: Cw,
          floorPowerOfTwo: my,
          generateUUID: ms,
          inverseLerp: function (_, I, R) {
            return _ !== I ? (R - _) / (I - _) : 0;
          },
          isPowerOfTwo: YS,
          lerp: vp,
          mapLinear: function (_, I, R, B, z) {
            return B + ((_ - I) * (z - B)) / (R - I);
          },
          normalize: br,
          pingpong: function (_, I = 1) {
            return I - Math.abs(Cw(_, 2 * I) - I);
          },
          radToDeg: function (_) {
            return _ * ri;
          },
          randFloat: function (_, I) {
            return _ + Math.random() * (I - _);
          },
          randFloatSpread: function (_) {
            return _ * (0.5 - Math.random());
          },
          randInt: function (_, I) {
            return _ + Math.floor(Math.random() * (I - _ + 1));
          },
          seededRandom: function (_) {
            void 0 !== _ && (i7 = _);
            let I = (i7 += 1831565813);
            return (
              (I = Math.imul(I ^ (I >>> 15), 1 | I)),
              (((I ^= I + Math.imul(I ^ (I >>> 7), 61 | I)) ^ (I >>> 14)) >>>
                0) /
                4294967296
            );
          },
          setQuaternionFromProperEuler: function (_, I, R, B, z) {
            let k = Math.cos,
              V = Math.sin,
              j = k(R / 2),
              G = V(R / 2),
              q = k((I + B) / 2),
              X = V((I + B) / 2),
              Q = k((I - B) / 2),
              $ = V((I - B) / 2),
              et = k((B - I) / 2),
              er = V((B - I) / 2);
            switch (z) {
              case "XYX":
                _.set(j * X, G * Q, G * $, j * q);
                break;
              case "YZY":
                _.set(G * $, j * X, G * Q, j * q);
                break;
              case "ZXZ":
                _.set(G * Q, G * $, j * X, j * q);
                break;
              case "XZX":
                _.set(j * X, G * er, G * et, j * q);
                break;
              case "YXY":
                _.set(G * et, j * X, G * er, j * q);
                break;
              case "ZYZ":
                _.set(G * er, G * et, j * X, j * q);
                break;
              default:
                console.warn(
                  "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                    z
                );
            }
          },
          smootherstep: function (_, I, R) {
            return _ <= I
              ? 0
              : _ >= R
              ? 1
              : (_ = (_ - I) / (R - I)) * _ * _ * (_ * (6 * _ - 15) + 10);
          },
          smoothstep: function (_, I, R) {
            return _ <= I
              ? 0
              : _ >= R
              ? 1
              : (_ = (_ - I) / (R - I)) * _ * (3 - 2 * _);
          },
        }),
        rs = class {
          constructor(_ = 0, I = 0) {
            (rs.prototype.isVector2 = !0), (this.x = _), (this.y = I);
          }
          get width() {
            return this.x;
          }
          set width(_) {
            this.x = _;
          }
          get height() {
            return this.y;
          }
          set height(_) {
            this.y = _;
          }
          set(_, I) {
            return (this.x = _), (this.y = I), this;
          }
          setScalar(_) {
            return (this.x = _), (this.y = _), this;
          }
          setX(_) {
            return (this.x = _), this;
          }
          setY(_) {
            return (this.y = _), this;
          }
          setComponent(_, I) {
            switch (_) {
              case 0:
                this.x = I;
                break;
              case 1:
                this.y = I;
                break;
              default:
                throw Error("index is out of range: " + _);
            }
            return this;
          }
          getComponent(_) {
            switch (_) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              default:
                throw Error("index is out of range: " + _);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y);
          }
          copy(_) {
            return (this.x = _.x), (this.y = _.y), this;
          }
          add(_) {
            return (this.x += _.x), (this.y += _.y), this;
          }
          addScalar(_) {
            return (this.x += _), (this.y += _), this;
          }
          addVectors(_, I) {
            return (this.x = _.x + I.x), (this.y = _.y + I.y), this;
          }
          addScaledVector(_, I) {
            return (this.x += _.x * I), (this.y += _.y * I), this;
          }
          sub(_) {
            return (this.x -= _.x), (this.y -= _.y), this;
          }
          subScalar(_) {
            return (this.x -= _), (this.y -= _), this;
          }
          subVectors(_, I) {
            return (this.x = _.x - I.x), (this.y = _.y - I.y), this;
          }
          multiply(_) {
            return (this.x *= _.x), (this.y *= _.y), this;
          }
          multiplyScalar(_) {
            return (this.x *= _), (this.y *= _), this;
          }
          divide(_) {
            return (this.x /= _.x), (this.y /= _.y), this;
          }
          divideScalar(_) {
            return this.multiplyScalar(1 / _);
          }
          applyMatrix3(_) {
            let I = this.x,
              R = this.y,
              B = _.elements;
            return (
              (this.x = B[0] * I + B[3] * R + B[6]),
              (this.y = B[1] * I + B[4] * R + B[7]),
              this
            );
          }
          min(_) {
            return (
              (this.x = Math.min(this.x, _.x)),
              (this.y = Math.min(this.y, _.y)),
              this
            );
          }
          max(_) {
            return (
              (this.x = Math.max(this.x, _.x)),
              (this.y = Math.max(this.y, _.y)),
              this
            );
          }
          clamp(_, I) {
            return (
              (this.x = Math.max(_.x, Math.min(I.x, this.x))),
              (this.y = Math.max(_.y, Math.min(I.y, this.y))),
              this
            );
          }
          clampScalar(_, I) {
            return (
              (this.x = Math.max(_, Math.min(I, this.x))),
              (this.y = Math.max(_, Math.min(I, this.y))),
              this
            );
          }
          clampLength(_, I) {
            let R = this.length();
            return this.divideScalar(R || 1).multiplyScalar(
              Math.max(_, Math.min(I, R))
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
            );
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              this
            );
          }
          negate() {
            return (this.x = -this.x), (this.y = -this.y), this;
          }
          dot(_) {
            return this.x * _.x + this.y * _.y;
          }
          cross(_) {
            return this.x * _.y - this.y * _.x;
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y;
          }
          length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y);
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI;
          }
          distanceTo(_) {
            return Math.sqrt(this.distanceToSquared(_));
          }
          distanceToSquared(_) {
            let I = this.x - _.x,
              R = this.y - _.y;
            return I * I + R * R;
          }
          manhattanDistanceTo(_) {
            return Math.abs(this.x - _.x) + Math.abs(this.y - _.y);
          }
          setLength(_) {
            return this.normalize().multiplyScalar(_);
          }
          lerp(_, I) {
            return (
              (this.x += (_.x - this.x) * I),
              (this.y += (_.y - this.y) * I),
              this
            );
          }
          lerpVectors(_, I, R) {
            return (
              (this.x = _.x + (I.x - _.x) * R),
              (this.y = _.y + (I.y - _.y) * R),
              this
            );
          }
          equals(_) {
            return _.x === this.x && _.y === this.y;
          }
          fromArray(_, I = 0) {
            return (this.x = _[I]), (this.y = _[I + 1]), this;
          }
          toArray(_ = [], I = 0) {
            return (_[I] = this.x), (_[I + 1] = this.y), _;
          }
          fromBufferAttribute(_, I) {
            return (this.x = _.getX(I)), (this.y = _.getY(I)), this;
          }
          rotateAround(_, I) {
            let R = Math.cos(I),
              B = Math.sin(I),
              z = this.x - _.x,
              k = this.y - _.y;
            return (
              (this.x = z * R - k * B + _.x),
              (this.y = z * B + k * R + _.y),
              this
            );
          }
          random() {
            return (this.x = Math.random()), (this.y = Math.random()), this;
          }
          *[Symbol.iterator]() {
            yield this.x, yield this.y;
          }
        },
        ro = class {
          constructor() {
            (ro.prototype.isMatrix3 = !0),
              (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
          }
          set(_, I, R, B, z, k, V, j, G) {
            let q = this.elements;
            return (
              (q[0] = _),
              (q[1] = B),
              (q[2] = V),
              (q[3] = I),
              (q[4] = z),
              (q[5] = j),
              (q[6] = R),
              (q[7] = k),
              (q[8] = G),
              this
            );
          }
          identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
          }
          copy(_) {
            let I = this.elements,
              R = _.elements;
            return (
              (I[0] = R[0]),
              (I[1] = R[1]),
              (I[2] = R[2]),
              (I[3] = R[3]),
              (I[4] = R[4]),
              (I[5] = R[5]),
              (I[6] = R[6]),
              (I[7] = R[7]),
              (I[8] = R[8]),
              this
            );
          }
          extractBasis(_, I, R) {
            return (
              _.setFromMatrix3Column(this, 0),
              I.setFromMatrix3Column(this, 1),
              R.setFromMatrix3Column(this, 2),
              this
            );
          }
          setFromMatrix4(_) {
            let I = _.elements;
            return (
              this.set(I[0], I[4], I[8], I[1], I[5], I[9], I[2], I[6], I[10]),
              this
            );
          }
          multiply(_) {
            return this.multiplyMatrices(this, _);
          }
          premultiply(_) {
            return this.multiplyMatrices(_, this);
          }
          multiplyMatrices(_, I) {
            let R = _.elements,
              B = I.elements,
              z = this.elements,
              k = R[0],
              V = R[3],
              j = R[6],
              G = R[1],
              q = R[4],
              X = R[7],
              Q = R[2],
              $ = R[5],
              et = R[8],
              er = B[0],
              es = B[3],
              ea = B[6],
              en = B[1],
              eo = B[4],
              el = B[7],
              eh = B[2],
              ec = B[5],
              ed = B[8];
            return (
              (z[0] = k * er + V * en + j * eh),
              (z[3] = k * es + V * eo + j * ec),
              (z[6] = k * ea + V * el + j * ed),
              (z[1] = G * er + q * en + X * eh),
              (z[4] = G * es + q * eo + X * ec),
              (z[7] = G * ea + q * el + X * ed),
              (z[2] = Q * er + $ * en + et * eh),
              (z[5] = Q * es + $ * eo + et * ec),
              (z[8] = Q * ea + $ * el + et * ed),
              this
            );
          }
          multiplyScalar(_) {
            let I = this.elements;
            return (
              (I[0] *= _),
              (I[3] *= _),
              (I[6] *= _),
              (I[1] *= _),
              (I[4] *= _),
              (I[7] *= _),
              (I[2] *= _),
              (I[5] *= _),
              (I[8] *= _),
              this
            );
          }
          determinant() {
            let _ = this.elements,
              I = _[0],
              R = _[1],
              B = _[2],
              z = _[3],
              k = _[4],
              V = _[5],
              j = _[6],
              G = _[7],
              q = _[8];
            return (
              I * k * q -
              I * V * G -
              R * z * q +
              R * V * j +
              B * z * G -
              B * k * j
            );
          }
          invert() {
            let _ = this.elements,
              I = _[0],
              R = _[1],
              B = _[2],
              z = _[3],
              k = _[4],
              V = _[5],
              j = _[6],
              G = _[7],
              q = _[8],
              X = q * k - V * G,
              Q = V * j - q * z,
              $ = G * z - k * j,
              et = I * X + R * Q + B * $;
            if (0 === et) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            let er = 1 / et;
            return (
              (_[0] = X * er),
              (_[1] = (B * G - q * R) * er),
              (_[2] = (V * R - B * k) * er),
              (_[3] = Q * er),
              (_[4] = (q * I - B * j) * er),
              (_[5] = (B * z - V * I) * er),
              (_[6] = $ * er),
              (_[7] = (R * j - G * I) * er),
              (_[8] = (k * I - R * z) * er),
              this
            );
          }
          transpose() {
            let _,
              I = this.elements;
            return (
              (_ = I[1]),
              (I[1] = I[3]),
              (I[3] = _),
              (_ = I[2]),
              (I[2] = I[6]),
              (I[6] = _),
              (_ = I[5]),
              (I[5] = I[7]),
              (I[7] = _),
              this
            );
          }
          getNormalMatrix(_) {
            return this.setFromMatrix4(_).invert().transpose();
          }
          transposeIntoArray(_) {
            let I = this.elements;
            return (
              (_[0] = I[0]),
              (_[1] = I[3]),
              (_[2] = I[6]),
              (_[3] = I[1]),
              (_[4] = I[4]),
              (_[5] = I[7]),
              (_[6] = I[2]),
              (_[7] = I[5]),
              (_[8] = I[8]),
              this
            );
          }
          setUvTransform(_, I, R, B, z, k, V) {
            let j = Math.cos(z),
              G = Math.sin(z);
            return (
              this.set(
                R * j,
                R * G,
                -R * (j * k + G * V) + k + _,
                -B * G,
                B * j,
                -B * (-G * k + j * V) + V + I,
                0,
                0,
                1
              ),
              this
            );
          }
          scale(_, I) {
            return this.premultiply(rl.makeScale(_, I)), this;
          }
          rotate(_) {
            return this.premultiply(rl.makeRotation(-_)), this;
          }
          translate(_, I) {
            return this.premultiply(rl.makeTranslation(_, I)), this;
          }
          makeTranslation(_, I) {
            return this.set(1, 0, _, 0, 1, I, 0, 0, 1), this;
          }
          makeRotation(_) {
            let I = Math.cos(_),
              R = Math.sin(_);
            return this.set(I, -R, 0, R, I, 0, 0, 0, 1), this;
          }
          makeScale(_, I) {
            return this.set(_, 0, 0, 0, I, 0, 0, 0, 1), this;
          }
          equals(_) {
            let I = this.elements,
              R = _.elements;
            for (let _ = 0; _ < 9; _++) if (I[_] !== R[_]) return !1;
            return !0;
          }
          fromArray(_, I = 0) {
            for (let R = 0; R < 9; R++) this.elements[R] = _[R + I];
            return this;
          }
          toArray(_ = [], I = 0) {
            let R = this.elements;
            return (
              (_[I] = R[0]),
              (_[I + 1] = R[1]),
              (_[I + 2] = R[2]),
              (_[I + 3] = R[3]),
              (_[I + 4] = R[4]),
              (_[I + 5] = R[5]),
              (_[I + 6] = R[6]),
              (_[I + 7] = R[7]),
              (_[I + 8] = R[8]),
              _
            );
          }
          clone() {
            return new this.constructor().fromArray(this.elements);
          }
        },
        rl = new ro();
      function YM(_) {
        for (let I = _.length - 1; I >= 0; --I) if (_[I] >= 65535) return !0;
        return !1;
      }
      var rh = {
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array,
      };
      function Fg(_, I) {
        return new rh[_](I);
      }
      function _p(_) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", _);
      }
      function Sc(_) {
        return _ < 0.04045
          ? 0.0773993808 * _
          : Math.pow(0.9478672986 * _ + 0.0521327014, 2.4);
      }
      function hy(_) {
        return _ < 0.0031308 ? 12.92 * _ : 1.055 * Math.pow(_, 0.41666) - 0.055;
      }
      var rc = { [i4]: { [i5]: Sc }, [i5]: { [i4]: hy } },
        rd = {
          legacyMode: !0,
          get workingColorSpace() {
            return i5;
          },
          set workingColorSpace(n) {
            console.warn(
              "THREE.ColorManagement: .workingColorSpace is readonly."
            );
          },
          convert: function (_, I, R) {
            if (this.legacyMode || I === R || !I || !R) return _;
            if (rc[I] && void 0 !== rc[I][R]) {
              let B = rc[I][R];
              return (_.r = B(_.r)), (_.g = B(_.g)), (_.b = B(_.b)), _;
            }
            throw Error("Unsupported color space conversion.");
          },
          fromWorkingColorSpace: function (_, I) {
            return this.convert(_, this.workingColorSpace, I);
          },
          toWorkingColorSpace: function (_, I) {
            return this.convert(_, I, this.workingColorSpace);
          },
        },
        ru = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        rp = { r: 0, g: 0, b: 0 },
        rf = { h: 0, s: 0, l: 0 },
        rm = { h: 0, s: 0, l: 0 };
      function pS(_, I, R) {
        return (
          R < 0 && (R += 1),
          R > 1 && (R -= 1),
          R < 1 / 6
            ? _ + (I - _) * 6 * R
            : R < 0.5
            ? I
            : R < 2 / 3
            ? _ + (I - _) * 6 * (2 / 3 - R)
            : _
        );
      }
      function Vg(_, I) {
        return (I.r = _.r), (I.g = _.g), (I.b = _.b), I;
      }
      var ry = class {
        constructor(_, I, R) {
          return (
            (this.isColor = !0),
            (this.r = 1),
            (this.g = 1),
            (this.b = 1),
            void 0 === I && void 0 === R ? this.set(_) : this.setRGB(_, I, R)
          );
        }
        set(_) {
          return (
            _ && _.isColor
              ? this.copy(_)
              : "number" == typeof _
              ? this.setHex(_)
              : "string" == typeof _ && this.setStyle(_),
            this
          );
        }
        setScalar(_) {
          return (this.r = _), (this.g = _), (this.b = _), this;
        }
        setHex(_, I = i4) {
          return (
            (_ = Math.floor(_)),
            (this.r = ((_ >> 16) & 255) / 255),
            (this.g = ((_ >> 8) & 255) / 255),
            (this.b = (255 & _) / 255),
            rd.toWorkingColorSpace(this, I),
            this
          );
        }
        setRGB(_, I, R, B = rd.workingColorSpace) {
          return (
            (this.r = _),
            (this.g = I),
            (this.b = R),
            rd.toWorkingColorSpace(this, B),
            this
          );
        }
        setHSL(_, I, R, B = rd.workingColorSpace) {
          if (((_ = Cw(_, 1)), (I = gi(I, 0, 1)), (R = gi(R, 0, 1)), 0 === I))
            this.r = this.g = this.b = R;
          else {
            let B = R <= 0.5 ? R * (1 + I) : R + I - R * I,
              z = 2 * R - B;
            (this.r = pS(z, B, _ + 1 / 3)),
              (this.g = pS(z, B, _)),
              (this.b = pS(z, B, _ - 1 / 3));
          }
          return rd.toWorkingColorSpace(this, B), this;
        }
        setStyle(_, I = i4) {
          let R;
          function r(I) {
            void 0 !== I &&
              1 > parseFloat(I) &&
              console.warn(
                "THREE.Color: Alpha component of " + _ + " will be ignored."
              );
          }
          if ((R = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(_))) {
            let _,
              B = R[1],
              z = R[2];
            switch (B) {
              case "rgb":
              case "rgba":
                if (
                  (_ =
                    /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      z
                    ))
                )
                  return (
                    (this.r = Math.min(255, parseInt(_[1], 10)) / 255),
                    (this.g = Math.min(255, parseInt(_[2], 10)) / 255),
                    (this.b = Math.min(255, parseInt(_[3], 10)) / 255),
                    rd.toWorkingColorSpace(this, I),
                    r(_[4]),
                    this
                  );
                if (
                  (_ =
                    /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      z
                    ))
                )
                  return (
                    (this.r = Math.min(100, parseInt(_[1], 10)) / 100),
                    (this.g = Math.min(100, parseInt(_[2], 10)) / 100),
                    (this.b = Math.min(100, parseInt(_[3], 10)) / 100),
                    rd.toWorkingColorSpace(this, I),
                    r(_[4]),
                    this
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (_ =
                    /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      z
                    ))
                ) {
                  let R = parseFloat(_[1]) / 360,
                    B = parseFloat(_[2]) / 100,
                    z = parseFloat(_[3]) / 100;
                  return r(_[4]), this.setHSL(R, B, z, I);
                }
            }
          } else if ((R = /^\#([A-Fa-f\d]+)$/.exec(_))) {
            let _ = R[1],
              B = _.length;
            if (3 === B)
              return (
                (this.r = parseInt(_.charAt(0) + _.charAt(0), 16) / 255),
                (this.g = parseInt(_.charAt(1) + _.charAt(1), 16) / 255),
                (this.b = parseInt(_.charAt(2) + _.charAt(2), 16) / 255),
                rd.toWorkingColorSpace(this, I),
                this
              );
            if (6 === B)
              return (
                (this.r = parseInt(_.charAt(0) + _.charAt(1), 16) / 255),
                (this.g = parseInt(_.charAt(2) + _.charAt(3), 16) / 255),
                (this.b = parseInt(_.charAt(4) + _.charAt(5), 16) / 255),
                rd.toWorkingColorSpace(this, I),
                this
              );
          }
          return _ && _.length > 0 ? this.setColorName(_, I) : this;
        }
        setColorName(_, I = i4) {
          let R = ru[_.toLowerCase()];
          return (
            void 0 !== R
              ? this.setHex(R, I)
              : console.warn("THREE.Color: Unknown color " + _),
            this
          );
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(_) {
          return (this.r = _.r), (this.g = _.g), (this.b = _.b), this;
        }
        copySRGBToLinear(_) {
          return (
            (this.r = Sc(_.r)), (this.g = Sc(_.g)), (this.b = Sc(_.b)), this
          );
        }
        copyLinearToSRGB(_) {
          return (
            (this.r = hy(_.r)), (this.g = hy(_.g)), (this.b = hy(_.b)), this
          );
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(_ = i4) {
          return (
            rd.fromWorkingColorSpace(Vg(this, rp), _),
            (gi(255 * rp.r, 0, 255) << 16) ^
              (gi(255 * rp.g, 0, 255) << 8) ^
              (gi(255 * rp.b, 0, 255) << 0)
          );
        }
        getHexString(_ = i4) {
          return ("000000" + this.getHex(_).toString(16)).slice(-6);
        }
        getHSL(_, I = rd.workingColorSpace) {
          rd.fromWorkingColorSpace(Vg(this, rp), I);
          let R = rp.r,
            B = rp.g,
            z = rp.b,
            k = Math.max(R, B, z),
            V = Math.min(R, B, z),
            j,
            G,
            q = (V + k) / 2;
          if (V === k) (j = 0), (G = 0);
          else {
            let _ = k - V;
            switch (((G = q <= 0.5 ? _ / (k + V) : _ / (2 - k - V)), k)) {
              case R:
                j = (B - z) / _ + (B < z ? 6 : 0);
                break;
              case B:
                j = (z - R) / _ + 2;
                break;
              case z:
                j = (R - B) / _ + 4;
            }
            j /= 6;
          }
          return (_.h = j), (_.s = G), (_.l = q), _;
        }
        getRGB(_, I = rd.workingColorSpace) {
          return (
            rd.fromWorkingColorSpace(Vg(this, rp), I),
            (_.r = rp.r),
            (_.g = rp.g),
            (_.b = rp.b),
            _
          );
        }
        getStyle(_ = i4) {
          return (
            rd.fromWorkingColorSpace(Vg(this, rp), _),
            _ !== i4
              ? `color(${_} ${rp.r} ${rp.g} ${rp.b})`
              : `rgb(${(255 * rp.r) | 0},${(255 * rp.g) | 0},${
                  (255 * rp.b) | 0
                })`
          );
        }
        offsetHSL(_, I, R) {
          return (
            this.getHSL(rf),
            (rf.h += _),
            (rf.s += I),
            (rf.l += R),
            this.setHSL(rf.h, rf.s, rf.l),
            this
          );
        }
        add(_) {
          return (this.r += _.r), (this.g += _.g), (this.b += _.b), this;
        }
        addColors(_, I) {
          return (
            (this.r = _.r + I.r),
            (this.g = _.g + I.g),
            (this.b = _.b + I.b),
            this
          );
        }
        addScalar(_) {
          return (this.r += _), (this.g += _), (this.b += _), this;
        }
        sub(_) {
          return (
            (this.r = Math.max(0, this.r - _.r)),
            (this.g = Math.max(0, this.g - _.g)),
            (this.b = Math.max(0, this.b - _.b)),
            this
          );
        }
        multiply(_) {
          return (this.r *= _.r), (this.g *= _.g), (this.b *= _.b), this;
        }
        multiplyScalar(_) {
          return (this.r *= _), (this.g *= _), (this.b *= _), this;
        }
        lerp(_, I) {
          return (
            (this.r += (_.r - this.r) * I),
            (this.g += (_.g - this.g) * I),
            (this.b += (_.b - this.b) * I),
            this
          );
        }
        lerpColors(_, I, R) {
          return (
            (this.r = _.r + (I.r - _.r) * R),
            (this.g = _.g + (I.g - _.g) * R),
            (this.b = _.b + (I.b - _.b) * R),
            this
          );
        }
        lerpHSL(_, I) {
          this.getHSL(rf), _.getHSL(rm);
          let R = vp(rf.h, rm.h, I),
            B = vp(rf.s, rm.s, I),
            z = vp(rf.l, rm.l, I);
          return this.setHSL(R, B, z), this;
        }
        equals(_) {
          return _.r === this.r && _.g === this.g && _.b === this.b;
        }
        fromArray(_, I = 0) {
          return (
            (this.r = _[I]), (this.g = _[I + 1]), (this.b = _[I + 2]), this
          );
        }
        toArray(_ = [], I = 0) {
          return (_[I] = this.r), (_[I + 1] = this.g), (_[I + 2] = this.b), _;
        }
        fromBufferAttribute(_, I) {
          return (
            (this.r = _.getX(I)),
            (this.g = _.getY(I)),
            (this.b = _.getZ(I)),
            this
          );
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      };
      ry.NAMES = ru;
      var rx,
        rw = class {
          static getDataURL(_) {
            let I;
            if (/^data:/i.test(_.src) || typeof HTMLCanvasElement > "u")
              return _.src;
            if (_ instanceof HTMLCanvasElement) I = _;
            else {
              void 0 === rx && (rx = _p("canvas")),
                (rx.width = _.width),
                (rx.height = _.height);
              let R = rx.getContext("2d");
              _ instanceof ImageData
                ? R.putImageData(_, 0, 0)
                : R.drawImage(_, 0, 0, _.width, _.height),
                (I = rx);
            }
            return I.width > 2048 || I.height > 2048
              ? (console.warn(
                  "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                  _
                ),
                I.toDataURL("image/jpeg", 0.6))
              : I.toDataURL("image/png");
          }
          static sRGBToLinear(_) {
            if (
              ("u" > typeof HTMLImageElement &&
                _ instanceof HTMLImageElement) ||
              ("u" > typeof HTMLCanvasElement &&
                _ instanceof HTMLCanvasElement) ||
              ("u" > typeof ImageBitmap && _ instanceof ImageBitmap)
            ) {
              let I = _p("canvas");
              (I.width = _.width), (I.height = _.height);
              let R = I.getContext("2d");
              R.drawImage(_, 0, 0, _.width, _.height);
              let B = R.getImageData(0, 0, _.width, _.height),
                z = B.data;
              for (let _ = 0; _ < z.length; _++) z[_] = 255 * Sc(z[_] / 255);
              return R.putImageData(B, 0, 0), I;
            }
            if (!_.data)
              return (
                console.warn(
                  "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
                ),
                _
              );
            {
              let I = _.data.slice(0);
              for (let _ = 0; _ < I.length; _++)
                I instanceof Uint8Array || I instanceof Uint8ClampedArray
                  ? (I[_] = Math.floor(255 * Sc(I[_] / 255)))
                  : (I[_] = Sc(I[_]));
              return { data: I, width: _.width, height: _.height };
            }
          }
        },
        r_ = class {
          constructor(_ = null) {
            (this.isSource = !0),
              (this.uuid = ms()),
              (this.data = _),
              (this.version = 0);
          }
          set needsUpdate(_) {
            !0 === _ && this.version++;
          }
          toJSON(_) {
            let I = void 0 === _ || "string" == typeof _;
            if (!I && void 0 !== _.images[this.uuid])
              return _.images[this.uuid];
            let R = { uuid: this.uuid, url: "" },
              B = this.data;
            if (null !== B) {
              let _;
              if (Array.isArray(B)) {
                _ = [];
                for (let I = 0, R = B.length; I < R; I++)
                  B[I].isDataTexture
                    ? _.push(mS(B[I].image))
                    : _.push(mS(B[I]));
              } else _ = mS(B);
              R.url = _;
            }
            return I || (_.images[this.uuid] = R), R;
          }
        };
      function mS(_) {
        return ("u" > typeof HTMLImageElement &&
          _ instanceof HTMLImageElement) ||
          ("u" > typeof HTMLCanvasElement && _ instanceof HTMLCanvasElement) ||
          ("u" > typeof ImageBitmap && _ instanceof ImageBitmap)
          ? rw.getDataURL(_)
          : _.data
          ? {
              data: Array.from(_.data),
              width: _.width,
              height: _.height,
              type: _.data.constructor.name,
            }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      var rS = 0,
        rA = class extends i8 {
          constructor(
            _ = rA.DEFAULT_IMAGE,
            I = rA.DEFAULT_MAPPING,
            R = 1001,
            B = 1001,
            z = 1006,
            k = 1008,
            V = 1023,
            j = 1009,
            G = rA.DEFAULT_ANISOTROPY,
            q = 3e3
          ) {
            super(),
              (this.isTexture = !0),
              Object.defineProperty(this, "id", { value: rS++ }),
              (this.uuid = ms()),
              (this.name = ""),
              (this.source = new r_(_)),
              (this.mipmaps = []),
              (this.mapping = I),
              (this.wrapS = R),
              (this.wrapT = B),
              (this.magFilter = z),
              (this.minFilter = k),
              (this.anisotropy = G),
              (this.format = V),
              (this.internalFormat = null),
              (this.type = j),
              (this.offset = new rs(0, 0)),
              (this.repeat = new rs(1, 1)),
              (this.center = new rs(0, 0)),
              (this.rotation = 0),
              (this.matrixAutoUpdate = !0),
              (this.matrix = new ro()),
              (this.generateMipmaps = !0),
              (this.premultiplyAlpha = !1),
              (this.flipY = !0),
              (this.unpackAlignment = 4),
              (this.encoding = q),
              (this.userData = {}),
              (this.version = 0),
              (this.onUpdate = null),
              (this.isRenderTargetTexture = !1),
              (this.needsPMREMUpdate = !1);
          }
          get image() {
            return this.source.data;
          }
          set image(_) {
            this.source.data = _;
          }
          updateMatrix() {
            this.matrix.setUvTransform(
              this.offset.x,
              this.offset.y,
              this.repeat.x,
              this.repeat.y,
              this.rotation,
              this.center.x,
              this.center.y
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(_) {
            return (
              (this.name = _.name),
              (this.source = _.source),
              (this.mipmaps = _.mipmaps.slice(0)),
              (this.mapping = _.mapping),
              (this.wrapS = _.wrapS),
              (this.wrapT = _.wrapT),
              (this.magFilter = _.magFilter),
              (this.minFilter = _.minFilter),
              (this.anisotropy = _.anisotropy),
              (this.format = _.format),
              (this.internalFormat = _.internalFormat),
              (this.type = _.type),
              this.offset.copy(_.offset),
              this.repeat.copy(_.repeat),
              this.center.copy(_.center),
              (this.rotation = _.rotation),
              (this.matrixAutoUpdate = _.matrixAutoUpdate),
              this.matrix.copy(_.matrix),
              (this.generateMipmaps = _.generateMipmaps),
              (this.premultiplyAlpha = _.premultiplyAlpha),
              (this.flipY = _.flipY),
              (this.unpackAlignment = _.unpackAlignment),
              (this.encoding = _.encoding),
              (this.userData = JSON.parse(JSON.stringify(_.userData))),
              (this.needsUpdate = !0),
              this
            );
          }
          toJSON(_) {
            let I = void 0 === _ || "string" == typeof _;
            if (!I && void 0 !== _.textures[this.uuid])
              return _.textures[this.uuid];
            let R = {
              metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON",
              },
              uuid: this.uuid,
              name: this.name,
              image: this.source.toJSON(_).uuid,
              mapping: this.mapping,
              repeat: [this.repeat.x, this.repeat.y],
              offset: [this.offset.x, this.offset.y],
              center: [this.center.x, this.center.y],
              rotation: this.rotation,
              wrap: [this.wrapS, this.wrapT],
              format: this.format,
              type: this.type,
              encoding: this.encoding,
              minFilter: this.minFilter,
              magFilter: this.magFilter,
              anisotropy: this.anisotropy,
              flipY: this.flipY,
              generateMipmaps: this.generateMipmaps,
              premultiplyAlpha: this.premultiplyAlpha,
              unpackAlignment: this.unpackAlignment,
            };
            return (
              Object.keys(this.userData).length > 0 &&
                (R.userData = this.userData),
              I || (_.textures[this.uuid] = R),
              R
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
          transformUv(_) {
            if (300 !== this.mapping) return _;
            if ((_.applyMatrix3(this.matrix), _.x < 0 || _.x > 1))
              switch (this.wrapS) {
                case 1e3:
                  _.x = _.x - Math.floor(_.x);
                  break;
                case 1001:
                  _.x = _.x < 0 ? 0 : 1;
                  break;
                case 1002:
                  1 === Math.abs(Math.floor(_.x) % 2)
                    ? (_.x = Math.ceil(_.x) - _.x)
                    : (_.x = _.x - Math.floor(_.x));
              }
            if (_.y < 0 || _.y > 1)
              switch (this.wrapT) {
                case 1e3:
                  _.y = _.y - Math.floor(_.y);
                  break;
                case 1001:
                  _.y = _.y < 0 ? 0 : 1;
                  break;
                case 1002:
                  1 === Math.abs(Math.floor(_.y) % 2)
                    ? (_.y = Math.ceil(_.y) - _.y)
                    : (_.y = _.y - Math.floor(_.y));
              }
            return this.flipY && (_.y = 1 - _.y), _;
          }
          set needsUpdate(_) {
            !0 === _ && (this.version++, (this.source.needsUpdate = !0));
          }
        };
      (rA.DEFAULT_IMAGE = null),
        (rA.DEFAULT_MAPPING = 300),
        (rA.DEFAULT_ANISOTROPY = 1);
      var rM = class {
          constructor(_ = 0, I = 0, R = 0, B = 1) {
            (rM.prototype.isVector4 = !0),
              (this.x = _),
              (this.y = I),
              (this.z = R),
              (this.w = B);
          }
          get width() {
            return this.z;
          }
          set width(_) {
            this.z = _;
          }
          get height() {
            return this.w;
          }
          set height(_) {
            this.w = _;
          }
          set(_, I, R, B) {
            return (this.x = _), (this.y = I), (this.z = R), (this.w = B), this;
          }
          setScalar(_) {
            return (this.x = _), (this.y = _), (this.z = _), (this.w = _), this;
          }
          setX(_) {
            return (this.x = _), this;
          }
          setY(_) {
            return (this.y = _), this;
          }
          setZ(_) {
            return (this.z = _), this;
          }
          setW(_) {
            return (this.w = _), this;
          }
          setComponent(_, I) {
            switch (_) {
              case 0:
                this.x = I;
                break;
              case 1:
                this.y = I;
                break;
              case 2:
                this.z = I;
                break;
              case 3:
                this.w = I;
                break;
              default:
                throw Error("index is out of range: " + _);
            }
            return this;
          }
          getComponent(_) {
            switch (_) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              case 3:
                return this.w;
              default:
                throw Error("index is out of range: " + _);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y, this.z, this.w);
          }
          copy(_) {
            return (
              (this.x = _.x),
              (this.y = _.y),
              (this.z = _.z),
              (this.w = void 0 !== _.w ? _.w : 1),
              this
            );
          }
          add(_) {
            return (
              (this.x += _.x),
              (this.y += _.y),
              (this.z += _.z),
              (this.w += _.w),
              this
            );
          }
          addScalar(_) {
            return (
              (this.x += _), (this.y += _), (this.z += _), (this.w += _), this
            );
          }
          addVectors(_, I) {
            return (
              (this.x = _.x + I.x),
              (this.y = _.y + I.y),
              (this.z = _.z + I.z),
              (this.w = _.w + I.w),
              this
            );
          }
          addScaledVector(_, I) {
            return (
              (this.x += _.x * I),
              (this.y += _.y * I),
              (this.z += _.z * I),
              (this.w += _.w * I),
              this
            );
          }
          sub(_) {
            return (
              (this.x -= _.x),
              (this.y -= _.y),
              (this.z -= _.z),
              (this.w -= _.w),
              this
            );
          }
          subScalar(_) {
            return (
              (this.x -= _), (this.y -= _), (this.z -= _), (this.w -= _), this
            );
          }
          subVectors(_, I) {
            return (
              (this.x = _.x - I.x),
              (this.y = _.y - I.y),
              (this.z = _.z - I.z),
              (this.w = _.w - I.w),
              this
            );
          }
          multiply(_) {
            return (
              (this.x *= _.x),
              (this.y *= _.y),
              (this.z *= _.z),
              (this.w *= _.w),
              this
            );
          }
          multiplyScalar(_) {
            return (
              (this.x *= _), (this.y *= _), (this.z *= _), (this.w *= _), this
            );
          }
          applyMatrix4(_) {
            let I = this.x,
              R = this.y,
              B = this.z,
              z = this.w,
              k = _.elements;
            return (
              (this.x = k[0] * I + k[4] * R + k[8] * B + k[12] * z),
              (this.y = k[1] * I + k[5] * R + k[9] * B + k[13] * z),
              (this.z = k[2] * I + k[6] * R + k[10] * B + k[14] * z),
              (this.w = k[3] * I + k[7] * R + k[11] * B + k[15] * z),
              this
            );
          }
          divideScalar(_) {
            return this.multiplyScalar(1 / _);
          }
          setAxisAngleFromQuaternion(_) {
            this.w = 2 * Math.acos(_.w);
            let I = Math.sqrt(1 - _.w * _.w);
            return (
              I < 1e-4
                ? ((this.x = 1), (this.y = 0), (this.z = 0))
                : ((this.x = _.x / I), (this.y = _.y / I), (this.z = _.z / I)),
              this
            );
          }
          setAxisAngleFromRotationMatrix(_) {
            let I,
              R,
              B,
              z,
              k = _.elements,
              V = k[0],
              j = k[4],
              G = k[8],
              q = k[1],
              X = k[5],
              Q = k[9],
              $ = k[2],
              et = k[6],
              er = k[10];
            if (
              0.01 > Math.abs(j - q) &&
              0.01 > Math.abs(G - $) &&
              0.01 > Math.abs(Q - et)
            ) {
              if (
                0.1 > Math.abs(j + q) &&
                0.1 > Math.abs(G + $) &&
                0.1 > Math.abs(Q + et) &&
                0.1 > Math.abs(V + X + er - 3)
              )
                return this.set(1, 0, 0, 0), this;
              I = Math.PI;
              let _ = (V + 1) / 2,
                k = (X + 1) / 2,
                es = (er + 1) / 2,
                ea = (j + q) / 4,
                en = (G + $) / 4,
                eo = (Q + et) / 4;
              return (
                _ > k && _ > es
                  ? _ < 0.01
                    ? ((R = 0), (B = 0.707106781), (z = 0.707106781))
                    : ((B = ea / (R = Math.sqrt(_))), (z = en / R))
                  : k > es
                  ? k < 0.01
                    ? ((R = 0.707106781), (B = 0), (z = 0.707106781))
                    : ((R = ea / (B = Math.sqrt(k))), (z = eo / B))
                  : es < 0.01
                  ? ((R = 0.707106781), (B = 0.707106781), (z = 0))
                  : ((R = en / (z = Math.sqrt(es))), (B = eo / z)),
                this.set(R, B, z, I),
                this
              );
            }
            let es = Math.sqrt(
              (et - Q) * (et - Q) + (G - $) * (G - $) + (q - j) * (q - j)
            );
            return (
              0.001 > Math.abs(es) && (es = 1),
              (this.x = (et - Q) / es),
              (this.y = (G - $) / es),
              (this.z = (q - j) / es),
              (this.w = Math.acos((V + X + er - 1) / 2)),
              this
            );
          }
          min(_) {
            return (
              (this.x = Math.min(this.x, _.x)),
              (this.y = Math.min(this.y, _.y)),
              (this.z = Math.min(this.z, _.z)),
              (this.w = Math.min(this.w, _.w)),
              this
            );
          }
          max(_) {
            return (
              (this.x = Math.max(this.x, _.x)),
              (this.y = Math.max(this.y, _.y)),
              (this.z = Math.max(this.z, _.z)),
              (this.w = Math.max(this.w, _.w)),
              this
            );
          }
          clamp(_, I) {
            return (
              (this.x = Math.max(_.x, Math.min(I.x, this.x))),
              (this.y = Math.max(_.y, Math.min(I.y, this.y))),
              (this.z = Math.max(_.z, Math.min(I.z, this.z))),
              (this.w = Math.max(_.w, Math.min(I.w, this.w))),
              this
            );
          }
          clampScalar(_, I) {
            return (
              (this.x = Math.max(_, Math.min(I, this.x))),
              (this.y = Math.max(_, Math.min(I, this.y))),
              (this.z = Math.max(_, Math.min(I, this.z))),
              (this.w = Math.max(_, Math.min(I, this.w))),
              this
            );
          }
          clampLength(_, I) {
            let R = this.length();
            return this.divideScalar(R || 1).multiplyScalar(
              Math.max(_, Math.min(I, R))
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              (this.w = Math.floor(this.w)),
              this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              (this.w = Math.ceil(this.w)),
              this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              (this.w = Math.round(this.w)),
              this
            );
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
              (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
              this
            );
          }
          negate() {
            return (
              (this.x = -this.x),
              (this.y = -this.y),
              (this.z = -this.z),
              (this.w = -this.w),
              this
            );
          }
          dot(_) {
            return this.x * _.x + this.y * _.y + this.z * _.z + this.w * _.w;
          }
          lengthSq() {
            return (
              this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
            );
          }
          length() {
            return Math.sqrt(
              this.x * this.x +
                this.y * this.y +
                this.z * this.z +
                this.w * this.w
            );
          }
          manhattanLength() {
            return (
              Math.abs(this.x) +
              Math.abs(this.y) +
              Math.abs(this.z) +
              Math.abs(this.w)
            );
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          setLength(_) {
            return this.normalize().multiplyScalar(_);
          }
          lerp(_, I) {
            return (
              (this.x += (_.x - this.x) * I),
              (this.y += (_.y - this.y) * I),
              (this.z += (_.z - this.z) * I),
              (this.w += (_.w - this.w) * I),
              this
            );
          }
          lerpVectors(_, I, R) {
            return (
              (this.x = _.x + (I.x - _.x) * R),
              (this.y = _.y + (I.y - _.y) * R),
              (this.z = _.z + (I.z - _.z) * R),
              (this.w = _.w + (I.w - _.w) * R),
              this
            );
          }
          equals(_) {
            return (
              _.x === this.x &&
              _.y === this.y &&
              _.z === this.z &&
              _.w === this.w
            );
          }
          fromArray(_, I = 0) {
            return (
              (this.x = _[I]),
              (this.y = _[I + 1]),
              (this.z = _[I + 2]),
              (this.w = _[I + 3]),
              this
            );
          }
          toArray(_ = [], I = 0) {
            return (
              (_[I] = this.x),
              (_[I + 1] = this.y),
              (_[I + 2] = this.z),
              (_[I + 3] = this.w),
              _
            );
          }
          fromBufferAttribute(_, I) {
            return (
              (this.x = _.getX(I)),
              (this.y = _.getY(I)),
              (this.z = _.getZ(I)),
              (this.w = _.getW(I)),
              this
            );
          }
          random() {
            return (
              (this.x = Math.random()),
              (this.y = Math.random()),
              (this.z = Math.random()),
              (this.w = Math.random()),
              this
            );
          }
          *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z, yield this.w;
          }
        },
        rT = class extends i8 {
          constructor(_ = 1, I = 1, R = {}) {
            super(),
              (this.isWebGLRenderTarget = !0),
              (this.width = _),
              (this.height = I),
              (this.depth = 1),
              (this.scissor = new rM(0, 0, _, I)),
              (this.scissorTest = !1),
              (this.viewport = new rM(0, 0, _, I)),
              (this.texture = new rA(
                { width: _, height: I, depth: 1 },
                R.mapping,
                R.wrapS,
                R.wrapT,
                R.magFilter,
                R.minFilter,
                R.format,
                R.type,
                R.anisotropy,
                R.encoding
              )),
              (this.texture.isRenderTargetTexture = !0),
              (this.texture.flipY = !1),
              (this.texture.generateMipmaps =
                void 0 !== R.generateMipmaps && R.generateMipmaps),
              (this.texture.internalFormat =
                void 0 !== R.internalFormat ? R.internalFormat : null),
              (this.texture.minFilter =
                void 0 !== R.minFilter ? R.minFilter : 1006),
              (this.depthBuffer = void 0 === R.depthBuffer || R.depthBuffer),
              (this.stencilBuffer =
                void 0 !== R.stencilBuffer && R.stencilBuffer),
              (this.depthTexture =
                void 0 !== R.depthTexture ? R.depthTexture : null),
              (this.samples = void 0 !== R.samples ? R.samples : 0);
          }
          setSize(_, I, R = 1) {
            (this.width !== _ || this.height !== I || this.depth !== R) &&
              ((this.width = _),
              (this.height = I),
              (this.depth = R),
              (this.texture.image.width = _),
              (this.texture.image.height = I),
              (this.texture.image.depth = R),
              this.dispose()),
              this.viewport.set(0, 0, _, I),
              this.scissor.set(0, 0, _, I);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(_) {
            (this.width = _.width),
              (this.height = _.height),
              (this.depth = _.depth),
              this.viewport.copy(_.viewport),
              (this.texture = _.texture.clone()),
              (this.texture.isRenderTargetTexture = !0);
            let I = Object.assign({}, _.texture.image);
            return (
              (this.texture.source = new r_(I)),
              (this.depthBuffer = _.depthBuffer),
              (this.stencilBuffer = _.stencilBuffer),
              null !== _.depthTexture &&
                (this.depthTexture = _.depthTexture.clone()),
              (this.samples = _.samples),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
        },
        rP = class extends rA {
          constructor(_ = null, I = 1, R = 1, B = 1) {
            super(null),
              (this.isDataArrayTexture = !0),
              (this.image = { data: _, width: I, height: R, depth: B }),
              (this.magFilter = 1003),
              (this.minFilter = 1003),
              (this.wrapR = 1001),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1);
          }
        },
        rR = class extends rA {
          constructor(_ = null, I = 1, R = 1, B = 1) {
            super(null),
              (this.isData3DTexture = !0),
              (this.image = { data: _, width: I, height: R, depth: B }),
              (this.magFilter = 1003),
              (this.minFilter = 1003),
              (this.wrapR = 1001),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1);
          }
        },
        rB = class extends rT {
          constructor(_ = 1, I = 1, R = 1, B = {}) {
            super(_, I, B), (this.isWebGLMultipleRenderTargets = !0);
            let z = this.texture;
            this.texture = [];
            for (let _ = 0; _ < R; _++)
              (this.texture[_] = z.clone()),
                (this.texture[_].isRenderTargetTexture = !0);
          }
          setSize(_, I, R = 1) {
            if (this.width !== _ || this.height !== I || this.depth !== R) {
              (this.width = _), (this.height = I), (this.depth = R);
              for (let B = 0, z = this.texture.length; B < z; B++)
                (this.texture[B].image.width = _),
                  (this.texture[B].image.height = I),
                  (this.texture[B].image.depth = R);
              this.dispose();
            }
            return (
              this.viewport.set(0, 0, _, I), this.scissor.set(0, 0, _, I), this
            );
          }
          copy(_) {
            this.dispose(),
              (this.width = _.width),
              (this.height = _.height),
              (this.depth = _.depth),
              this.viewport.set(0, 0, this.width, this.height),
              this.scissor.set(0, 0, this.width, this.height),
              (this.depthBuffer = _.depthBuffer),
              (this.stencilBuffer = _.stencilBuffer),
              null !== _.depthTexture &&
                (this.depthTexture = _.depthTexture.clone()),
              (this.texture.length = 0);
            for (let I = 0, R = _.texture.length; I < R; I++)
              (this.texture[I] = _.texture[I].clone()),
                (this.texture[I].isRenderTargetTexture = !0);
            return this;
          }
        },
        rz = class {
          constructor(_ = 0, I = 0, R = 0, B = 1) {
            (this.isQuaternion = !0),
              (this._x = _),
              (this._y = I),
              (this._z = R),
              (this._w = B);
          }
          static slerpFlat(_, I, R, B, z, k, V) {
            let j = R[B + 0],
              G = R[B + 1],
              q = R[B + 2],
              X = R[B + 3],
              Q = z[k + 0],
              $ = z[k + 1],
              et = z[k + 2],
              er = z[k + 3];
            if (0 === V) {
              (_[I + 0] = j), (_[I + 1] = G), (_[I + 2] = q), (_[I + 3] = X);
              return;
            }
            if (1 === V) {
              (_[I + 0] = Q), (_[I + 1] = $), (_[I + 2] = et), (_[I + 3] = er);
              return;
            }
            if (X !== er || j !== Q || G !== $ || q !== et) {
              let _ = 1 - V,
                I = j * Q + G * $ + q * et + X * er,
                R = I >= 0 ? 1 : -1,
                B = 1 - I * I;
              if (B > Number.EPSILON) {
                let z = Math.sqrt(B),
                  k = Math.atan2(z, I * R);
                (_ = Math.sin(_ * k) / z), (V = Math.sin(V * k) / z);
              }
              let z = V * R;
              if (
                ((j = j * _ + Q * z),
                (G = G * _ + $ * z),
                (q = q * _ + et * z),
                (X = X * _ + er * z),
                _ === 1 - V)
              ) {
                let _ = 1 / Math.sqrt(j * j + G * G + q * q + X * X);
                (j *= _), (G *= _), (q *= _), (X *= _);
              }
            }
            (_[I] = j), (_[I + 1] = G), (_[I + 2] = q), (_[I + 3] = X);
          }
          static multiplyQuaternionsFlat(_, I, R, B, z, k) {
            let V = R[B],
              j = R[B + 1],
              G = R[B + 2],
              q = R[B + 3],
              X = z[k],
              Q = z[k + 1],
              $ = z[k + 2],
              et = z[k + 3];
            return (
              (_[I] = V * et + q * X + j * $ - G * Q),
              (_[I + 1] = j * et + q * Q + G * X - V * $),
              (_[I + 2] = G * et + q * $ + V * Q - j * X),
              (_[I + 3] = q * et - V * X - j * Q - G * $),
              _
            );
          }
          get x() {
            return this._x;
          }
          set x(_) {
            (this._x = _), this._onChangeCallback();
          }
          get y() {
            return this._y;
          }
          set y(_) {
            (this._y = _), this._onChangeCallback();
          }
          get z() {
            return this._z;
          }
          set z(_) {
            (this._z = _), this._onChangeCallback();
          }
          get w() {
            return this._w;
          }
          set w(_) {
            (this._w = _), this._onChangeCallback();
          }
          set(_, I, R, B) {
            return (
              (this._x = _),
              (this._y = I),
              (this._z = R),
              (this._w = B),
              this._onChangeCallback(),
              this
            );
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._w);
          }
          copy(_) {
            return (
              (this._x = _.x),
              (this._y = _.y),
              (this._z = _.z),
              (this._w = _.w),
              this._onChangeCallback(),
              this
            );
          }
          setFromEuler(_, I) {
            let R = _._x,
              B = _._y,
              z = _._z,
              k = _._order,
              V = Math.cos,
              j = Math.sin,
              G = V(R / 2),
              q = V(B / 2),
              X = V(z / 2),
              Q = j(R / 2),
              $ = j(B / 2),
              et = j(z / 2);
            switch (k) {
              case "XYZ":
                (this._x = Q * q * X + G * $ * et),
                  (this._y = G * $ * X - Q * q * et),
                  (this._z = G * q * et + Q * $ * X),
                  (this._w = G * q * X - Q * $ * et);
                break;
              case "YXZ":
                (this._x = Q * q * X + G * $ * et),
                  (this._y = G * $ * X - Q * q * et),
                  (this._z = G * q * et - Q * $ * X),
                  (this._w = G * q * X + Q * $ * et);
                break;
              case "ZXY":
                (this._x = Q * q * X - G * $ * et),
                  (this._y = G * $ * X + Q * q * et),
                  (this._z = G * q * et + Q * $ * X),
                  (this._w = G * q * X - Q * $ * et);
                break;
              case "ZYX":
                (this._x = Q * q * X - G * $ * et),
                  (this._y = G * $ * X + Q * q * et),
                  (this._z = G * q * et - Q * $ * X),
                  (this._w = G * q * X + Q * $ * et);
                break;
              case "YZX":
                (this._x = Q * q * X + G * $ * et),
                  (this._y = G * $ * X + Q * q * et),
                  (this._z = G * q * et - Q * $ * X),
                  (this._w = G * q * X - Q * $ * et);
                break;
              case "XZY":
                (this._x = Q * q * X - G * $ * et),
                  (this._y = G * $ * X - Q * q * et),
                  (this._z = G * q * et + Q * $ * X),
                  (this._w = G * q * X + Q * $ * et);
                break;
              default:
                console.warn(
                  "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                    k
                );
            }
            return !1 !== I && this._onChangeCallback(), this;
          }
          setFromAxisAngle(_, I) {
            let R = I / 2,
              B = Math.sin(R);
            return (
              (this._x = _.x * B),
              (this._y = _.y * B),
              (this._z = _.z * B),
              (this._w = Math.cos(R)),
              this._onChangeCallback(),
              this
            );
          }
          setFromRotationMatrix(_) {
            let I = _.elements,
              R = I[0],
              B = I[4],
              z = I[8],
              k = I[1],
              V = I[5],
              j = I[9],
              G = I[2],
              q = I[6],
              X = I[10],
              Q = R + V + X;
            if (Q > 0) {
              let _ = 0.5 / Math.sqrt(Q + 1);
              (this._w = 0.25 / _),
                (this._x = (q - j) * _),
                (this._y = (z - G) * _),
                (this._z = (k - B) * _);
            } else if (R > V && R > X) {
              let _ = 2 * Math.sqrt(1 + R - V - X);
              (this._w = (q - j) / _),
                (this._x = 0.25 * _),
                (this._y = (B + k) / _),
                (this._z = (z + G) / _);
            } else if (V > X) {
              let _ = 2 * Math.sqrt(1 + V - R - X);
              (this._w = (z - G) / _),
                (this._x = (B + k) / _),
                (this._y = 0.25 * _),
                (this._z = (j + q) / _);
            } else {
              let _ = 2 * Math.sqrt(1 + X - R - V);
              (this._w = (k - B) / _),
                (this._x = (z + G) / _),
                (this._y = (j + q) / _),
                (this._z = 0.25 * _);
            }
            return this._onChangeCallback(), this;
          }
          setFromUnitVectors(_, I) {
            let R = _.dot(I) + 1;
            return (
              R < Number.EPSILON
                ? ((R = 0),
                  Math.abs(_.x) > Math.abs(_.z)
                    ? ((this._x = -_.y), (this._y = _.x), (this._z = 0))
                    : ((this._x = 0), (this._y = -_.z), (this._z = _.y)))
                : ((this._x = _.y * I.z - _.z * I.y),
                  (this._y = _.z * I.x - _.x * I.z),
                  (this._z = _.x * I.y - _.y * I.x)),
              (this._w = R),
              this.normalize()
            );
          }
          angleTo(_) {
            return 2 * Math.acos(Math.abs(gi(this.dot(_), -1, 1)));
          }
          rotateTowards(_, I) {
            let R = this.angleTo(_);
            if (0 === R) return this;
            let B = Math.min(1, I / R);
            return this.slerp(_, B), this;
          }
          identity() {
            return this.set(0, 0, 0, 1);
          }
          invert() {
            return this.conjugate();
          }
          conjugate() {
            return (
              (this._x *= -1),
              (this._y *= -1),
              (this._z *= -1),
              this._onChangeCallback(),
              this
            );
          }
          dot(_) {
            return (
              this._x * _._x + this._y * _._y + this._z * _._z + this._w * _._w
            );
          }
          lengthSq() {
            return (
              this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
            );
          }
          length() {
            return Math.sqrt(
              this._x * this._x +
                this._y * this._y +
                this._z * this._z +
                this._w * this._w
            );
          }
          normalize() {
            let _ = this.length();
            return (
              0 === _
                ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
                : ((_ = 1 / _),
                  (this._x = this._x * _),
                  (this._y = this._y * _),
                  (this._z = this._z * _),
                  (this._w = this._w * _)),
              this._onChangeCallback(),
              this
            );
          }
          multiply(_) {
            return this.multiplyQuaternions(this, _);
          }
          premultiply(_) {
            return this.multiplyQuaternions(_, this);
          }
          multiplyQuaternions(_, I) {
            let R = _._x,
              B = _._y,
              z = _._z,
              k = _._w,
              V = I._x,
              j = I._y,
              G = I._z,
              q = I._w;
            return (
              (this._x = R * q + k * V + B * G - z * j),
              (this._y = B * q + k * j + z * V - R * G),
              (this._z = z * q + k * G + R * j - B * V),
              (this._w = k * q - R * V - B * j - z * G),
              this._onChangeCallback(),
              this
            );
          }
          slerp(_, I) {
            if (0 === I) return this;
            if (1 === I) return this.copy(_);
            let R = this._x,
              B = this._y,
              z = this._z,
              k = this._w,
              V = k * _._w + R * _._x + B * _._y + z * _._z;
            if (
              (V < 0
                ? ((this._w = -_._w),
                  (this._x = -_._x),
                  (this._y = -_._y),
                  (this._z = -_._z),
                  (V = -V))
                : this.copy(_),
              V >= 1)
            )
              return (
                (this._w = k), (this._x = R), (this._y = B), (this._z = z), this
              );
            let j = 1 - V * V;
            if (j <= Number.EPSILON) {
              let _ = 1 - I;
              return (
                (this._w = _ * k + I * this._w),
                (this._x = _ * R + I * this._x),
                (this._y = _ * B + I * this._y),
                (this._z = _ * z + I * this._z),
                this.normalize(),
                this._onChangeCallback(),
                this
              );
            }
            let G = Math.sqrt(j),
              q = Math.atan2(G, V),
              X = Math.sin((1 - I) * q) / G,
              Q = Math.sin(I * q) / G;
            return (
              (this._w = k * X + this._w * Q),
              (this._x = R * X + this._x * Q),
              (this._y = B * X + this._y * Q),
              (this._z = z * X + this._z * Q),
              this._onChangeCallback(),
              this
            );
          }
          slerpQuaternions(_, I, R) {
            return this.copy(_).slerp(I, R);
          }
          random() {
            let _ = Math.random(),
              I = Math.sqrt(1 - _),
              R = Math.sqrt(_),
              B = 2 * Math.PI * Math.random(),
              z = 2 * Math.PI * Math.random();
            return this.set(
              I * Math.cos(B),
              R * Math.sin(z),
              R * Math.cos(z),
              I * Math.sin(B)
            );
          }
          equals(_) {
            return (
              _._x === this._x &&
              _._y === this._y &&
              _._z === this._z &&
              _._w === this._w
            );
          }
          fromArray(_, I = 0) {
            return (
              (this._x = _[I]),
              (this._y = _[I + 1]),
              (this._z = _[I + 2]),
              (this._w = _[I + 3]),
              this._onChangeCallback(),
              this
            );
          }
          toArray(_ = [], I = 0) {
            return (
              (_[I] = this._x),
              (_[I + 1] = this._y),
              (_[I + 2] = this._z),
              (_[I + 3] = this._w),
              _
            );
          }
          fromBufferAttribute(_, I) {
            return (
              (this._x = _.getX(I)),
              (this._y = _.getY(I)),
              (this._z = _.getZ(I)),
              (this._w = _.getW(I)),
              this
            );
          }
          _onChange(_) {
            return (this._onChangeCallback = _), this;
          }
          _onChangeCallback() {}
          *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._w;
          }
        },
        rF = class {
          constructor(_ = 0, I = 0, R = 0) {
            (rF.prototype.isVector3 = !0),
              (this.x = _),
              (this.y = I),
              (this.z = R);
          }
          set(_, I, R) {
            return (
              void 0 === R && (R = this.z),
              (this.x = _),
              (this.y = I),
              (this.z = R),
              this
            );
          }
          setScalar(_) {
            return (this.x = _), (this.y = _), (this.z = _), this;
          }
          setX(_) {
            return (this.x = _), this;
          }
          setY(_) {
            return (this.y = _), this;
          }
          setZ(_) {
            return (this.z = _), this;
          }
          setComponent(_, I) {
            switch (_) {
              case 0:
                this.x = I;
                break;
              case 1:
                this.y = I;
                break;
              case 2:
                this.z = I;
                break;
              default:
                throw Error("index is out of range: " + _);
            }
            return this;
          }
          getComponent(_) {
            switch (_) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              default:
                throw Error("index is out of range: " + _);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y, this.z);
          }
          copy(_) {
            return (this.x = _.x), (this.y = _.y), (this.z = _.z), this;
          }
          add(_) {
            return (this.x += _.x), (this.y += _.y), (this.z += _.z), this;
          }
          addScalar(_) {
            return (this.x += _), (this.y += _), (this.z += _), this;
          }
          addVectors(_, I) {
            return (
              (this.x = _.x + I.x),
              (this.y = _.y + I.y),
              (this.z = _.z + I.z),
              this
            );
          }
          addScaledVector(_, I) {
            return (
              (this.x += _.x * I),
              (this.y += _.y * I),
              (this.z += _.z * I),
              this
            );
          }
          sub(_) {
            return (this.x -= _.x), (this.y -= _.y), (this.z -= _.z), this;
          }
          subScalar(_) {
            return (this.x -= _), (this.y -= _), (this.z -= _), this;
          }
          subVectors(_, I) {
            return (
              (this.x = _.x - I.x),
              (this.y = _.y - I.y),
              (this.z = _.z - I.z),
              this
            );
          }
          multiply(_) {
            return (this.x *= _.x), (this.y *= _.y), (this.z *= _.z), this;
          }
          multiplyScalar(_) {
            return (this.x *= _), (this.y *= _), (this.z *= _), this;
          }
          multiplyVectors(_, I) {
            return (
              (this.x = _.x * I.x),
              (this.y = _.y * I.y),
              (this.z = _.z * I.z),
              this
            );
          }
          applyEuler(_) {
            return this.applyQuaternion(rk.setFromEuler(_));
          }
          applyAxisAngle(_, I) {
            return this.applyQuaternion(rk.setFromAxisAngle(_, I));
          }
          applyMatrix3(_) {
            let I = this.x,
              R = this.y,
              B = this.z,
              z = _.elements;
            return (
              (this.x = z[0] * I + z[3] * R + z[6] * B),
              (this.y = z[1] * I + z[4] * R + z[7] * B),
              (this.z = z[2] * I + z[5] * R + z[8] * B),
              this
            );
          }
          applyNormalMatrix(_) {
            return this.applyMatrix3(_).normalize();
          }
          applyMatrix4(_) {
            let I = this.x,
              R = this.y,
              B = this.z,
              z = _.elements,
              k = 1 / (z[3] * I + z[7] * R + z[11] * B + z[15]);
            return (
              (this.x = (z[0] * I + z[4] * R + z[8] * B + z[12]) * k),
              (this.y = (z[1] * I + z[5] * R + z[9] * B + z[13]) * k),
              (this.z = (z[2] * I + z[6] * R + z[10] * B + z[14]) * k),
              this
            );
          }
          applyQuaternion(_) {
            let I = this.x,
              R = this.y,
              B = this.z,
              z = _.x,
              k = _.y,
              V = _.z,
              j = _.w,
              G = j * I + k * B - V * R,
              q = j * R + V * I - z * B,
              X = j * B + z * R - k * I,
              Q = -z * I - k * R - V * B;
            return (
              (this.x = G * j + -(Q * z) + -(q * V) - -(X * k)),
              (this.y = q * j + -(Q * k) + -(X * z) - -(G * V)),
              (this.z = X * j + -(Q * V) + -(G * k) - -(q * z)),
              this
            );
          }
          project(_) {
            return this.applyMatrix4(_.matrixWorldInverse).applyMatrix4(
              _.projectionMatrix
            );
          }
          unproject(_) {
            return this.applyMatrix4(_.projectionMatrixInverse).applyMatrix4(
              _.matrixWorld
            );
          }
          transformDirection(_) {
            let I = this.x,
              R = this.y,
              B = this.z,
              z = _.elements;
            return (
              (this.x = z[0] * I + z[4] * R + z[8] * B),
              (this.y = z[1] * I + z[5] * R + z[9] * B),
              (this.z = z[2] * I + z[6] * R + z[10] * B),
              this.normalize()
            );
          }
          divide(_) {
            return (this.x /= _.x), (this.y /= _.y), (this.z /= _.z), this;
          }
          divideScalar(_) {
            return this.multiplyScalar(1 / _);
          }
          min(_) {
            return (
              (this.x = Math.min(this.x, _.x)),
              (this.y = Math.min(this.y, _.y)),
              (this.z = Math.min(this.z, _.z)),
              this
            );
          }
          max(_) {
            return (
              (this.x = Math.max(this.x, _.x)),
              (this.y = Math.max(this.y, _.y)),
              (this.z = Math.max(this.z, _.z)),
              this
            );
          }
          clamp(_, I) {
            return (
              (this.x = Math.max(_.x, Math.min(I.x, this.x))),
              (this.y = Math.max(_.y, Math.min(I.y, this.y))),
              (this.z = Math.max(_.z, Math.min(I.z, this.z))),
              this
            );
          }
          clampScalar(_, I) {
            return (
              (this.x = Math.max(_, Math.min(I, this.x))),
              (this.y = Math.max(_, Math.min(I, this.y))),
              (this.z = Math.max(_, Math.min(I, this.z))),
              this
            );
          }
          clampLength(_, I) {
            let R = this.length();
            return this.divideScalar(R || 1).multiplyScalar(
              Math.max(_, Math.min(I, R))
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              this
            );
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
              this
            );
          }
          negate() {
            return (
              (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
            );
          }
          dot(_) {
            return this.x * _.x + this.y * _.y + this.z * _.z;
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
          }
          length() {
            return Math.sqrt(
              this.x * this.x + this.y * this.y + this.z * this.z
            );
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          setLength(_) {
            return this.normalize().multiplyScalar(_);
          }
          lerp(_, I) {
            return (
              (this.x += (_.x - this.x) * I),
              (this.y += (_.y - this.y) * I),
              (this.z += (_.z - this.z) * I),
              this
            );
          }
          lerpVectors(_, I, R) {
            return (
              (this.x = _.x + (I.x - _.x) * R),
              (this.y = _.y + (I.y - _.y) * R),
              (this.z = _.z + (I.z - _.z) * R),
              this
            );
          }
          cross(_) {
            return this.crossVectors(this, _);
          }
          crossVectors(_, I) {
            let R = _.x,
              B = _.y,
              z = _.z,
              k = I.x,
              V = I.y,
              j = I.z;
            return (
              (this.x = B * j - z * V),
              (this.y = z * k - R * j),
              (this.z = R * V - B * k),
              this
            );
          }
          projectOnVector(_) {
            let I = _.lengthSq();
            if (0 === I) return this.set(0, 0, 0);
            let R = _.dot(this) / I;
            return this.copy(_).multiplyScalar(R);
          }
          projectOnPlane(_) {
            return rN.copy(this).projectOnVector(_), this.sub(rN);
          }
          reflect(_) {
            return this.sub(rN.copy(_).multiplyScalar(2 * this.dot(_)));
          }
          angleTo(_) {
            let I = Math.sqrt(this.lengthSq() * _.lengthSq());
            return 0 === I
              ? Math.PI / 2
              : Math.acos(gi(this.dot(_) / I, -1, 1));
          }
          distanceTo(_) {
            return Math.sqrt(this.distanceToSquared(_));
          }
          distanceToSquared(_) {
            let I = this.x - _.x,
              R = this.y - _.y,
              B = this.z - _.z;
            return I * I + R * R + B * B;
          }
          manhattanDistanceTo(_) {
            return (
              Math.abs(this.x - _.x) +
              Math.abs(this.y - _.y) +
              Math.abs(this.z - _.z)
            );
          }
          setFromSpherical(_) {
            return this.setFromSphericalCoords(_.radius, _.phi, _.theta);
          }
          setFromSphericalCoords(_, I, R) {
            let B = Math.sin(I) * _;
            return (
              (this.x = B * Math.sin(R)),
              (this.y = Math.cos(I) * _),
              (this.z = B * Math.cos(R)),
              this
            );
          }
          setFromCylindrical(_) {
            return this.setFromCylindricalCoords(_.radius, _.theta, _.y);
          }
          setFromCylindricalCoords(_, I, R) {
            return (
              (this.x = _ * Math.sin(I)),
              (this.y = R),
              (this.z = _ * Math.cos(I)),
              this
            );
          }
          setFromMatrixPosition(_) {
            let I = _.elements;
            return (this.x = I[12]), (this.y = I[13]), (this.z = I[14]), this;
          }
          setFromMatrixScale(_) {
            let I = this.setFromMatrixColumn(_, 0).length(),
              R = this.setFromMatrixColumn(_, 1).length(),
              B = this.setFromMatrixColumn(_, 2).length();
            return (this.x = I), (this.y = R), (this.z = B), this;
          }
          setFromMatrixColumn(_, I) {
            return this.fromArray(_.elements, 4 * I);
          }
          setFromMatrix3Column(_, I) {
            return this.fromArray(_.elements, 3 * I);
          }
          setFromEuler(_) {
            return (this.x = _._x), (this.y = _._y), (this.z = _._z), this;
          }
          equals(_) {
            return _.x === this.x && _.y === this.y && _.z === this.z;
          }
          fromArray(_, I = 0) {
            return (
              (this.x = _[I]), (this.y = _[I + 1]), (this.z = _[I + 2]), this
            );
          }
          toArray(_ = [], I = 0) {
            return (_[I] = this.x), (_[I + 1] = this.y), (_[I + 2] = this.z), _;
          }
          fromBufferAttribute(_, I) {
            return (
              (this.x = _.getX(I)),
              (this.y = _.getY(I)),
              (this.z = _.getZ(I)),
              this
            );
          }
          random() {
            return (
              (this.x = Math.random()),
              (this.y = Math.random()),
              (this.z = Math.random()),
              this
            );
          }
          randomDirection() {
            let _ = (Math.random() - 0.5) * 2,
              I = Math.random() * Math.PI * 2,
              R = Math.sqrt(1 - _ ** 2);
            return (
              (this.x = R * Math.cos(I)),
              (this.y = R * Math.sin(I)),
              (this.z = _),
              this
            );
          }
          *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z;
          }
        },
        rN = new rF(),
        rk = new rz(),
        rU = class {
          constructor(
            _ = new rF(1 / 0, 1 / 0, 1 / 0),
            I = new rF(-1 / 0, -1 / 0, -1 / 0)
          ) {
            (this.isBox3 = !0), (this.min = _), (this.max = I);
          }
          set(_, I) {
            return this.min.copy(_), this.max.copy(I), this;
          }
          setFromArray(_) {
            let I = 1 / 0,
              R = 1 / 0,
              B = 1 / 0,
              z = -1 / 0,
              k = -1 / 0,
              V = -1 / 0;
            for (let j = 0, G = _.length; j < G; j += 3) {
              let G = _[j],
                q = _[j + 1],
                X = _[j + 2];
              G < I && (I = G),
                q < R && (R = q),
                X < B && (B = X),
                G > z && (z = G),
                q > k && (k = q),
                X > V && (V = X);
            }
            return this.min.set(I, R, B), this.max.set(z, k, V), this;
          }
          setFromBufferAttribute(_) {
            let I = 1 / 0,
              R = 1 / 0,
              B = 1 / 0,
              z = -1 / 0,
              k = -1 / 0,
              V = -1 / 0;
            for (let j = 0, G = _.count; j < G; j++) {
              let G = _.getX(j),
                q = _.getY(j),
                X = _.getZ(j);
              G < I && (I = G),
                q < R && (R = q),
                X < B && (B = X),
                G > z && (z = G),
                q > k && (k = q),
                X > V && (V = X);
            }
            return this.min.set(I, R, B), this.max.set(z, k, V), this;
          }
          setFromPoints(_) {
            this.makeEmpty();
            for (let I = 0, R = _.length; I < R; I++) this.expandByPoint(_[I]);
            return this;
          }
          setFromCenterAndSize(_, I) {
            let R = rj.copy(I).multiplyScalar(0.5);
            return this.min.copy(_).sub(R), this.max.copy(_).add(R), this;
          }
          setFromObject(_, I = !1) {
            return this.makeEmpty(), this.expandByObject(_, I);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(_) {
            return this.min.copy(_.min), this.max.copy(_.max), this;
          }
          makeEmpty() {
            return (
              (this.min.x = this.min.y = this.min.z = 1 / 0),
              (this.max.x = this.max.y = this.max.z = -1 / 0),
              this
            );
          }
          isEmpty() {
            return (
              this.max.x < this.min.x ||
              this.max.y < this.min.y ||
              this.max.z < this.min.z
            );
          }
          getCenter(_) {
            return this.isEmpty()
              ? _.set(0, 0, 0)
              : _.addVectors(this.min, this.max).multiplyScalar(0.5);
          }
          getSize(_) {
            return this.isEmpty()
              ? _.set(0, 0, 0)
              : _.subVectors(this.max, this.min);
          }
          expandByPoint(_) {
            return this.min.min(_), this.max.max(_), this;
          }
          expandByVector(_) {
            return this.min.sub(_), this.max.add(_), this;
          }
          expandByScalar(_) {
            return this.min.addScalar(-_), this.max.addScalar(_), this;
          }
          expandByObject(_, I = !1) {
            _.updateWorldMatrix(!1, !1);
            let R = _.geometry;
            if (void 0 !== R) {
              if (
                I &&
                null != R.attributes &&
                void 0 !== R.attributes.position
              ) {
                let I = R.attributes.position;
                for (let R = 0, B = I.count; R < B; R++)
                  rj.fromBufferAttribute(I, R).applyMatrix4(_.matrixWorld),
                    this.expandByPoint(rj);
              } else
                null === R.boundingBox && R.computeBoundingBox(),
                  rH.copy(R.boundingBox),
                  rH.applyMatrix4(_.matrixWorld),
                  this.union(rH);
            }
            let B = _.children;
            for (let _ = 0, R = B.length; _ < R; _++)
              this.expandByObject(B[_], I);
            return this;
          }
          containsPoint(_) {
            return !(
              _.x < this.min.x ||
              _.x > this.max.x ||
              _.y < this.min.y ||
              _.y > this.max.y ||
              _.z < this.min.z ||
              _.z > this.max.z
            );
          }
          containsBox(_) {
            return (
              this.min.x <= _.min.x &&
              _.max.x <= this.max.x &&
              this.min.y <= _.min.y &&
              _.max.y <= this.max.y &&
              this.min.z <= _.min.z &&
              _.max.z <= this.max.z
            );
          }
          getParameter(_, I) {
            return I.set(
              (_.x - this.min.x) / (this.max.x - this.min.x),
              (_.y - this.min.y) / (this.max.y - this.min.y),
              (_.z - this.min.z) / (this.max.z - this.min.z)
            );
          }
          intersectsBox(_) {
            return !(
              _.max.x < this.min.x ||
              _.min.x > this.max.x ||
              _.max.y < this.min.y ||
              _.min.y > this.max.y ||
              _.max.z < this.min.z ||
              _.min.z > this.max.z
            );
          }
          intersectsSphere(_) {
            return (
              this.clampPoint(_.center, rj),
              rj.distanceToSquared(_.center) <= _.radius * _.radius
            );
          }
          intersectsPlane(_) {
            let I, R;
            return (
              _.normal.x > 0
                ? ((I = _.normal.x * this.min.x), (R = _.normal.x * this.max.x))
                : ((I = _.normal.x * this.max.x),
                  (R = _.normal.x * this.min.x)),
              _.normal.y > 0
                ? ((I += _.normal.y * this.min.y),
                  (R += _.normal.y * this.max.y))
                : ((I += _.normal.y * this.max.y),
                  (R += _.normal.y * this.min.y)),
              _.normal.z > 0
                ? ((I += _.normal.z * this.min.z),
                  (R += _.normal.z * this.max.z))
                : ((I += _.normal.z * this.max.z),
                  (R += _.normal.z * this.min.z)),
              I <= -_.constant && R >= -_.constant
            );
          }
          intersectsTriangle(_) {
            if (this.isEmpty()) return !1;
            this.getCenter(rJ),
              r$.subVectors(this.max, rJ),
              rW.subVectors(_.a, rJ),
              rq.subVectors(_.b, rJ),
              rX.subVectors(_.c, rJ),
              rQ.subVectors(rq, rW),
              rZ.subVectors(rX, rq),
              rK.subVectors(rW, rX);
            let I = [
              0,
              -rQ.z,
              rQ.y,
              0,
              -rZ.z,
              rZ.y,
              0,
              -rK.z,
              rK.y,
              rQ.z,
              0,
              -rQ.x,
              rZ.z,
              0,
              -rZ.x,
              rK.z,
              0,
              -rK.x,
              -rQ.y,
              rQ.x,
              0,
              -rZ.y,
              rZ.x,
              0,
              -rK.y,
              rK.x,
              0,
            ];
            return (
              !!(
                vS(I, rW, rq, rX, r$) &&
                vS((I = [1, 0, 0, 0, 1, 0, 0, 0, 1]), rW, rq, rX, r$)
              ) &&
              (r0.crossVectors(rQ, rZ),
              vS((I = [r0.x, r0.y, r0.z]), rW, rq, rX, r$))
            );
          }
          clampPoint(_, I) {
            return I.copy(_).clamp(this.min, this.max);
          }
          distanceToPoint(_) {
            return rj.copy(_).clamp(this.min, this.max).sub(_).length();
          }
          getBoundingSphere(_) {
            return (
              this.getCenter(_.center),
              (_.radius = 0.5 * this.getSize(rj).length()),
              _
            );
          }
          intersect(_) {
            return (
              this.min.max(_.min),
              this.max.min(_.max),
              this.isEmpty() && this.makeEmpty(),
              this
            );
          }
          union(_) {
            return this.min.min(_.min), this.max.max(_.max), this;
          }
          applyMatrix4(_) {
            return (
              this.isEmpty() ||
                (rV[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(_),
                rV[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(_),
                rV[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(_),
                rV[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(_),
                rV[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(_),
                rV[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(_),
                rV[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(_),
                rV[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(_),
                this.setFromPoints(rV)),
              this
            );
          }
          translate(_) {
            return this.min.add(_), this.max.add(_), this;
          }
          equals(_) {
            return _.min.equals(this.min) && _.max.equals(this.max);
          }
        },
        rV = [
          new rF(),
          new rF(),
          new rF(),
          new rF(),
          new rF(),
          new rF(),
          new rF(),
          new rF(),
        ],
        rj = new rF(),
        rH = new rU(),
        rW = new rF(),
        rq = new rF(),
        rX = new rF(),
        rQ = new rF(),
        rZ = new rF(),
        rK = new rF(),
        rJ = new rF(),
        r$ = new rF(),
        r0 = new rF(),
        r1 = new rF();
      function vS(_, I, R, B, z) {
        for (let k = 0, V = _.length - 3; k <= V; k += 3) {
          r1.fromArray(_, k);
          let V =
              z.x * Math.abs(r1.x) +
              z.y * Math.abs(r1.y) +
              z.z * Math.abs(r1.z),
            j = I.dot(r1),
            G = R.dot(r1),
            q = B.dot(r1);
          if (Math.max(-Math.max(j, G, q), Math.min(j, G, q)) > V) return !1;
        }
        return !0;
      }
      var r2 = new rU(),
        r3 = new rF(),
        r4 = new rF(),
        r5 = class {
          constructor(_ = new rF(), I = -1) {
            (this.center = _), (this.radius = I);
          }
          set(_, I) {
            return this.center.copy(_), (this.radius = I), this;
          }
          setFromPoints(_, I) {
            let R = this.center;
            void 0 !== I ? R.copy(I) : r2.setFromPoints(_).getCenter(R);
            let B = 0;
            for (let I = 0, z = _.length; I < z; I++)
              B = Math.max(B, R.distanceToSquared(_[I]));
            return (this.radius = Math.sqrt(B)), this;
          }
          copy(_) {
            return this.center.copy(_.center), (this.radius = _.radius), this;
          }
          isEmpty() {
            return this.radius < 0;
          }
          makeEmpty() {
            return this.center.set(0, 0, 0), (this.radius = -1), this;
          }
          containsPoint(_) {
            return (
              _.distanceToSquared(this.center) <= this.radius * this.radius
            );
          }
          distanceToPoint(_) {
            return _.distanceTo(this.center) - this.radius;
          }
          intersectsSphere(_) {
            let I = this.radius + _.radius;
            return _.center.distanceToSquared(this.center) <= I * I;
          }
          intersectsBox(_) {
            return _.intersectsSphere(this);
          }
          intersectsPlane(_) {
            return Math.abs(_.distanceToPoint(this.center)) <= this.radius;
          }
          clampPoint(_, I) {
            let R = this.center.distanceToSquared(_);
            return (
              I.copy(_),
              R > this.radius * this.radius &&
                (I.sub(this.center).normalize(),
                I.multiplyScalar(this.radius).add(this.center)),
              I
            );
          }
          getBoundingBox(_) {
            return (
              this.isEmpty()
                ? _.makeEmpty()
                : (_.set(this.center, this.center),
                  _.expandByScalar(this.radius)),
              _
            );
          }
          applyMatrix4(_) {
            return (
              this.center.applyMatrix4(_),
              (this.radius = this.radius * _.getMaxScaleOnAxis()),
              this
            );
          }
          translate(_) {
            return this.center.add(_), this;
          }
          expandByPoint(_) {
            if (this.isEmpty())
              return this.center.copy(_), (this.radius = 0), this;
            r3.subVectors(_, this.center);
            let I = r3.lengthSq();
            if (I > this.radius * this.radius) {
              let _ = Math.sqrt(I),
                R = (_ - this.radius) * 0.5;
              this.center.addScaledVector(r3, R / _), (this.radius += R);
            }
            return this;
          }
          union(_) {
            return (
              _.isEmpty() ||
                (this.isEmpty()
                  ? this.copy(_)
                  : !0 === this.center.equals(_.center)
                  ? (this.radius = Math.max(this.radius, _.radius))
                  : (r4.subVectors(_.center, this.center).setLength(_.radius),
                    this.expandByPoint(r3.copy(_.center).add(r4)),
                    this.expandByPoint(r3.copy(_.center).sub(r4)))),
              this
            );
          }
          equals(_) {
            return _.center.equals(this.center) && _.radius === this.radius;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        },
        r6 = new rF(),
        r8 = new rF(),
        r9 = new rF(),
        r7 = new rF(),
        se = new rF(),
        si = new rF(),
        sr = new rF(),
        ss = class {
          constructor(_ = new rF(), I = new rF(0, 0, -1)) {
            (this.origin = _), (this.direction = I);
          }
          set(_, I) {
            return this.origin.copy(_), this.direction.copy(I), this;
          }
          copy(_) {
            return (
              this.origin.copy(_.origin), this.direction.copy(_.direction), this
            );
          }
          at(_, I) {
            return I.copy(this.direction).multiplyScalar(_).add(this.origin);
          }
          lookAt(_) {
            return this.direction.copy(_).sub(this.origin).normalize(), this;
          }
          recast(_) {
            return this.origin.copy(this.at(_, r6)), this;
          }
          closestPointToPoint(_, I) {
            I.subVectors(_, this.origin);
            let R = I.dot(this.direction);
            return R < 0
              ? I.copy(this.origin)
              : I.copy(this.direction).multiplyScalar(R).add(this.origin);
          }
          distanceToPoint(_) {
            return Math.sqrt(this.distanceSqToPoint(_));
          }
          distanceSqToPoint(_) {
            let I = r6.subVectors(_, this.origin).dot(this.direction);
            return I < 0
              ? this.origin.distanceToSquared(_)
              : (r6.copy(this.direction).multiplyScalar(I).add(this.origin),
                r6.distanceToSquared(_));
          }
          distanceSqToSegment(_, I, R, B) {
            r8.copy(_).add(I).multiplyScalar(0.5),
              r9.copy(I).sub(_).normalize(),
              r7.copy(this.origin).sub(r8);
            let z = 0.5 * _.distanceTo(I),
              k = -this.direction.dot(r9),
              V = r7.dot(this.direction),
              j = -r7.dot(r9),
              G = r7.lengthSq(),
              q = Math.abs(1 - k * k),
              X,
              Q,
              $,
              et;
            if (q > 0) {
              if (((X = k * j - V), (Q = k * V - j), (et = z * q), X >= 0)) {
                if (Q >= -et) {
                  if (Q <= et) {
                    let _ = 1 / q;
                    (X *= _),
                      (Q *= _),
                      ($ =
                        X * (X + k * Q + 2 * V) + Q * (k * X + Q + 2 * j) + G);
                  } else
                    $ =
                      -(X = Math.max(0, -(k * (Q = z) + V))) * X +
                      Q * (Q + 2 * j) +
                      G;
                } else
                  $ =
                    -(X = Math.max(0, -(k * (Q = -z) + V))) * X +
                    Q * (Q + 2 * j) +
                    G;
              } else
                Q <= -et
                  ? ((Q =
                      (X = Math.max(0, -(-k * z + V))) > 0
                        ? -z
                        : Math.min(Math.max(-z, -j), z)),
                    ($ = -X * X + Q * (Q + 2 * j) + G))
                  : Q <= et
                  ? ((X = 0),
                    ($ = (Q = Math.min(Math.max(-z, -j), z)) * (Q + 2 * j) + G))
                  : ((Q =
                      (X = Math.max(0, -(k * z + V))) > 0
                        ? z
                        : Math.min(Math.max(-z, -j), z)),
                    ($ = -X * X + Q * (Q + 2 * j) + G));
            } else
              (Q = k > 0 ? -z : z),
                ($ =
                  -(X = Math.max(0, -(k * Q + V))) * X + Q * (Q + 2 * j) + G);
            return (
              R && R.copy(this.direction).multiplyScalar(X).add(this.origin),
              B && B.copy(r9).multiplyScalar(Q).add(r8),
              $
            );
          }
          intersectSphere(_, I) {
            r6.subVectors(_.center, this.origin);
            let R = r6.dot(this.direction),
              B = r6.dot(r6) - R * R,
              z = _.radius * _.radius;
            if (B > z) return null;
            let k = Math.sqrt(z - B),
              V = R - k,
              j = R + k;
            return V < 0 && j < 0
              ? null
              : V < 0
              ? this.at(j, I)
              : this.at(V, I);
          }
          intersectsSphere(_) {
            return this.distanceSqToPoint(_.center) <= _.radius * _.radius;
          }
          distanceToPlane(_) {
            let I = _.normal.dot(this.direction);
            if (0 === I) return 0 === _.distanceToPoint(this.origin) ? 0 : null;
            let R = -(this.origin.dot(_.normal) + _.constant) / I;
            return R >= 0 ? R : null;
          }
          intersectPlane(_, I) {
            let R = this.distanceToPlane(_);
            return null === R ? null : this.at(R, I);
          }
          intersectsPlane(_) {
            let I = _.distanceToPoint(this.origin);
            return 0 === I || _.normal.dot(this.direction) * I < 0;
          }
          intersectBox(_, I) {
            let R,
              B,
              z,
              k,
              V,
              j,
              G = 1 / this.direction.x,
              q = 1 / this.direction.y,
              X = 1 / this.direction.z,
              Q = this.origin;
            return (
              G >= 0
                ? ((R = (_.min.x - Q.x) * G), (B = (_.max.x - Q.x) * G))
                : ((R = (_.max.x - Q.x) * G), (B = (_.min.x - Q.x) * G)),
              q >= 0
                ? ((z = (_.min.y - Q.y) * q), (k = (_.max.y - Q.y) * q))
                : ((z = (_.max.y - Q.y) * q), (k = (_.min.y - Q.y) * q)),
              R > k ||
              z > B ||
              ((z > R || isNaN(R)) && (R = z),
              (k < B || isNaN(B)) && (B = k),
              X >= 0
                ? ((V = (_.min.z - Q.z) * X), (j = (_.max.z - Q.z) * X))
                : ((V = (_.max.z - Q.z) * X), (j = (_.min.z - Q.z) * X)),
              R > j || V > B) ||
              ((V > R || R != R) && (R = V),
              (j < B || B != B) && (B = j),
              B < 0)
                ? null
                : this.at(R >= 0 ? R : B, I)
            );
          }
          intersectsBox(_) {
            return null !== this.intersectBox(_, r6);
          }
          intersectTriangle(_, I, R, B, z) {
            se.subVectors(I, _), si.subVectors(R, _), sr.crossVectors(se, si);
            let k = this.direction.dot(sr),
              V;
            if (k > 0) {
              if (B) return null;
              V = 1;
            } else {
              if (!(k < 0)) return null;
              (V = -1), (k = -k);
            }
            r7.subVectors(this.origin, _);
            let j = V * this.direction.dot(si.crossVectors(r7, si));
            if (j < 0) return null;
            let G = V * this.direction.dot(se.cross(r7));
            if (G < 0 || j + G > k) return null;
            let q = -V * r7.dot(sr);
            return q < 0 ? null : this.at(q / k, z);
          }
          applyMatrix4(_) {
            return (
              this.origin.applyMatrix4(_),
              this.direction.transformDirection(_),
              this
            );
          }
          equals(_) {
            return (
              _.origin.equals(this.origin) && _.direction.equals(this.direction)
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
        },
        sa = class {
          constructor() {
            (sa.prototype.isMatrix4 = !0),
              (this.elements = [
                1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
              ]);
          }
          set(_, I, R, B, z, k, V, j, G, q, X, Q, $, et, er, es) {
            let ea = this.elements;
            return (
              (ea[0] = _),
              (ea[4] = I),
              (ea[8] = R),
              (ea[12] = B),
              (ea[1] = z),
              (ea[5] = k),
              (ea[9] = V),
              (ea[13] = j),
              (ea[2] = G),
              (ea[6] = q),
              (ea[10] = X),
              (ea[14] = Q),
              (ea[3] = $),
              (ea[7] = et),
              (ea[11] = er),
              (ea[15] = es),
              this
            );
          }
          identity() {
            return (
              this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            );
          }
          clone() {
            return new sa().fromArray(this.elements);
          }
          copy(_) {
            let I = this.elements,
              R = _.elements;
            return (
              (I[0] = R[0]),
              (I[1] = R[1]),
              (I[2] = R[2]),
              (I[3] = R[3]),
              (I[4] = R[4]),
              (I[5] = R[5]),
              (I[6] = R[6]),
              (I[7] = R[7]),
              (I[8] = R[8]),
              (I[9] = R[9]),
              (I[10] = R[10]),
              (I[11] = R[11]),
              (I[12] = R[12]),
              (I[13] = R[13]),
              (I[14] = R[14]),
              (I[15] = R[15]),
              this
            );
          }
          copyPosition(_) {
            let I = this.elements,
              R = _.elements;
            return (I[12] = R[12]), (I[13] = R[13]), (I[14] = R[14]), this;
          }
          setFromMatrix3(_) {
            let I = _.elements;
            return (
              this.set(
                I[0],
                I[3],
                I[6],
                0,
                I[1],
                I[4],
                I[7],
                0,
                I[2],
                I[5],
                I[8],
                0,
                0,
                0,
                0,
                1
              ),
              this
            );
          }
          extractBasis(_, I, R) {
            return (
              _.setFromMatrixColumn(this, 0),
              I.setFromMatrixColumn(this, 1),
              R.setFromMatrixColumn(this, 2),
              this
            );
          }
          makeBasis(_, I, R) {
            return (
              this.set(
                _.x,
                I.x,
                R.x,
                0,
                _.y,
                I.y,
                R.y,
                0,
                _.z,
                I.z,
                R.z,
                0,
                0,
                0,
                0,
                1
              ),
              this
            );
          }
          extractRotation(_) {
            let I = this.elements,
              R = _.elements,
              B = 1 / sn.setFromMatrixColumn(_, 0).length(),
              z = 1 / sn.setFromMatrixColumn(_, 1).length(),
              k = 1 / sn.setFromMatrixColumn(_, 2).length();
            return (
              (I[0] = R[0] * B),
              (I[1] = R[1] * B),
              (I[2] = R[2] * B),
              (I[3] = 0),
              (I[4] = R[4] * z),
              (I[5] = R[5] * z),
              (I[6] = R[6] * z),
              (I[7] = 0),
              (I[8] = R[8] * k),
              (I[9] = R[9] * k),
              (I[10] = R[10] * k),
              (I[11] = 0),
              (I[12] = 0),
              (I[13] = 0),
              (I[14] = 0),
              (I[15] = 1),
              this
            );
          }
          makeRotationFromEuler(_) {
            let I = this.elements,
              R = _.x,
              B = _.y,
              z = _.z,
              k = Math.cos(R),
              V = Math.sin(R),
              j = Math.cos(B),
              G = Math.sin(B),
              q = Math.cos(z),
              X = Math.sin(z);
            if ("XYZ" === _.order) {
              let _ = k * q,
                R = k * X,
                B = V * q,
                z = V * X;
              (I[0] = j * q),
                (I[4] = -j * X),
                (I[8] = G),
                (I[1] = R + B * G),
                (I[5] = _ - z * G),
                (I[9] = -V * j),
                (I[2] = z - _ * G),
                (I[6] = B + R * G),
                (I[10] = k * j);
            } else if ("YXZ" === _.order) {
              let _ = j * q,
                R = j * X,
                B = G * q,
                z = G * X;
              (I[0] = _ + z * V),
                (I[4] = B * V - R),
                (I[8] = k * G),
                (I[1] = k * X),
                (I[5] = k * q),
                (I[9] = -V),
                (I[2] = R * V - B),
                (I[6] = z + _ * V),
                (I[10] = k * j);
            } else if ("ZXY" === _.order) {
              let _ = j * q,
                R = j * X,
                B = G * q,
                z = G * X;
              (I[0] = _ - z * V),
                (I[4] = -k * X),
                (I[8] = B + R * V),
                (I[1] = R + B * V),
                (I[5] = k * q),
                (I[9] = z - _ * V),
                (I[2] = -k * G),
                (I[6] = V),
                (I[10] = k * j);
            } else if ("ZYX" === _.order) {
              let _ = k * q,
                R = k * X,
                B = V * q,
                z = V * X;
              (I[0] = j * q),
                (I[4] = B * G - R),
                (I[8] = _ * G + z),
                (I[1] = j * X),
                (I[5] = z * G + _),
                (I[9] = R * G - B),
                (I[2] = -G),
                (I[6] = V * j),
                (I[10] = k * j);
            } else if ("YZX" === _.order) {
              let _ = k * j,
                R = k * G,
                B = V * j,
                z = V * G;
              (I[0] = j * q),
                (I[4] = z - _ * X),
                (I[8] = B * X + R),
                (I[1] = X),
                (I[5] = k * q),
                (I[9] = -V * q),
                (I[2] = -G * q),
                (I[6] = R * X + B),
                (I[10] = _ - z * X);
            } else if ("XZY" === _.order) {
              let _ = k * j,
                R = k * G,
                B = V * j,
                z = V * G;
              (I[0] = j * q),
                (I[4] = -X),
                (I[8] = G * q),
                (I[1] = _ * X + z),
                (I[5] = k * q),
                (I[9] = R * X - B),
                (I[2] = B * X - R),
                (I[6] = V * q),
                (I[10] = z * X + _);
            }
            return (
              (I[3] = 0),
              (I[7] = 0),
              (I[11] = 0),
              (I[12] = 0),
              (I[13] = 0),
              (I[14] = 0),
              (I[15] = 1),
              this
            );
          }
          makeRotationFromQuaternion(_) {
            return this.compose(sl, _, sh);
          }
          lookAt(_, I, R) {
            let B = this.elements;
            return (
              su.subVectors(_, I),
              0 === su.lengthSq() && (su.z = 1),
              su.normalize(),
              sc.crossVectors(R, su),
              0 === sc.lengthSq() &&
                (1 === Math.abs(R.z) ? (su.x += 1e-4) : (su.z += 1e-4),
                su.normalize(),
                sc.crossVectors(R, su)),
              sc.normalize(),
              sd.crossVectors(su, sc),
              (B[0] = sc.x),
              (B[4] = sd.x),
              (B[8] = su.x),
              (B[1] = sc.y),
              (B[5] = sd.y),
              (B[9] = su.y),
              (B[2] = sc.z),
              (B[6] = sd.z),
              (B[10] = su.z),
              this
            );
          }
          multiply(_) {
            return this.multiplyMatrices(this, _);
          }
          premultiply(_) {
            return this.multiplyMatrices(_, this);
          }
          multiplyMatrices(_, I) {
            let R = _.elements,
              B = I.elements,
              z = this.elements,
              k = R[0],
              V = R[4],
              j = R[8],
              G = R[12],
              q = R[1],
              X = R[5],
              Q = R[9],
              $ = R[13],
              et = R[2],
              er = R[6],
              es = R[10],
              ea = R[14],
              en = R[3],
              eo = R[7],
              el = R[11],
              eh = R[15],
              ec = B[0],
              ed = B[4],
              ep = B[8],
              ef = B[12],
              em = B[1],
              ey = B[5],
              ex = B[9],
              eb = B[13],
              ew = B[2],
              e_ = B[6],
              eS = B[10],
              eA = B[14],
              eC = B[3],
              eT = B[7],
              eP = B[11],
              eI = B[15];
            return (
              (z[0] = k * ec + V * em + j * ew + G * eC),
              (z[4] = k * ed + V * ey + j * e_ + G * eT),
              (z[8] = k * ep + V * ex + j * eS + G * eP),
              (z[12] = k * ef + V * eb + j * eA + G * eI),
              (z[1] = q * ec + X * em + Q * ew + $ * eC),
              (z[5] = q * ed + X * ey + Q * e_ + $ * eT),
              (z[9] = q * ep + X * ex + Q * eS + $ * eP),
              (z[13] = q * ef + X * eb + Q * eA + $ * eI),
              (z[2] = et * ec + er * em + es * ew + ea * eC),
              (z[6] = et * ed + er * ey + es * e_ + ea * eT),
              (z[10] = et * ep + er * ex + es * eS + ea * eP),
              (z[14] = et * ef + er * eb + es * eA + ea * eI),
              (z[3] = en * ec + eo * em + el * ew + eh * eC),
              (z[7] = en * ed + eo * ey + el * e_ + eh * eT),
              (z[11] = en * ep + eo * ex + el * eS + eh * eP),
              (z[15] = en * ef + eo * eb + el * eA + eh * eI),
              this
            );
          }
          multiplyScalar(_) {
            let I = this.elements;
            return (
              (I[0] *= _),
              (I[4] *= _),
              (I[8] *= _),
              (I[12] *= _),
              (I[1] *= _),
              (I[5] *= _),
              (I[9] *= _),
              (I[13] *= _),
              (I[2] *= _),
              (I[6] *= _),
              (I[10] *= _),
              (I[14] *= _),
              (I[3] *= _),
              (I[7] *= _),
              (I[11] *= _),
              (I[15] *= _),
              this
            );
          }
          determinant() {
            let _ = this.elements,
              I = _[0],
              R = _[4],
              B = _[8],
              z = _[12],
              k = _[1],
              V = _[5],
              j = _[9],
              G = _[13],
              q = _[2],
              X = _[6],
              Q = _[10],
              $ = _[14];
            return (
              _[3] *
                (+z * j * X -
                  B * G * X -
                  z * V * Q +
                  R * G * Q +
                  B * V * $ -
                  R * j * $) +
              _[7] *
                (+I * j * $ -
                  I * G * Q +
                  z * k * Q -
                  B * k * $ +
                  B * G * q -
                  z * j * q) +
              _[11] *
                (+I * G * X -
                  I * V * $ -
                  z * k * X +
                  R * k * $ +
                  z * V * q -
                  R * G * q) +
              _[15] *
                (-B * V * q -
                  I * j * X +
                  I * V * Q +
                  B * k * X -
                  R * k * Q +
                  R * j * q)
            );
          }
          transpose() {
            let _ = this.elements,
              I;
            return (
              (I = _[1]),
              (_[1] = _[4]),
              (_[4] = I),
              (I = _[2]),
              (_[2] = _[8]),
              (_[8] = I),
              (I = _[6]),
              (_[6] = _[9]),
              (_[9] = I),
              (I = _[3]),
              (_[3] = _[12]),
              (_[12] = I),
              (I = _[7]),
              (_[7] = _[13]),
              (_[13] = I),
              (I = _[11]),
              (_[11] = _[14]),
              (_[14] = I),
              this
            );
          }
          setPosition(_, I, R) {
            let B = this.elements;
            return (
              _.isVector3
                ? ((B[12] = _.x), (B[13] = _.y), (B[14] = _.z))
                : ((B[12] = _), (B[13] = I), (B[14] = R)),
              this
            );
          }
          invert() {
            let _ = this.elements,
              I = _[0],
              R = _[1],
              B = _[2],
              z = _[3],
              k = _[4],
              V = _[5],
              j = _[6],
              G = _[7],
              q = _[8],
              X = _[9],
              Q = _[10],
              $ = _[11],
              et = _[12],
              er = _[13],
              es = _[14],
              ea = _[15],
              en =
                X * es * G -
                er * Q * G +
                er * j * $ -
                V * es * $ -
                X * j * ea +
                V * Q * ea,
              eo =
                et * Q * G -
                q * es * G -
                et * j * $ +
                k * es * $ +
                q * j * ea -
                k * Q * ea,
              el =
                q * er * G -
                et * X * G +
                et * V * $ -
                k * er * $ -
                q * V * ea +
                k * X * ea,
              eh =
                et * X * j -
                q * er * j -
                et * V * Q +
                k * er * Q +
                q * V * es -
                k * X * es,
              ec = I * en + R * eo + B * el + z * eh;
            if (0 === ec)
              return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            let ed = 1 / ec;
            return (
              (_[0] = en * ed),
              (_[1] =
                (er * Q * z -
                  X * es * z -
                  er * B * $ +
                  R * es * $ +
                  X * B * ea -
                  R * Q * ea) *
                ed),
              (_[2] =
                (V * es * z -
                  er * j * z +
                  er * B * G -
                  R * es * G -
                  V * B * ea +
                  R * j * ea) *
                ed),
              (_[3] =
                (X * j * z -
                  V * Q * z -
                  X * B * G +
                  R * Q * G +
                  V * B * $ -
                  R * j * $) *
                ed),
              (_[4] = eo * ed),
              (_[5] =
                (q * es * z -
                  et * Q * z +
                  et * B * $ -
                  I * es * $ -
                  q * B * ea +
                  I * Q * ea) *
                ed),
              (_[6] =
                (et * j * z -
                  k * es * z -
                  et * B * G +
                  I * es * G +
                  k * B * ea -
                  I * j * ea) *
                ed),
              (_[7] =
                (k * Q * z -
                  q * j * z +
                  q * B * G -
                  I * Q * G -
                  k * B * $ +
                  I * j * $) *
                ed),
              (_[8] = el * ed),
              (_[9] =
                (et * X * z -
                  q * er * z -
                  et * R * $ +
                  I * er * $ +
                  q * R * ea -
                  I * X * ea) *
                ed),
              (_[10] =
                (k * er * z -
                  et * V * z +
                  et * R * G -
                  I * er * G -
                  k * R * ea +
                  I * V * ea) *
                ed),
              (_[11] =
                (q * V * z -
                  k * X * z -
                  q * R * G +
                  I * X * G +
                  k * R * $ -
                  I * V * $) *
                ed),
              (_[12] = eh * ed),
              (_[13] =
                (q * er * B -
                  et * X * B +
                  et * R * Q -
                  I * er * Q -
                  q * R * es +
                  I * X * es) *
                ed),
              (_[14] =
                (et * V * B -
                  k * er * B -
                  et * R * j +
                  I * er * j +
                  k * R * es -
                  I * V * es) *
                ed),
              (_[15] =
                (k * X * B -
                  q * V * B +
                  q * R * j -
                  I * X * j -
                  k * R * Q +
                  I * V * Q) *
                ed),
              this
            );
          }
          scale(_) {
            let I = this.elements,
              R = _.x,
              B = _.y,
              z = _.z;
            return (
              (I[0] *= R),
              (I[4] *= B),
              (I[8] *= z),
              (I[1] *= R),
              (I[5] *= B),
              (I[9] *= z),
              (I[2] *= R),
              (I[6] *= B),
              (I[10] *= z),
              (I[3] *= R),
              (I[7] *= B),
              (I[11] *= z),
              this
            );
          }
          getMaxScaleOnAxis() {
            let _ = this.elements;
            return Math.sqrt(
              Math.max(
                _[0] * _[0] + _[1] * _[1] + _[2] * _[2],
                _[4] * _[4] + _[5] * _[5] + _[6] * _[6],
                _[8] * _[8] + _[9] * _[9] + _[10] * _[10]
              )
            );
          }
          makeTranslation(_, I, R) {
            return (
              this.set(1, 0, 0, _, 0, 1, 0, I, 0, 0, 1, R, 0, 0, 0, 1), this
            );
          }
          makeRotationX(_) {
            let I = Math.cos(_),
              R = Math.sin(_);
            return (
              this.set(1, 0, 0, 0, 0, I, -R, 0, 0, R, I, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationY(_) {
            let I = Math.cos(_),
              R = Math.sin(_);
            return (
              this.set(I, 0, R, 0, 0, 1, 0, 0, -R, 0, I, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationZ(_) {
            let I = Math.cos(_),
              R = Math.sin(_);
            return (
              this.set(I, -R, 0, 0, R, I, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationAxis(_, I) {
            let R = Math.cos(I),
              B = Math.sin(I),
              z = 1 - R,
              k = _.x,
              V = _.y,
              j = _.z,
              G = z * k,
              q = z * V;
            return (
              this.set(
                G * k + R,
                G * V - B * j,
                G * j + B * V,
                0,
                G * V + B * j,
                q * V + R,
                q * j - B * k,
                0,
                G * j - B * V,
                q * j + B * k,
                z * j * j + R,
                0,
                0,
                0,
                0,
                1
              ),
              this
            );
          }
          makeScale(_, I, R) {
            return (
              this.set(_, 0, 0, 0, 0, I, 0, 0, 0, 0, R, 0, 0, 0, 0, 1), this
            );
          }
          makeShear(_, I, R, B, z, k) {
            return (
              this.set(1, R, z, 0, _, 1, k, 0, I, B, 1, 0, 0, 0, 0, 1), this
            );
          }
          compose(_, I, R) {
            let B = this.elements,
              z = I._x,
              k = I._y,
              V = I._z,
              j = I._w,
              G = z + z,
              q = k + k,
              X = V + V,
              Q = z * G,
              $ = z * q,
              et = z * X,
              er = k * q,
              es = k * X,
              ea = V * X,
              en = j * G,
              eo = j * q,
              el = j * X,
              eh = R.x,
              ec = R.y,
              ed = R.z;
            return (
              (B[0] = (1 - (er + ea)) * eh),
              (B[1] = ($ + el) * eh),
              (B[2] = (et - eo) * eh),
              (B[3] = 0),
              (B[4] = ($ - el) * ec),
              (B[5] = (1 - (Q + ea)) * ec),
              (B[6] = (es + en) * ec),
              (B[7] = 0),
              (B[8] = (et + eo) * ed),
              (B[9] = (es - en) * ed),
              (B[10] = (1 - (Q + er)) * ed),
              (B[11] = 0),
              (B[12] = _.x),
              (B[13] = _.y),
              (B[14] = _.z),
              (B[15] = 1),
              this
            );
          }
          decompose(_, I, R) {
            let B = this.elements,
              z = sn.set(B[0], B[1], B[2]).length(),
              k = sn.set(B[4], B[5], B[6]).length(),
              V = sn.set(B[8], B[9], B[10]).length();
            0 > this.determinant() && (z = -z),
              (_.x = B[12]),
              (_.y = B[13]),
              (_.z = B[14]),
              so.copy(this);
            let j = 1 / z,
              G = 1 / k,
              q = 1 / V;
            return (
              (so.elements[0] *= j),
              (so.elements[1] *= j),
              (so.elements[2] *= j),
              (so.elements[4] *= G),
              (so.elements[5] *= G),
              (so.elements[6] *= G),
              (so.elements[8] *= q),
              (so.elements[9] *= q),
              (so.elements[10] *= q),
              I.setFromRotationMatrix(so),
              (R.x = z),
              (R.y = k),
              (R.z = V),
              this
            );
          }
          makePerspective(_, I, R, B, z, k) {
            let V = this.elements;
            return (
              (V[0] = (2 * z) / (I - _)),
              (V[4] = 0),
              (V[8] = (I + _) / (I - _)),
              (V[12] = 0),
              (V[1] = 0),
              (V[5] = (2 * z) / (R - B)),
              (V[9] = (R + B) / (R - B)),
              (V[13] = 0),
              (V[2] = 0),
              (V[6] = 0),
              (V[10] = -(k + z) / (k - z)),
              (V[14] = (-2 * k * z) / (k - z)),
              (V[3] = 0),
              (V[7] = 0),
              (V[11] = -1),
              (V[15] = 0),
              this
            );
          }
          makeOrthographic(_, I, R, B, z, k) {
            let V = this.elements,
              j = 1 / (I - _),
              G = 1 / (R - B),
              q = 1 / (k - z);
            return (
              (V[0] = 2 * j),
              (V[4] = 0),
              (V[8] = 0),
              (V[12] = -((I + _) * j)),
              (V[1] = 0),
              (V[5] = 2 * G),
              (V[9] = 0),
              (V[13] = -((R + B) * G)),
              (V[2] = 0),
              (V[6] = 0),
              (V[10] = -2 * q),
              (V[14] = -((k + z) * q)),
              (V[3] = 0),
              (V[7] = 0),
              (V[11] = 0),
              (V[15] = 1),
              this
            );
          }
          equals(_) {
            let I = this.elements,
              R = _.elements;
            for (let _ = 0; _ < 16; _++) if (I[_] !== R[_]) return !1;
            return !0;
          }
          fromArray(_, I = 0) {
            for (let R = 0; R < 16; R++) this.elements[R] = _[R + I];
            return this;
          }
          toArray(_ = [], I = 0) {
            let R = this.elements;
            return (
              (_[I] = R[0]),
              (_[I + 1] = R[1]),
              (_[I + 2] = R[2]),
              (_[I + 3] = R[3]),
              (_[I + 4] = R[4]),
              (_[I + 5] = R[5]),
              (_[I + 6] = R[6]),
              (_[I + 7] = R[7]),
              (_[I + 8] = R[8]),
              (_[I + 9] = R[9]),
              (_[I + 10] = R[10]),
              (_[I + 11] = R[11]),
              (_[I + 12] = R[12]),
              (_[I + 13] = R[13]),
              (_[I + 14] = R[14]),
              (_[I + 15] = R[15]),
              _
            );
          }
        },
        sn = new rF(),
        so = new sa(),
        sl = new rF(0, 0, 0),
        sh = new rF(1, 1, 1),
        sc = new rF(),
        sd = new rF(),
        su = new rF(),
        sf = new sa(),
        sm = new rz(),
        sg = class {
          constructor(_ = 0, I = 0, R = 0, B = sg.DEFAULT_ORDER) {
            (this.isEuler = !0),
              (this._x = _),
              (this._y = I),
              (this._z = R),
              (this._order = B);
          }
          get x() {
            return this._x;
          }
          set x(_) {
            (this._x = _), this._onChangeCallback();
          }
          get y() {
            return this._y;
          }
          set y(_) {
            (this._y = _), this._onChangeCallback();
          }
          get z() {
            return this._z;
          }
          set z(_) {
            (this._z = _), this._onChangeCallback();
          }
          get order() {
            return this._order;
          }
          set order(_) {
            (this._order = _), this._onChangeCallback();
          }
          set(_, I, R, B = this._order) {
            return (
              (this._x = _),
              (this._y = I),
              (this._z = R),
              (this._order = B),
              this._onChangeCallback(),
              this
            );
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._order);
          }
          copy(_) {
            return (
              (this._x = _._x),
              (this._y = _._y),
              (this._z = _._z),
              (this._order = _._order),
              this._onChangeCallback(),
              this
            );
          }
          setFromRotationMatrix(_, I = this._order, R = !0) {
            let B = _.elements,
              z = B[0],
              k = B[4],
              V = B[8],
              j = B[1],
              G = B[5],
              q = B[9],
              X = B[2],
              Q = B[6],
              $ = B[10];
            switch (I) {
              case "XYZ":
                (this._y = Math.asin(gi(V, -1, 1))),
                  0.9999999 > Math.abs(V)
                    ? ((this._x = Math.atan2(-q, $)),
                      (this._z = Math.atan2(-k, z)))
                    : ((this._x = Math.atan2(Q, G)), (this._z = 0));
                break;
              case "YXZ":
                (this._x = Math.asin(-gi(q, -1, 1))),
                  0.9999999 > Math.abs(q)
                    ? ((this._y = Math.atan2(V, $)),
                      (this._z = Math.atan2(j, G)))
                    : ((this._y = Math.atan2(-X, z)), (this._z = 0));
                break;
              case "ZXY":
                (this._x = Math.asin(gi(Q, -1, 1))),
                  0.9999999 > Math.abs(Q)
                    ? ((this._y = Math.atan2(-X, $)),
                      (this._z = Math.atan2(-k, G)))
                    : ((this._y = 0), (this._z = Math.atan2(j, z)));
                break;
              case "ZYX":
                (this._y = Math.asin(-gi(X, -1, 1))),
                  0.9999999 > Math.abs(X)
                    ? ((this._x = Math.atan2(Q, $)),
                      (this._z = Math.atan2(j, z)))
                    : ((this._x = 0), (this._z = Math.atan2(-k, G)));
                break;
              case "YZX":
                (this._z = Math.asin(gi(j, -1, 1))),
                  0.9999999 > Math.abs(j)
                    ? ((this._x = Math.atan2(-q, G)),
                      (this._y = Math.atan2(-X, z)))
                    : ((this._x = 0), (this._y = Math.atan2(V, $)));
                break;
              case "XZY":
                (this._z = Math.asin(-gi(k, -1, 1))),
                  0.9999999 > Math.abs(k)
                    ? ((this._x = Math.atan2(Q, G)),
                      (this._y = Math.atan2(V, z)))
                    : ((this._x = Math.atan2(-q, $)), (this._y = 0));
                break;
              default:
                console.warn(
                  "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                    I
                );
            }
            return (
              (this._order = I), !0 === R && this._onChangeCallback(), this
            );
          }
          setFromQuaternion(_, I, R) {
            return (
              sf.makeRotationFromQuaternion(_),
              this.setFromRotationMatrix(sf, I, R)
            );
          }
          setFromVector3(_, I = this._order) {
            return this.set(_.x, _.y, _.z, I);
          }
          reorder(_) {
            return sm.setFromEuler(this), this.setFromQuaternion(sm, _);
          }
          equals(_) {
            return (
              _._x === this._x &&
              _._y === this._y &&
              _._z === this._z &&
              _._order === this._order
            );
          }
          fromArray(_) {
            return (
              (this._x = _[0]),
              (this._y = _[1]),
              (this._z = _[2]),
              void 0 !== _[3] && (this._order = _[3]),
              this._onChangeCallback(),
              this
            );
          }
          toArray(_ = [], I = 0) {
            return (
              (_[I] = this._x),
              (_[I + 1] = this._y),
              (_[I + 2] = this._z),
              (_[I + 3] = this._order),
              _
            );
          }
          _onChange(_) {
            return (this._onChangeCallback = _), this;
          }
          _onChangeCallback() {}
          *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._order;
          }
        };
      sg.DEFAULT_ORDER = "XYZ";
      var sv = class {
          constructor() {
            this.mask = 1;
          }
          set(_) {
            this.mask = ((1 << _) | 0) >>> 0;
          }
          enable(_) {
            this.mask |= (1 << _) | 0;
          }
          enableAll() {
            this.mask = -1;
          }
          toggle(_) {
            this.mask ^= (1 << _) | 0;
          }
          disable(_) {
            this.mask &= ~((1 << _) | 0);
          }
          disableAll() {
            this.mask = 0;
          }
          test(_) {
            return (this.mask & _.mask) != 0;
          }
          isEnabled(_) {
            return (this.mask & ((1 << _) | 0)) != 0;
          }
        },
        sx = 0,
        sb = new rF(),
        sw = new rz(),
        s_ = new sa(),
        sS = new rF(),
        sM = new rF(),
        sT = new rF(),
        sP = new rz(),
        sD = new rF(1, 0, 0),
        sO = new rF(0, 1, 0),
        sI = new rF(0, 0, 1),
        sR = { type: "added" },
        sB = { type: "removed" },
        sL = class extends i8 {
          constructor() {
            super(),
              (this.isObject3D = !0),
              Object.defineProperty(this, "id", { value: sx++ }),
              (this.uuid = ms()),
              (this.name = ""),
              (this.type = "Object3D"),
              (this.parent = null),
              (this.children = []),
              (this.up = sL.DEFAULT_UP.clone());
            let _ = new rF(),
              I = new sg(),
              R = new rz(),
              B = new rF(1, 1, 1);
            I._onChange(function () {
              R.setFromEuler(I, !1);
            }),
              R._onChange(function () {
                I.setFromQuaternion(R, void 0, !1);
              }),
              Object.defineProperties(this, {
                position: { configurable: !0, enumerable: !0, value: _ },
                rotation: { configurable: !0, enumerable: !0, value: I },
                quaternion: { configurable: !0, enumerable: !0, value: R },
                scale: { configurable: !0, enumerable: !0, value: B },
                modelViewMatrix: { value: new sa() },
                normalMatrix: { value: new ro() },
              }),
              (this.matrix = new sa()),
              (this.matrixWorld = new sa()),
              (this.matrixAutoUpdate = sL.DEFAULT_MATRIX_AUTO_UPDATE),
              (this.matrixWorldNeedsUpdate = !1),
              (this.matrixWorldAutoUpdate =
                sL.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
              (this.layers = new sv()),
              (this.visible = !0),
              (this.castShadow = !1),
              (this.receiveShadow = !1),
              (this.frustumCulled = !0),
              (this.renderOrder = 0),
              (this.animations = []),
              (this.userData = {});
          }
          onBeforeRender() {}
          onAfterRender() {}
          applyMatrix4(_) {
            this.matrixAutoUpdate && this.updateMatrix(),
              this.matrix.premultiply(_),
              this.matrix.decompose(this.position, this.quaternion, this.scale);
          }
          applyQuaternion(_) {
            return this.quaternion.premultiply(_), this;
          }
          setRotationFromAxisAngle(_, I) {
            this.quaternion.setFromAxisAngle(_, I);
          }
          setRotationFromEuler(_) {
            this.quaternion.setFromEuler(_, !0);
          }
          setRotationFromMatrix(_) {
            this.quaternion.setFromRotationMatrix(_);
          }
          setRotationFromQuaternion(_) {
            this.quaternion.copy(_);
          }
          rotateOnAxis(_, I) {
            return (
              sw.setFromAxisAngle(_, I), this.quaternion.multiply(sw), this
            );
          }
          rotateOnWorldAxis(_, I) {
            return (
              sw.setFromAxisAngle(_, I), this.quaternion.premultiply(sw), this
            );
          }
          rotateX(_) {
            return this.rotateOnAxis(sD, _);
          }
          rotateY(_) {
            return this.rotateOnAxis(sO, _);
          }
          rotateZ(_) {
            return this.rotateOnAxis(sI, _);
          }
          translateOnAxis(_, I) {
            return (
              sb.copy(_).applyQuaternion(this.quaternion),
              this.position.add(sb.multiplyScalar(I)),
              this
            );
          }
          translateX(_) {
            return this.translateOnAxis(sD, _);
          }
          translateY(_) {
            return this.translateOnAxis(sO, _);
          }
          translateZ(_) {
            return this.translateOnAxis(sI, _);
          }
          localToWorld(_) {
            return (
              this.updateWorldMatrix(!0, !1), _.applyMatrix4(this.matrixWorld)
            );
          }
          worldToLocal(_) {
            return (
              this.updateWorldMatrix(!0, !1),
              _.applyMatrix4(s_.copy(this.matrixWorld).invert())
            );
          }
          lookAt(_, I, R) {
            _.isVector3 ? sS.copy(_) : sS.set(_, I, R);
            let B = this.parent;
            this.updateWorldMatrix(!0, !1),
              sM.setFromMatrixPosition(this.matrixWorld),
              this.isCamera || this.isLight
                ? s_.lookAt(sM, sS, this.up)
                : s_.lookAt(sS, sM, this.up),
              this.quaternion.setFromRotationMatrix(s_),
              B &&
                (s_.extractRotation(B.matrixWorld),
                sw.setFromRotationMatrix(s_),
                this.quaternion.premultiply(sw.invert()));
          }
          add(_) {
            if (arguments.length > 1) {
              for (let _ = 0; _ < arguments.length; _++) this.add(arguments[_]);
              return this;
            }
            return (
              _ === this
                ? console.error(
                    "THREE.Object3D.add: object can't be added as a child of itself.",
                    _
                  )
                : _ && _.isObject3D
                ? (null !== _.parent && _.parent.remove(_),
                  (_.parent = this),
                  this.children.push(_),
                  _.dispatchEvent(sR))
                : console.error(
                    "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                    _
                  ),
              this
            );
          }
          remove(_) {
            if (arguments.length > 1) {
              for (let _ = 0; _ < arguments.length; _++)
                this.remove(arguments[_]);
              return this;
            }
            let I = this.children.indexOf(_);
            return (
              -1 !== I &&
                ((_.parent = null),
                this.children.splice(I, 1),
                _.dispatchEvent(sB)),
              this
            );
          }
          removeFromParent() {
            let _ = this.parent;
            return null !== _ && _.remove(this), this;
          }
          clear() {
            for (let _ = 0; _ < this.children.length; _++) {
              let I = this.children[_];
              (I.parent = null), I.dispatchEvent(sB);
            }
            return (this.children.length = 0), this;
          }
          attach(_) {
            return (
              this.updateWorldMatrix(!0, !1),
              s_.copy(this.matrixWorld).invert(),
              null !== _.parent &&
                (_.parent.updateWorldMatrix(!0, !1),
                s_.multiply(_.parent.matrixWorld)),
              _.applyMatrix4(s_),
              this.add(_),
              _.updateWorldMatrix(!1, !0),
              this
            );
          }
          getObjectById(_) {
            return this.getObjectByProperty("id", _);
          }
          getObjectByName(_) {
            return this.getObjectByProperty("name", _);
          }
          getObjectByProperty(_, I) {
            if (this[_] === I) return this;
            for (let R = 0, B = this.children.length; R < B; R++) {
              let B = this.children[R].getObjectByProperty(_, I);
              if (void 0 !== B) return B;
            }
          }
          getObjectsByProperty(_, I) {
            let R = [];
            this[_] === I && R.push(this);
            for (let B = 0, z = this.children.length; B < z; B++) {
              let z = this.children[B].getObjectsByProperty(_, I);
              z.length > 0 && (R = R.concat(z));
            }
            return R;
          }
          getWorldPosition(_) {
            return (
              this.updateWorldMatrix(!0, !1),
              _.setFromMatrixPosition(this.matrixWorld)
            );
          }
          getWorldQuaternion(_) {
            return (
              this.updateWorldMatrix(!0, !1),
              this.matrixWorld.decompose(sM, _, sT),
              _
            );
          }
          getWorldScale(_) {
            return (
              this.updateWorldMatrix(!0, !1),
              this.matrixWorld.decompose(sM, sP, _),
              _
            );
          }
          getWorldDirection(_) {
            this.updateWorldMatrix(!0, !1);
            let I = this.matrixWorld.elements;
            return _.set(I[8], I[9], I[10]).normalize();
          }
          raycast() {}
          traverse(_) {
            _(this);
            let I = this.children;
            for (let R = 0, B = I.length; R < B; R++) I[R].traverse(_);
          }
          traverseVisible(_) {
            if (!1 === this.visible) return;
            _(this);
            let I = this.children;
            for (let R = 0, B = I.length; R < B; R++) I[R].traverseVisible(_);
          }
          traverseAncestors(_) {
            let I = this.parent;
            null !== I && (_(I), I.traverseAncestors(_));
          }
          updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
              (this.matrixWorldNeedsUpdate = !0);
          }
          updateMatrixWorld(_) {
            this.matrixAutoUpdate && this.updateMatrix(),
              (this.matrixWorldNeedsUpdate || _) &&
                (null === this.parent
                  ? this.matrixWorld.copy(this.matrix)
                  : this.matrixWorld.multiplyMatrices(
                      this.parent.matrixWorld,
                      this.matrix
                    ),
                (this.matrixWorldNeedsUpdate = !1),
                (_ = !0));
            let I = this.children;
            for (let R = 0, B = I.length; R < B; R++) {
              let B = I[R];
              (!0 === B.matrixWorldAutoUpdate || !0 === _) &&
                B.updateMatrixWorld(_);
            }
          }
          updateWorldMatrix(_, I) {
            let R = this.parent;
            if (
              (!0 === _ &&
                null !== R &&
                !0 === R.matrixWorldAutoUpdate &&
                R.updateWorldMatrix(!0, !1),
              this.matrixAutoUpdate && this.updateMatrix(),
              null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              !0 === I)
            ) {
              let _ = this.children;
              for (let I = 0, R = _.length; I < R; I++) {
                let R = _[I];
                !0 === R.matrixWorldAutoUpdate && R.updateWorldMatrix(!1, !0);
              }
            }
          }
          toJSON(_) {
            let I = void 0 === _ || "string" == typeof _,
              R = {};
            I &&
              ((_ = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
                nodes: {},
              }),
              (R.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON",
              }));
            let B = {};
            function s(I, R) {
              return void 0 === I[R.uuid] && (I[R.uuid] = R.toJSON(_)), R.uuid;
            }
            if (
              ((B.uuid = this.uuid),
              (B.type = this.type),
              "" !== this.name && (B.name = this.name),
              !0 === this.castShadow && (B.castShadow = !0),
              !0 === this.receiveShadow && (B.receiveShadow = !0),
              !1 === this.visible && (B.visible = !1),
              !1 === this.frustumCulled && (B.frustumCulled = !1),
              0 !== this.renderOrder && (B.renderOrder = this.renderOrder),
              Object.keys(this.userData).length > 0 &&
                (B.userData = this.userData),
              (B.layers = this.layers.mask),
              (B.matrix = this.matrix.toArray()),
              !1 === this.matrixAutoUpdate && (B.matrixAutoUpdate = !1),
              this.isInstancedMesh &&
                ((B.type = "InstancedMesh"),
                (B.count = this.count),
                (B.instanceMatrix = this.instanceMatrix.toJSON()),
                null !== this.instanceColor &&
                  (B.instanceColor = this.instanceColor.toJSON())),
              this.isScene)
            )
              this.background &&
                (this.background.isColor
                  ? (B.background = this.background.toJSON())
                  : this.background.isTexture &&
                    (B.background = this.background.toJSON(_).uuid)),
                this.environment &&
                  this.environment.isTexture &&
                  !0 !== this.environment.isRenderTargetTexture &&
                  (B.environment = this.environment.toJSON(_).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
              B.geometry = s(_.geometries, this.geometry);
              let I = this.geometry.parameters;
              if (void 0 !== I && void 0 !== I.shapes) {
                let R = I.shapes;
                if (Array.isArray(R))
                  for (let I = 0, B = R.length; I < B; I++) {
                    let B = R[I];
                    s(_.shapes, B);
                  }
                else s(_.shapes, R);
              }
            }
            if (
              (this.isSkinnedMesh &&
                ((B.bindMode = this.bindMode),
                (B.bindMatrix = this.bindMatrix.toArray()),
                void 0 !== this.skeleton &&
                  (s(_.skeletons, this.skeleton),
                  (B.skeleton = this.skeleton.uuid))),
              void 0 !== this.material)
            ) {
              if (Array.isArray(this.material)) {
                let I = [];
                for (let R = 0, B = this.material.length; R < B; R++)
                  I.push(s(_.materials, this.material[R]));
                B.material = I;
              } else B.material = s(_.materials, this.material);
            }
            if (this.children.length > 0) {
              B.children = [];
              for (let I = 0; I < this.children.length; I++)
                B.children.push(this.children[I].toJSON(_).object);
            }
            if (this.animations.length > 0) {
              B.animations = [];
              for (let I = 0; I < this.animations.length; I++) {
                let R = this.animations[I];
                B.animations.push(s(_.animations, R));
              }
            }
            if (I) {
              let I = o(_.geometries),
                B = o(_.materials),
                z = o(_.textures),
                k = o(_.images),
                V = o(_.shapes),
                j = o(_.skeletons),
                G = o(_.animations),
                q = o(_.nodes);
              I.length > 0 && (R.geometries = I),
                B.length > 0 && (R.materials = B),
                z.length > 0 && (R.textures = z),
                k.length > 0 && (R.images = k),
                V.length > 0 && (R.shapes = V),
                j.length > 0 && (R.skeletons = j),
                G.length > 0 && (R.animations = G),
                q.length > 0 && (R.nodes = q);
            }
            return (R.object = B), R;
            function o(_) {
              let I = [];
              for (let R in _) {
                let B = _[R];
                delete B.metadata, I.push(B);
              }
              return I;
            }
          }
          clone(_) {
            return new this.constructor().copy(this, _);
          }
          copy(_, I = !0) {
            if (
              ((this.name = _.name),
              this.up.copy(_.up),
              this.position.copy(_.position),
              (this.rotation.order = _.rotation.order),
              this.quaternion.copy(_.quaternion),
              this.scale.copy(_.scale),
              this.matrix.copy(_.matrix),
              this.matrixWorld.copy(_.matrixWorld),
              (this.matrixAutoUpdate = _.matrixAutoUpdate),
              (this.matrixWorldNeedsUpdate = _.matrixWorldNeedsUpdate),
              (this.matrixWorldAutoUpdate = _.matrixWorldAutoUpdate),
              (this.layers.mask = _.layers.mask),
              (this.visible = _.visible),
              (this.castShadow = _.castShadow),
              (this.receiveShadow = _.receiveShadow),
              (this.frustumCulled = _.frustumCulled),
              (this.renderOrder = _.renderOrder),
              (this.userData = JSON.parse(JSON.stringify(_.userData))),
              !0 === I)
            )
              for (let I = 0; I < _.children.length; I++) {
                let R = _.children[I];
                this.add(R.clone());
              }
            return this;
          }
        };
      (sL.DEFAULT_UP = new rF(0, 1, 0)),
        (sL.DEFAULT_MATRIX_AUTO_UPDATE = !0),
        (sL.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0);
      var sz = new rF(),
        sN = new rF(),
        sk = new rF(),
        sU = new rF(),
        sV = new rF(),
        sj = new rF(),
        sH = new rF(),
        sW = new rF(),
        sq = new rF(),
        sY = new rF(),
        sX = class {
          constructor(_ = new rF(), I = new rF(), R = new rF()) {
            (this.a = _), (this.b = I), (this.c = R);
          }
          static getNormal(_, I, R, B) {
            B.subVectors(R, I), sz.subVectors(_, I), B.cross(sz);
            let z = B.lengthSq();
            return z > 0 ? B.multiplyScalar(1 / Math.sqrt(z)) : B.set(0, 0, 0);
          }
          static getBarycoord(_, I, R, B, z) {
            sz.subVectors(B, I), sN.subVectors(R, I), sk.subVectors(_, I);
            let k = sz.dot(sz),
              V = sz.dot(sN),
              j = sz.dot(sk),
              G = sN.dot(sN),
              q = sN.dot(sk),
              X = k * G - V * V;
            if (0 === X) return z.set(-2, -1, -1);
            let Q = 1 / X,
              $ = (G * j - V * q) * Q,
              et = (k * q - V * j) * Q;
            return z.set(1 - $ - et, et, $);
          }
          static containsPoint(_, I, R, B) {
            return (
              this.getBarycoord(_, I, R, B, sU),
              sU.x >= 0 && sU.y >= 0 && sU.x + sU.y <= 1
            );
          }
          static getUV(_, I, R, B, z, k, V, j) {
            return (
              this.getBarycoord(_, I, R, B, sU),
              j.set(0, 0),
              j.addScaledVector(z, sU.x),
              j.addScaledVector(k, sU.y),
              j.addScaledVector(V, sU.z),
              j
            );
          }
          static isFrontFacing(_, I, R, B) {
            return (
              sz.subVectors(R, I), sN.subVectors(_, I), 0 > sz.cross(sN).dot(B)
            );
          }
          set(_, I, R) {
            return this.a.copy(_), this.b.copy(I), this.c.copy(R), this;
          }
          setFromPointsAndIndices(_, I, R, B) {
            return (
              this.a.copy(_[I]), this.b.copy(_[R]), this.c.copy(_[B]), this
            );
          }
          setFromAttributeAndIndices(_, I, R, B) {
            return (
              this.a.fromBufferAttribute(_, I),
              this.b.fromBufferAttribute(_, R),
              this.c.fromBufferAttribute(_, B),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(_) {
            return this.a.copy(_.a), this.b.copy(_.b), this.c.copy(_.c), this;
          }
          getArea() {
            return (
              sz.subVectors(this.c, this.b),
              sN.subVectors(this.a, this.b),
              0.5 * sz.cross(sN).length()
            );
          }
          getMidpoint(_) {
            return _.addVectors(this.a, this.b)
              .add(this.c)
              .multiplyScalar(1 / 3);
          }
          getNormal(_) {
            return sX.getNormal(this.a, this.b, this.c, _);
          }
          getPlane(_) {
            return _.setFromCoplanarPoints(this.a, this.b, this.c);
          }
          getBarycoord(_, I) {
            return sX.getBarycoord(_, this.a, this.b, this.c, I);
          }
          getUV(_, I, R, B, z) {
            return sX.getUV(_, this.a, this.b, this.c, I, R, B, z);
          }
          containsPoint(_) {
            return sX.containsPoint(_, this.a, this.b, this.c);
          }
          isFrontFacing(_) {
            return sX.isFrontFacing(this.a, this.b, this.c, _);
          }
          intersectsBox(_) {
            return _.intersectsTriangle(this);
          }
          closestPointToPoint(_, I) {
            let R = this.a,
              B = this.b,
              z = this.c,
              k,
              V;
            sV.subVectors(B, R), sj.subVectors(z, R), sW.subVectors(_, R);
            let j = sV.dot(sW),
              G = sj.dot(sW);
            if (j <= 0 && G <= 0) return I.copy(R);
            sq.subVectors(_, B);
            let q = sV.dot(sq),
              X = sj.dot(sq);
            if (q >= 0 && X <= q) return I.copy(B);
            let Q = j * X - q * G;
            if (Q <= 0 && j >= 0 && q <= 0)
              return (k = j / (j - q)), I.copy(R).addScaledVector(sV, k);
            sY.subVectors(_, z);
            let $ = sV.dot(sY),
              et = sj.dot(sY);
            if (et >= 0 && $ <= et) return I.copy(z);
            let er = $ * G - j * et;
            if (er <= 0 && G >= 0 && et <= 0)
              return (V = G / (G - et)), I.copy(R).addScaledVector(sj, V);
            let es = q * et - $ * X;
            if (es <= 0 && X - q >= 0 && $ - et >= 0)
              return (
                sH.subVectors(z, B),
                (V = (X - q) / (X - q + ($ - et))),
                I.copy(B).addScaledVector(sH, V)
              );
            let ea = 1 / (es + er + Q);
            return (
              (k = er * ea),
              (V = Q * ea),
              I.copy(R).addScaledVector(sV, k).addScaledVector(sj, V)
            );
          }
          equals(_) {
            return (
              _.a.equals(this.a) && _.b.equals(this.b) && _.c.equals(this.c)
            );
          }
        },
        sQ = 0,
        sZ = class extends i8 {
          constructor() {
            super(),
              (this.isMaterial = !0),
              Object.defineProperty(this, "id", { value: sQ++ }),
              (this.uuid = ms()),
              (this.name = ""),
              (this.type = "Material"),
              (this.blending = 1),
              (this.side = 0),
              (this.vertexColors = !1),
              (this.opacity = 1),
              (this.transparent = !1),
              (this.blendSrc = 204),
              (this.blendDst = 205),
              (this.blendEquation = 100),
              (this.blendSrcAlpha = null),
              (this.blendDstAlpha = null),
              (this.blendEquationAlpha = null),
              (this.depthFunc = 3),
              (this.depthTest = !0),
              (this.depthWrite = !0),
              (this.stencilWriteMask = 255),
              (this.stencilFunc = 519),
              (this.stencilRef = 0),
              (this.stencilFuncMask = 255),
              (this.stencilFail = 7680),
              (this.stencilZFail = 7680),
              (this.stencilZPass = 7680),
              (this.stencilWrite = !1),
              (this.clippingPlanes = null),
              (this.clipIntersection = !1),
              (this.clipShadows = !1),
              (this.shadowSide = null),
              (this.colorWrite = !0),
              (this.precision = null),
              (this.polygonOffset = !1),
              (this.polygonOffsetFactor = 0),
              (this.polygonOffsetUnits = 0),
              (this.dithering = !1),
              (this.alphaToCoverage = !1),
              (this.premultipliedAlpha = !1),
              (this.forceSinglePass = !1),
              (this.visible = !0),
              (this.toneMapped = !0),
              (this.userData = {}),
              (this.version = 0),
              (this._alphaTest = 0);
          }
          get alphaTest() {
            return this._alphaTest;
          }
          set alphaTest(_) {
            this._alphaTest > 0 != _ > 0 && this.version++,
              (this._alphaTest = _);
          }
          onBuild() {}
          onBeforeRender() {}
          onBeforeCompile() {}
          customProgramCacheKey() {
            return this.onBeforeCompile.toString();
          }
          setValues(_) {
            if (void 0 !== _)
              for (let I in _) {
                let R = _[I];
                if (void 0 === R) {
                  console.warn(
                    "THREE.Material: '" + I + "' parameter is undefined."
                  );
                  continue;
                }
                let B = this[I];
                if (void 0 === B) {
                  console.warn(
                    "THREE." +
                      this.type +
                      ": '" +
                      I +
                      "' is not a property of this material."
                  );
                  continue;
                }
                B && B.isColor
                  ? B.set(R)
                  : B && B.isVector3 && R && R.isVector3
                  ? B.copy(R)
                  : (this[I] = R);
              }
          }
          toJSON(_) {
            let I = void 0 === _ || "string" == typeof _;
            I && (_ = { textures: {}, images: {} });
            let R = {
              metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON",
              },
            };
            function i(_) {
              let I = [];
              for (let R in _) {
                let B = _[R];
                delete B.metadata, I.push(B);
              }
              return I;
            }
            if (
              ((R.uuid = this.uuid),
              (R.type = this.type),
              "" !== this.name && (R.name = this.name),
              this.color &&
                this.color.isColor &&
                (R.color = this.color.getHex()),
              void 0 !== this.roughness && (R.roughness = this.roughness),
              void 0 !== this.metalness && (R.metalness = this.metalness),
              void 0 !== this.sheen && (R.sheen = this.sheen),
              this.sheenColor &&
                this.sheenColor.isColor &&
                (R.sheenColor = this.sheenColor.getHex()),
              void 0 !== this.sheenRoughness &&
                (R.sheenRoughness = this.sheenRoughness),
              this.emissive &&
                this.emissive.isColor &&
                (R.emissive = this.emissive.getHex()),
              this.emissiveIntensity &&
                1 !== this.emissiveIntensity &&
                (R.emissiveIntensity = this.emissiveIntensity),
              this.specular &&
                this.specular.isColor &&
                (R.specular = this.specular.getHex()),
              void 0 !== this.specularIntensity &&
                (R.specularIntensity = this.specularIntensity),
              this.specularColor &&
                this.specularColor.isColor &&
                (R.specularColor = this.specularColor.getHex()),
              void 0 !== this.shininess && (R.shininess = this.shininess),
              void 0 !== this.clearcoat && (R.clearcoat = this.clearcoat),
              void 0 !== this.clearcoatRoughness &&
                (R.clearcoatRoughness = this.clearcoatRoughness),
              this.clearcoatMap &&
                this.clearcoatMap.isTexture &&
                (R.clearcoatMap = this.clearcoatMap.toJSON(_).uuid),
              this.clearcoatRoughnessMap &&
                this.clearcoatRoughnessMap.isTexture &&
                (R.clearcoatRoughnessMap =
                  this.clearcoatRoughnessMap.toJSON(_).uuid),
              this.clearcoatNormalMap &&
                this.clearcoatNormalMap.isTexture &&
                ((R.clearcoatNormalMap =
                  this.clearcoatNormalMap.toJSON(_).uuid),
                (R.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
              void 0 !== this.iridescence && (R.iridescence = this.iridescence),
              void 0 !== this.iridescenceIOR &&
                (R.iridescenceIOR = this.iridescenceIOR),
              void 0 !== this.iridescenceThicknessRange &&
                (R.iridescenceThicknessRange = this.iridescenceThicknessRange),
              this.iridescenceMap &&
                this.iridescenceMap.isTexture &&
                (R.iridescenceMap = this.iridescenceMap.toJSON(_).uuid),
              this.iridescenceThicknessMap &&
                this.iridescenceThicknessMap.isTexture &&
                (R.iridescenceThicknessMap =
                  this.iridescenceThicknessMap.toJSON(_).uuid),
              this.map &&
                this.map.isTexture &&
                (R.map = this.map.toJSON(_).uuid),
              this.matcap &&
                this.matcap.isTexture &&
                (R.matcap = this.matcap.toJSON(_).uuid),
              this.alphaMap &&
                this.alphaMap.isTexture &&
                (R.alphaMap = this.alphaMap.toJSON(_).uuid),
              this.lightMap &&
                this.lightMap.isTexture &&
                ((R.lightMap = this.lightMap.toJSON(_).uuid),
                (R.lightMapIntensity = this.lightMapIntensity)),
              this.aoMap &&
                this.aoMap.isTexture &&
                ((R.aoMap = this.aoMap.toJSON(_).uuid),
                (R.aoMapIntensity = this.aoMapIntensity)),
              this.bumpMap &&
                this.bumpMap.isTexture &&
                ((R.bumpMap = this.bumpMap.toJSON(_).uuid),
                (R.bumpScale = this.bumpScale)),
              this.normalMap &&
                this.normalMap.isTexture &&
                ((R.normalMap = this.normalMap.toJSON(_).uuid),
                (R.normalMapType = this.normalMapType),
                (R.normalScale = this.normalScale.toArray())),
              this.displacementMap &&
                this.displacementMap.isTexture &&
                ((R.displacementMap = this.displacementMap.toJSON(_).uuid),
                (R.displacementScale = this.displacementScale),
                (R.displacementBias = this.displacementBias)),
              this.roughnessMap &&
                this.roughnessMap.isTexture &&
                (R.roughnessMap = this.roughnessMap.toJSON(_).uuid),
              this.metalnessMap &&
                this.metalnessMap.isTexture &&
                (R.metalnessMap = this.metalnessMap.toJSON(_).uuid),
              this.emissiveMap &&
                this.emissiveMap.isTexture &&
                (R.emissiveMap = this.emissiveMap.toJSON(_).uuid),
              this.specularMap &&
                this.specularMap.isTexture &&
                (R.specularMap = this.specularMap.toJSON(_).uuid),
              this.specularIntensityMap &&
                this.specularIntensityMap.isTexture &&
                (R.specularIntensityMap =
                  this.specularIntensityMap.toJSON(_).uuid),
              this.specularColorMap &&
                this.specularColorMap.isTexture &&
                (R.specularColorMap = this.specularColorMap.toJSON(_).uuid),
              this.envMap &&
                this.envMap.isTexture &&
                ((R.envMap = this.envMap.toJSON(_).uuid),
                void 0 !== this.combine && (R.combine = this.combine)),
              void 0 !== this.envMapIntensity &&
                (R.envMapIntensity = this.envMapIntensity),
              void 0 !== this.reflectivity &&
                (R.reflectivity = this.reflectivity),
              void 0 !== this.refractionRatio &&
                (R.refractionRatio = this.refractionRatio),
              this.gradientMap &&
                this.gradientMap.isTexture &&
                (R.gradientMap = this.gradientMap.toJSON(_).uuid),
              void 0 !== this.transmission &&
                (R.transmission = this.transmission),
              this.transmissionMap &&
                this.transmissionMap.isTexture &&
                (R.transmissionMap = this.transmissionMap.toJSON(_).uuid),
              void 0 !== this.thickness && (R.thickness = this.thickness),
              this.thicknessMap &&
                this.thicknessMap.isTexture &&
                (R.thicknessMap = this.thicknessMap.toJSON(_).uuid),
              void 0 !== this.attenuationDistance &&
                this.attenuationDistance !== 1 / 0 &&
                (R.attenuationDistance = this.attenuationDistance),
              void 0 !== this.attenuationColor &&
                (R.attenuationColor = this.attenuationColor.getHex()),
              void 0 !== this.size && (R.size = this.size),
              null !== this.shadowSide && (R.shadowSide = this.shadowSide),
              void 0 !== this.sizeAttenuation &&
                (R.sizeAttenuation = this.sizeAttenuation),
              1 !== this.blending && (R.blending = this.blending),
              0 !== this.side && (R.side = this.side),
              this.vertexColors && (R.vertexColors = !0),
              this.opacity < 1 && (R.opacity = this.opacity),
              !0 === this.transparent && (R.transparent = this.transparent),
              (R.depthFunc = this.depthFunc),
              (R.depthTest = this.depthTest),
              (R.depthWrite = this.depthWrite),
              (R.colorWrite = this.colorWrite),
              (R.stencilWrite = this.stencilWrite),
              (R.stencilWriteMask = this.stencilWriteMask),
              (R.stencilFunc = this.stencilFunc),
              (R.stencilRef = this.stencilRef),
              (R.stencilFuncMask = this.stencilFuncMask),
              (R.stencilFail = this.stencilFail),
              (R.stencilZFail = this.stencilZFail),
              (R.stencilZPass = this.stencilZPass),
              void 0 !== this.rotation &&
                0 !== this.rotation &&
                (R.rotation = this.rotation),
              !0 === this.polygonOffset && (R.polygonOffset = !0),
              0 !== this.polygonOffsetFactor &&
                (R.polygonOffsetFactor = this.polygonOffsetFactor),
              0 !== this.polygonOffsetUnits &&
                (R.polygonOffsetUnits = this.polygonOffsetUnits),
              void 0 !== this.linewidth &&
                1 !== this.linewidth &&
                (R.linewidth = this.linewidth),
              void 0 !== this.dashSize && (R.dashSize = this.dashSize),
              void 0 !== this.gapSize && (R.gapSize = this.gapSize),
              void 0 !== this.scale && (R.scale = this.scale),
              !0 === this.dithering && (R.dithering = !0),
              this.alphaTest > 0 && (R.alphaTest = this.alphaTest),
              !0 === this.alphaToCoverage &&
                (R.alphaToCoverage = this.alphaToCoverage),
              !0 === this.premultipliedAlpha &&
                (R.premultipliedAlpha = this.premultipliedAlpha),
              !0 === this.forceSinglePass &&
                (R.forceSinglePass = this.forceSinglePass),
              !0 === this.wireframe && (R.wireframe = this.wireframe),
              this.wireframeLinewidth > 1 &&
                (R.wireframeLinewidth = this.wireframeLinewidth),
              "round" !== this.wireframeLinecap &&
                (R.wireframeLinecap = this.wireframeLinecap),
              "round" !== this.wireframeLinejoin &&
                (R.wireframeLinejoin = this.wireframeLinejoin),
              !0 === this.flatShading && (R.flatShading = this.flatShading),
              !1 === this.visible && (R.visible = !1),
              !1 === this.toneMapped && (R.toneMapped = !1),
              !1 === this.fog && (R.fog = !1),
              Object.keys(this.userData).length > 0 &&
                (R.userData = this.userData),
              I)
            ) {
              let I = i(_.textures),
                B = i(_.images);
              I.length > 0 && (R.textures = I), B.length > 0 && (R.images = B);
            }
            return R;
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(_) {
            (this.name = _.name),
              (this.blending = _.blending),
              (this.side = _.side),
              (this.vertexColors = _.vertexColors),
              (this.opacity = _.opacity),
              (this.transparent = _.transparent),
              (this.blendSrc = _.blendSrc),
              (this.blendDst = _.blendDst),
              (this.blendEquation = _.blendEquation),
              (this.blendSrcAlpha = _.blendSrcAlpha),
              (this.blendDstAlpha = _.blendDstAlpha),
              (this.blendEquationAlpha = _.blendEquationAlpha),
              (this.depthFunc = _.depthFunc),
              (this.depthTest = _.depthTest),
              (this.depthWrite = _.depthWrite),
              (this.stencilWriteMask = _.stencilWriteMask),
              (this.stencilFunc = _.stencilFunc),
              (this.stencilRef = _.stencilRef),
              (this.stencilFuncMask = _.stencilFuncMask),
              (this.stencilFail = _.stencilFail),
              (this.stencilZFail = _.stencilZFail),
              (this.stencilZPass = _.stencilZPass),
              (this.stencilWrite = _.stencilWrite);
            let I = _.clippingPlanes,
              R = null;
            if (null !== I) {
              let _ = I.length;
              R = Array(_);
              for (let B = 0; B !== _; ++B) R[B] = I[B].clone();
            }
            return (
              (this.clippingPlanes = R),
              (this.clipIntersection = _.clipIntersection),
              (this.clipShadows = _.clipShadows),
              (this.shadowSide = _.shadowSide),
              (this.colorWrite = _.colorWrite),
              (this.precision = _.precision),
              (this.polygonOffset = _.polygonOffset),
              (this.polygonOffsetFactor = _.polygonOffsetFactor),
              (this.polygonOffsetUnits = _.polygonOffsetUnits),
              (this.dithering = _.dithering),
              (this.alphaTest = _.alphaTest),
              (this.alphaToCoverage = _.alphaToCoverage),
              (this.premultipliedAlpha = _.premultipliedAlpha),
              (this.forceSinglePass = _.forceSinglePass),
              (this.visible = _.visible),
              (this.toneMapped = _.toneMapped),
              (this.userData = JSON.parse(JSON.stringify(_.userData))),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
          set needsUpdate(_) {
            !0 === _ && this.version++;
          }
        },
        sK = class extends sZ {
          constructor(_) {
            super(),
              (this.isMeshBasicMaterial = !0),
              (this.type = "MeshBasicMaterial"),
              (this.color = new ry(16777215)),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = 0),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.fog = !0),
              this.setValues(_);
          }
          copy(_) {
            return (
              super.copy(_),
              this.color.copy(_.color),
              (this.map = _.map),
              (this.lightMap = _.lightMap),
              (this.lightMapIntensity = _.lightMapIntensity),
              (this.aoMap = _.aoMap),
              (this.aoMapIntensity = _.aoMapIntensity),
              (this.specularMap = _.specularMap),
              (this.alphaMap = _.alphaMap),
              (this.envMap = _.envMap),
              (this.combine = _.combine),
              (this.reflectivity = _.reflectivity),
              (this.refractionRatio = _.refractionRatio),
              (this.wireframe = _.wireframe),
              (this.wireframeLinewidth = _.wireframeLinewidth),
              (this.wireframeLinecap = _.wireframeLinecap),
              (this.wireframeLinejoin = _.wireframeLinejoin),
              (this.fog = _.fog),
              this
            );
          }
        },
        sJ = new rF(),
        s$ = new rs(),
        s0 = class {
          constructor(_, I, R = !1) {
            if (Array.isArray(_))
              throw TypeError(
                "THREE.BufferAttribute: array should be a Typed Array."
              );
            (this.isBufferAttribute = !0),
              (this.name = ""),
              (this.array = _),
              (this.itemSize = I),
              (this.count = void 0 !== _ ? _.length / I : 0),
              (this.normalized = R),
              (this.usage = 35044),
              (this.updateRange = { offset: 0, count: -1 }),
              (this.version = 0);
          }
          onUploadCallback() {}
          set needsUpdate(_) {
            !0 === _ && this.version++;
          }
          setUsage(_) {
            return (this.usage = _), this;
          }
          copy(_) {
            return (
              (this.name = _.name),
              (this.array = new _.array.constructor(_.array)),
              (this.itemSize = _.itemSize),
              (this.count = _.count),
              (this.normalized = _.normalized),
              (this.usage = _.usage),
              this
            );
          }
          copyAt(_, I, R) {
            (_ *= this.itemSize), (R *= I.itemSize);
            for (let B = 0, z = this.itemSize; B < z; B++)
              this.array[_ + B] = I.array[R + B];
            return this;
          }
          copyArray(_) {
            return this.array.set(_), this;
          }
          applyMatrix3(_) {
            if (2 === this.itemSize)
              for (let I = 0, R = this.count; I < R; I++)
                s$.fromBufferAttribute(this, I),
                  s$.applyMatrix3(_),
                  this.setXY(I, s$.x, s$.y);
            else if (3 === this.itemSize)
              for (let I = 0, R = this.count; I < R; I++)
                sJ.fromBufferAttribute(this, I),
                  sJ.applyMatrix3(_),
                  this.setXYZ(I, sJ.x, sJ.y, sJ.z);
            return this;
          }
          applyMatrix4(_) {
            for (let I = 0, R = this.count; I < R; I++)
              sJ.fromBufferAttribute(this, I),
                sJ.applyMatrix4(_),
                this.setXYZ(I, sJ.x, sJ.y, sJ.z);
            return this;
          }
          applyNormalMatrix(_) {
            for (let I = 0, R = this.count; I < R; I++)
              sJ.fromBufferAttribute(this, I),
                sJ.applyNormalMatrix(_),
                this.setXYZ(I, sJ.x, sJ.y, sJ.z);
            return this;
          }
          transformDirection(_) {
            for (let I = 0, R = this.count; I < R; I++)
              sJ.fromBufferAttribute(this, I),
                sJ.transformDirection(_),
                this.setXYZ(I, sJ.x, sJ.y, sJ.z);
            return this;
          }
          set(_, I = 0) {
            return this.array.set(_, I), this;
          }
          getX(_) {
            let I = this.array[_ * this.itemSize];
            return this.normalized && (I = ya(I, this.array)), I;
          }
          setX(_, I) {
            return (
              this.normalized && (I = br(I, this.array)),
              (this.array[_ * this.itemSize] = I),
              this
            );
          }
          getY(_) {
            let I = this.array[_ * this.itemSize + 1];
            return this.normalized && (I = ya(I, this.array)), I;
          }
          setY(_, I) {
            return (
              this.normalized && (I = br(I, this.array)),
              (this.array[_ * this.itemSize + 1] = I),
              this
            );
          }
          getZ(_) {
            let I = this.array[_ * this.itemSize + 2];
            return this.normalized && (I = ya(I, this.array)), I;
          }
          setZ(_, I) {
            return (
              this.normalized && (I = br(I, this.array)),
              (this.array[_ * this.itemSize + 2] = I),
              this
            );
          }
          getW(_) {
            let I = this.array[_ * this.itemSize + 3];
            return this.normalized && (I = ya(I, this.array)), I;
          }
          setW(_, I) {
            return (
              this.normalized && (I = br(I, this.array)),
              (this.array[_ * this.itemSize + 3] = I),
              this
            );
          }
          setXY(_, I, R) {
            return (
              (_ *= this.itemSize),
              this.normalized &&
                ((I = br(I, this.array)), (R = br(R, this.array))),
              (this.array[_ + 0] = I),
              (this.array[_ + 1] = R),
              this
            );
          }
          setXYZ(_, I, R, B) {
            return (
              (_ *= this.itemSize),
              this.normalized &&
                ((I = br(I, this.array)),
                (R = br(R, this.array)),
                (B = br(B, this.array))),
              (this.array[_ + 0] = I),
              (this.array[_ + 1] = R),
              (this.array[_ + 2] = B),
              this
            );
          }
          setXYZW(_, I, R, B, z) {
            return (
              (_ *= this.itemSize),
              this.normalized &&
                ((I = br(I, this.array)),
                (R = br(R, this.array)),
                (B = br(B, this.array)),
                (z = br(z, this.array))),
              (this.array[_ + 0] = I),
              (this.array[_ + 1] = R),
              (this.array[_ + 2] = B),
              (this.array[_ + 3] = z),
              this
            );
          }
          onUpload(_) {
            return (this.onUploadCallback = _), this;
          }
          clone() {
            return new this.constructor(this.array, this.itemSize).copy(this);
          }
          toJSON() {
            let _ = {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: Array.from(this.array),
              normalized: this.normalized,
            };
            return (
              "" !== this.name && (_.name = this.name),
              35044 !== this.usage && (_.usage = this.usage),
              (0 !== this.updateRange.offset ||
                -1 !== this.updateRange.count) &&
                (_.updateRange = this.updateRange),
              _
            );
          }
          copyColorsArray() {
            console.error(
              "THREE.BufferAttribute: copyColorsArray() was removed in r144."
            );
          }
          copyVector2sArray() {
            console.error(
              "THREE.BufferAttribute: copyVector2sArray() was removed in r144."
            );
          }
          copyVector3sArray() {
            console.error(
              "THREE.BufferAttribute: copyVector3sArray() was removed in r144."
            );
          }
          copyVector4sArray() {
            console.error(
              "THREE.BufferAttribute: copyVector4sArray() was removed in r144."
            );
          }
        },
        s2 = class extends s0 {
          constructor(_, I, R) {
            super(new Uint16Array(_), I, R);
          }
        },
        s3 = class extends s0 {
          constructor(_, I, R) {
            super(new Uint32Array(_), I, R);
          }
        },
        s4 = class extends s0 {
          constructor(_, I, R) {
            super(new Float32Array(_), I, R);
          }
        },
        s5 = 0,
        s6 = new sa(),
        s8 = new sL(),
        s9 = new rF(),
        s7 = new rU(),
        ae = new rU(),
        at = new rF(),
        ai = class extends i8 {
          constructor() {
            super(),
              (this.isBufferGeometry = !0),
              Object.defineProperty(this, "id", { value: s5++ }),
              (this.uuid = ms()),
              (this.name = ""),
              (this.type = "BufferGeometry"),
              (this.index = null),
              (this.attributes = {}),
              (this.morphAttributes = {}),
              (this.morphTargetsRelative = !1),
              (this.groups = []),
              (this.boundingBox = null),
              (this.boundingSphere = null),
              (this.drawRange = { start: 0, count: 1 / 0 }),
              (this.userData = {});
          }
          getIndex() {
            return this.index;
          }
          setIndex(_) {
            return (
              Array.isArray(_)
                ? (this.index = new (YM(_) ? s3 : s2)(_, 1))
                : (this.index = _),
              this
            );
          }
          getAttribute(_) {
            return this.attributes[_];
          }
          setAttribute(_, I) {
            return (this.attributes[_] = I), this;
          }
          deleteAttribute(_) {
            return delete this.attributes[_], this;
          }
          hasAttribute(_) {
            return void 0 !== this.attributes[_];
          }
          addGroup(_, I, R = 0) {
            this.groups.push({ start: _, count: I, materialIndex: R });
          }
          clearGroups() {
            this.groups = [];
          }
          setDrawRange(_, I) {
            (this.drawRange.start = _), (this.drawRange.count = I);
          }
          applyMatrix4(_) {
            let I = this.attributes.position;
            void 0 !== I && (I.applyMatrix4(_), (I.needsUpdate = !0));
            let R = this.attributes.normal;
            if (void 0 !== R) {
              let I = new ro().getNormalMatrix(_);
              R.applyNormalMatrix(I), (R.needsUpdate = !0);
            }
            let B = this.attributes.tangent;
            return (
              void 0 !== B && (B.transformDirection(_), (B.needsUpdate = !0)),
              null !== this.boundingBox && this.computeBoundingBox(),
              null !== this.boundingSphere && this.computeBoundingSphere(),
              this
            );
          }
          applyQuaternion(_) {
            return (
              s6.makeRotationFromQuaternion(_), this.applyMatrix4(s6), this
            );
          }
          rotateX(_) {
            return s6.makeRotationX(_), this.applyMatrix4(s6), this;
          }
          rotateY(_) {
            return s6.makeRotationY(_), this.applyMatrix4(s6), this;
          }
          rotateZ(_) {
            return s6.makeRotationZ(_), this.applyMatrix4(s6), this;
          }
          translate(_, I, R) {
            return s6.makeTranslation(_, I, R), this.applyMatrix4(s6), this;
          }
          scale(_, I, R) {
            return s6.makeScale(_, I, R), this.applyMatrix4(s6), this;
          }
          lookAt(_) {
            return (
              s8.lookAt(_),
              s8.updateMatrix(),
              this.applyMatrix4(s8.matrix),
              this
            );
          }
          center() {
            return (
              this.computeBoundingBox(),
              this.boundingBox.getCenter(s9).negate(),
              this.translate(s9.x, s9.y, s9.z),
              this
            );
          }
          setFromPoints(_) {
            let I = [];
            for (let R = 0, B = _.length; R < B; R++) {
              let B = _[R];
              I.push(B.x, B.y, B.z || 0);
            }
            return this.setAttribute("position", new s4(I, 3)), this;
          }
          computeBoundingBox() {
            null === this.boundingBox && (this.boundingBox = new rU());
            let _ = this.attributes.position,
              I = this.morphAttributes.position;
            if (_ && _.isGLBufferAttribute) {
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                this
              ),
                this.boundingBox.set(
                  new rF(-1 / 0, -1 / 0, -1 / 0),
                  new rF(1 / 0, 1 / 0, 1 / 0)
                );
              return;
            }
            if (void 0 !== _) {
              if ((this.boundingBox.setFromBufferAttribute(_), I))
                for (let _ = 0, R = I.length; _ < R; _++) {
                  let R = I[_];
                  s7.setFromBufferAttribute(R),
                    this.morphTargetsRelative
                      ? (at.addVectors(this.boundingBox.min, s7.min),
                        this.boundingBox.expandByPoint(at),
                        at.addVectors(this.boundingBox.max, s7.max),
                        this.boundingBox.expandByPoint(at))
                      : (this.boundingBox.expandByPoint(s7.min),
                        this.boundingBox.expandByPoint(s7.max));
                }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) ||
              isNaN(this.boundingBox.min.y) ||
              isNaN(this.boundingBox.min.z)) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                this
              );
          }
          computeBoundingSphere() {
            null === this.boundingSphere && (this.boundingSphere = new r5());
            let _ = this.attributes.position,
              I = this.morphAttributes.position;
            if (_ && _.isGLBufferAttribute) {
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                this
              ),
                this.boundingSphere.set(new rF(), 1 / 0);
              return;
            }
            if (_) {
              let R = this.boundingSphere.center;
              if ((s7.setFromBufferAttribute(_), I))
                for (let _ = 0, R = I.length; _ < R; _++) {
                  let R = I[_];
                  ae.setFromBufferAttribute(R),
                    this.morphTargetsRelative
                      ? (at.addVectors(s7.min, ae.min),
                        s7.expandByPoint(at),
                        at.addVectors(s7.max, ae.max),
                        s7.expandByPoint(at))
                      : (s7.expandByPoint(ae.min), s7.expandByPoint(ae.max));
                }
              s7.getCenter(R);
              let B = 0;
              for (let I = 0, z = _.count; I < z; I++)
                at.fromBufferAttribute(_, I),
                  (B = Math.max(B, R.distanceToSquared(at)));
              if (I)
                for (let z = 0, k = I.length; z < k; z++) {
                  let k = I[z],
                    V = this.morphTargetsRelative;
                  for (let I = 0, z = k.count; I < z; I++)
                    at.fromBufferAttribute(k, I),
                      V && (s9.fromBufferAttribute(_, I), at.add(s9)),
                      (B = Math.max(B, R.distanceToSquared(at)));
                }
              (this.boundingSphere.radius = Math.sqrt(B)),
                isNaN(this.boundingSphere.radius) &&
                  console.error(
                    'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                    this
                  );
            }
          }
          computeTangents() {
            let _ = this.index,
              I = this.attributes;
            if (
              null === _ ||
              void 0 === I.position ||
              void 0 === I.normal ||
              void 0 === I.uv
            ) {
              console.error(
                "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
              );
              return;
            }
            let R = _.array,
              B = I.position.array,
              z = I.normal.array,
              k = I.uv.array,
              V = B.length / 3;
            !1 === this.hasAttribute("tangent") &&
              this.setAttribute("tangent", new s0(new Float32Array(4 * V), 4));
            let j = this.getAttribute("tangent").array,
              G = [],
              q = [];
            for (let _ = 0; _ < V; _++) (G[_] = new rF()), (q[_] = new rF());
            let X = new rF(),
              Q = new rF(),
              $ = new rF(),
              et = new rs(),
              er = new rs(),
              es = new rs(),
              ea = new rF(),
              en = new rF(),
              eo = this.groups;
            0 === eo.length && (eo = [{ start: 0, count: R.length }]);
            for (let _ = 0, I = eo.length; _ < I; ++_) {
              let I = eo[_],
                z = I.start,
                V = I.count;
              for (let _ = z, I = z + V; _ < I; _ += 3)
                !(function (_, I, R) {
                  X.fromArray(B, 3 * _),
                    Q.fromArray(B, 3 * I),
                    $.fromArray(B, 3 * R),
                    et.fromArray(k, 2 * _),
                    er.fromArray(k, 2 * I),
                    es.fromArray(k, 2 * R),
                    Q.sub(X),
                    $.sub(X),
                    er.sub(et),
                    es.sub(et);
                  let z = 1 / (er.x * es.y - es.x * er.y);
                  isFinite(z) &&
                    (ea
                      .copy(Q)
                      .multiplyScalar(es.y)
                      .addScaledVector($, -er.y)
                      .multiplyScalar(z),
                    en
                      .copy($)
                      .multiplyScalar(er.x)
                      .addScaledVector(Q, -es.x)
                      .multiplyScalar(z),
                    G[_].add(ea),
                    G[I].add(ea),
                    G[R].add(ea),
                    q[_].add(en),
                    q[I].add(en),
                    q[R].add(en));
                })(R[_ + 0], R[_ + 1], R[_ + 2]);
            }
            let el = new rF(),
              eh = new rF(),
              ec = new rF(),
              ed = new rF();
            function T(_) {
              ec.fromArray(z, 3 * _), ed.copy(ec);
              let I = G[_];
              el.copy(I),
                el.sub(ec.multiplyScalar(ec.dot(I))).normalize(),
                eh.crossVectors(ed, I);
              let R = 0 > eh.dot(q[_]) ? -1 : 1;
              (j[4 * _] = el.x),
                (j[4 * _ + 1] = el.y),
                (j[4 * _ + 2] = el.z),
                (j[4 * _ + 3] = R);
            }
            for (let _ = 0, I = eo.length; _ < I; ++_) {
              let I = eo[_],
                B = I.start,
                z = I.count;
              for (let _ = B, I = B + z; _ < I; _ += 3)
                T(R[_ + 0]), T(R[_ + 1]), T(R[_ + 2]);
            }
          }
          computeVertexNormals() {
            let _ = this.index,
              I = this.getAttribute("position");
            if (void 0 !== I) {
              let R = this.getAttribute("normal");
              if (void 0 === R)
                (R = new s0(new Float32Array(3 * I.count), 3)),
                  this.setAttribute("normal", R);
              else
                for (let _ = 0, I = R.count; _ < I; _++) R.setXYZ(_, 0, 0, 0);
              let B = new rF(),
                z = new rF(),
                k = new rF(),
                V = new rF(),
                j = new rF(),
                G = new rF(),
                q = new rF(),
                X = new rF();
              if (_)
                for (let Q = 0, $ = _.count; Q < $; Q += 3) {
                  let $ = _.getX(Q + 0),
                    et = _.getX(Q + 1),
                    er = _.getX(Q + 2);
                  B.fromBufferAttribute(I, $),
                    z.fromBufferAttribute(I, et),
                    k.fromBufferAttribute(I, er),
                    q.subVectors(k, z),
                    X.subVectors(B, z),
                    q.cross(X),
                    V.fromBufferAttribute(R, $),
                    j.fromBufferAttribute(R, et),
                    G.fromBufferAttribute(R, er),
                    V.add(q),
                    j.add(q),
                    G.add(q),
                    R.setXYZ($, V.x, V.y, V.z),
                    R.setXYZ(et, j.x, j.y, j.z),
                    R.setXYZ(er, G.x, G.y, G.z);
                }
              else
                for (let _ = 0, V = I.count; _ < V; _ += 3)
                  B.fromBufferAttribute(I, _ + 0),
                    z.fromBufferAttribute(I, _ + 1),
                    k.fromBufferAttribute(I, _ + 2),
                    q.subVectors(k, z),
                    X.subVectors(B, z),
                    q.cross(X),
                    R.setXYZ(_ + 0, q.x, q.y, q.z),
                    R.setXYZ(_ + 1, q.x, q.y, q.z),
                    R.setXYZ(_ + 2, q.x, q.y, q.z);
              this.normalizeNormals(), (R.needsUpdate = !0);
            }
          }
          merge() {
            return (
              console.error(
                "THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."
              ),
              this
            );
          }
          normalizeNormals() {
            let _ = this.attributes.normal;
            for (let I = 0, R = _.count; I < R; I++)
              at.fromBufferAttribute(_, I),
                at.normalize(),
                _.setXYZ(I, at.x, at.y, at.z);
          }
          toNonIndexed() {
            function t(_, I) {
              let R = _.array,
                B = _.itemSize,
                z = _.normalized,
                k = new R.constructor(I.length * B),
                V = 0,
                j = 0;
              for (let z = 0, G = I.length; z < G; z++) {
                V = _.isInterleavedBufferAttribute
                  ? I[z] * _.data.stride + _.offset
                  : I[z] * B;
                for (let _ = 0; _ < B; _++) k[j++] = R[V++];
              }
              return new s0(k, B, z);
            }
            if (null === this.index)
              return (
                console.warn(
                  "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
                ),
                this
              );
            let _ = new ai(),
              I = this.index.array,
              R = this.attributes;
            for (let B in R) {
              let z = t(R[B], I);
              _.setAttribute(B, z);
            }
            let B = this.morphAttributes;
            for (let R in B) {
              let z = [],
                k = B[R];
              for (let _ = 0, R = k.length; _ < R; _++) {
                let R = t(k[_], I);
                z.push(R);
              }
              _.morphAttributes[R] = z;
            }
            _.morphTargetsRelative = this.morphTargetsRelative;
            let z = this.groups;
            for (let I = 0, R = z.length; I < R; I++) {
              let R = z[I];
              _.addGroup(R.start, R.count, R.materialIndex);
            }
            return _;
          }
          toJSON() {
            let _ = {
              metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON",
              },
            };
            if (
              ((_.uuid = this.uuid),
              (_.type = this.type),
              "" !== this.name && (_.name = this.name),
              Object.keys(this.userData).length > 0 &&
                (_.userData = this.userData),
              void 0 !== this.parameters)
            ) {
              let I = this.parameters;
              for (let R in I) void 0 !== I[R] && (_[R] = I[R]);
              return _;
            }
            _.data = { attributes: {} };
            let I = this.index;
            null !== I &&
              (_.data.index = {
                type: I.array.constructor.name,
                array: Array.prototype.slice.call(I.array),
              });
            let R = this.attributes;
            for (let I in R) {
              let B = R[I];
              _.data.attributes[I] = B.toJSON(_.data);
            }
            let B = {},
              z = !1;
            for (let I in this.morphAttributes) {
              let R = this.morphAttributes[I],
                k = [];
              for (let I = 0, B = R.length; I < B; I++) {
                let B = R[I];
                k.push(B.toJSON(_.data));
              }
              k.length > 0 && ((B[I] = k), (z = !0));
            }
            z &&
              ((_.data.morphAttributes = B),
              (_.data.morphTargetsRelative = this.morphTargetsRelative));
            let k = this.groups;
            k.length > 0 && (_.data.groups = JSON.parse(JSON.stringify(k)));
            let V = this.boundingSphere;
            return (
              null !== V &&
                (_.data.boundingSphere = {
                  center: V.center.toArray(),
                  radius: V.radius,
                }),
              _
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(_) {
            (this.index = null),
              (this.attributes = {}),
              (this.morphAttributes = {}),
              (this.groups = []),
              (this.boundingBox = null),
              (this.boundingSphere = null);
            let I = {};
            this.name = _.name;
            let R = _.index;
            null !== R && this.setIndex(R.clone(I));
            let B = _.attributes;
            for (let _ in B) {
              let R = B[_];
              this.setAttribute(_, R.clone(I));
            }
            let z = _.morphAttributes;
            for (let _ in z) {
              let R = [],
                B = z[_];
              for (let _ = 0, z = B.length; _ < z; _++) R.push(B[_].clone(I));
              this.morphAttributes[_] = R;
            }
            this.morphTargetsRelative = _.morphTargetsRelative;
            let k = _.groups;
            for (let _ = 0, I = k.length; _ < I; _++) {
              let I = k[_];
              this.addGroup(I.start, I.count, I.materialIndex);
            }
            let V = _.boundingBox;
            null !== V && (this.boundingBox = V.clone());
            let j = _.boundingSphere;
            return (
              null !== j && (this.boundingSphere = j.clone()),
              (this.drawRange.start = _.drawRange.start),
              (this.drawRange.count = _.drawRange.count),
              (this.userData = _.userData),
              void 0 !== _.parameters &&
                (this.parameters = Object.assign({}, _.parameters)),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
        },
        ar = new sa(),
        as = new ss(),
        aa = new r5(),
        an = new rF(),
        al = new rF(),
        ah = new rF(),
        ad = new rF(),
        ap = new rF(),
        af = new rs(),
        am = new rs(),
        ag = new rs(),
        ax = new rF(),
        ab = new rF(),
        aw = class extends sL {
          constructor(_ = new ai(), I = new sK()) {
            super(),
              (this.isMesh = !0),
              (this.type = "Mesh"),
              (this.geometry = _),
              (this.material = I),
              this.updateMorphTargets();
          }
          copy(_, I) {
            return (
              super.copy(_, I),
              void 0 !== _.morphTargetInfluences &&
                (this.morphTargetInfluences = _.morphTargetInfluences.slice()),
              void 0 !== _.morphTargetDictionary &&
                (this.morphTargetDictionary = Object.assign(
                  {},
                  _.morphTargetDictionary
                )),
              (this.material = _.material),
              (this.geometry = _.geometry),
              this
            );
          }
          updateMorphTargets() {
            let _ = this.geometry.morphAttributes,
              I = Object.keys(_);
            if (I.length > 0) {
              let R = _[I[0]];
              if (void 0 !== R) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let _ = 0, I = R.length; _ < I; _++) {
                  let I = R[_].name || String(_);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[I] = _);
                }
              }
            }
          }
          getVertexPosition(_, I) {
            let R = this.geometry,
              B = R.attributes.position,
              z = R.morphAttributes.position,
              k = R.morphTargetsRelative;
            I.fromBufferAttribute(B, _);
            let V = this.morphTargetInfluences;
            if (z && V) {
              ap.set(0, 0, 0);
              for (let R = 0, B = z.length; R < B; R++) {
                let B = V[R],
                  j = z[R];
                0 !== B &&
                  (ad.fromBufferAttribute(j, _),
                  k
                    ? ap.addScaledVector(ad, B)
                    : ap.addScaledVector(ad.sub(I), B));
              }
              I.add(ap);
            }
            return this.isSkinnedMesh && this.boneTransform(_, I), I;
          }
          raycast(_, I) {
            let R = this.geometry,
              B = this.material,
              z = this.matrixWorld;
            if (
              void 0 === B ||
              (null === R.boundingSphere && R.computeBoundingSphere(),
              aa.copy(R.boundingSphere),
              aa.applyMatrix4(z),
              !1 === _.ray.intersectsSphere(aa)) ||
              (ar.copy(z).invert(),
              as.copy(_.ray).applyMatrix4(ar),
              null !== R.boundingBox && !1 === as.intersectsBox(R.boundingBox))
            )
              return;
            let k,
              V = R.index,
              j = R.attributes.position,
              G = R.attributes.uv,
              q = R.attributes.uv2,
              X = R.groups,
              Q = R.drawRange;
            if (null !== V) {
              if (Array.isArray(B))
                for (let R = 0, z = X.length; R < z; R++) {
                  let z = X[R],
                    j = B[z.materialIndex],
                    $ = Math.max(z.start, Q.start),
                    et = Math.min(
                      V.count,
                      Math.min(z.start + z.count, Q.start + Q.count)
                    );
                  for (let R = $; R < et; R += 3)
                    (k = Jg(
                      this,
                      j,
                      _,
                      as,
                      G,
                      q,
                      V.getX(R),
                      V.getX(R + 1),
                      V.getX(R + 2)
                    )) &&
                      ((k.faceIndex = Math.floor(R / 3)),
                      (k.face.materialIndex = z.materialIndex),
                      I.push(k));
                }
              else {
                let R = Math.max(0, Q.start),
                  z = Math.min(V.count, Q.start + Q.count);
                for (let j = R; j < z; j += 3)
                  (k = Jg(
                    this,
                    B,
                    _,
                    as,
                    G,
                    q,
                    V.getX(j),
                    V.getX(j + 1),
                    V.getX(j + 2)
                  )) && ((k.faceIndex = Math.floor(j / 3)), I.push(k));
              }
            } else if (void 0 !== j) {
              if (Array.isArray(B))
                for (let R = 0, z = X.length; R < z; R++) {
                  let z = X[R],
                    V = B[z.materialIndex],
                    $ = Math.max(z.start, Q.start),
                    et = Math.min(
                      j.count,
                      Math.min(z.start + z.count, Q.start + Q.count)
                    );
                  for (let R = $; R < et; R += 3)
                    (k = Jg(this, V, _, as, G, q, R, R + 1, R + 2)) &&
                      ((k.faceIndex = Math.floor(R / 3)),
                      (k.face.materialIndex = z.materialIndex),
                      I.push(k));
                }
              else {
                let R = Math.max(0, Q.start),
                  z = Math.min(j.count, Q.start + Q.count);
                for (let V = R; V < z; V += 3)
                  (k = Jg(this, B, _, as, G, q, V, V + 1, V + 2)) &&
                    ((k.faceIndex = Math.floor(V / 3)), I.push(k));
              }
            }
          }
        };
      function Jg(_, I, R, B, z, k, V, j, G) {
        _.getVertexPosition(V, an),
          _.getVertexPosition(j, al),
          _.getVertexPosition(G, ah);
        let q = (function (_, I, R, B, z, k, V, j) {
          if (
            null ===
            (1 === I.side
              ? B.intersectTriangle(V, k, z, !0, j)
              : B.intersectTriangle(z, k, V, 0 === I.side, j))
          )
            return null;
          ab.copy(j), ab.applyMatrix4(_.matrixWorld);
          let G = R.ray.origin.distanceTo(ab);
          return G < R.near || G > R.far
            ? null
            : { distance: G, point: ab.clone(), object: _ };
        })(_, I, R, B, an, al, ah, ax);
        if (q) {
          z &&
            (af.fromBufferAttribute(z, V),
            am.fromBufferAttribute(z, j),
            ag.fromBufferAttribute(z, G),
            (q.uv = sX.getUV(ax, an, al, ah, af, am, ag, new rs()))),
            k &&
              (af.fromBufferAttribute(k, V),
              am.fromBufferAttribute(k, j),
              ag.fromBufferAttribute(k, G),
              (q.uv2 = sX.getUV(ax, an, al, ah, af, am, ag, new rs())));
          let _ = { a: V, b: j, c: G, normal: new rF(), materialIndex: 0 };
          sX.getNormal(an, al, ah, _.normal), (q.face = _);
        }
        return q;
      }
      var aS = class extends ai {
        constructor(_ = 1, I = 1, R = 1, B = 1, z = 1, k = 1) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: _,
              height: I,
              depth: R,
              widthSegments: B,
              heightSegments: z,
              depthSegments: k,
            });
          let V = this;
          (B = Math.floor(B)), (z = Math.floor(z));
          let j = [],
            G = [],
            q = [],
            X = [],
            Q = 0,
            $ = 0;
          function p(_, I, R, B, z, k, et, er, es, ea, en) {
            let eo = k / es,
              el = et / ea,
              eh = k / 2,
              ec = et / 2,
              ed = er / 2,
              ep = es + 1,
              ef = ea + 1,
              em = 0,
              ey = 0,
              ex = new rF();
            for (let k = 0; k < ef; k++) {
              let V = k * el - ec;
              for (let j = 0; j < ep; j++) {
                let Q = j * eo - eh;
                (ex[_] = Q * B),
                  (ex[I] = V * z),
                  (ex[R] = ed),
                  G.push(ex.x, ex.y, ex.z),
                  (ex[_] = 0),
                  (ex[I] = 0),
                  (ex[R] = er > 0 ? 1 : -1),
                  q.push(ex.x, ex.y, ex.z),
                  X.push(j / es),
                  X.push(1 - k / ea),
                  (em += 1);
              }
            }
            for (let _ = 0; _ < ea; _++)
              for (let I = 0; I < es; I++) {
                let R = Q + I + ep * _,
                  B = Q + I + ep * (_ + 1),
                  z = Q + (I + 1) + ep * (_ + 1),
                  k = Q + (I + 1) + ep * _;
                j.push(R, B, k), j.push(B, z, k), (ey += 6);
              }
            V.addGroup($, ey, en), ($ += ey), (Q += em);
          }
          p("z", "y", "x", -1, -1, R, I, _, (k = Math.floor(k)), z, 0),
            p("z", "y", "x", 1, -1, R, I, -_, k, z, 1),
            p("x", "z", "y", 1, 1, _, R, I, B, k, 2),
            p("x", "z", "y", 1, -1, _, R, -I, B, k, 3),
            p("x", "y", "z", 1, -1, _, I, R, B, z, 4),
            p("x", "y", "z", -1, -1, _, I, -R, B, z, 5),
            this.setIndex(j),
            this.setAttribute("position", new s4(G, 3)),
            this.setAttribute("normal", new s4(q, 3)),
            this.setAttribute("uv", new s4(X, 2));
        }
        static fromJSON(_) {
          return new aS(
            _.width,
            _.height,
            _.depth,
            _.widthSegments,
            _.heightSegments,
            _.depthSegments
          );
        }
      };
      function Gu(_) {
        let I = {};
        for (let R in _)
          for (let B in ((I[R] = {}), _[R])) {
            let z = _[R][B];
            z &&
            (z.isColor ||
              z.isMatrix3 ||
              z.isMatrix4 ||
              z.isVector2 ||
              z.isVector3 ||
              z.isVector4 ||
              z.isTexture ||
              z.isQuaternion)
              ? (I[R][B] = z.clone())
              : Array.isArray(z)
              ? (I[R][B] = z.slice())
              : (I[R][B] = z);
          }
        return I;
      }
      function bn(_) {
        let I = {};
        for (let R = 0; R < _.length; R++) {
          let B = Gu(_[R]);
          for (let _ in B) I[_] = B[_];
        }
        return I;
      }
      function QM(_) {
        return null === _.getRenderTarget() && 3001 === _.outputEncoding
          ? i4
          : i5;
      }
      var aA = { clone: Gu, merge: bn },
        aE = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
        aC = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`,
        aT = class extends sZ {
          constructor(_) {
            super(),
              (this.isShaderMaterial = !0),
              (this.type = "ShaderMaterial"),
              (this.defines = {}),
              (this.uniforms = {}),
              (this.uniformsGroups = []),
              (this.vertexShader = aE),
              (this.fragmentShader = aC),
              (this.linewidth = 1),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.fog = !1),
              (this.lights = !1),
              (this.clipping = !1),
              (this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1,
              }),
              (this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0],
              }),
              (this.index0AttributeName = void 0),
              (this.uniformsNeedUpdate = !1),
              (this.glslVersion = null),
              void 0 !== _ && this.setValues(_);
          }
          copy(_) {
            return (
              super.copy(_),
              (this.fragmentShader = _.fragmentShader),
              (this.vertexShader = _.vertexShader),
              (this.uniforms = Gu(_.uniforms)),
              (this.uniformsGroups = (function (_) {
                let I = [];
                for (let R = 0; R < _.length; R++) I.push(_[R].clone());
                return I;
              })(_.uniformsGroups)),
              (this.defines = Object.assign({}, _.defines)),
              (this.wireframe = _.wireframe),
              (this.wireframeLinewidth = _.wireframeLinewidth),
              (this.fog = _.fog),
              (this.lights = _.lights),
              (this.clipping = _.clipping),
              (this.extensions = Object.assign({}, _.extensions)),
              (this.glslVersion = _.glslVersion),
              this
            );
          }
          toJSON(_) {
            let I = super.toJSON(_);
            for (let R in ((I.glslVersion = this.glslVersion),
            (I.uniforms = {}),
            this.uniforms)) {
              let B = this.uniforms[R].value;
              B && B.isTexture
                ? (I.uniforms[R] = { type: "t", value: B.toJSON(_).uuid })
                : B && B.isColor
                ? (I.uniforms[R] = { type: "c", value: B.getHex() })
                : B && B.isVector2
                ? (I.uniforms[R] = { type: "v2", value: B.toArray() })
                : B && B.isVector3
                ? (I.uniforms[R] = { type: "v3", value: B.toArray() })
                : B && B.isVector4
                ? (I.uniforms[R] = { type: "v4", value: B.toArray() })
                : B && B.isMatrix3
                ? (I.uniforms[R] = { type: "m3", value: B.toArray() })
                : B && B.isMatrix4
                ? (I.uniforms[R] = { type: "m4", value: B.toArray() })
                : (I.uniforms[R] = { value: B });
            }
            Object.keys(this.defines).length > 0 && (I.defines = this.defines),
              (I.vertexShader = this.vertexShader),
              (I.fragmentShader = this.fragmentShader);
            let R = {};
            for (let _ in this.extensions)
              !0 === this.extensions[_] && (R[_] = !0);
            return Object.keys(R).length > 0 && (I.extensions = R), I;
          }
        },
        aP = class extends sL {
          constructor() {
            super(),
              (this.isCamera = !0),
              (this.type = "Camera"),
              (this.matrixWorldInverse = new sa()),
              (this.projectionMatrix = new sa()),
              (this.projectionMatrixInverse = new sa());
          }
          copy(_, I) {
            return (
              super.copy(_, I),
              this.matrixWorldInverse.copy(_.matrixWorldInverse),
              this.projectionMatrix.copy(_.projectionMatrix),
              this.projectionMatrixInverse.copy(_.projectionMatrixInverse),
              this
            );
          }
          getWorldDirection(_) {
            this.updateWorldMatrix(!0, !1);
            let I = this.matrixWorld.elements;
            return _.set(-I[8], -I[9], -I[10]).normalize();
          }
          updateMatrixWorld(_) {
            super.updateMatrixWorld(_),
              this.matrixWorldInverse.copy(this.matrixWorld).invert();
          }
          updateWorldMatrix(_, I) {
            super.updateWorldMatrix(_, I),
              this.matrixWorldInverse.copy(this.matrixWorld).invert();
          }
          clone() {
            return new this.constructor().copy(this);
          }
        },
        aI = class extends aP {
          constructor(_ = 50, I = 1, R = 0.1, B = 2e3) {
            super(),
              (this.isPerspectiveCamera = !0),
              (this.type = "PerspectiveCamera"),
              (this.fov = _),
              (this.zoom = 1),
              (this.near = R),
              (this.far = B),
              (this.focus = 10),
              (this.aspect = I),
              (this.view = null),
              (this.filmGauge = 35),
              (this.filmOffset = 0),
              this.updateProjectionMatrix();
          }
          copy(_, I) {
            return (
              super.copy(_, I),
              (this.fov = _.fov),
              (this.zoom = _.zoom),
              (this.near = _.near),
              (this.far = _.far),
              (this.focus = _.focus),
              (this.aspect = _.aspect),
              (this.view = null === _.view ? null : Object.assign({}, _.view)),
              (this.filmGauge = _.filmGauge),
              (this.filmOffset = _.filmOffset),
              this
            );
          }
          setFocalLength(_) {
            let I = (0.5 * this.getFilmHeight()) / _;
            (this.fov = 2 * ri * Math.atan(I)), this.updateProjectionMatrix();
          }
          getFocalLength() {
            let _ = Math.tan(0.5 * rt * this.fov);
            return (0.5 * this.getFilmHeight()) / _;
          }
          getEffectiveFOV() {
            return (
              2 * ri * Math.atan(Math.tan(0.5 * rt * this.fov) / this.zoom)
            );
          }
          getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1);
          }
          getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1);
          }
          setViewOffset(_, I, R, B, z, k) {
            (this.aspect = _ / I),
              null === this.view &&
                (this.view = {
                  enabled: !0,
                  fullWidth: 1,
                  fullHeight: 1,
                  offsetX: 0,
                  offsetY: 0,
                  width: 1,
                  height: 1,
                }),
              (this.view.enabled = !0),
              (this.view.fullWidth = _),
              (this.view.fullHeight = I),
              (this.view.offsetX = R),
              (this.view.offsetY = B),
              (this.view.width = z),
              (this.view.height = k),
              this.updateProjectionMatrix();
          }
          clearViewOffset() {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix();
          }
          updateProjectionMatrix() {
            let _ = this.near,
              I = (_ * Math.tan(0.5 * rt * this.fov)) / this.zoom,
              R = 2 * I,
              B = this.aspect * R,
              z = -0.5 * B,
              k = this.view;
            if (null !== this.view && this.view.enabled) {
              let _ = k.fullWidth,
                V = k.fullHeight;
              (z += (k.offsetX * B) / _),
                (I -= (k.offsetY * R) / V),
                (B *= k.width / _),
                (R *= k.height / V);
            }
            let V = this.filmOffset;
            0 !== V && (z += (_ * V) / this.getFilmWidth()),
              this.projectionMatrix.makePerspective(
                z,
                z + B,
                I,
                I - R,
                _,
                this.far
              ),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
          }
          toJSON(_) {
            let I = super.toJSON(_);
            return (
              (I.object.fov = this.fov),
              (I.object.zoom = this.zoom),
              (I.object.near = this.near),
              (I.object.far = this.far),
              (I.object.focus = this.focus),
              (I.object.aspect = this.aspect),
              null !== this.view &&
                (I.object.view = Object.assign({}, this.view)),
              (I.object.filmGauge = this.filmGauge),
              (I.object.filmOffset = this.filmOffset),
              I
            );
          }
        },
        aR = class extends sL {
          constructor(_, I, R) {
            super(), (this.type = "CubeCamera"), (this.renderTarget = R);
            let B = new aI(-90, 1, _, I);
            (B.layers = this.layers),
              B.up.set(0, 1, 0),
              B.lookAt(1, 0, 0),
              this.add(B);
            let z = new aI(-90, 1, _, I);
            (z.layers = this.layers),
              z.up.set(0, 1, 0),
              z.lookAt(-1, 0, 0),
              this.add(z);
            let k = new aI(-90, 1, _, I);
            (k.layers = this.layers),
              k.up.set(0, 0, -1),
              k.lookAt(0, 1, 0),
              this.add(k);
            let V = new aI(-90, 1, _, I);
            (V.layers = this.layers),
              V.up.set(0, 0, 1),
              V.lookAt(0, -1, 0),
              this.add(V);
            let j = new aI(-90, 1, _, I);
            (j.layers = this.layers),
              j.up.set(0, 1, 0),
              j.lookAt(0, 0, 1),
              this.add(j);
            let G = new aI(-90, 1, _, I);
            (G.layers = this.layers),
              G.up.set(0, 1, 0),
              G.lookAt(0, 0, -1),
              this.add(G);
          }
          update(_, I) {
            null === this.parent && this.updateMatrixWorld();
            let R = this.renderTarget,
              [B, z, k, V, j, G] = this.children,
              q = _.getRenderTarget(),
              X = _.toneMapping,
              Q = _.xr.enabled;
            (_.toneMapping = 0), (_.xr.enabled = !1);
            let $ = R.texture.generateMipmaps;
            (R.texture.generateMipmaps = !1),
              _.setRenderTarget(R, 0),
              _.render(I, B),
              _.setRenderTarget(R, 1),
              _.render(I, z),
              _.setRenderTarget(R, 2),
              _.render(I, k),
              _.setRenderTarget(R, 3),
              _.render(I, V),
              _.setRenderTarget(R, 4),
              _.render(I, j),
              (R.texture.generateMipmaps = $),
              _.setRenderTarget(R, 5),
              _.render(I, G),
              _.setRenderTarget(q),
              (_.toneMapping = X),
              (_.xr.enabled = Q),
              (R.texture.needsPMREMUpdate = !0);
          }
        },
        aL = class extends rA {
          constructor(_, I, R, B, z, k, V, j, G, q) {
            super(
              (_ = void 0 !== _ ? _ : []),
              (I = void 0 !== I ? I : 301),
              R,
              B,
              z,
              k,
              V,
              j,
              G,
              q
            ),
              (this.isCubeTexture = !0),
              (this.flipY = !1);
          }
          get images() {
            return this.image;
          }
          set images(_) {
            this.image = _;
          }
        },
        az = class extends rT {
          constructor(_ = 1, I = {}) {
            super(_, _, I), (this.isWebGLCubeRenderTarget = !0);
            let R = { width: _, height: _, depth: 1 },
              B = [R, R, R, R, R, R];
            (this.texture = new aL(
              B,
              I.mapping,
              I.wrapS,
              I.wrapT,
              I.magFilter,
              I.minFilter,
              I.format,
              I.type,
              I.anisotropy,
              I.encoding
            )),
              (this.texture.isRenderTargetTexture = !0),
              (this.texture.generateMipmaps =
                void 0 !== I.generateMipmaps && I.generateMipmaps),
              (this.texture.minFilter =
                void 0 !== I.minFilter ? I.minFilter : 1006);
          }
          fromEquirectangularTexture(_, I) {
            (this.texture.type = I.type),
              (this.texture.encoding = I.encoding),
              (this.texture.generateMipmaps = I.generateMipmaps),
              (this.texture.minFilter = I.minFilter),
              (this.texture.magFilter = I.magFilter);
            let R = {
                uniforms: { tEquirect: { value: null } },
                vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
              },
              B = new aS(5, 5, 5),
              z = new aT({
                name: "CubemapFromEquirect",
                uniforms: Gu(R.uniforms),
                vertexShader: R.vertexShader,
                fragmentShader: R.fragmentShader,
                side: 1,
                blending: 0,
              });
            z.uniforms.tEquirect.value = I;
            let k = new aw(B, z),
              V = I.minFilter;
            return (
              1008 === I.minFilter && (I.minFilter = 1006),
              new aR(1, 10, this).update(_, k),
              (I.minFilter = V),
              k.geometry.dispose(),
              k.material.dispose(),
              this
            );
          }
          clear(_, I, R, B) {
            let z = _.getRenderTarget();
            for (let z = 0; z < 6; z++)
              _.setRenderTarget(this, z), _.clear(I, R, B);
            _.setRenderTarget(z);
          }
        },
        aF = new rF(),
        ak = new rF(),
        aU = new ro(),
        aV = class {
          constructor(_ = new rF(1, 0, 0), I = 0) {
            (this.isPlane = !0), (this.normal = _), (this.constant = I);
          }
          set(_, I) {
            return this.normal.copy(_), (this.constant = I), this;
          }
          setComponents(_, I, R, B) {
            return this.normal.set(_, I, R), (this.constant = B), this;
          }
          setFromNormalAndCoplanarPoint(_, I) {
            return (
              this.normal.copy(_), (this.constant = -I.dot(this.normal)), this
            );
          }
          setFromCoplanarPoints(_, I, R) {
            let B = aF.subVectors(R, I).cross(ak.subVectors(_, I)).normalize();
            return this.setFromNormalAndCoplanarPoint(B, _), this;
          }
          copy(_) {
            return (
              this.normal.copy(_.normal), (this.constant = _.constant), this
            );
          }
          normalize() {
            let _ = 1 / this.normal.length();
            return this.normal.multiplyScalar(_), (this.constant *= _), this;
          }
          negate() {
            return (this.constant *= -1), this.normal.negate(), this;
          }
          distanceToPoint(_) {
            return this.normal.dot(_) + this.constant;
          }
          distanceToSphere(_) {
            return this.distanceToPoint(_.center) - _.radius;
          }
          projectPoint(_, I) {
            return I.copy(this.normal)
              .multiplyScalar(-this.distanceToPoint(_))
              .add(_);
          }
          intersectLine(_, I) {
            let R = _.delta(aF),
              B = this.normal.dot(R);
            if (0 === B)
              return 0 === this.distanceToPoint(_.start)
                ? I.copy(_.start)
                : null;
            let z = -(_.start.dot(this.normal) + this.constant) / B;
            return z < 0 || z > 1
              ? null
              : I.copy(R).multiplyScalar(z).add(_.start);
          }
          intersectsLine(_) {
            let I = this.distanceToPoint(_.start),
              R = this.distanceToPoint(_.end);
            return (I < 0 && R > 0) || (R < 0 && I > 0);
          }
          intersectsBox(_) {
            return _.intersectsPlane(this);
          }
          intersectsSphere(_) {
            return _.intersectsPlane(this);
          }
          coplanarPoint(_) {
            return _.copy(this.normal).multiplyScalar(-this.constant);
          }
          applyMatrix4(_, I) {
            let R = I || aU.getNormalMatrix(_),
              B = this.coplanarPoint(aF).applyMatrix4(_),
              z = this.normal.applyMatrix3(R).normalize();
            return (this.constant = -B.dot(z)), this;
          }
          translate(_) {
            return (this.constant -= _.dot(this.normal)), this;
          }
          equals(_) {
            return _.normal.equals(this.normal) && _.constant === this.constant;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        },
        aj = new r5(),
        aH = new rF(),
        aW = class {
          constructor(
            _ = new aV(),
            I = new aV(),
            R = new aV(),
            B = new aV(),
            z = new aV(),
            k = new aV()
          ) {
            this.planes = [_, I, R, B, z, k];
          }
          set(_, I, R, B, z, k) {
            let V = this.planes;
            return (
              V[0].copy(_),
              V[1].copy(I),
              V[2].copy(R),
              V[3].copy(B),
              V[4].copy(z),
              V[5].copy(k),
              this
            );
          }
          copy(_) {
            let I = this.planes;
            for (let R = 0; R < 6; R++) I[R].copy(_.planes[R]);
            return this;
          }
          setFromProjectionMatrix(_) {
            let I = this.planes,
              R = _.elements,
              B = R[0],
              z = R[1],
              k = R[2],
              V = R[3],
              j = R[4],
              G = R[5],
              q = R[6],
              X = R[7],
              Q = R[8],
              $ = R[9],
              et = R[10],
              er = R[11],
              es = R[12],
              ea = R[13],
              en = R[14],
              eo = R[15];
            return (
              I[0].setComponents(V - B, X - j, er - Q, eo - es).normalize(),
              I[1].setComponents(V + B, X + j, er + Q, eo + es).normalize(),
              I[2].setComponents(V + z, X + G, er + $, eo + ea).normalize(),
              I[3].setComponents(V - z, X - G, er - $, eo - ea).normalize(),
              I[4].setComponents(V - k, X - q, er - et, eo - en).normalize(),
              I[5].setComponents(V + k, X + q, er + et, eo + en).normalize(),
              this
            );
          }
          intersectsObject(_) {
            let I = _.geometry;
            return (
              null === I.boundingSphere && I.computeBoundingSphere(),
              aj.copy(I.boundingSphere).applyMatrix4(_.matrixWorld),
              this.intersectsSphere(aj)
            );
          }
          intersectsSprite(_) {
            return (
              aj.center.set(0, 0, 0),
              (aj.radius = 0.7071067811865476),
              aj.applyMatrix4(_.matrixWorld),
              this.intersectsSphere(aj)
            );
          }
          intersectsSphere(_) {
            let I = this.planes,
              R = _.center,
              B = -_.radius;
            for (let _ = 0; _ < 6; _++)
              if (I[_].distanceToPoint(R) < B) return !1;
            return !0;
          }
          intersectsBox(_) {
            let I = this.planes;
            for (let R = 0; R < 6; R++) {
              let B = I[R];
              if (
                ((aH.x = B.normal.x > 0 ? _.max.x : _.min.x),
                (aH.y = B.normal.y > 0 ? _.max.y : _.min.y),
                (aH.z = B.normal.z > 0 ? _.max.z : _.min.z),
                0 > B.distanceToPoint(aH))
              )
                return !1;
            }
            return !0;
          }
          containsPoint(_) {
            let I = this.planes;
            for (let R = 0; R < 6; R++)
              if (0 > I[R].distanceToPoint(_)) return !1;
            return !0;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        };
      function KM() {
        let _ = null,
          I = !1,
          R = null,
          B = null;
        function i(I, z) {
          R(I, z), (B = _.requestAnimationFrame(i));
        }
        return {
          start: function () {
            !0 !== I &&
              null !== R &&
              ((B = _.requestAnimationFrame(i)), (I = !0));
          },
          stop: function () {
            _.cancelAnimationFrame(B), (I = !1);
          },
          setAnimationLoop: function (_) {
            R = _;
          },
          setContext: function (I) {
            _ = I;
          },
        };
      }
      function Pk(_, I) {
        let R = I.isWebGL2,
          B = new WeakMap();
        return {
          get: function (_) {
            return _.isInterleavedBufferAttribute && (_ = _.data), B.get(_);
          },
          remove: function (I) {
            I.isInterleavedBufferAttribute && (I = I.data);
            let R = B.get(I);
            R && (_.deleteBuffer(R.buffer), B.delete(I));
          },
          update: function (I, z) {
            var k, V;
            let j, G;
            if (I.isGLBufferAttribute) {
              let _ = B.get(I);
              (!_ || _.version < I.version) &&
                B.set(I, {
                  buffer: I.buffer,
                  type: I.type,
                  bytesPerElement: I.elementSize,
                  version: I.version,
                });
              return;
            }
            I.isInterleavedBufferAttribute && (I = I.data);
            let q = B.get(I);
            void 0 === q
              ? B.set(
                  I,
                  (function (I, B) {
                    let z,
                      k = I.array,
                      V = I.usage,
                      j = _.createBuffer();
                    if (
                      (_.bindBuffer(B, j),
                      _.bufferData(B, k, V),
                      I.onUploadCallback(),
                      k instanceof Float32Array)
                    )
                      z = 5126;
                    else if (k instanceof Uint16Array) {
                      if (I.isFloat16BufferAttribute) {
                        if (R) z = 5131;
                        else
                          throw Error(
                            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                          );
                      } else z = 5123;
                    } else if (k instanceof Int16Array) z = 5122;
                    else if (k instanceof Uint32Array) z = 5125;
                    else if (k instanceof Int32Array) z = 5124;
                    else if (k instanceof Int8Array) z = 5120;
                    else if (k instanceof Uint8Array) z = 5121;
                    else if (k instanceof Uint8ClampedArray) z = 5121;
                    else
                      throw Error(
                        "THREE.WebGLAttributes: Unsupported buffer data format: " +
                          k
                      );
                    return {
                      buffer: j,
                      type: z,
                      bytesPerElement: k.BYTES_PER_ELEMENT,
                      version: I.version,
                    };
                  })(I, z)
                )
              : q.version < I.version &&
                ((k = q.buffer),
                (j = (V = I).array),
                (G = V.updateRange),
                _.bindBuffer(z, k),
                -1 === G.count
                  ? _.bufferSubData(z, 0, j)
                  : (R
                      ? _.bufferSubData(
                          z,
                          G.offset * j.BYTES_PER_ELEMENT,
                          j,
                          G.offset,
                          G.count
                        )
                      : _.bufferSubData(
                          z,
                          G.offset * j.BYTES_PER_ELEMENT,
                          j.subarray(G.offset, G.offset + G.count)
                        ),
                    (G.count = -1)),
                V.onUploadCallback(),
                (q.version = I.version));
          },
        };
      }
      var aq = class extends ai {
          constructor(_ = 1, I = 1, R = 1, B = 1) {
            super(),
              (this.type = "PlaneGeometry"),
              (this.parameters = {
                width: _,
                height: I,
                widthSegments: R,
                heightSegments: B,
              });
            let z = _ / 2,
              k = I / 2,
              V = Math.floor(R),
              j = Math.floor(B),
              G = V + 1,
              q = j + 1,
              X = _ / V,
              Q = I / j,
              $ = [],
              et = [],
              er = [],
              es = [];
            for (let _ = 0; _ < q; _++) {
              let I = _ * Q - k;
              for (let R = 0; R < G; R++) {
                let B = R * X - z;
                et.push(B, -I, 0),
                  er.push(0, 0, 1),
                  es.push(R / V),
                  es.push(1 - _ / j);
              }
            }
            for (let _ = 0; _ < j; _++)
              for (let I = 0; I < V; I++) {
                let R = I + G * _,
                  B = I + G * (_ + 1),
                  z = I + 1 + G * (_ + 1),
                  k = I + 1 + G * _;
                $.push(R, B, k), $.push(B, z, k);
              }
            this.setIndex($),
              this.setAttribute("position", new s4(et, 3)),
              this.setAttribute("normal", new s4(er, 3)),
              this.setAttribute("uv", new s4(es, 2));
          }
          static fromJSON(_) {
            return new aq(_.width, _.height, _.widthSegments, _.heightSegments);
          }
        },
        aY = {
          alphamap_fragment: `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
          alphamap_pars_fragment: `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
          alphatest_fragment: `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
          alphatest_pars_fragment: `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
          aomap_fragment: `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
          aomap_pars_fragment: `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
          begin_vertex: "vec3 transformed = vec3( position );",
          beginnormal_vertex: `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
          bsdfs: `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,
          iridescence_fragment: `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
          bumpmap_pars_fragment: `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
          clipping_planes_fragment: `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
          clipping_planes_pars_fragment: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
          clipping_planes_pars_vertex: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
          clipping_planes_vertex: `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
          color_fragment: `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
          color_pars_fragment: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
          color_pars_vertex: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
          color_vertex: `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
          common: `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
          cube_uv_reflection_fragment: `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
          defaultnormal_vertex: `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
          displacementmap_pars_vertex: `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
          displacementmap_vertex: `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
          emissivemap_fragment: `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
          emissivemap_pars_fragment: `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
          encodings_fragment:
            "gl_FragColor = linearToOutputTexel( gl_FragColor );",
          encodings_pars_fragment: `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
          envmap_fragment: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
          envmap_common_pars_fragment: `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
          envmap_pars_fragment: `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
          envmap_pars_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
          envmap_physical_pars_fragment: `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
          envmap_vertex: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
          fog_vertex: `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
          fog_pars_vertex: `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
          fog_fragment: `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
          fog_pars_fragment: `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
          gradientmap_pars_fragment: `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
          lightmap_fragment: `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
          lightmap_pars_fragment: `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
          lights_lambert_fragment: `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
          lights_lambert_pars_fragment: `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
          lights_pars_begin: `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
          lights_toon_fragment: `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
          lights_toon_pars_fragment: `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
          lights_phong_fragment: `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
          lights_phong_pars_fragment: `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
          lights_physical_fragment: `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,
          lights_physical_pars_fragment: `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
          lights_fragment_begin: `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
          lights_fragment_maps: `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
          lights_fragment_end: `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
          logdepthbuf_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
          logdepthbuf_pars_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
          logdepthbuf_pars_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
          logdepthbuf_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
          map_fragment: `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
          map_pars_fragment: `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
          map_particle_fragment: `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
          map_particle_pars_fragment: `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
          metalnessmap_fragment: `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
          metalnessmap_pars_fragment: `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
          morphcolor_vertex: `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
          morphnormal_vertex: `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
          morphtarget_pars_vertex: `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
          morphtarget_vertex: `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
          normal_fragment_begin: `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
          normal_fragment_maps: `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
          normal_pars_fragment: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
          normal_pars_vertex: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
          normal_vertex: `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
          normalmap_pars_fragment: `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
          clearcoat_normal_fragment_begin: `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
          clearcoat_normal_fragment_maps: `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
          clearcoat_pars_fragment: `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
          iridescence_pars_fragment: `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
          output_fragment: `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
          packing: `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
          premultiplied_alpha_fragment: `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
          project_vertex: `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
          dithering_fragment: `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
          dithering_pars_fragment: `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
          roughnessmap_fragment: `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
          roughnessmap_pars_fragment: `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
          shadowmap_pars_fragment: `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
          shadowmap_pars_vertex: `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
          shadowmap_vertex: `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
          shadowmask_pars_fragment: `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
          skinbase_vertex: `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
          skinning_pars_vertex: `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
          skinning_vertex: `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
          skinnormal_vertex: `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
          specularmap_fragment: `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
          specularmap_pars_fragment: `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
          tonemapping_fragment: `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
          tonemapping_pars_fragment: `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
          transmission_fragment: `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,
          transmission_pars_fragment: `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
          uv_pars_fragment: `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
          uv_pars_vertex: `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
          uv_vertex: `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
          uv2_pars_fragment: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
          uv2_pars_vertex: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
          uv2_vertex: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
          worldpos_vertex: `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
          background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
          background_frag: `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
          backgroundCube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
          backgroundCube_frag: `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
          cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
          cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
          depth_vert: `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
          depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
          distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
          distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
          equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
          equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
          linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
          linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
          meshbasic_vert: `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
          meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
          meshlambert_vert: `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
          meshlambert_frag: `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
          meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
          meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
          meshnormal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
          meshnormal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
          meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
          meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
          meshphysical_vert: `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
          meshphysical_frag: `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
          meshtoon_vert: `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
          meshtoon_frag: `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
          points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
          points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
          shadow_vert: `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
          shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
          sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
          sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
        },
        aX = {
          common: {
            diffuse: { value: new ry(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            uvTransform: { value: new ro() },
            uv2Transform: { value: new ro() },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
          },
          specularmap: { specularMap: { value: null } },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            ior: { value: 1.5 },
            refractionRatio: { value: 0.98 },
          },
          aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
          },
          emissivemap: { emissiveMap: { value: null } },
          bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
          normalmap: {
            normalMap: { value: null },
            normalScale: { value: new rs(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          roughnessmap: { roughnessMap: { value: null } },
          metalnessmap: { metalnessMap: { value: null } },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new ry(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotLightMap: { value: [] },
            spotShadowMap: { value: [] },
            spotLightMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new ry(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new ro() },
          },
          sprite: {
            diffuse: { value: new ry(16777215) },
            opacity: { value: 1 },
            center: { value: new rs(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new ro() },
          },
        },
        aQ = {
          basic: {
            uniforms: bn([
              aX.common,
              aX.specularmap,
              aX.envmap,
              aX.aomap,
              aX.lightmap,
              aX.fog,
            ]),
            vertexShader: aY.meshbasic_vert,
            fragmentShader: aY.meshbasic_frag,
          },
          lambert: {
            uniforms: bn([
              aX.common,
              aX.specularmap,
              aX.envmap,
              aX.aomap,
              aX.lightmap,
              aX.emissivemap,
              aX.bumpmap,
              aX.normalmap,
              aX.displacementmap,
              aX.fog,
              aX.lights,
              { emissive: { value: new ry(0) } },
            ]),
            vertexShader: aY.meshlambert_vert,
            fragmentShader: aY.meshlambert_frag,
          },
          phong: {
            uniforms: bn([
              aX.common,
              aX.specularmap,
              aX.envmap,
              aX.aomap,
              aX.lightmap,
              aX.emissivemap,
              aX.bumpmap,
              aX.normalmap,
              aX.displacementmap,
              aX.fog,
              aX.lights,
              {
                emissive: { value: new ry(0) },
                specular: { value: new ry(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: aY.meshphong_vert,
            fragmentShader: aY.meshphong_frag,
          },
          standard: {
            uniforms: bn([
              aX.common,
              aX.envmap,
              aX.aomap,
              aX.lightmap,
              aX.emissivemap,
              aX.bumpmap,
              aX.normalmap,
              aX.displacementmap,
              aX.roughnessmap,
              aX.metalnessmap,
              aX.fog,
              aX.lights,
              {
                emissive: { value: new ry(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: aY.meshphysical_vert,
            fragmentShader: aY.meshphysical_frag,
          },
          toon: {
            uniforms: bn([
              aX.common,
              aX.aomap,
              aX.lightmap,
              aX.emissivemap,
              aX.bumpmap,
              aX.normalmap,
              aX.displacementmap,
              aX.gradientmap,
              aX.fog,
              aX.lights,
              { emissive: { value: new ry(0) } },
            ]),
            vertexShader: aY.meshtoon_vert,
            fragmentShader: aY.meshtoon_frag,
          },
          matcap: {
            uniforms: bn([
              aX.common,
              aX.bumpmap,
              aX.normalmap,
              aX.displacementmap,
              aX.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: aY.meshmatcap_vert,
            fragmentShader: aY.meshmatcap_frag,
          },
          points: {
            uniforms: bn([aX.points, aX.fog]),
            vertexShader: aY.points_vert,
            fragmentShader: aY.points_frag,
          },
          dashed: {
            uniforms: bn([
              aX.common,
              aX.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: aY.linedashed_vert,
            fragmentShader: aY.linedashed_frag,
          },
          depth: {
            uniforms: bn([aX.common, aX.displacementmap]),
            vertexShader: aY.depth_vert,
            fragmentShader: aY.depth_frag,
          },
          normal: {
            uniforms: bn([
              aX.common,
              aX.bumpmap,
              aX.normalmap,
              aX.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: aY.meshnormal_vert,
            fragmentShader: aY.meshnormal_frag,
          },
          sprite: {
            uniforms: bn([aX.sprite, aX.fog]),
            vertexShader: aY.sprite_vert,
            fragmentShader: aY.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: { value: new ro() },
              t2D: { value: null },
              backgroundIntensity: { value: 1 },
            },
            vertexShader: aY.background_vert,
            fragmentShader: aY.background_frag,
          },
          backgroundCube: {
            uniforms: {
              envMap: { value: null },
              flipEnvMap: { value: -1 },
              backgroundBlurriness: { value: 0 },
              backgroundIntensity: { value: 1 },
            },
            vertexShader: aY.backgroundCube_vert,
            fragmentShader: aY.backgroundCube_frag,
          },
          cube: {
            uniforms: {
              tCube: { value: null },
              tFlip: { value: -1 },
              opacity: { value: 1 },
            },
            vertexShader: aY.cube_vert,
            fragmentShader: aY.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: aY.equirect_vert,
            fragmentShader: aY.equirect_frag,
          },
          distanceRGBA: {
            uniforms: bn([
              aX.common,
              aX.displacementmap,
              {
                referencePosition: { value: new rF() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: aY.distanceRGBA_vert,
            fragmentShader: aY.distanceRGBA_frag,
          },
          shadow: {
            uniforms: bn([
              aX.lights,
              aX.fog,
              { color: { value: new ry(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: aY.shadow_vert,
            fragmentShader: aY.shadow_frag,
          },
        };
      aQ.physical = {
        uniforms: bn([
          aQ.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatNormalScale: { value: new rs(1, 1) },
            clearcoatNormalMap: { value: null },
            iridescence: { value: 0 },
            iridescenceMap: { value: null },
            iridescenceIOR: { value: 1.3 },
            iridescenceThicknessMinimum: { value: 100 },
            iridescenceThicknessMaximum: { value: 400 },
            iridescenceThicknessMap: { value: null },
            sheen: { value: 0 },
            sheenColor: { value: new ry(0) },
            sheenColorMap: { value: null },
            sheenRoughness: { value: 1 },
            sheenRoughnessMap: { value: null },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionSamplerSize: { value: new rs() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new ry(0) },
            specularIntensity: { value: 1 },
            specularIntensityMap: { value: null },
            specularColor: { value: new ry(1, 1, 1) },
            specularColorMap: { value: null },
          },
        ]),
        vertexShader: aY.meshphysical_vert,
        fragmentShader: aY.meshphysical_frag,
      };
      var aZ = { r: 0, b: 0, g: 0 };
      function lU(_, I, R, B, z, k, V) {
        let j = new ry(0),
          G = !0 === k ? 0 : 1,
          q,
          X,
          Q = null,
          $ = 0,
          et = null;
        function m(I, R) {
          I.getRGB(aZ, QM(_)), B.buffers.color.setClear(aZ.r, aZ.g, aZ.b, R, V);
        }
        return {
          getClearColor: function () {
            return j;
          },
          setClearColor: function (_, I = 1) {
            j.set(_), m(j, (G = I));
          },
          getClearAlpha: function () {
            return G;
          },
          setClearAlpha: function (_) {
            m(j, (G = _));
          },
          render: function (B, k) {
            let V = !1,
              er = !0 === k.isScene ? k.background : null;
            er &&
              er.isTexture &&
              (er = (k.backgroundBlurriness > 0 ? R : I).get(er));
            let es = _.xr,
              ea = es.getSession && es.getSession();
            ea && "additive" === ea.environmentBlendMode && (er = null),
              null === er ? m(j, G) : er && er.isColor && (m(er, 1), (V = !0)),
              (_.autoClear || V) &&
                _.clear(_.autoClearColor, _.autoClearDepth, _.autoClearStencil),
              er && (er.isCubeTexture || 306 === er.mapping)
                ? (void 0 === X &&
                    ((X = new aw(
                      new aS(1, 1, 1),
                      new aT({
                        name: "BackgroundCubeMaterial",
                        uniforms: Gu(aQ.backgroundCube.uniforms),
                        vertexShader: aQ.backgroundCube.vertexShader,
                        fragmentShader: aQ.backgroundCube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      })
                    )).geometry.deleteAttribute("normal"),
                    X.geometry.deleteAttribute("uv"),
                    (X.onBeforeRender = function (_, I, R) {
                      this.matrixWorld.copyPosition(R.matrixWorld);
                    }),
                    Object.defineProperty(X.material, "envMap", {
                      get: function () {
                        return this.uniforms.envMap.value;
                      },
                    }),
                    z.update(X)),
                  (X.material.uniforms.envMap.value = er),
                  (X.material.uniforms.flipEnvMap.value =
                    er.isCubeTexture && !1 === er.isRenderTargetTexture
                      ? -1
                      : 1),
                  (X.material.uniforms.backgroundBlurriness.value =
                    k.backgroundBlurriness),
                  (X.material.uniforms.backgroundIntensity.value =
                    k.backgroundIntensity),
                  (X.material.toneMapped = 3001 !== er.encoding),
                  (Q !== er || $ !== er.version || et !== _.toneMapping) &&
                    ((X.material.needsUpdate = !0),
                    (Q = er),
                    ($ = er.version),
                    (et = _.toneMapping)),
                  X.layers.enableAll(),
                  B.unshift(X, X.geometry, X.material, 0, 0, null))
                : er &&
                  er.isTexture &&
                  (void 0 === q &&
                    ((q = new aw(
                      new aq(2, 2),
                      new aT({
                        name: "BackgroundMaterial",
                        uniforms: Gu(aQ.background.uniforms),
                        vertexShader: aQ.background.vertexShader,
                        fragmentShader: aQ.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      })
                    )).geometry.deleteAttribute("normal"),
                    Object.defineProperty(q.material, "map", {
                      get: function () {
                        return this.uniforms.t2D.value;
                      },
                    }),
                    z.update(q)),
                  (q.material.uniforms.t2D.value = er),
                  (q.material.uniforms.backgroundIntensity.value =
                    k.backgroundIntensity),
                  (q.material.toneMapped = 3001 !== er.encoding),
                  !0 === er.matrixAutoUpdate && er.updateMatrix(),
                  q.material.uniforms.uvTransform.value.copy(er.matrix),
                  (Q !== er || $ !== er.version || et !== _.toneMapping) &&
                    ((q.material.needsUpdate = !0),
                    (Q = er),
                    ($ = er.version),
                    (et = _.toneMapping)),
                  q.layers.enableAll(),
                  B.unshift(q, q.geometry, q.material, 0, 0, null));
          },
        };
      }
      function cU(_, I, R, B) {
        let z = _.getParameter(34921),
          k = B.isWebGL2 ? null : I.get("OES_vertex_array_object"),
          V = B.isWebGL2 || null !== k,
          j = {},
          G = g(null),
          q = G,
          X = !1;
        function f(I) {
          return B.isWebGL2 ? _.bindVertexArray(I) : k.bindVertexArrayOES(I);
        }
        function p(I) {
          return B.isWebGL2
            ? _.deleteVertexArray(I)
            : k.deleteVertexArrayOES(I);
        }
        function g(_) {
          let I = [],
            R = [],
            B = [];
          for (let _ = 0; _ < z; _++) (I[_] = 0), (R[_] = 0), (B[_] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: I,
            enabledAttributes: R,
            attributeDivisors: B,
            object: _,
            attributes: {},
            index: null,
          };
        }
        function x() {
          let _ = q.newAttributes;
          for (let I = 0, R = _.length; I < R; I++) _[I] = 0;
        }
        function S(_) {
          w(_, 0);
        }
        function w(R, z) {
          let k = q.newAttributes,
            V = q.enabledAttributes,
            j = q.attributeDivisors;
          (k[R] = 1),
            0 === V[R] && (_.enableVertexAttribArray(R), (V[R] = 1)),
            j[R] !== z &&
              ((B.isWebGL2 ? _ : I.get("ANGLE_instanced_arrays"))[
                B.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
              ](R, z),
              (j[R] = z));
        }
        function A() {
          let I = q.newAttributes,
            R = q.enabledAttributes;
          for (let B = 0, z = R.length; B < z; B++)
            R[B] !== I[B] && (_.disableVertexAttribArray(B), (R[B] = 0));
        }
        function E(I, R, z, k, V, j) {
          !0 === B.isWebGL2 && (5124 === z || 5125 === z)
            ? _.vertexAttribIPointer(I, R, z, V, j)
            : _.vertexAttribPointer(I, R, z, k, V, j);
        }
        function P() {
          D(), (X = !0), q !== G && f((q = G).object);
        }
        function D() {
          (G.geometry = null), (G.program = null), (G.wireframe = !1);
        }
        return {
          setup: function (z, G, Q, $, et) {
            let er = !1;
            if (V) {
              let I, R, V, X;
              let es =
                ((I = !0 === G.wireframe),
                void 0 === (R = j[$.id]) && ((R = {}), (j[$.id] = R)),
                void 0 === (V = R[Q.id]) && ((V = {}), (R[Q.id] = V)),
                void 0 === (X = V[I]) &&
                  ((X = g(
                    B.isWebGL2
                      ? _.createVertexArray()
                      : k.createVertexArrayOES()
                  )),
                  (V[I] = X)),
                X);
              q !== es && f((q = es).object),
                (er = (function (_, I, R, B) {
                  let z = q.attributes,
                    k = I.attributes,
                    V = 0,
                    j = R.getAttributes();
                  for (let I in j)
                    if (j[I].location >= 0) {
                      let R = z[I],
                        B = k[I];
                      if (
                        (void 0 === B &&
                          ("instanceMatrix" === I &&
                            _.instanceMatrix &&
                            (B = _.instanceMatrix),
                          "instanceColor" === I &&
                            _.instanceColor &&
                            (B = _.instanceColor)),
                        void 0 === R ||
                          R.attribute !== B ||
                          (B && R.data !== B.data))
                      )
                        return !0;
                      V++;
                    }
                  return q.attributesNum !== V || q.index !== B;
                })(z, $, Q, et)) &&
                  (function (_, I, R, B) {
                    let z = {},
                      k = I.attributes,
                      V = 0,
                      j = R.getAttributes();
                    for (let I in j)
                      if (j[I].location >= 0) {
                        let R = k[I];
                        void 0 === R &&
                          ("instanceMatrix" === I &&
                            _.instanceMatrix &&
                            (R = _.instanceMatrix),
                          "instanceColor" === I &&
                            _.instanceColor &&
                            (R = _.instanceColor));
                        let B = {};
                        (B.attribute = R),
                          R && R.data && (B.data = R.data),
                          (z[I] = B),
                          V++;
                      }
                    (q.attributes = z), (q.attributesNum = V), (q.index = B);
                  })(z, $, Q, et);
            } else {
              let _ = !0 === G.wireframe;
              (q.geometry !== $.id ||
                q.program !== Q.id ||
                q.wireframe !== _) &&
                ((q.geometry = $.id),
                (q.program = Q.id),
                (q.wireframe = _),
                (er = !0));
            }
            null !== et && R.update(et, 34963),
              (er || X) &&
                ((X = !1),
                (function (z, k, V, j) {
                  if (
                    !1 === B.isWebGL2 &&
                    (z.isInstancedMesh || j.isInstancedBufferGeometry) &&
                    null === I.get("ANGLE_instanced_arrays")
                  )
                    return;
                  x();
                  let G = j.attributes,
                    q = V.getAttributes(),
                    X = k.defaultAttributeValues;
                  for (let I in q) {
                    let B = q[I];
                    if (B.location >= 0) {
                      let k = G[I];
                      if (
                        (void 0 === k &&
                          ("instanceMatrix" === I &&
                            z.instanceMatrix &&
                            (k = z.instanceMatrix),
                          "instanceColor" === I &&
                            z.instanceColor &&
                            (k = z.instanceColor)),
                        void 0 !== k)
                      ) {
                        let I = k.normalized,
                          V = k.itemSize,
                          G = R.get(k);
                        if (void 0 === G) continue;
                        let q = G.buffer,
                          X = G.type,
                          Q = G.bytesPerElement;
                        if (k.isInterleavedBufferAttribute) {
                          let R = k.data,
                            G = R.stride,
                            $ = k.offset;
                          if (R.isInstancedInterleavedBuffer) {
                            for (let _ = 0; _ < B.locationSize; _++)
                              w(B.location + _, R.meshPerAttribute);
                            !0 !== z.isInstancedMesh &&
                              void 0 === j._maxInstanceCount &&
                              (j._maxInstanceCount =
                                R.meshPerAttribute * R.count);
                          } else
                            for (let _ = 0; _ < B.locationSize; _++)
                              S(B.location + _);
                          _.bindBuffer(34962, q);
                          for (let _ = 0; _ < B.locationSize; _++)
                            E(
                              B.location + _,
                              V / B.locationSize,
                              X,
                              I,
                              G * Q,
                              ($ + (V / B.locationSize) * _) * Q
                            );
                        } else {
                          if (k.isInstancedBufferAttribute) {
                            for (let _ = 0; _ < B.locationSize; _++)
                              w(B.location + _, k.meshPerAttribute);
                            !0 !== z.isInstancedMesh &&
                              void 0 === j._maxInstanceCount &&
                              (j._maxInstanceCount =
                                k.meshPerAttribute * k.count);
                          } else
                            for (let _ = 0; _ < B.locationSize; _++)
                              S(B.location + _);
                          _.bindBuffer(34962, q);
                          for (let _ = 0; _ < B.locationSize; _++)
                            E(
                              B.location + _,
                              V / B.locationSize,
                              X,
                              I,
                              V * Q,
                              (V / B.locationSize) * _ * Q
                            );
                        }
                      } else if (void 0 !== X) {
                        let R = X[I];
                        if (void 0 !== R)
                          switch (R.length) {
                            case 2:
                              _.vertexAttrib2fv(B.location, R);
                              break;
                            case 3:
                              _.vertexAttrib3fv(B.location, R);
                              break;
                            case 4:
                              _.vertexAttrib4fv(B.location, R);
                              break;
                            default:
                              _.vertexAttrib1fv(B.location, R);
                          }
                      }
                    }
                  }
                  A();
                })(z, G, Q, $),
                null !== et && _.bindBuffer(34963, R.get(et).buffer));
          },
          reset: P,
          resetDefaultState: D,
          dispose: function () {
            for (let _ in (P(), j)) {
              let I = j[_];
              for (let _ in I) {
                let R = I[_];
                for (let _ in R) p(R[_].object), delete R[_];
                delete I[_];
              }
              delete j[_];
            }
          },
          releaseStatesOfGeometry: function (_) {
            if (void 0 === j[_.id]) return;
            let I = j[_.id];
            for (let _ in I) {
              let R = I[_];
              for (let _ in R) p(R[_].object), delete R[_];
              delete I[_];
            }
            delete j[_.id];
          },
          releaseStatesOfProgram: function (_) {
            for (let I in j) {
              let R = j[I];
              if (void 0 === R[_.id]) continue;
              let B = R[_.id];
              for (let _ in B) p(B[_].object), delete B[_];
              delete R[_.id];
            }
          },
          initAttributes: x,
          enableAttribute: S,
          disableUnusedAttributes: A,
        };
      }
      function uU(_, I, R, B) {
        let z = B.isWebGL2,
          k;
        (this.setMode = function (_) {
          k = _;
        }),
          (this.render = function (I, B) {
            _.drawArrays(k, I, B), R.update(B, k, 1);
          }),
          (this.renderInstances = function (B, V, j) {
            let G, q;
            if (0 !== j) {
              if (z) (G = _), (q = "drawArraysInstanced");
              else if (
                ((G = I.get("ANGLE_instanced_arrays")),
                (q = "drawArraysInstancedANGLE"),
                null === G)
              ) {
                console.error(
                  "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
                return;
              }
              G[q](k, B, V, j), R.update(V, k, j);
            }
          });
      }
      function hU(_, I, R) {
        let B;
        function s(I) {
          if ("highp" === I) {
            if (
              _.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
              _.getShaderPrecisionFormat(35632, 36338).precision > 0
            )
              return "highp";
            I = "mediump";
          }
          return "mediump" === I &&
            _.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
            _.getShaderPrecisionFormat(35632, 36337).precision > 0
            ? "mediump"
            : "lowp";
        }
        let z =
            "u" > typeof WebGL2RenderingContext &&
            _ instanceof WebGL2RenderingContext,
          k = void 0 !== R.precision ? R.precision : "highp",
          V = s(k);
        V !== k &&
          (console.warn(
            "THREE.WebGLRenderer:",
            k,
            "not supported, using",
            V,
            "instead."
          ),
          (k = V));
        let j = z || I.has("WEBGL_draw_buffers"),
          G = !0 === R.logarithmicDepthBuffer,
          q = _.getParameter(34930),
          X = _.getParameter(35660),
          Q = _.getParameter(3379),
          $ = _.getParameter(34076),
          et = _.getParameter(34921),
          er = _.getParameter(36347),
          es = _.getParameter(36348),
          ea = _.getParameter(36349),
          en = X > 0,
          eo = z || I.has("OES_texture_float"),
          el = z ? _.getParameter(36183) : 0;
        return {
          isWebGL2: z,
          drawBuffers: j,
          getMaxAnisotropy: function () {
            if (void 0 !== B) return B;
            if (!0 === I.has("EXT_texture_filter_anisotropic")) {
              let R = I.get("EXT_texture_filter_anisotropic");
              B = _.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else B = 0;
            return B;
          },
          getMaxPrecision: s,
          precision: k,
          logarithmicDepthBuffer: G,
          maxTextures: q,
          maxVertexTextures: X,
          maxTextureSize: Q,
          maxCubemapSize: $,
          maxAttributes: et,
          maxVertexUniforms: er,
          maxVaryings: es,
          maxFragmentUniforms: ea,
          vertexTextures: en,
          floatFragmentTextures: eo,
          floatVertexTextures: en && eo,
          maxSamples: el,
        };
      }
      function dU(_) {
        let I = this,
          R = null,
          B = 0,
          z = !1,
          k = !1,
          V = new aV(),
          j = new ro(),
          G = { value: null, needsUpdate: !1 };
        function c(_, R, B, z) {
          let k = null !== _ ? _.length : 0,
            q = null;
          if (0 !== k) {
            if (((q = G.value), !0 !== z || null === q)) {
              let I = B + 4 * k,
                z = R.matrixWorldInverse;
              j.getNormalMatrix(z),
                (null === q || q.length < I) && (q = new Float32Array(I));
              for (let I = 0, R = B; I !== k; ++I, R += 4)
                V.copy(_[I]).applyMatrix4(z, j),
                  V.normal.toArray(q, R),
                  (q[R + 3] = V.constant);
            }
            (G.value = q), (G.needsUpdate = !0);
          }
          return (I.numPlanes = k), (I.numIntersection = 0), q;
        }
        (this.uniform = G),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (_, I) {
            let R = 0 !== _.length || I || 0 !== B || z;
            return (z = I), (B = _.length), R;
          }),
          (this.beginShadows = function () {
            (k = !0), c(null);
          }),
          (this.endShadows = function () {
            k = !1;
          }),
          (this.setGlobalState = function (_, I) {
            R = c(_, I, 0);
          }),
          (this.setState = function (V, j, q) {
            let X = V.clippingPlanes,
              Q = V.clipIntersection,
              $ = V.clipShadows,
              et = _.get(V);
            if (z && null !== X && 0 !== X.length && (!k || $)) {
              let _ = k ? 0 : B,
                I = 4 * _,
                z = et.clippingState || null;
              (G.value = z), (z = c(X, j, I, q));
              for (let _ = 0; _ !== I; ++_) z[_] = R[_];
              (et.clippingState = z),
                (this.numIntersection = Q ? this.numPlanes : 0),
                (this.numPlanes += _);
            } else
              k
                ? c(null)
                : (G.value !== R && ((G.value = R), (G.needsUpdate = B > 0)),
                  (I.numPlanes = B),
                  (I.numIntersection = 0));
          });
      }
      function fU(_) {
        let I = new WeakMap();
        function e(_, I) {
          return (
            303 === I ? (_.mapping = 301) : 304 === I && (_.mapping = 302), _
          );
        }
        function i(_) {
          let R = _.target;
          R.removeEventListener("dispose", i);
          let B = I.get(R);
          void 0 !== B && (I.delete(R), B.dispose());
        }
        return {
          get: function (R) {
            if (R && R.isTexture && !1 === R.isRenderTargetTexture) {
              let B = R.mapping;
              if (303 === B || 304 === B) {
                if (I.has(R)) return e(I.get(R).texture, R.mapping);
                {
                  let B = R.image;
                  if (!B || !(B.height > 0)) return null;
                  {
                    let z = new az(B.height / 2);
                    return (
                      z.fromEquirectangularTexture(_, R),
                      I.set(R, z),
                      R.addEventListener("dispose", i),
                      e(z.texture, R.mapping)
                    );
                  }
                }
              }
            }
            return R;
          },
          dispose: function () {
            I = new WeakMap();
          },
        };
      }
      var aK = class extends aP {
          constructor(_ = -1, I = 1, R = 1, B = -1, z = 0.1, k = 2e3) {
            super(),
              (this.isOrthographicCamera = !0),
              (this.type = "OrthographicCamera"),
              (this.zoom = 1),
              (this.view = null),
              (this.left = _),
              (this.right = I),
              (this.top = R),
              (this.bottom = B),
              (this.near = z),
              (this.far = k),
              this.updateProjectionMatrix();
          }
          copy(_, I) {
            return (
              super.copy(_, I),
              (this.left = _.left),
              (this.right = _.right),
              (this.top = _.top),
              (this.bottom = _.bottom),
              (this.near = _.near),
              (this.far = _.far),
              (this.zoom = _.zoom),
              (this.view = null === _.view ? null : Object.assign({}, _.view)),
              this
            );
          }
          setViewOffset(_, I, R, B, z, k) {
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
              (this.view.enabled = !0),
              (this.view.fullWidth = _),
              (this.view.fullHeight = I),
              (this.view.offsetX = R),
              (this.view.offsetY = B),
              (this.view.width = z),
              (this.view.height = k),
              this.updateProjectionMatrix();
          }
          clearViewOffset() {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix();
          }
          updateProjectionMatrix() {
            let _ = (this.right - this.left) / (2 * this.zoom),
              I = (this.top - this.bottom) / (2 * this.zoom),
              R = (this.right + this.left) / 2,
              B = (this.top + this.bottom) / 2,
              z = R - _,
              k = R + _,
              V = B + I,
              j = B - I;
            if (null !== this.view && this.view.enabled) {
              let _ =
                  (this.right - this.left) / this.view.fullWidth / this.zoom,
                I = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
              (z += _ * this.view.offsetX),
                (k = z + _ * this.view.width),
                (V -= I * this.view.offsetY),
                (j = V - I * this.view.height);
            }
            this.projectionMatrix.makeOrthographic(
              z,
              k,
              V,
              j,
              this.near,
              this.far
            ),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
          }
          toJSON(_) {
            let I = super.toJSON(_);
            return (
              (I.object.zoom = this.zoom),
              (I.object.left = this.left),
              (I.object.right = this.right),
              (I.object.top = this.top),
              (I.object.bottom = this.bottom),
              (I.object.near = this.near),
              (I.object.far = this.far),
              null !== this.view &&
                (I.object.view = Object.assign({}, this.view)),
              I
            );
          }
        },
        a$ = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        a0 = new aK(),
        a1 = new ry(),
        a2 = null,
        a3 = (1 + Math.sqrt(5)) / 2,
        a4 = 1 / a3,
        a5 = [
          new rF(1, 1, 1),
          new rF(-1, 1, 1),
          new rF(1, 1, -1),
          new rF(-1, 1, -1),
          new rF(0, a3, a4),
          new rF(0, a3, -a4),
          new rF(a4, 0, a3),
          new rF(-a4, 0, a3),
          new rF(a3, a4, 0),
          new rF(-a3, a4, 0),
        ],
        a6 = class {
          constructor(_) {
            (this._renderer = _),
              (this._pingPongRenderTarget = null),
              (this._lodMax = 0),
              (this._cubeSize = 0),
              (this._lodPlanes = []),
              (this._sizeLods = []),
              (this._sigmas = []),
              (this._blurMaterial = null),
              (this._cubemapMaterial = null),
              (this._equirectMaterial = null),
              this._compileMaterial(this._blurMaterial);
          }
          fromScene(_, I = 0, R = 0.1, B = 100) {
            (a2 = this._renderer.getRenderTarget()), this._setSize(256);
            let z = this._allocateTargets();
            return (
              (z.depthBuffer = !0),
              this._sceneToCubeUV(_, R, B, z),
              I > 0 && this._blur(z, 0, 0, I),
              this._applyPMREM(z),
              this._cleanup(z),
              z
            );
          }
          fromEquirectangular(_, I = null) {
            return this._fromTexture(_, I);
          }
          fromCubemap(_, I = null) {
            return this._fromTexture(_, I);
          }
          compileCubemapShader() {
            null === this._cubemapMaterial &&
              ((this._cubemapMaterial = tM()),
              this._compileMaterial(this._cubemapMaterial));
          }
          compileEquirectangularShader() {
            null === this._equirectMaterial &&
              ((this._equirectMaterial = eM()),
              this._compileMaterial(this._equirectMaterial));
          }
          dispose() {
            this._dispose(),
              null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
              null !== this._equirectMaterial &&
                this._equirectMaterial.dispose();
          }
          _setSize(_) {
            (this._lodMax = Math.floor(Math.log2(_))),
              (this._cubeSize = Math.pow(2, this._lodMax));
          }
          _dispose() {
            null !== this._blurMaterial && this._blurMaterial.dispose(),
              null !== this._pingPongRenderTarget &&
                this._pingPongRenderTarget.dispose();
            for (let _ = 0; _ < this._lodPlanes.length; _++)
              this._lodPlanes[_].dispose();
          }
          _cleanup(_) {
            this._renderer.setRenderTarget(a2),
              (_.scissorTest = !1),
              ty(_, 0, 0, _.width, _.height);
          }
          _fromTexture(_, I) {
            301 === _.mapping || 302 === _.mapping
              ? this._setSize(
                  0 === _.image.length
                    ? 16
                    : _.image[0].width || _.image[0].image.width
                )
              : this._setSize(_.image.width / 4),
              (a2 = this._renderer.getRenderTarget());
            let R = I || this._allocateTargets();
            return (
              this._textureToCubeUV(_, R),
              this._applyPMREM(R),
              this._cleanup(R),
              R
            );
          }
          _allocateTargets() {
            let _ = 3 * Math.max(this._cubeSize, 112),
              I = 4 * this._cubeSize,
              R = {
                magFilter: 1006,
                minFilter: 1006,
                generateMipmaps: !1,
                type: 1016,
                format: 1023,
                encoding: 3e3,
                depthBuffer: !1,
              },
              B = $T(_, I, R);
            if (
              null === this._pingPongRenderTarget ||
              this._pingPongRenderTarget.width !== _ ||
              this._pingPongRenderTarget.height !== I
            ) {
              let B, z;
              null !== this._pingPongRenderTarget && this._dispose(),
                (this._pingPongRenderTarget = $T(_, I, R));
              let { _lodMax: k } = this;
              ({
                sizeLods: this._sizeLods,
                lodPlanes: this._lodPlanes,
                sigmas: this._sigmas,
              } = (function (_) {
                let I = [],
                  R = [],
                  B = [],
                  z = _,
                  k = _ - 4 + 1 + a$.length;
                for (let V = 0; V < k; V++) {
                  let k = Math.pow(2, z);
                  R.push(k);
                  let j = 1 / k;
                  V > _ - 4 ? (j = a$[V - _ + 4 - 1]) : 0 === V && (j = 0),
                    B.push(j);
                  let G = 1 / (k - 2),
                    q = -G,
                    X = 1 + G,
                    Q = [q, q, X, q, X, X, q, q, X, X, q, X],
                    $ = new Float32Array(108),
                    et = new Float32Array(72),
                    er = new Float32Array(36);
                  for (let _ = 0; _ < 6; _++) {
                    let I = ((_ % 3) * 2) / 3 - 1,
                      R = _ > 2 ? 0 : -1,
                      B = [
                        I,
                        R,
                        0,
                        I + 2 / 3,
                        R,
                        0,
                        I + 2 / 3,
                        R + 1,
                        0,
                        I,
                        R,
                        0,
                        I + 2 / 3,
                        R + 1,
                        0,
                        I,
                        R + 1,
                        0,
                      ];
                    $.set(B, 18 * _), et.set(Q, 12 * _);
                    let z = [_, _, _, _, _, _];
                    er.set(z, 6 * _);
                  }
                  let es = new ai();
                  es.setAttribute("position", new s0($, 3)),
                    es.setAttribute("uv", new s0(et, 2)),
                    es.setAttribute("faceIndex", new s0(er, 1)),
                    I.push(es),
                    z > 4 && z--;
                }
                return { lodPlanes: I, sizeLods: R, sigmas: B };
              })(k)),
                (this._blurMaterial =
                  ((B = new Float32Array(20)),
                  (z = new rF(0, 1, 0)),
                  new aT({
                    name: "SphericalGaussianBlur",
                    defines: {
                      n: 20,
                      CUBEUV_TEXEL_WIDTH: 1 / _,
                      CUBEUV_TEXEL_HEIGHT: 1 / I,
                      CUBEUV_MAX_MIP: `${k}.0`,
                    },
                    uniforms: {
                      envMap: { value: null },
                      samples: { value: 1 },
                      weights: { value: B },
                      latitudinal: { value: !1 },
                      dTheta: { value: 0 },
                      mipInt: { value: 0 },
                      poleAxis: { value: z },
                    },
                    vertexShader: Pw(),
                    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1,
                  })));
            }
            return B;
          }
          _compileMaterial(_) {
            let I = new aw(this._lodPlanes[0], _);
            this._renderer.compile(I, a0);
          }
          _sceneToCubeUV(_, I, R, B) {
            let z = new aI(90, 1, I, R),
              k = [1, -1, 1, 1, 1, 1],
              V = [1, 1, 1, -1, -1, -1],
              j = this._renderer,
              G = j.autoClear,
              q = j.toneMapping;
            j.getClearColor(a1), (j.toneMapping = 0), (j.autoClear = !1);
            let X = new sK({
                name: "PMREM.Background",
                side: 1,
                depthWrite: !1,
                depthTest: !1,
              }),
              Q = new aw(new aS(), X),
              $ = !1,
              et = _.background;
            et
              ? et.isColor &&
                (X.color.copy(et), (_.background = null), ($ = !0))
              : (X.color.copy(a1), ($ = !0));
            for (let I = 0; I < 6; I++) {
              let R = I % 3;
              0 === R
                ? (z.up.set(0, k[I], 0), z.lookAt(V[I], 0, 0))
                : 1 === R
                ? (z.up.set(0, 0, k[I]), z.lookAt(0, V[I], 0))
                : (z.up.set(0, k[I], 0), z.lookAt(0, 0, V[I]));
              let G = this._cubeSize;
              ty(B, R * G, I > 2 ? G : 0, G, G),
                j.setRenderTarget(B),
                $ && j.render(Q, z),
                j.render(_, z);
            }
            Q.geometry.dispose(),
              Q.material.dispose(),
              (j.toneMapping = q),
              (j.autoClear = G),
              (_.background = et);
          }
          _textureToCubeUV(_, I) {
            let R = this._renderer,
              B = 301 === _.mapping || 302 === _.mapping;
            B
              ? (null === this._cubemapMaterial &&
                  (this._cubemapMaterial = tM()),
                (this._cubemapMaterial.uniforms.flipEnvMap.value =
                  !1 === _.isRenderTargetTexture ? -1 : 1))
              : null === this._equirectMaterial &&
                (this._equirectMaterial = eM());
            let z = B ? this._cubemapMaterial : this._equirectMaterial,
              k = new aw(this._lodPlanes[0], z);
            z.uniforms.envMap.value = _;
            let V = this._cubeSize;
            ty(I, 0, 0, 3 * V, 2 * V), R.setRenderTarget(I), R.render(k, a0);
          }
          _applyPMREM(_) {
            let I = this._renderer,
              R = I.autoClear;
            I.autoClear = !1;
            for (let I = 1; I < this._lodPlanes.length; I++) {
              let R = Math.sqrt(
                  this._sigmas[I] * this._sigmas[I] -
                    this._sigmas[I - 1] * this._sigmas[I - 1]
                ),
                B = a5[(I - 1) % a5.length];
              this._blur(_, I - 1, I, R, B);
            }
            I.autoClear = R;
          }
          _blur(_, I, R, B, z) {
            let k = this._pingPongRenderTarget;
            this._halfBlur(_, k, I, R, B, "latitudinal", z),
              this._halfBlur(k, _, R, R, B, "longitudinal", z);
          }
          _halfBlur(_, I, R, B, z, k, V) {
            let j = this._renderer,
              G = this._blurMaterial;
            "latitudinal" !== k &&
              "longitudinal" !== k &&
              console.error(
                "blur direction must be either latitudinal or longitudinal!"
              );
            let q = new aw(this._lodPlanes[B], G),
              X = G.uniforms,
              Q = this._sizeLods[R] - 1,
              $ = isFinite(z) ? Math.PI / (2 * Q) : (2 * Math.PI) / 39,
              et = z / $,
              er = isFinite(z) ? 1 + Math.floor(3 * et) : 20;
            er > 20 &&
              console.warn(
                `sigmaRadians, ${z}, is too large and will clip, as it requested ${er} samples when the maximum is set to 20`
              );
            let es = [],
              ea = 0;
            for (let _ = 0; _ < 20; ++_) {
              let I = _ / et,
                R = Math.exp((-I * I) / 2);
              es.push(R), 0 === _ ? (ea += R) : _ < er && (ea += 2 * R);
            }
            for (let _ = 0; _ < es.length; _++) es[_] = es[_] / ea;
            (X.envMap.value = _.texture),
              (X.samples.value = er),
              (X.weights.value = es),
              (X.latitudinal.value = "latitudinal" === k),
              V && (X.poleAxis.value = V);
            let { _lodMax: en } = this;
            (X.dTheta.value = $), (X.mipInt.value = en - R);
            let eo = this._sizeLods[B];
            ty(
              I,
              3 * eo * (B > en - 4 ? B - en + 4 : 0),
              4 * (this._cubeSize - eo),
              3 * eo,
              2 * eo
            ),
              j.setRenderTarget(I),
              j.render(q, a0);
          }
        };
      function $T(_, I, R) {
        let B = new rT(_, I, R);
        return (
          (B.texture.mapping = 306),
          (B.texture.name = "PMREM.cubeUv"),
          (B.scissorTest = !0),
          B
        );
      }
      function ty(_, I, R, B, z) {
        _.viewport.set(I, R, B, z), _.scissor.set(I, R, B, z);
      }
      function eM() {
        return new aT({
          name: "EquirectangularToCubeUV",
          uniforms: { envMap: { value: null } },
          vertexShader: Pw(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function tM() {
        return new aT({
          name: "CubemapToCubeUV",
          uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
          vertexShader: Pw(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function Pw() {
        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
      }
      function gU(_) {
        let I = new WeakMap(),
          R = null;
        function s(_) {
          let R = _.target;
          R.removeEventListener("dispose", s);
          let B = I.get(R);
          void 0 !== B && (I.delete(R), B.dispose());
        }
        return {
          get: function (B) {
            if (B && B.isTexture) {
              let z = B.mapping,
                k = 303 === z || 304 === z,
                V = 301 === z || 302 === z;
              if (k || V) {
                if (B.isRenderTargetTexture && !0 === B.needsPMREMUpdate) {
                  B.needsPMREMUpdate = !1;
                  let z = I.get(B);
                  return (
                    null === R && (R = new a6(_)),
                    (z = k ? R.fromEquirectangular(B, z) : R.fromCubemap(B, z)),
                    I.set(B, z),
                    z.texture
                  );
                }
                if (I.has(B)) return I.get(B).texture;
                {
                  let z = B.image;
                  if (
                    !(
                      (k && z && z.height > 0) ||
                      (V &&
                        z &&
                        (function (_) {
                          let I = 0;
                          for (let R = 0; R < 6; R++) void 0 !== _[R] && I++;
                          return 6 === I;
                        })(z))
                    )
                  )
                    return null;
                  {
                    null === R && (R = new a6(_));
                    let z = k ? R.fromEquirectangular(B) : R.fromCubemap(B);
                    return (
                      I.set(B, z), B.addEventListener("dispose", s), z.texture
                    );
                  }
                }
              }
            }
            return B;
          },
          dispose: function () {
            (I = new WeakMap()), null !== R && (R.dispose(), (R = null));
          },
        };
      }
      function yU(_) {
        let I = {};
        function e(R) {
          let B;
          if (void 0 !== I[R]) return I[R];
          switch (R) {
            case "WEBGL_depth_texture":
              B =
                _.getExtension("WEBGL_depth_texture") ||
                _.getExtension("MOZ_WEBGL_depth_texture") ||
                _.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              B =
                _.getExtension("EXT_texture_filter_anisotropic") ||
                _.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                _.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              B =
                _.getExtension("WEBGL_compressed_texture_s3tc") ||
                _.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                _.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              B =
                _.getExtension("WEBGL_compressed_texture_pvrtc") ||
                _.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              B = _.getExtension(R);
          }
          return (I[R] = B), B;
        }
        return {
          has: function (_) {
            return null !== e(_);
          },
          init: function (_) {
            _.isWebGL2
              ? e("EXT_color_buffer_float")
              : (e("WEBGL_depth_texture"),
                e("OES_texture_float"),
                e("OES_texture_half_float"),
                e("OES_texture_half_float_linear"),
                e("OES_standard_derivatives"),
                e("OES_element_index_uint"),
                e("OES_vertex_array_object"),
                e("ANGLE_instanced_arrays")),
              e("OES_texture_float_linear"),
              e("EXT_color_buffer_half_float"),
              e("WEBGL_multisampled_render_to_texture");
          },
          get: function (_) {
            let I = e(_);
            return (
              null === I &&
                console.warn(
                  "THREE.WebGLRenderer: " + _ + " extension not supported."
                ),
              I
            );
          },
        };
      }
      function vU(_, I, R, B) {
        let z = {},
          k = new WeakMap();
        function o(_) {
          let V = _.target;
          for (let _ in (null !== V.index && I.remove(V.index), V.attributes))
            I.remove(V.attributes[_]);
          V.removeEventListener("dispose", o), delete z[V.id];
          let j = k.get(V);
          j && (I.remove(j), k.delete(V)),
            B.releaseStatesOfGeometry(V),
            !0 === V.isInstancedBufferGeometry && delete V._maxInstanceCount,
            R.memory.geometries--;
        }
        function u(_) {
          let R = [],
            B = _.index,
            z = _.attributes.position,
            V = 0;
          if (null !== B) {
            let _ = B.array;
            V = B.version;
            for (let I = 0, B = _.length; I < B; I += 3) {
              let B = _[I + 0],
                z = _[I + 1],
                k = _[I + 2];
              R.push(B, z, z, k, k, B);
            }
          } else {
            let _ = z.array;
            V = z.version;
            for (let I = 0, B = _.length / 3 - 1; I < B; I += 3) {
              let _ = I + 0,
                B = I + 1,
                z = I + 2;
              R.push(_, B, B, z, z, _);
            }
          }
          let j = new (YM(R) ? s3 : s2)(R, 1);
          j.version = V;
          let G = k.get(_);
          G && I.remove(G), k.set(_, j);
        }
        return {
          get: function (_, I) {
            return (
              !0 === z[I.id] ||
                (I.addEventListener("dispose", o),
                (z[I.id] = !0),
                R.memory.geometries++),
              I
            );
          },
          update: function (_) {
            let R = _.attributes;
            for (let _ in R) I.update(R[_], 34962);
            let B = _.morphAttributes;
            for (let _ in B) {
              let R = B[_];
              for (let _ = 0, B = R.length; _ < B; _++) I.update(R[_], 34962);
            }
          },
          getWireframeAttribute: function (_) {
            let I = k.get(_);
            if (I) {
              let R = _.index;
              null !== R && I.version < R.version && u(_);
            } else u(_);
            return k.get(_);
          },
        };
      }
      function xU(_, I, R, B) {
        let z,
          k,
          V = B.isWebGL2,
          j;
        (this.setMode = function (_) {
          j = _;
        }),
          (this.setIndex = function (_) {
            (z = _.type), (k = _.bytesPerElement);
          }),
          (this.render = function (I, B) {
            _.drawElements(j, B, z, I * k), R.update(B, j, 1);
          }),
          (this.renderInstances = function (B, G, q) {
            let X, Q;
            if (0 !== q) {
              if (V) (X = _), (Q = "drawElementsInstanced");
              else if (
                ((X = I.get("ANGLE_instanced_arrays")),
                (Q = "drawElementsInstancedANGLE"),
                null === X)
              ) {
                console.error(
                  "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
                return;
              }
              X[Q](j, G, z, B * k, q), R.update(G, j, q);
            }
          });
      }
      function bU(_) {
        let I = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        return {
          memory: { geometries: 0, textures: 0 },
          render: I,
          programs: null,
          autoReset: !0,
          reset: function () {
            I.frame++,
              (I.calls = 0),
              (I.triangles = 0),
              (I.points = 0),
              (I.lines = 0);
          },
          update: function (_, R, B) {
            switch ((I.calls++, R)) {
              case 4:
                I.triangles += B * (_ / 3);
                break;
              case 1:
                I.lines += B * (_ / 2);
                break;
              case 3:
                I.lines += B * (_ - 1);
                break;
              case 2:
                I.lines += B * _;
                break;
              case 0:
                I.points += B * _;
                break;
              default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", R);
            }
          },
        };
      }
      function SU(_, I) {
        return _[0] - I[0];
      }
      function wU(_, I) {
        return Math.abs(I[1]) - Math.abs(_[1]);
      }
      function AU(_, I, R) {
        let B = {},
          z = new Float32Array(8),
          k = new WeakMap(),
          V = new rM(),
          j = [];
        for (let _ = 0; _ < 8; _++) j[_] = [_, 0];
        return {
          update: function (G, q, X, Q) {
            let $ = G.morphTargetInfluences;
            if (!0 === I.isWebGL2) {
              let B =
                  q.morphAttributes.position ||
                  q.morphAttributes.normal ||
                  q.morphAttributes.color,
                z = void 0 !== B ? B.length : 0,
                j = k.get(q);
              if (void 0 === j || j.count !== z) {
                let L = function () {
                  ea.dispose(),
                    k.delete(q),
                    q.removeEventListener("dispose", L);
                };
                void 0 !== j && j.texture.dispose();
                let _ = void 0 !== q.morphAttributes.position,
                  R = void 0 !== q.morphAttributes.normal,
                  B = void 0 !== q.morphAttributes.color,
                  G = q.morphAttributes.position || [],
                  X = q.morphAttributes.normal || [],
                  Q = q.morphAttributes.color || [],
                  $ = 0;
                !0 === _ && ($ = 1), !0 === R && ($ = 2), !0 === B && ($ = 3);
                let et = q.attributes.position.count * $,
                  er = 1;
                et > I.maxTextureSize &&
                  ((er = Math.ceil(et / I.maxTextureSize)),
                  (et = I.maxTextureSize));
                let es = new Float32Array(et * er * 4 * z),
                  ea = new rP(es, et, er, z);
                (ea.type = 1015), (ea.needsUpdate = !0);
                let en = 4 * $;
                for (let I = 0; I < z; I++) {
                  let z = G[I],
                    k = X[I],
                    j = Q[I],
                    q = et * er * 4 * I;
                  for (let I = 0; I < z.count; I++) {
                    let G = I * en;
                    !0 === _ &&
                      (V.fromBufferAttribute(z, I),
                      (es[q + G + 0] = V.x),
                      (es[q + G + 1] = V.y),
                      (es[q + G + 2] = V.z),
                      (es[q + G + 3] = 0)),
                      !0 === R &&
                        (V.fromBufferAttribute(k, I),
                        (es[q + G + 4] = V.x),
                        (es[q + G + 5] = V.y),
                        (es[q + G + 6] = V.z),
                        (es[q + G + 7] = 0)),
                      !0 === B &&
                        (V.fromBufferAttribute(j, I),
                        (es[q + G + 8] = V.x),
                        (es[q + G + 9] = V.y),
                        (es[q + G + 10] = V.z),
                        (es[q + G + 11] = 4 === j.itemSize ? V.w : 1));
                  }
                }
                (j = { count: z, texture: ea, size: new rs(et, er) }),
                  k.set(q, j),
                  q.addEventListener("dispose", L);
              }
              let G = 0;
              for (let _ = 0; _ < $.length; _++) G += $[_];
              let X = q.morphTargetsRelative ? 1 : 1 - G;
              Q.getUniforms().setValue(_, "morphTargetBaseInfluence", X),
                Q.getUniforms().setValue(_, "morphTargetInfluences", $),
                Q.getUniforms().setValue(
                  _,
                  "morphTargetsTexture",
                  j.texture,
                  R
                ),
                Q.getUniforms().setValue(_, "morphTargetsTextureSize", j.size);
            } else {
              let I = void 0 === $ ? 0 : $.length,
                R = B[q.id];
              if (void 0 === R || R.length !== I) {
                R = [];
                for (let _ = 0; _ < I; _++) R[_] = [_, 0];
                B[q.id] = R;
              }
              for (let _ = 0; _ < I; _++) {
                let I = R[_];
                (I[0] = _), (I[1] = $[_]);
              }
              R.sort(wU);
              for (let _ = 0; _ < 8; _++)
                _ < I && R[_][1]
                  ? ((j[_][0] = R[_][0]), (j[_][1] = R[_][1]))
                  : ((j[_][0] = Number.MAX_SAFE_INTEGER), (j[_][1] = 0));
              j.sort(SU);
              let k = q.morphAttributes.position,
                V = q.morphAttributes.normal,
                G = 0;
              for (let _ = 0; _ < 8; _++) {
                let I = j[_],
                  R = I[0],
                  B = I[1];
                R !== Number.MAX_SAFE_INTEGER && B
                  ? (k &&
                      q.getAttribute("morphTarget" + _) !== k[R] &&
                      q.setAttribute("morphTarget" + _, k[R]),
                    V &&
                      q.getAttribute("morphNormal" + _) !== V[R] &&
                      q.setAttribute("morphNormal" + _, V[R]),
                    (z[_] = B),
                    (G += B))
                  : (k &&
                      !0 === q.hasAttribute("morphTarget" + _) &&
                      q.deleteAttribute("morphTarget" + _),
                    V &&
                      !0 === q.hasAttribute("morphNormal" + _) &&
                      q.deleteAttribute("morphNormal" + _),
                    (z[_] = 0));
              }
              let X = q.morphTargetsRelative ? 1 : 1 - G;
              Q.getUniforms().setValue(_, "morphTargetBaseInfluence", X),
                Q.getUniforms().setValue(_, "morphTargetInfluences", z);
            }
          },
        };
      }
      function _U(_, I, R, B) {
        let z = new WeakMap();
        function a(_) {
          let I = _.target;
          I.removeEventListener("dispose", a),
            R.remove(I.instanceMatrix),
            null !== I.instanceColor && R.remove(I.instanceColor);
        }
        return {
          update: function (_) {
            let k = B.render.frame,
              V = _.geometry,
              j = I.get(_, V);
            return (
              z.get(j) !== k && (I.update(j), z.set(j, k)),
              _.isInstancedMesh &&
                (!1 === _.hasEventListener("dispose", a) &&
                  _.addEventListener("dispose", a),
                R.update(_.instanceMatrix, 34962),
                null !== _.instanceColor && R.update(_.instanceColor, 34962)),
              j
            );
          },
          dispose: function () {
            z = new WeakMap();
          },
        };
      }
      var a8 = new rA(),
        a9 = new rP(),
        a7 = new rR(),
        nt = new aL(),
        ni = [],
        nr = [],
        ns = new Float32Array(16),
        na = new Float32Array(9),
        nn = new Float32Array(4);
      function uh(_, I, R) {
        let B = _[0];
        if (B <= 0 || B > 0) return _;
        let z = I * R,
          k = ni[z];
        if (
          (void 0 === k && ((k = new Float32Array(z)), (ni[z] = k)), 0 !== I)
        ) {
          B.toArray(k, 0);
          for (let B = 1, z = 0; B !== I; ++B) (z += R), _[B].toArray(k, z);
        }
        return k;
      }
      function Mi(_, I) {
        if (_.length !== I.length) return !1;
        for (let R = 0, B = _.length; R < B; R++) if (_[R] !== I[R]) return !1;
        return !0;
      }
      function Ci(_, I) {
        for (let R = 0, B = I.length; R < B; R++) _[R] = I[R];
      }
      function Gy(_, I) {
        let R = nr[I];
        void 0 === R && ((R = new Int32Array(I)), (nr[I] = R));
        for (let B = 0; B !== I; ++B) R[B] = _.allocateTextureUnit();
        return R;
      }
      function EU(_, I) {
        let R = this.cache;
        R[0] !== I && (_.uniform1f(this.addr, I), (R[0] = I));
      }
      function TU(_, I) {
        let R = this.cache;
        if (void 0 !== I.x)
          (R[0] !== I.x || R[1] !== I.y) &&
            (_.uniform2f(this.addr, I.x, I.y), (R[0] = I.x), (R[1] = I.y));
        else {
          if (Mi(R, I)) return;
          _.uniform2fv(this.addr, I), Ci(R, I);
        }
      }
      function MU(_, I) {
        let R = this.cache;
        if (void 0 !== I.x)
          (R[0] !== I.x || R[1] !== I.y || R[2] !== I.z) &&
            (_.uniform3f(this.addr, I.x, I.y, I.z),
            (R[0] = I.x),
            (R[1] = I.y),
            (R[2] = I.z));
        else if (void 0 !== I.r)
          (R[0] !== I.r || R[1] !== I.g || R[2] !== I.b) &&
            (_.uniform3f(this.addr, I.r, I.g, I.b),
            (R[0] = I.r),
            (R[1] = I.g),
            (R[2] = I.b));
        else {
          if (Mi(R, I)) return;
          _.uniform3fv(this.addr, I), Ci(R, I);
        }
      }
      function CU(_, I) {
        let R = this.cache;
        if (void 0 !== I.x)
          (R[0] !== I.x || R[1] !== I.y || R[2] !== I.z || R[3] !== I.w) &&
            (_.uniform4f(this.addr, I.x, I.y, I.z, I.w),
            (R[0] = I.x),
            (R[1] = I.y),
            (R[2] = I.z),
            (R[3] = I.w));
        else {
          if (Mi(R, I)) return;
          _.uniform4fv(this.addr, I), Ci(R, I);
        }
      }
      function PU(_, I) {
        let R = this.cache,
          B = I.elements;
        if (void 0 === B) {
          if (Mi(R, I)) return;
          _.uniformMatrix2fv(this.addr, !1, I), Ci(R, I);
        } else {
          if (Mi(R, B)) return;
          nn.set(B), _.uniformMatrix2fv(this.addr, !1, nn), Ci(R, B);
        }
      }
      function DU(_, I) {
        let R = this.cache,
          B = I.elements;
        if (void 0 === B) {
          if (Mi(R, I)) return;
          _.uniformMatrix3fv(this.addr, !1, I), Ci(R, I);
        } else {
          if (Mi(R, B)) return;
          na.set(B), _.uniformMatrix3fv(this.addr, !1, na), Ci(R, B);
        }
      }
      function OU(_, I) {
        let R = this.cache,
          B = I.elements;
        if (void 0 === B) {
          if (Mi(R, I)) return;
          _.uniformMatrix4fv(this.addr, !1, I), Ci(R, I);
        } else {
          if (Mi(R, B)) return;
          ns.set(B), _.uniformMatrix4fv(this.addr, !1, ns), Ci(R, B);
        }
      }
      function IU(_, I) {
        let R = this.cache;
        R[0] !== I && (_.uniform1i(this.addr, I), (R[0] = I));
      }
      function RU(_, I) {
        let R = this.cache;
        if (void 0 !== I.x)
          (R[0] !== I.x || R[1] !== I.y) &&
            (_.uniform2i(this.addr, I.x, I.y), (R[0] = I.x), (R[1] = I.y));
        else {
          if (Mi(R, I)) return;
          _.uniform2iv(this.addr, I), Ci(R, I);
        }
      }
      function LU(_, I) {
        let R = this.cache;
        if (void 0 !== I.x)
          (R[0] !== I.x || R[1] !== I.y || R[2] !== I.z) &&
            (_.uniform3i(this.addr, I.x, I.y, I.z),
            (R[0] = I.x),
            (R[1] = I.y),
            (R[2] = I.z));
        else {
          if (Mi(R, I)) return;
          _.uniform3iv(this.addr, I), Ci(R, I);
        }
      }
      function BU(_, I) {
        let R = this.cache;
        if (void 0 !== I.x)
          (R[0] !== I.x || R[1] !== I.y || R[2] !== I.z || R[3] !== I.w) &&
            (_.uniform4i(this.addr, I.x, I.y, I.z, I.w),
            (R[0] = I.x),
            (R[1] = I.y),
            (R[2] = I.z),
            (R[3] = I.w));
        else {
          if (Mi(R, I)) return;
          _.uniform4iv(this.addr, I), Ci(R, I);
        }
      }
      function NU(_, I) {
        let R = this.cache;
        R[0] !== I && (_.uniform1ui(this.addr, I), (R[0] = I));
      }
      function FU(_, I) {
        let R = this.cache;
        if (void 0 !== I.x)
          (R[0] !== I.x || R[1] !== I.y) &&
            (_.uniform2ui(this.addr, I.x, I.y), (R[0] = I.x), (R[1] = I.y));
        else {
          if (Mi(R, I)) return;
          _.uniform2uiv(this.addr, I), Ci(R, I);
        }
      }
      function kU(_, I) {
        let R = this.cache;
        if (void 0 !== I.x)
          (R[0] !== I.x || R[1] !== I.y || R[2] !== I.z) &&
            (_.uniform3ui(this.addr, I.x, I.y, I.z),
            (R[0] = I.x),
            (R[1] = I.y),
            (R[2] = I.z));
        else {
          if (Mi(R, I)) return;
          _.uniform3uiv(this.addr, I), Ci(R, I);
        }
      }
      function VU(_, I) {
        let R = this.cache;
        if (void 0 !== I.x)
          (R[0] !== I.x || R[1] !== I.y || R[2] !== I.z || R[3] !== I.w) &&
            (_.uniform4ui(this.addr, I.x, I.y, I.z, I.w),
            (R[0] = I.x),
            (R[1] = I.y),
            (R[2] = I.z),
            (R[3] = I.w));
        else {
          if (Mi(R, I)) return;
          _.uniform4uiv(this.addr, I), Ci(R, I);
        }
      }
      function zU(_, I, R) {
        let B = this.cache,
          z = R.allocateTextureUnit();
        B[0] !== z && (_.uniform1i(this.addr, z), (B[0] = z)),
          R.setTexture2D(I || a8, z);
      }
      function UU(_, I, R) {
        let B = this.cache,
          z = R.allocateTextureUnit();
        B[0] !== z && (_.uniform1i(this.addr, z), (B[0] = z)),
          R.setTexture3D(I || a7, z);
      }
      function GU(_, I, R) {
        let B = this.cache,
          z = R.allocateTextureUnit();
        B[0] !== z && (_.uniform1i(this.addr, z), (B[0] = z)),
          R.setTextureCube(I || nt, z);
      }
      function jU(_, I, R) {
        let B = this.cache,
          z = R.allocateTextureUnit();
        B[0] !== z && (_.uniform1i(this.addr, z), (B[0] = z)),
          R.setTexture2DArray(I || a9, z);
      }
      function WU(_, I) {
        _.uniform1fv(this.addr, I);
      }
      function qU(_, I) {
        let R = uh(I, this.size, 2);
        _.uniform2fv(this.addr, R);
      }
      function YU(_, I) {
        let R = uh(I, this.size, 3);
        _.uniform3fv(this.addr, R);
      }
      function XU(_, I) {
        let R = uh(I, this.size, 4);
        _.uniform4fv(this.addr, R);
      }
      function QU(_, I) {
        let R = uh(I, this.size, 4);
        _.uniformMatrix2fv(this.addr, !1, R);
      }
      function KU(_, I) {
        let R = uh(I, this.size, 9);
        _.uniformMatrix3fv(this.addr, !1, R);
      }
      function ZU(_, I) {
        let R = uh(I, this.size, 16);
        _.uniformMatrix4fv(this.addr, !1, R);
      }
      function JU(_, I) {
        _.uniform1iv(this.addr, I);
      }
      function $U(_, I) {
        _.uniform2iv(this.addr, I);
      }
      function eG(_, I) {
        _.uniform3iv(this.addr, I);
      }
      function tG(_, I) {
        _.uniform4iv(this.addr, I);
      }
      function rG(_, I) {
        _.uniform1uiv(this.addr, I);
      }
      function iG(_, I) {
        _.uniform2uiv(this.addr, I);
      }
      function nG(_, I) {
        _.uniform3uiv(this.addr, I);
      }
      function sG(_, I) {
        _.uniform4uiv(this.addr, I);
      }
      function oG(_, I, R) {
        let B = this.cache,
          z = I.length,
          k = Gy(R, z);
        Mi(B, k) || (_.uniform1iv(this.addr, k), Ci(B, k));
        for (let _ = 0; _ !== z; ++_) R.setTexture2D(I[_] || a8, k[_]);
      }
      function aG(_, I, R) {
        let B = this.cache,
          z = I.length,
          k = Gy(R, z);
        Mi(B, k) || (_.uniform1iv(this.addr, k), Ci(B, k));
        for (let _ = 0; _ !== z; ++_) R.setTexture3D(I[_] || a7, k[_]);
      }
      function lG(_, I, R) {
        let B = this.cache,
          z = I.length,
          k = Gy(R, z);
        Mi(B, k) || (_.uniform1iv(this.addr, k), Ci(B, k));
        for (let _ = 0; _ !== z; ++_) R.setTextureCube(I[_] || nt, k[_]);
      }
      function cG(_, I, R) {
        let B = this.cache,
          z = I.length,
          k = Gy(R, z);
        Mi(B, k) || (_.uniform1iv(this.addr, k), Ci(B, k));
        for (let _ = 0; _ !== z; ++_) R.setTexture2DArray(I[_] || a9, k[_]);
      }
      var no = class {
          constructor(_, I, R) {
            (this.id = _),
              (this.addr = R),
              (this.cache = []),
              (this.setValue = (function (_) {
                switch (_) {
                  case 5126:
                    return EU;
                  case 35664:
                    return TU;
                  case 35665:
                    return MU;
                  case 35666:
                    return CU;
                  case 35674:
                    return PU;
                  case 35675:
                    return DU;
                  case 35676:
                    return OU;
                  case 5124:
                  case 35670:
                    return IU;
                  case 35667:
                  case 35671:
                    return RU;
                  case 35668:
                  case 35672:
                    return LU;
                  case 35669:
                  case 35673:
                    return BU;
                  case 5125:
                    return NU;
                  case 36294:
                    return FU;
                  case 36295:
                    return kU;
                  case 36296:
                    return VU;
                  case 35678:
                  case 36198:
                  case 36298:
                  case 36306:
                  case 35682:
                    return zU;
                  case 35679:
                  case 36299:
                  case 36307:
                    return UU;
                  case 35680:
                  case 36300:
                  case 36308:
                  case 36293:
                    return GU;
                  case 36289:
                  case 36303:
                  case 36311:
                  case 36292:
                    return jU;
                }
              })(I.type));
          }
        },
        nh = class {
          constructor(_, I, R) {
            (this.id = _),
              (this.addr = R),
              (this.cache = []),
              (this.size = I.size),
              (this.setValue = (function (_) {
                switch (_) {
                  case 5126:
                    return WU;
                  case 35664:
                    return qU;
                  case 35665:
                    return YU;
                  case 35666:
                    return XU;
                  case 35674:
                    return QU;
                  case 35675:
                    return KU;
                  case 35676:
                    return ZU;
                  case 5124:
                  case 35670:
                    return JU;
                  case 35667:
                  case 35671:
                    return $U;
                  case 35668:
                  case 35672:
                    return eG;
                  case 35669:
                  case 35673:
                    return tG;
                  case 5125:
                    return rG;
                  case 36294:
                    return iG;
                  case 36295:
                    return nG;
                  case 36296:
                    return sG;
                  case 35678:
                  case 36198:
                  case 36298:
                  case 36306:
                  case 35682:
                    return oG;
                  case 35679:
                  case 36299:
                  case 36307:
                    return aG;
                  case 35680:
                  case 36300:
                  case 36308:
                  case 36293:
                    return lG;
                  case 36289:
                  case 36303:
                  case 36311:
                  case 36292:
                    return cG;
                }
              })(I.type));
          }
        },
        nc = class {
          constructor(_) {
            (this.id = _), (this.seq = []), (this.map = {});
          }
          setValue(_, I, R) {
            let B = this.seq;
            for (let z = 0, k = B.length; z !== k; ++z) {
              let k = B[z];
              k.setValue(_, I[k.id], R);
            }
          }
        },
        nd = /(\w+)(\])?(\[|\.)?/g;
      function aM(_, I) {
        _.seq.push(I), (_.map[I.id] = I);
      }
      var nu = class {
        constructor(_, I) {
          (this.seq = []), (this.map = {});
          let R = _.getProgramParameter(I, 35718);
          for (let B = 0; B < R; ++B) {
            let R = _.getActiveUniform(I, B),
              z = _.getUniformLocation(I, R.name);
            !(function (_, I, R) {
              let B = _.name,
                z = B.length;
              for (nd.lastIndex = 0; ; ) {
                let k = nd.exec(B),
                  V = nd.lastIndex,
                  j = k[1],
                  G = "]" === k[2],
                  q = k[3];
                if (
                  (G && (j |= 0), void 0 === q || ("[" === q && V + 2 === z))
                ) {
                  aM(R, void 0 === q ? new no(j, _, I) : new nh(j, _, I));
                  break;
                }
                {
                  let _ = R.map[j];
                  void 0 === _ && aM(R, (_ = new nc(j))), (R = _);
                }
              }
            })(R, z, this);
          }
        }
        setValue(_, I, R, B) {
          let z = this.map[I];
          void 0 !== z && z.setValue(_, R, B);
        }
        setOptional(_, I, R) {
          let B = I[R];
          void 0 !== B && this.setValue(_, R, B);
        }
        static upload(_, I, R, B) {
          for (let z = 0, k = I.length; z !== k; ++z) {
            let k = I[z],
              V = R[k.id];
            !1 !== V.needsUpdate && k.setValue(_, V.value, B);
          }
        }
        static seqWithValue(_, I) {
          let R = [];
          for (let B = 0, z = _.length; B !== z; ++B) {
            let z = _[B];
            z.id in I && R.push(z);
          }
          return R;
        }
      };
      function lM(_, I, R) {
        let B = _.createShader(I);
        return _.shaderSource(B, R), _.compileShader(B), B;
      }
      var np = 0;
      function cM(_, I, R) {
        let B = _.getShaderParameter(I, 35713),
          z = _.getShaderInfoLog(I).trim();
        if (B && "" === z) return "";
        let k = /ERROR: 0:(\d+)/.exec(z);
        if (!k) return z;
        {
          let B = parseInt(k[1]);
          return (
            R.toUpperCase() +
            `

` +
            z +
            `

` +
            (function (_, I) {
              let R = _.split(`
`),
                B = [],
                z = Math.max(I - 6, 0),
                k = Math.min(I + 6, R.length);
              for (let _ = z; _ < k; _++) {
                let z = _ + 1;
                B.push(`${z === I ? ">" : " "} ${z}: ${R[_]}`);
              }
              return B.join(`
`);
            })(_.getShaderSource(I), B)
          );
        }
      }
      function gp(_) {
        return "" !== _;
      }
      function uM(_, I) {
        let R =
          I.numSpotLightShadows +
          I.numSpotLightMaps -
          I.numSpotLightShadowsWithMaps;
        return _.replace(/NUM_DIR_LIGHTS/g, I.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, I.numSpotLights)
          .replace(/NUM_SPOT_LIGHT_MAPS/g, I.numSpotLightMaps)
          .replace(/NUM_SPOT_LIGHT_COORDS/g, R)
          .replace(/NUM_RECT_AREA_LIGHTS/g, I.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, I.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, I.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, I.numDirLightShadows)
          .replace(
            /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
            I.numSpotLightShadowsWithMaps
          )
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, I.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, I.numPointLightShadows);
      }
      function hM(_, I) {
        return _.replace(/NUM_CLIPPING_PLANES/g, I.numClippingPlanes).replace(
          /UNION_CLIPPING_PLANES/g,
          I.numClippingPlanes - I.numClipIntersection
        );
      }
      var nf = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function $S(_) {
        return _.replace(nf, SG);
      }
      function SG(_, I) {
        let R = aY[I];
        if (void 0 === R) throw Error("Can not resolve #include <" + I + ">");
        return $S(R);
      }
      var nm =
        /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function dM(_) {
        return _.replace(nm, AG);
      }
      function AG(_, I, R, B) {
        let z = "";
        for (let _ = parseInt(I); _ < parseInt(R); _++)
          z += B.replace(/\[\s*i\s*\]/g, "[ " + _ + " ]").replace(
            /UNROLLED_LOOP_INDEX/g,
            _
          );
        return z;
      }
      function fM(_) {
        let I =
          "precision " +
          _.precision +
          ` float;
precision ` +
          _.precision +
          " int;";
        return (
          "highp" === _.precision
            ? (I += `
#define HIGH_PRECISION`)
            : "mediump" === _.precision
            ? (I += `
#define MEDIUM_PRECISION`)
            : "lowp" === _.precision &&
              (I += `
#define LOW_PRECISION`),
          I
        );
      }
      function PG(_, I, R, B) {
        let z, k, V;
        let j,
          G,
          q = _.getContext(),
          X = R.defines,
          Q = R.vertexShader,
          $ = R.fragmentShader,
          et =
            ((z = "SHADOWMAP_TYPE_BASIC"),
            1 === R.shadowMapType
              ? (z = "SHADOWMAP_TYPE_PCF")
              : 2 === R.shadowMapType
              ? (z = "SHADOWMAP_TYPE_PCF_SOFT")
              : 3 === R.shadowMapType && (z = "SHADOWMAP_TYPE_VSM"),
            z),
          er = (function (_) {
            let I = "ENVMAP_TYPE_CUBE";
            if (_.envMap)
              switch (_.envMapMode) {
                case 301:
                case 302:
                  I = "ENVMAP_TYPE_CUBE";
                  break;
                case 306:
                  I = "ENVMAP_TYPE_CUBE_UV";
              }
            return I;
          })(R),
          es =
            ((k = "ENVMAP_MODE_REFLECTION"),
            R.envMap && 302 === R.envMapMode && (k = "ENVMAP_MODE_REFRACTION"),
            k),
          ea = (function (_) {
            let I = "ENVMAP_BLENDING_NONE";
            if (_.envMap)
              switch (_.combine) {
                case 0:
                  I = "ENVMAP_BLENDING_MULTIPLY";
                  break;
                case 1:
                  I = "ENVMAP_BLENDING_MIX";
                  break;
                case 2:
                  I = "ENVMAP_BLENDING_ADD";
              }
            return I;
          })(R),
          en = (function (_) {
            let I = _.envMapCubeUVHeight;
            if (null === I) return null;
            let R = Math.log2(I) - 2;
            return {
              texelWidth: 1 / (3 * Math.max(Math.pow(2, R), 112)),
              texelHeight: 1 / I,
              maxMip: R,
            };
          })(R),
          eo = R.isWebGL2
            ? ""
            : [
                R.extensionDerivatives ||
                R.envMapCubeUVHeight ||
                R.bumpMap ||
                R.tangentSpaceNormalMap ||
                R.clearcoatNormalMap ||
                R.flatShading ||
                "physical" === R.shaderID
                  ? "#extension GL_OES_standard_derivatives : enable"
                  : "",
                (R.extensionFragDepth || R.logarithmicDepthBuffer) &&
                R.rendererExtensionFragDepth
                  ? "#extension GL_EXT_frag_depth : enable"
                  : "",
                R.extensionDrawBuffers && R.rendererExtensionDrawBuffers
                  ? "#extension GL_EXT_draw_buffers : require"
                  : "",
                (R.extensionShaderTextureLOD || R.envMap || R.transmission) &&
                R.rendererExtensionShaderTextureLod
                  ? "#extension GL_EXT_shader_texture_lod : enable"
                  : "",
              ].filter(gp).join(`
`),
          el = (function (_) {
            let I = [];
            for (let R in _) {
              let B = _[R];
              !1 !== B && I.push("#define " + R + " " + B);
            }
            return I.join(`
`);
          })(X),
          eh = q.createProgram(),
          ec,
          ed,
          ep = R.glslVersion
            ? "#version " +
              R.glslVersion +
              `
`
            : "";
        R.isRawShaderMaterial
          ? ((ec = [el].filter(gp).join(`
`)).length > 0 &&
              (ec += `
`),
            (ed = [eo, el].filter(gp).join(`
`)).length > 0 &&
              (ed += `
`))
          : ((ec = [
              fM(R),
              "#define SHADER_NAME " + R.shaderName,
              el,
              R.instancing ? "#define USE_INSTANCING" : "",
              R.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              R.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
              R.useFog && R.fog ? "#define USE_FOG" : "",
              R.useFog && R.fogExp2 ? "#define FOG_EXP2" : "",
              R.map ? "#define USE_MAP" : "",
              R.envMap ? "#define USE_ENVMAP" : "",
              R.envMap ? "#define " + es : "",
              R.lightMap ? "#define USE_LIGHTMAP" : "",
              R.aoMap ? "#define USE_AOMAP" : "",
              R.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              R.bumpMap ? "#define USE_BUMPMAP" : "",
              R.normalMap ? "#define USE_NORMALMAP" : "",
              R.normalMap && R.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              R.normalMap && R.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              R.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              R.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              R.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              R.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              R.iridescenceThicknessMap
                ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                : "",
              R.displacementMap && R.supportsVertexTextures
                ? "#define USE_DISPLACEMENTMAP"
                : "",
              R.specularMap ? "#define USE_SPECULARMAP" : "",
              R.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              R.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
              R.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              R.metalnessMap ? "#define USE_METALNESSMAP" : "",
              R.alphaMap ? "#define USE_ALPHAMAP" : "",
              R.transmission ? "#define USE_TRANSMISSION" : "",
              R.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              R.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              R.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
              R.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
              R.vertexTangents ? "#define USE_TANGENT" : "",
              R.vertexColors ? "#define USE_COLOR" : "",
              R.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              R.vertexUvs ? "#define USE_UV" : "",
              R.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              R.flatShading ? "#define FLAT_SHADED" : "",
              R.skinning ? "#define USE_SKINNING" : "",
              R.morphTargets ? "#define USE_MORPHTARGETS" : "",
              R.morphNormals && !1 === R.flatShading
                ? "#define USE_MORPHNORMALS"
                : "",
              R.morphColors && R.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
              R.morphTargetsCount > 0 && R.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE"
                : "",
              R.morphTargetsCount > 0 && R.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE_STRIDE " + R.morphTextureStride
                : "",
              R.morphTargetsCount > 0 && R.isWebGL2
                ? "#define MORPHTARGETS_COUNT " + R.morphTargetsCount
                : "",
              R.doubleSided ? "#define DOUBLE_SIDED" : "",
              R.flipSided ? "#define FLIP_SIDED" : "",
              R.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              R.shadowMapEnabled ? "#define " + et : "",
              R.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              R.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              R.logarithmicDepthBuffer && R.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "	attribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "	attribute vec3 instanceColor;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_TANGENT",
              "	attribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "	attribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "	attribute vec3 color;",
              "#endif",
              "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
              "	attribute vec3 morphTarget0;",
              "	attribute vec3 morphTarget1;",
              "	attribute vec3 morphTarget2;",
              "	attribute vec3 morphTarget3;",
              "	#ifdef USE_MORPHNORMALS",
              "		attribute vec3 morphNormal0;",
              "		attribute vec3 morphNormal1;",
              "		attribute vec3 morphNormal2;",
              "		attribute vec3 morphNormal3;",
              "	#else",
              "		attribute vec3 morphTarget4;",
              "		attribute vec3 morphTarget5;",
              "		attribute vec3 morphTarget6;",
              "		attribute vec3 morphTarget7;",
              "	#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "	attribute vec4 skinIndex;",
              "	attribute vec4 skinWeight;",
              "#endif",
              `
`,
            ].filter(gp).join(`
`)),
            (ed = [
              eo,
              fM(R),
              "#define SHADER_NAME " + R.shaderName,
              el,
              R.useFog && R.fog ? "#define USE_FOG" : "",
              R.useFog && R.fogExp2 ? "#define FOG_EXP2" : "",
              R.map ? "#define USE_MAP" : "",
              R.matcap ? "#define USE_MATCAP" : "",
              R.envMap ? "#define USE_ENVMAP" : "",
              R.envMap ? "#define " + er : "",
              R.envMap ? "#define " + es : "",
              R.envMap ? "#define " + ea : "",
              en ? "#define CUBEUV_TEXEL_WIDTH " + en.texelWidth : "",
              en ? "#define CUBEUV_TEXEL_HEIGHT " + en.texelHeight : "",
              en ? "#define CUBEUV_MAX_MIP " + en.maxMip + ".0" : "",
              R.lightMap ? "#define USE_LIGHTMAP" : "",
              R.aoMap ? "#define USE_AOMAP" : "",
              R.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              R.bumpMap ? "#define USE_BUMPMAP" : "",
              R.normalMap ? "#define USE_NORMALMAP" : "",
              R.normalMap && R.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              R.normalMap && R.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              R.clearcoat ? "#define USE_CLEARCOAT" : "",
              R.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              R.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              R.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              R.iridescence ? "#define USE_IRIDESCENCE" : "",
              R.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              R.iridescenceThicknessMap
                ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                : "",
              R.specularMap ? "#define USE_SPECULARMAP" : "",
              R.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              R.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
              R.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              R.metalnessMap ? "#define USE_METALNESSMAP" : "",
              R.alphaMap ? "#define USE_ALPHAMAP" : "",
              R.alphaTest ? "#define USE_ALPHATEST" : "",
              R.sheen ? "#define USE_SHEEN" : "",
              R.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
              R.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
              R.transmission ? "#define USE_TRANSMISSION" : "",
              R.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              R.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              R.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
              R.vertexTangents ? "#define USE_TANGENT" : "",
              R.vertexColors || R.instancingColor ? "#define USE_COLOR" : "",
              R.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              R.vertexUvs ? "#define USE_UV" : "",
              R.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              R.gradientMap ? "#define USE_GRADIENTMAP" : "",
              R.flatShading ? "#define FLAT_SHADED" : "",
              R.doubleSided ? "#define DOUBLE_SIDED" : "",
              R.flipSided ? "#define FLIP_SIDED" : "",
              R.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              R.shadowMapEnabled ? "#define " + et : "",
              R.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              R.physicallyCorrectLights
                ? "#define PHYSICALLY_CORRECT_LIGHTS"
                : "",
              R.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              R.logarithmicDepthBuffer && R.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              0 !== R.toneMapping ? "#define TONE_MAPPING" : "",
              0 !== R.toneMapping ? aY.tonemapping_pars_fragment : "",
              0 !== R.toneMapping
                ? (function (_, I) {
                    let R;
                    switch (I) {
                      case 1:
                        R = "Linear";
                        break;
                      case 2:
                        R = "Reinhard";
                        break;
                      case 3:
                        R = "OptimizedCineon";
                        break;
                      case 4:
                        R = "ACESFilmic";
                        break;
                      case 5:
                        R = "Custom";
                        break;
                      default:
                        console.warn(
                          "THREE.WebGLProgram: Unsupported toneMapping:",
                          I
                        ),
                          (R = "Linear");
                    }
                    return (
                      "vec3 " +
                      _ +
                      "( vec3 color ) { return " +
                      R +
                      "ToneMapping( color ); }"
                    );
                  })("toneMapping", R.toneMapping)
                : "",
              R.dithering ? "#define DITHERING" : "",
              R.opaque ? "#define OPAQUE" : "",
              aY.encodings_pars_fragment,
              "vec4 linearToOutputTexel( vec4 value ) { return LinearTo" +
                (V = (function (_) {
                  switch (_) {
                    case 3e3:
                      return ["Linear", "( value )"];
                    case 3001:
                      return ["sRGB", "( value )"];
                    default:
                      return (
                        console.warn(
                          "THREE.WebGLProgram: Unsupported encoding:",
                          _
                        ),
                        ["Linear", "( value )"]
                      );
                  }
                })(R.outputEncoding))[0] +
                V[1] +
                "; }",
              R.useDepthPacking
                ? "#define DEPTH_PACKING " + R.depthPacking
                : "",
              `
`,
            ].filter(gp).join(`
`))),
          (Q = hM((Q = uM((Q = $S(Q)), R)), R)),
          ($ = hM(($ = uM(($ = $S($)), R)), R)),
          (Q = dM(Q)),
          ($ = dM($)),
          R.isWebGL2 &&
            !0 !== R.isRawShaderMaterial &&
            ((ep = `#version 300 es
`),
            (ec =
              [
                "precision mediump sampler2DArray;",
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join(`
`) +
              `
` +
              ec),
            (ed =
              [
                "#define varying in",
                R.glslVersion === i6
                  ? ""
                  : "layout(location = 0) out highp vec4 pc_fragColor;",
                R.glslVersion === i6 ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join(`
`) +
              `
` +
              ed));
        let ef = ep + ec + Q,
          em = ep + ed + $,
          ey = lM(q, 35633, ef),
          ex = lM(q, 35632, em);
        if (
          (q.attachShader(eh, ey),
          q.attachShader(eh, ex),
          void 0 !== R.index0AttributeName
            ? q.bindAttribLocation(eh, 0, R.index0AttributeName)
            : !0 === R.morphTargets && q.bindAttribLocation(eh, 0, "position"),
          q.linkProgram(eh),
          _.debug.checkShaderErrors)
        ) {
          let _ = q.getProgramInfoLog(eh).trim(),
            I = q.getShaderInfoLog(ey).trim(),
            R = q.getShaderInfoLog(ex).trim(),
            B = !0,
            z = !0;
          if (!1 === q.getProgramParameter(eh, 35714)) {
            B = !1;
            let I = cM(q, ey, "vertex"),
              R = cM(q, ex, "fragment");
            console.error(
              "THREE.WebGLProgram: Shader Error " +
                q.getError() +
                " - VALIDATE_STATUS " +
                q.getProgramParameter(eh, 35715) +
                `

Program Info Log: ` +
                _ +
                `
` +
                I +
                `
` +
                R
            );
          } else
            "" !== _
              ? console.warn("THREE.WebGLProgram: Program Info Log:", _)
              : ("" === I || "" === R) && (z = !1);
          z &&
            (this.diagnostics = {
              runnable: B,
              programLog: _,
              vertexShader: { log: I, prefix: ec },
              fragmentShader: { log: R, prefix: ed },
            });
        }
        return (
          q.deleteShader(ey),
          q.deleteShader(ex),
          (this.getUniforms = function () {
            return void 0 === j && (j = new nu(q, eh)), j;
          }),
          (this.getAttributes = function () {
            return (
              void 0 === G &&
                (G = (function (_, I) {
                  let R = {},
                    B = _.getProgramParameter(I, 35721);
                  for (let z = 0; z < B; z++) {
                    let B = _.getActiveAttrib(I, z),
                      k = B.name,
                      V = 1;
                    35674 === B.type && (V = 2),
                      35675 === B.type && (V = 3),
                      35676 === B.type && (V = 4),
                      (R[k] = {
                        type: B.type,
                        location: _.getAttribLocation(I, k),
                        locationSize: V,
                      });
                  }
                  return R;
                })(q, eh)),
              G
            );
          }),
          (this.destroy = function () {
            B.releaseStatesOfProgram(this),
              q.deleteProgram(eh),
              (this.program = void 0);
          }),
          (this.name = R.shaderName),
          (this.id = np++),
          (this.cacheKey = I),
          (this.usedTimes = 1),
          (this.program = eh),
          (this.vertexShader = ey),
          (this.fragmentShader = ex),
          this
        );
      }
      var ng = 0,
        ny = class {
          constructor() {
            (this.shaderCache = new Map()), (this.materialCache = new Map());
          }
          update(_) {
            let I = _.vertexShader,
              R = _.fragmentShader,
              B = this._getShaderStage(I),
              z = this._getShaderStage(R),
              k = this._getShaderCacheForMaterial(_);
            return (
              !1 === k.has(B) && (k.add(B), B.usedTimes++),
              !1 === k.has(z) && (k.add(z), z.usedTimes++),
              this
            );
          }
          remove(_) {
            for (let I of this.materialCache.get(_))
              I.usedTimes--,
                0 === I.usedTimes && this.shaderCache.delete(I.code);
            return this.materialCache.delete(_), this;
          }
          getVertexShaderID(_) {
            return this._getShaderStage(_.vertexShader).id;
          }
          getFragmentShaderID(_) {
            return this._getShaderStage(_.fragmentShader).id;
          }
          dispose() {
            this.shaderCache.clear(), this.materialCache.clear();
          }
          _getShaderCacheForMaterial(_) {
            let I = this.materialCache,
              R = I.get(_);
            return void 0 === R && ((R = new Set()), I.set(_, R)), R;
          }
          _getShaderStage(_) {
            let I = this.shaderCache,
              R = I.get(_);
            return void 0 === R && ((R = new nb(_)), I.set(_, R)), R;
          }
        },
        nb = class {
          constructor(_) {
            (this.id = ng++), (this.code = _), (this.usedTimes = 0);
          }
        };
      function OG(_, I, R, B, z, k, V) {
        let j = new sv(),
          G = new ny(),
          q = [],
          X = z.isWebGL2,
          Q = z.logarithmicDepthBuffer,
          $ = z.vertexTextures,
          et = z.precision,
          er = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite",
          };
        return {
          getParameters: function (k, j, q, es, ea) {
            let en,
              eo,
              el,
              eh,
              ec = es.fog,
              ed = ea.geometry,
              ep = k.isMeshStandardMaterial ? es.environment : null,
              ef = (k.isMeshStandardMaterial ? R : I).get(k.envMap || ep),
              em = ef && 306 === ef.mapping ? ef.image.height : null,
              ey = er[k.type];
            null !== k.precision &&
              (et = z.getMaxPrecision(k.precision)) !== k.precision &&
              console.warn(
                "THREE.WebGLProgram.getParameters:",
                k.precision,
                "not supported, using",
                et,
                "instead."
              );
            let ex =
                ed.morphAttributes.position ||
                ed.morphAttributes.normal ||
                ed.morphAttributes.color,
              eb = void 0 !== ex ? ex.length : 0,
              ew = 0;
            if (
              (void 0 !== ed.morphAttributes.position && (ew = 1),
              void 0 !== ed.morphAttributes.normal && (ew = 2),
              void 0 !== ed.morphAttributes.color && (ew = 3),
              ey)
            ) {
              let _ = aQ[ey];
              (en = _.vertexShader), (eo = _.fragmentShader);
            } else
              (en = k.vertexShader),
                (eo = k.fragmentShader),
                G.update(k),
                (el = G.getVertexShaderID(k)),
                (eh = G.getFragmentShaderID(k));
            let e_ = _.getRenderTarget(),
              eS = k.alphaTest > 0,
              eA = k.clearcoat > 0,
              eC = k.iridescence > 0;
            return {
              isWebGL2: X,
              shaderID: ey,
              shaderName: k.type,
              vertexShader: en,
              fragmentShader: eo,
              defines: k.defines,
              customVertexShaderID: el,
              customFragmentShaderID: eh,
              isRawShaderMaterial: !0 === k.isRawShaderMaterial,
              glslVersion: k.glslVersion,
              precision: et,
              instancing: !0 === ea.isInstancedMesh,
              instancingColor:
                !0 === ea.isInstancedMesh && null !== ea.instanceColor,
              supportsVertexTextures: $,
              outputEncoding:
                null === e_
                  ? _.outputEncoding
                  : !0 === e_.isXRRenderTarget
                  ? e_.texture.encoding
                  : 3e3,
              map: !!k.map,
              matcap: !!k.matcap,
              envMap: !!ef,
              envMapMode: ef && ef.mapping,
              envMapCubeUVHeight: em,
              lightMap: !!k.lightMap,
              aoMap: !!k.aoMap,
              emissiveMap: !!k.emissiveMap,
              bumpMap: !!k.bumpMap,
              normalMap: !!k.normalMap,
              objectSpaceNormalMap: 1 === k.normalMapType,
              tangentSpaceNormalMap: 0 === k.normalMapType,
              decodeVideoTexture:
                !!k.map &&
                !0 === k.map.isVideoTexture &&
                3001 === k.map.encoding,
              clearcoat: eA,
              clearcoatMap: eA && !!k.clearcoatMap,
              clearcoatRoughnessMap: eA && !!k.clearcoatRoughnessMap,
              clearcoatNormalMap: eA && !!k.clearcoatNormalMap,
              iridescence: eC,
              iridescenceMap: eC && !!k.iridescenceMap,
              iridescenceThicknessMap: eC && !!k.iridescenceThicknessMap,
              displacementMap: !!k.displacementMap,
              roughnessMap: !!k.roughnessMap,
              metalnessMap: !!k.metalnessMap,
              specularMap: !!k.specularMap,
              specularIntensityMap: !!k.specularIntensityMap,
              specularColorMap: !!k.specularColorMap,
              opaque: !1 === k.transparent && 1 === k.blending,
              alphaMap: !!k.alphaMap,
              alphaTest: eS,
              gradientMap: !!k.gradientMap,
              sheen: k.sheen > 0,
              sheenColorMap: !!k.sheenColorMap,
              sheenRoughnessMap: !!k.sheenRoughnessMap,
              transmission: k.transmission > 0,
              transmissionMap: !!k.transmissionMap,
              thicknessMap: !!k.thicknessMap,
              combine: k.combine,
              vertexTangents: !!k.normalMap && !!ed.attributes.tangent,
              vertexColors: k.vertexColors,
              vertexAlphas:
                !0 === k.vertexColors &&
                !!ed.attributes.color &&
                4 === ed.attributes.color.itemSize,
              vertexUvs:
                !!k.map ||
                !!k.bumpMap ||
                !!k.normalMap ||
                !!k.specularMap ||
                !!k.alphaMap ||
                !!k.emissiveMap ||
                !!k.roughnessMap ||
                !!k.metalnessMap ||
                !!k.clearcoatMap ||
                !!k.clearcoatRoughnessMap ||
                !!k.clearcoatNormalMap ||
                !!k.iridescenceMap ||
                !!k.iridescenceThicknessMap ||
                !!k.displacementMap ||
                !!k.transmissionMap ||
                !!k.thicknessMap ||
                !!k.specularIntensityMap ||
                !!k.specularColorMap ||
                !!k.sheenColorMap ||
                !!k.sheenRoughnessMap,
              uvsVertexOnly:
                !(
                  k.map ||
                  k.bumpMap ||
                  k.normalMap ||
                  k.specularMap ||
                  k.alphaMap ||
                  k.emissiveMap ||
                  k.roughnessMap ||
                  k.metalnessMap ||
                  k.clearcoatNormalMap ||
                  k.iridescenceMap ||
                  k.iridescenceThicknessMap ||
                  k.transmission > 0 ||
                  k.transmissionMap ||
                  k.thicknessMap ||
                  k.specularIntensityMap ||
                  k.specularColorMap ||
                  k.sheen > 0 ||
                  k.sheenColorMap ||
                  k.sheenRoughnessMap
                ) && !!k.displacementMap,
              fog: !!ec,
              useFog: !0 === k.fog,
              fogExp2: ec && ec.isFogExp2,
              flatShading: !!k.flatShading,
              sizeAttenuation: k.sizeAttenuation,
              logarithmicDepthBuffer: Q,
              skinning: !0 === ea.isSkinnedMesh,
              morphTargets: void 0 !== ed.morphAttributes.position,
              morphNormals: void 0 !== ed.morphAttributes.normal,
              morphColors: void 0 !== ed.morphAttributes.color,
              morphTargetsCount: eb,
              morphTextureStride: ew,
              numDirLights: j.directional.length,
              numPointLights: j.point.length,
              numSpotLights: j.spot.length,
              numSpotLightMaps: j.spotLightMap.length,
              numRectAreaLights: j.rectArea.length,
              numHemiLights: j.hemi.length,
              numDirLightShadows: j.directionalShadowMap.length,
              numPointLightShadows: j.pointShadowMap.length,
              numSpotLightShadows: j.spotShadowMap.length,
              numSpotLightShadowsWithMaps: j.numSpotLightShadowsWithMaps,
              numClippingPlanes: V.numPlanes,
              numClipIntersection: V.numIntersection,
              dithering: k.dithering,
              shadowMapEnabled: _.shadowMap.enabled && q.length > 0,
              shadowMapType: _.shadowMap.type,
              toneMapping: k.toneMapped ? _.toneMapping : 0,
              physicallyCorrectLights: _.physicallyCorrectLights,
              premultipliedAlpha: k.premultipliedAlpha,
              doubleSided: 2 === k.side,
              flipSided: 1 === k.side,
              useDepthPacking: !!k.depthPacking,
              depthPacking: k.depthPacking || 0,
              index0AttributeName: k.index0AttributeName,
              extensionDerivatives: k.extensions && k.extensions.derivatives,
              extensionFragDepth: k.extensions && k.extensions.fragDepth,
              extensionDrawBuffers: k.extensions && k.extensions.drawBuffers,
              extensionShaderTextureLOD:
                k.extensions && k.extensions.shaderTextureLOD,
              rendererExtensionFragDepth: X || B.has("EXT_frag_depth"),
              rendererExtensionDrawBuffers: X || B.has("WEBGL_draw_buffers"),
              rendererExtensionShaderTextureLod:
                X || B.has("EXT_shader_texture_lod"),
              customProgramCacheKey: k.customProgramCacheKey(),
            };
          },
          getProgramCacheKey: function (I) {
            let R = [];
            if (
              (I.shaderID
                ? R.push(I.shaderID)
                : (R.push(I.customVertexShaderID),
                  R.push(I.customFragmentShaderID)),
              void 0 !== I.defines)
            )
              for (let _ in I.defines) R.push(_), R.push(I.defines[_]);
            return (
              !1 === I.isRawShaderMaterial &&
                (R.push(I.precision),
                R.push(I.outputEncoding),
                R.push(I.envMapMode),
                R.push(I.envMapCubeUVHeight),
                R.push(I.combine),
                R.push(I.vertexUvs),
                R.push(I.fogExp2),
                R.push(I.sizeAttenuation),
                R.push(I.morphTargetsCount),
                R.push(I.morphAttributeCount),
                R.push(I.numDirLights),
                R.push(I.numPointLights),
                R.push(I.numSpotLights),
                R.push(I.numSpotLightMaps),
                R.push(I.numHemiLights),
                R.push(I.numRectAreaLights),
                R.push(I.numDirLightShadows),
                R.push(I.numPointLightShadows),
                R.push(I.numSpotLightShadows),
                R.push(I.numSpotLightShadowsWithMaps),
                R.push(I.shadowMapType),
                R.push(I.toneMapping),
                R.push(I.numClippingPlanes),
                R.push(I.numClipIntersection),
                R.push(I.depthPacking),
                j.disableAll(),
                I.isWebGL2 && j.enable(0),
                I.supportsVertexTextures && j.enable(1),
                I.instancing && j.enable(2),
                I.instancingColor && j.enable(3),
                I.map && j.enable(4),
                I.matcap && j.enable(5),
                I.envMap && j.enable(6),
                I.lightMap && j.enable(7),
                I.aoMap && j.enable(8),
                I.emissiveMap && j.enable(9),
                I.bumpMap && j.enable(10),
                I.normalMap && j.enable(11),
                I.objectSpaceNormalMap && j.enable(12),
                I.tangentSpaceNormalMap && j.enable(13),
                I.clearcoat && j.enable(14),
                I.clearcoatMap && j.enable(15),
                I.clearcoatRoughnessMap && j.enable(16),
                I.clearcoatNormalMap && j.enable(17),
                I.iridescence && j.enable(18),
                I.iridescenceMap && j.enable(19),
                I.iridescenceThicknessMap && j.enable(20),
                I.displacementMap && j.enable(21),
                I.specularMap && j.enable(22),
                I.roughnessMap && j.enable(23),
                I.metalnessMap && j.enable(24),
                I.gradientMap && j.enable(25),
                I.alphaMap && j.enable(26),
                I.alphaTest && j.enable(27),
                I.vertexColors && j.enable(28),
                I.vertexAlphas && j.enable(29),
                I.vertexUvs && j.enable(30),
                I.vertexTangents && j.enable(31),
                I.uvsVertexOnly && j.enable(32),
                R.push(j.mask),
                j.disableAll(),
                I.fog && j.enable(0),
                I.useFog && j.enable(1),
                I.flatShading && j.enable(2),
                I.logarithmicDepthBuffer && j.enable(3),
                I.skinning && j.enable(4),
                I.morphTargets && j.enable(5),
                I.morphNormals && j.enable(6),
                I.morphColors && j.enable(7),
                I.premultipliedAlpha && j.enable(8),
                I.shadowMapEnabled && j.enable(9),
                I.physicallyCorrectLights && j.enable(10),
                I.doubleSided && j.enable(11),
                I.flipSided && j.enable(12),
                I.useDepthPacking && j.enable(13),
                I.dithering && j.enable(14),
                I.specularIntensityMap && j.enable(15),
                I.specularColorMap && j.enable(16),
                I.transmission && j.enable(17),
                I.transmissionMap && j.enable(18),
                I.thicknessMap && j.enable(19),
                I.sheen && j.enable(20),
                I.sheenColorMap && j.enable(21),
                I.sheenRoughnessMap && j.enable(22),
                I.decodeVideoTexture && j.enable(23),
                I.opaque && j.enable(24),
                R.push(j.mask),
                R.push(_.outputEncoding)),
              R.push(I.customProgramCacheKey),
              R.join()
            );
          },
          getUniforms: function (_) {
            let I = er[_.type],
              R;
            if (I) {
              let _ = aQ[I];
              R = aA.clone(_.uniforms);
            } else R = _.uniforms;
            return R;
          },
          acquireProgram: function (I, R) {
            let B;
            for (let _ = 0, I = q.length; _ < I; _++) {
              let I = q[_];
              if (I.cacheKey === R) {
                (B = I), ++B.usedTimes;
                break;
              }
            }
            return void 0 === B && ((B = new PG(_, R, I, k)), q.push(B)), B;
          },
          releaseProgram: function (_) {
            if (0 == --_.usedTimes) {
              let I = q.indexOf(_);
              (q[I] = q[q.length - 1]), q.pop(), _.destroy();
            }
          },
          releaseShaderCache: function (_) {
            G.remove(_);
          },
          programs: q,
          dispose: function () {
            G.dispose();
          },
        };
      }
      function IG() {
        let _ = new WeakMap();
        return {
          get: function (I) {
            let R = _.get(I);
            return void 0 === R && ((R = {}), _.set(I, R)), R;
          },
          remove: function (I) {
            _.delete(I);
          },
          update: function (I, R, B) {
            _.get(I)[R] = B;
          },
          dispose: function () {
            _ = new WeakMap();
          },
        };
      }
      function RG(_, I) {
        return _.groupOrder !== I.groupOrder
          ? _.groupOrder - I.groupOrder
          : _.renderOrder !== I.renderOrder
          ? _.renderOrder - I.renderOrder
          : _.material.id !== I.material.id
          ? _.material.id - I.material.id
          : _.z !== I.z
          ? _.z - I.z
          : _.id - I.id;
      }
      function pM(_, I) {
        return _.groupOrder !== I.groupOrder
          ? _.groupOrder - I.groupOrder
          : _.renderOrder !== I.renderOrder
          ? _.renderOrder - I.renderOrder
          : _.z !== I.z
          ? I.z - _.z
          : _.id - I.id;
      }
      function mM() {
        let _ = [],
          I = 0,
          R = [],
          B = [],
          z = [];
        function o(R, B, z, k, V, j) {
          let G = _[I];
          return (
            void 0 === G
              ? ((G = {
                  id: R.id,
                  object: R,
                  geometry: B,
                  material: z,
                  groupOrder: k,
                  renderOrder: R.renderOrder,
                  z: V,
                  group: j,
                }),
                (_[I] = G))
              : ((G.id = R.id),
                (G.object = R),
                (G.geometry = B),
                (G.material = z),
                (G.groupOrder = k),
                (G.renderOrder = R.renderOrder),
                (G.z = V),
                (G.group = j)),
            I++,
            G
          );
        }
        return {
          opaque: R,
          transmissive: B,
          transparent: z,
          init: function () {
            (I = 0), (R.length = 0), (B.length = 0), (z.length = 0);
          },
          push: function (_, I, k, V, j, G) {
            let q = o(_, I, k, V, j, G);
            k.transmission > 0
              ? B.push(q)
              : !0 === k.transparent
              ? z.push(q)
              : R.push(q);
          },
          unshift: function (_, I, k, V, j, G) {
            let q = o(_, I, k, V, j, G);
            k.transmission > 0
              ? B.unshift(q)
              : !0 === k.transparent
              ? z.unshift(q)
              : R.unshift(q);
          },
          finish: function () {
            for (let R = I, B = _.length; R < B; R++) {
              let I = _[R];
              if (null === I.id) break;
              (I.id = null),
                (I.object = null),
                (I.geometry = null),
                (I.material = null),
                (I.group = null);
            }
          },
          sort: function (_, I) {
            R.length > 1 && R.sort(_ || RG),
              B.length > 1 && B.sort(I || pM),
              z.length > 1 && z.sort(I || pM);
          },
        };
      }
      function LG() {
        let _ = new WeakMap();
        return {
          get: function (I, R) {
            let B = _.get(I),
              z;
            return (
              void 0 === B
                ? ((z = new mM()), _.set(I, [z]))
                : R >= B.length
                ? ((z = new mM()), B.push(z))
                : (z = B[R]),
              z
            );
          },
          dispose: function () {
            _ = new WeakMap();
          },
        };
      }
      function BG() {
        let _ = {};
        return {
          get: function (I) {
            let R;
            if (void 0 !== _[I.id]) return _[I.id];
            switch (I.type) {
              case "DirectionalLight":
                R = { direction: new rF(), color: new ry() };
                break;
              case "SpotLight":
                R = {
                  position: new rF(),
                  direction: new rF(),
                  color: new ry(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                R = {
                  position: new rF(),
                  color: new ry(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                R = {
                  direction: new rF(),
                  skyColor: new ry(),
                  groundColor: new ry(),
                };
                break;
              case "RectAreaLight":
                R = {
                  color: new ry(),
                  position: new rF(),
                  halfWidth: new rF(),
                  halfHeight: new rF(),
                };
            }
            return (_[I.id] = R), R;
          },
        };
      }
      var nw = 0;
      function kG(_, I) {
        return (
          (I.castShadow ? 2 : 0) -
          (_.castShadow ? 2 : 0) +
          (I.map ? 1 : 0) -
          (_.map ? 1 : 0)
        );
      }
      function VG(_, I) {
        let R;
        let B = new BG(),
          z =
            ((R = {}),
            {
              get: function (_) {
                let I;
                if (void 0 !== R[_.id]) return R[_.id];
                switch (_.type) {
                  case "DirectionalLight":
                  case "SpotLight":
                    I = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new rs(),
                    };
                    break;
                  case "PointLight":
                    I = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new rs(),
                      shadowCameraNear: 1,
                      shadowCameraFar: 1e3,
                    };
                }
                return (R[_.id] = I), I;
              },
            }),
          k = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
              numSpotMaps: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
          };
        for (let _ = 0; _ < 9; _++) k.probe.push(new rF());
        let V = new rF(),
          j = new sa(),
          G = new sa();
        return {
          setup: function (R, V) {
            let j = 0,
              G = 0,
              q = 0;
            for (let _ = 0; _ < 9; _++) k.probe[_].set(0, 0, 0);
            let X = 0,
              Q = 0,
              $ = 0,
              et = 0,
              er = 0,
              es = 0,
              ea = 0,
              en = 0,
              eo = 0,
              el = 0;
            R.sort(kG);
            let eh = !0 !== V ? Math.PI : 1;
            for (let _ = 0, I = R.length; _ < I; _++) {
              let I = R[_],
                V = I.color,
                ec = I.intensity,
                ed = I.distance,
                ep = I.shadow && I.shadow.map ? I.shadow.map.texture : null;
              if (I.isAmbientLight)
                (j += V.r * ec * eh),
                  (G += V.g * ec * eh),
                  (q += V.b * ec * eh);
              else if (I.isLightProbe)
                for (let _ = 0; _ < 9; _++)
                  k.probe[_].addScaledVector(I.sh.coefficients[_], ec);
              else if (I.isDirectionalLight) {
                let _ = B.get(I);
                if (
                  (_.color.copy(I.color).multiplyScalar(I.intensity * eh),
                  I.castShadow)
                ) {
                  let _ = I.shadow,
                    R = z.get(I);
                  (R.shadowBias = _.bias),
                    (R.shadowNormalBias = _.normalBias),
                    (R.shadowRadius = _.radius),
                    (R.shadowMapSize = _.mapSize),
                    (k.directionalShadow[X] = R),
                    (k.directionalShadowMap[X] = ep),
                    (k.directionalShadowMatrix[X] = I.shadow.matrix),
                    es++;
                }
                (k.directional[X] = _), X++;
              } else if (I.isSpotLight) {
                let _ = B.get(I);
                _.position.setFromMatrixPosition(I.matrixWorld),
                  _.color.copy(V).multiplyScalar(ec * eh),
                  (_.distance = ed),
                  (_.coneCos = Math.cos(I.angle)),
                  (_.penumbraCos = Math.cos(I.angle * (1 - I.penumbra))),
                  (_.decay = I.decay),
                  (k.spot[$] = _);
                let R = I.shadow;
                if (
                  (I.map &&
                    ((k.spotLightMap[eo] = I.map),
                    eo++,
                    R.updateMatrices(I),
                    I.castShadow && el++),
                  (k.spotLightMatrix[$] = R.matrix),
                  I.castShadow)
                ) {
                  let _ = z.get(I);
                  (_.shadowBias = R.bias),
                    (_.shadowNormalBias = R.normalBias),
                    (_.shadowRadius = R.radius),
                    (_.shadowMapSize = R.mapSize),
                    (k.spotShadow[$] = _),
                    (k.spotShadowMap[$] = ep),
                    en++;
                }
                $++;
              } else if (I.isRectAreaLight) {
                let _ = B.get(I);
                _.color.copy(V).multiplyScalar(ec),
                  _.halfWidth.set(0.5 * I.width, 0, 0),
                  _.halfHeight.set(0, 0.5 * I.height, 0),
                  (k.rectArea[et] = _),
                  et++;
              } else if (I.isPointLight) {
                let _ = B.get(I);
                if (
                  (_.color.copy(I.color).multiplyScalar(I.intensity * eh),
                  (_.distance = I.distance),
                  (_.decay = I.decay),
                  I.castShadow)
                ) {
                  let _ = I.shadow,
                    R = z.get(I);
                  (R.shadowBias = _.bias),
                    (R.shadowNormalBias = _.normalBias),
                    (R.shadowRadius = _.radius),
                    (R.shadowMapSize = _.mapSize),
                    (R.shadowCameraNear = _.camera.near),
                    (R.shadowCameraFar = _.camera.far),
                    (k.pointShadow[Q] = R),
                    (k.pointShadowMap[Q] = ep),
                    (k.pointShadowMatrix[Q] = I.shadow.matrix),
                    ea++;
                }
                (k.point[Q] = _), Q++;
              } else if (I.isHemisphereLight) {
                let _ = B.get(I);
                _.skyColor.copy(I.color).multiplyScalar(ec * eh),
                  _.groundColor.copy(I.groundColor).multiplyScalar(ec * eh),
                  (k.hemi[er] = _),
                  er++;
              }
            }
            et > 0 &&
              (I.isWebGL2 || !0 === _.has("OES_texture_float_linear")
                ? ((k.rectAreaLTC1 = aX.LTC_FLOAT_1),
                  (k.rectAreaLTC2 = aX.LTC_FLOAT_2))
                : !0 === _.has("OES_texture_half_float_linear")
                ? ((k.rectAreaLTC1 = aX.LTC_HALF_1),
                  (k.rectAreaLTC2 = aX.LTC_HALF_2))
                : console.error(
                    "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                  )),
              (k.ambient[0] = j),
              (k.ambient[1] = G),
              (k.ambient[2] = q);
            let ec = k.hash;
            (ec.directionalLength !== X ||
              ec.pointLength !== Q ||
              ec.spotLength !== $ ||
              ec.rectAreaLength !== et ||
              ec.hemiLength !== er ||
              ec.numDirectionalShadows !== es ||
              ec.numPointShadows !== ea ||
              ec.numSpotShadows !== en ||
              ec.numSpotMaps !== eo) &&
              ((k.directional.length = X),
              (k.spot.length = $),
              (k.rectArea.length = et),
              (k.point.length = Q),
              (k.hemi.length = er),
              (k.directionalShadow.length = es),
              (k.directionalShadowMap.length = es),
              (k.pointShadow.length = ea),
              (k.pointShadowMap.length = ea),
              (k.spotShadow.length = en),
              (k.spotShadowMap.length = en),
              (k.directionalShadowMatrix.length = es),
              (k.pointShadowMatrix.length = ea),
              (k.spotLightMatrix.length = en + eo - el),
              (k.spotLightMap.length = eo),
              (k.numSpotLightShadowsWithMaps = el),
              (ec.directionalLength = X),
              (ec.pointLength = Q),
              (ec.spotLength = $),
              (ec.rectAreaLength = et),
              (ec.hemiLength = er),
              (ec.numDirectionalShadows = es),
              (ec.numPointShadows = ea),
              (ec.numSpotShadows = en),
              (ec.numSpotMaps = eo),
              (k.version = nw++));
          },
          setupView: function (_, I) {
            let R = 0,
              B = 0,
              z = 0,
              q = 0,
              X = 0,
              Q = I.matrixWorldInverse;
            for (let I = 0, $ = _.length; I < $; I++) {
              let $ = _[I];
              if ($.isDirectionalLight) {
                let _ = k.directional[R];
                _.direction.setFromMatrixPosition($.matrixWorld),
                  V.setFromMatrixPosition($.target.matrixWorld),
                  _.direction.sub(V),
                  _.direction.transformDirection(Q),
                  R++;
              } else if ($.isSpotLight) {
                let _ = k.spot[z];
                _.position.setFromMatrixPosition($.matrixWorld),
                  _.position.applyMatrix4(Q),
                  _.direction.setFromMatrixPosition($.matrixWorld),
                  V.setFromMatrixPosition($.target.matrixWorld),
                  _.direction.sub(V),
                  _.direction.transformDirection(Q),
                  z++;
              } else if ($.isRectAreaLight) {
                let _ = k.rectArea[q];
                _.position.setFromMatrixPosition($.matrixWorld),
                  _.position.applyMatrix4(Q),
                  G.identity(),
                  j.copy($.matrixWorld),
                  j.premultiply(Q),
                  G.extractRotation(j),
                  _.halfWidth.set(0.5 * $.width, 0, 0),
                  _.halfHeight.set(0, 0.5 * $.height, 0),
                  _.halfWidth.applyMatrix4(G),
                  _.halfHeight.applyMatrix4(G),
                  q++;
              } else if ($.isPointLight) {
                let _ = k.point[B];
                _.position.setFromMatrixPosition($.matrixWorld),
                  _.position.applyMatrix4(Q),
                  B++;
              } else if ($.isHemisphereLight) {
                let _ = k.hemi[X];
                _.direction.setFromMatrixPosition($.matrixWorld),
                  _.direction.transformDirection(Q),
                  X++;
              }
            }
          },
          state: k,
        };
      }
      function gM(_, I) {
        let R = new VG(_, I),
          B = [],
          z = [];
        return {
          init: function () {
            (B.length = 0), (z.length = 0);
          },
          state: { lightsArray: B, shadowsArray: z, lights: R },
          setupLights: function (_) {
            R.setup(B, _);
          },
          setupLightsView: function (_) {
            R.setupView(B, _);
          },
          pushLight: function (_) {
            B.push(_);
          },
          pushShadow: function (_) {
            z.push(_);
          },
        };
      }
      function zG(_, I) {
        let R = new WeakMap();
        return {
          get: function (B, z = 0) {
            let k = R.get(B),
              V;
            return (
              void 0 === k
                ? ((V = new gM(_, I)), R.set(B, [V]))
                : z >= k.length
                ? ((V = new gM(_, I)), k.push(V))
                : (V = k[z]),
              V
            );
          },
          dispose: function () {
            R = new WeakMap();
          },
        };
      }
      var n_ = class extends sZ {
          constructor(_) {
            super(),
              (this.isMeshDepthMaterial = !0),
              (this.type = "MeshDepthMaterial"),
              (this.depthPacking = 3200),
              (this.map = null),
              (this.alphaMap = null),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              this.setValues(_);
          }
          copy(_) {
            return (
              super.copy(_),
              (this.depthPacking = _.depthPacking),
              (this.map = _.map),
              (this.alphaMap = _.alphaMap),
              (this.displacementMap = _.displacementMap),
              (this.displacementScale = _.displacementScale),
              (this.displacementBias = _.displacementBias),
              (this.wireframe = _.wireframe),
              (this.wireframeLinewidth = _.wireframeLinewidth),
              this
            );
          }
        },
        nS = class extends sZ {
          constructor(_) {
            super(),
              (this.isMeshDistanceMaterial = !0),
              (this.type = "MeshDistanceMaterial"),
              (this.referencePosition = new rF()),
              (this.nearDistance = 1),
              (this.farDistance = 1e3),
              (this.map = null),
              (this.alphaMap = null),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              this.setValues(_);
          }
          copy(_) {
            return (
              super.copy(_),
              this.referencePosition.copy(_.referencePosition),
              (this.nearDistance = _.nearDistance),
              (this.farDistance = _.farDistance),
              (this.map = _.map),
              (this.alphaMap = _.alphaMap),
              (this.displacementMap = _.displacementMap),
              (this.displacementScale = _.displacementScale),
              (this.displacementBias = _.displacementBias),
              this
            );
          }
        },
        nA = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
        nM = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
      function jG(_, I, R) {
        let B = new aW(),
          z = new rs(),
          k = new rs(),
          V = new rM(),
          j = new n_({ depthPacking: 3201 }),
          G = new nS(),
          q = {},
          X = R.maxTextureSize,
          Q = { 0: 1, 1: 0, 2: 2 },
          $ = new aT({
            defines: { VSM_SAMPLES: 8 },
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new rs() },
              radius: { value: 4 },
            },
            vertexShader: nA,
            fragmentShader: nM,
          }),
          et = $.clone();
        et.defines.HORIZONTAL_PASS = 1;
        let er = new ai();
        er.setAttribute(
          "position",
          new s0(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
        );
        let es = new aw(er, $),
          ea = this;
        function v(I, R, B, z, k, V) {
          let X = null,
            $ =
              !0 === B.isPointLight
                ? I.customDistanceMaterial
                : I.customDepthMaterial;
          if (void 0 !== $) X = $;
          else if (
            ((X = !0 === B.isPointLight ? G : j),
            (_.localClippingEnabled &&
              !0 === R.clipShadows &&
              Array.isArray(R.clippingPlanes) &&
              0 !== R.clippingPlanes.length) ||
              (R.displacementMap && 0 !== R.displacementScale) ||
              (R.alphaMap && R.alphaTest > 0) ||
              (R.map && R.alphaTest > 0))
          ) {
            let _ = X.uuid,
              I = R.uuid,
              B = q[_];
            void 0 === B && ((B = {}), (q[_] = B));
            let z = B[I];
            void 0 === z && ((z = X.clone()), (B[I] = z)), (X = z);
          }
          return (
            (X.visible = R.visible),
            (X.wireframe = R.wireframe),
            3 === V
              ? (X.side = null !== R.shadowSide ? R.shadowSide : R.side)
              : (X.side = null !== R.shadowSide ? R.shadowSide : Q[R.side]),
            (X.alphaMap = R.alphaMap),
            (X.alphaTest = R.alphaTest),
            (X.map = R.map),
            (X.clipShadows = R.clipShadows),
            (X.clippingPlanes = R.clippingPlanes),
            (X.clipIntersection = R.clipIntersection),
            (X.displacementMap = R.displacementMap),
            (X.displacementScale = R.displacementScale),
            (X.displacementBias = R.displacementBias),
            (X.wireframeLinewidth = R.wireframeLinewidth),
            (X.linewidth = R.linewidth),
            !0 === B.isPointLight &&
              !0 === X.isMeshDistanceMaterial &&
              (X.referencePosition.setFromMatrixPosition(B.matrixWorld),
              (X.nearDistance = z),
              (X.farDistance = k)),
            X
          );
        }
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = 1),
          (this.render = function (R, j, G) {
            if (
              !1 === ea.enabled ||
              (!1 === ea.autoUpdate && !1 === ea.needsUpdate) ||
              0 === R.length
            )
              return;
            let q = _.getRenderTarget(),
              Q = _.getActiveCubeFace(),
              er = _.getActiveMipmapLevel(),
              en = _.state;
            en.setBlending(0),
              en.buffers.color.setClear(1, 1, 1, 1),
              en.buffers.depth.setTest(!0),
              en.setScissorTest(!1);
            for (let q = 0, Q = R.length; q < Q; q++) {
              let Q = R[q],
                er = Q.shadow;
              if (void 0 === er) {
                console.warn("THREE.WebGLShadowMap:", Q, "has no shadow.");
                continue;
              }
              if (!1 === er.autoUpdate && !1 === er.needsUpdate) continue;
              z.copy(er.mapSize);
              let ea = er.getFrameExtents();
              if (
                (z.multiply(ea),
                k.copy(er.mapSize),
                (z.x > X || z.y > X) &&
                  (z.x > X &&
                    ((k.x = Math.floor(X / ea.x)),
                    (z.x = k.x * ea.x),
                    (er.mapSize.x = k.x)),
                  z.y > X &&
                    ((k.y = Math.floor(X / ea.y)),
                    (z.y = k.y * ea.y),
                    (er.mapSize.y = k.y))),
                null === er.map)
              ) {
                let _ =
                  3 !== this.type ? { minFilter: 1003, magFilter: 1003 } : {};
                (er.map = new rT(z.x, z.y, _)),
                  (er.map.texture.name = Q.name + ".shadowMap"),
                  er.camera.updateProjectionMatrix();
              }
              _.setRenderTarget(er.map), _.clear();
              let eo = er.getViewportCount();
              for (let R = 0; R < eo; R++) {
                let z = er.getViewport(R);
                V.set(k.x * z.x, k.y * z.y, k.x * z.z, k.y * z.w),
                  en.viewport(V),
                  er.updateMatrices(Q, R),
                  (B = er.getFrustum()),
                  (function x(R, z, k, V, j) {
                    if (!1 === R.visible) return;
                    if (
                      R.layers.test(z.layers) &&
                      (R.isMesh || R.isLine || R.isPoints) &&
                      (R.castShadow || (R.receiveShadow && 3 === j)) &&
                      (!R.frustumCulled || B.intersectsObject(R))
                    ) {
                      R.modelViewMatrix.multiplyMatrices(
                        k.matrixWorldInverse,
                        R.matrixWorld
                      );
                      let B = I.update(R),
                        z = R.material;
                      if (Array.isArray(z)) {
                        let I = B.groups;
                        for (let G = 0, q = I.length; G < q; G++) {
                          let q = I[G],
                            X = z[q.materialIndex];
                          if (X && X.visible) {
                            let I = v(R, X, V, k.near, k.far, j);
                            _.renderBufferDirect(k, null, B, I, R, q);
                          }
                        }
                      } else if (z.visible) {
                        let I = v(R, z, V, k.near, k.far, j);
                        _.renderBufferDirect(k, null, B, I, R, null);
                      }
                    }
                    let G = R.children;
                    for (let _ = 0, I = G.length; _ < I; _++)
                      x(G[_], z, k, V, j);
                  })(j, G, er.camera, Q, this.type);
              }
              !0 !== er.isPointLightShadow &&
                3 === this.type &&
                (function (R, B) {
                  let k = I.update(es);
                  $.defines.VSM_SAMPLES !== R.blurSamples &&
                    (($.defines.VSM_SAMPLES = R.blurSamples),
                    (et.defines.VSM_SAMPLES = R.blurSamples),
                    ($.needsUpdate = !0),
                    (et.needsUpdate = !0)),
                    null === R.mapPass && (R.mapPass = new rT(z.x, z.y)),
                    ($.uniforms.shadow_pass.value = R.map.texture),
                    ($.uniforms.resolution.value = R.mapSize),
                    ($.uniforms.radius.value = R.radius),
                    _.setRenderTarget(R.mapPass),
                    _.clear(),
                    _.renderBufferDirect(B, null, k, $, es, null),
                    (et.uniforms.shadow_pass.value = R.mapPass.texture),
                    (et.uniforms.resolution.value = R.mapSize),
                    (et.uniforms.radius.value = R.radius),
                    _.setRenderTarget(R.map),
                    _.clear(),
                    _.renderBufferDirect(B, null, k, et, es, null);
                })(er, G),
                (er.needsUpdate = !1);
            }
            (ea.needsUpdate = !1), _.setRenderTarget(q, Q, er);
          });
      }
      function HG(_, I, R) {
        let B = R.isWebGL2,
          z = new (function () {
            let I = !1,
              R = new rM(),
              B = null,
              z = new rM(0, 0, 0, 0);
            return {
              setMask: function (R) {
                B === R || I || (_.colorMask(R, R, R, R), (B = R));
              },
              setLocked: function (_) {
                I = _;
              },
              setClear: function (I, B, k, V, j) {
                !0 === j && ((I *= V), (B *= V), (k *= V)),
                  R.set(I, B, k, V),
                  !1 === z.equals(R) && (_.clearColor(I, B, k, V), z.copy(R));
              },
              reset: function () {
                (I = !1), (B = null), z.set(-1, 0, 0, 0);
              },
            };
          })(),
          k = new (function () {
            let I = !1,
              R = null,
              B = null,
              z = null;
            return {
              setTest: function (_) {
                _ ? ne(2929) : ie(2929);
              },
              setMask: function (B) {
                R === B || I || (_.depthMask(B), (R = B));
              },
              setFunc: function (I) {
                if (B !== I) {
                  switch (I) {
                    case 0:
                      _.depthFunc(512);
                      break;
                    case 1:
                      _.depthFunc(519);
                      break;
                    case 2:
                      _.depthFunc(513);
                      break;
                    case 3:
                    default:
                      _.depthFunc(515);
                      break;
                    case 4:
                      _.depthFunc(514);
                      break;
                    case 5:
                      _.depthFunc(518);
                      break;
                    case 6:
                      _.depthFunc(516);
                      break;
                    case 7:
                      _.depthFunc(517);
                  }
                  B = I;
                }
              },
              setLocked: function (_) {
                I = _;
              },
              setClear: function (I) {
                z !== I && (_.clearDepth(I), (z = I));
              },
              reset: function () {
                (I = !1), (R = null), (B = null), (z = null);
              },
            };
          })(),
          V = new (function () {
            let I = !1,
              R = null,
              B = null,
              z = null,
              k = null,
              V = null,
              j = null,
              G = null,
              q = null;
            return {
              setTest: function (_) {
                I || (_ ? ne(2960) : ie(2960));
              },
              setMask: function (B) {
                R === B || I || (_.stencilMask(B), (R = B));
              },
              setFunc: function (I, R, V) {
                (B !== I || z !== R || k !== V) &&
                  (_.stencilFunc(I, R, V), (B = I), (z = R), (k = V));
              },
              setOp: function (I, R, B) {
                (V !== I || j !== R || G !== B) &&
                  (_.stencilOp(I, R, B), (V = I), (j = R), (G = B));
              },
              setLocked: function (_) {
                I = _;
              },
              setClear: function (I) {
                q !== I && (_.clearStencil(I), (q = I));
              },
              reset: function () {
                (I = !1),
                  (R = null),
                  (B = null),
                  (z = null),
                  (k = null),
                  (V = null),
                  (j = null),
                  (G = null),
                  (q = null);
              },
            };
          })(),
          j = new WeakMap(),
          G = new WeakMap(),
          q = {},
          X = {},
          Q = new WeakMap(),
          $ = [],
          et = null,
          er = !1,
          es = null,
          ea = null,
          en = null,
          eo = null,
          el = null,
          eh = null,
          ec = null,
          ed = !1,
          ep = null,
          ef = null,
          em = null,
          ey = null,
          ex = null,
          eb = _.getParameter(35661),
          ew = !1,
          e_ = _.getParameter(7938);
        -1 !== e_.indexOf("WebGL")
          ? (ew = parseFloat(/^WebGL (\d)/.exec(e_)[1]) >= 1)
          : -1 !== e_.indexOf("OpenGL ES") &&
            (ew = parseFloat(/^OpenGL ES (\d)/.exec(e_)[1]) >= 2);
        let eS = null,
          eA = {},
          eC = _.getParameter(3088),
          eT = _.getParameter(2978),
          eP = new rM().fromArray(eC),
          eI = new rM().fromArray(eT);
        function Z(I, R, B) {
          let z = new Uint8Array(4),
            k = _.createTexture();
          _.bindTexture(I, k),
            _.texParameteri(I, 10241, 9728),
            _.texParameteri(I, 10240, 9728);
          for (let I = 0; I < B; I++)
            _.texImage2D(R + I, 0, 6408, 1, 1, 0, 6408, 5121, z);
          return k;
        }
        let eR = {};
        function ne(I) {
          !0 !== q[I] && (_.enable(I), (q[I] = !0));
        }
        function ie(I) {
          !1 !== q[I] && (_.disable(I), (q[I] = !1));
        }
        (eR[3553] = Z(3553, 3553, 1)),
          (eR[34067] = Z(34067, 34069, 6)),
          z.setClear(0, 0, 0, 1),
          k.setClear(1),
          V.setClear(0),
          ne(2929),
          k.setFunc(3),
          ze(!1),
          Ve(1),
          ne(2884),
          Oe(0);
        let eB = { 100: 32774, 101: 32778, 102: 32779 };
        if (B) (eB[103] = 32775), (eB[104] = 32776);
        else {
          let _ = I.get("EXT_blend_minmax");
          null !== _ && ((eB[103] = _.MIN_EXT), (eB[104] = _.MAX_EXT));
        }
        let ez = {
          200: 0,
          201: 1,
          202: 768,
          204: 770,
          210: 776,
          208: 774,
          206: 772,
          203: 769,
          205: 771,
          209: 775,
          207: 773,
        };
        function Oe(I, R, B, z, k, V, j, G) {
          if (0 === I) {
            !0 === er && (ie(3042), (er = !1));
            return;
          }
          if ((!1 === er && (ne(3042), (er = !0)), 5 !== I)) {
            if (I !== es || G !== ed) {
              if (
                ((100 !== ea || 100 !== el) &&
                  (_.blendEquation(32774), (ea = 100), (el = 100)),
                G)
              )
                switch (I) {
                  case 1:
                    _.blendFuncSeparate(1, 771, 1, 771);
                    break;
                  case 2:
                    _.blendFunc(1, 1);
                    break;
                  case 3:
                    _.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case 4:
                    _.blendFuncSeparate(0, 768, 0, 770);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", I);
                }
              else
                switch (I) {
                  case 1:
                    _.blendFuncSeparate(770, 771, 1, 771);
                    break;
                  case 2:
                    _.blendFunc(770, 1);
                    break;
                  case 3:
                    _.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case 4:
                    _.blendFunc(0, 768);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", I);
                }
              (en = null),
                (eo = null),
                (eh = null),
                (ec = null),
                (es = I),
                (ed = G);
            }
            return;
          }
          (k = k || R),
            (V = V || B),
            (j = j || z),
            (R !== ea || k !== el) &&
              (_.blendEquationSeparate(eB[R], eB[k]), (ea = R), (el = k)),
            (B !== en || z !== eo || V !== eh || j !== ec) &&
              (_.blendFuncSeparate(ez[B], ez[z], ez[V], ez[j]),
              (en = B),
              (eo = z),
              (eh = V),
              (ec = j)),
            (es = I),
            (ed = !1);
        }
        function ze(I) {
          ep !== I && (I ? _.frontFace(2304) : _.frontFace(2305), (ep = I));
        }
        function Ve(I) {
          0 !== I
            ? (ne(2884),
              I !== ef &&
                (1 === I
                  ? _.cullFace(1029)
                  : 2 === I
                  ? _.cullFace(1028)
                  : _.cullFace(1032)))
            : ie(2884),
            (ef = I);
        }
        function Ie(I, R, B) {
          I
            ? (ne(32823),
              (ey !== R || ex !== B) &&
                (_.polygonOffset(R, B), (ey = R), (ex = B)))
            : ie(32823);
        }
        return {
          buffers: { color: z, depth: k, stencil: V },
          enable: ne,
          disable: ie,
          bindFramebuffer: function (I, R) {
            return (
              X[I] !== R &&
              (_.bindFramebuffer(I, R),
              (X[I] = R),
              B &&
                (36009 === I && (X[36160] = R), 36160 === I && (X[36009] = R)),
              !0)
            );
          },
          drawBuffers: function (B, z) {
            let k = $,
              V = !1;
            if (B) {
              if (
                (void 0 === (k = Q.get(z)) && ((k = []), Q.set(z, k)),
                B.isWebGLMultipleRenderTargets)
              ) {
                let _ = B.texture;
                if (k.length !== _.length || 36064 !== k[0]) {
                  for (let I = 0, R = _.length; I < R; I++) k[I] = 36064 + I;
                  (k.length = _.length), (V = !0);
                }
              } else 36064 !== k[0] && ((k[0] = 36064), (V = !0));
            } else 1029 !== k[0] && ((k[0] = 1029), (V = !0));
            V &&
              (R.isWebGL2
                ? _.drawBuffers(k)
                : I.get("WEBGL_draw_buffers").drawBuffersWEBGL(k));
          },
          useProgram: function (I) {
            return et !== I && (_.useProgram(I), (et = I), !0);
          },
          setBlending: Oe,
          setMaterial: function (_, I) {
            2 === _.side ? ie(2884) : ne(2884);
            let R = 1 === _.side;
            I && (R = !R),
              ze(R),
              1 === _.blending && !1 === _.transparent
                ? Oe(0)
                : Oe(
                    _.blending,
                    _.blendEquation,
                    _.blendSrc,
                    _.blendDst,
                    _.blendEquationAlpha,
                    _.blendSrcAlpha,
                    _.blendDstAlpha,
                    _.premultipliedAlpha
                  ),
              k.setFunc(_.depthFunc),
              k.setTest(_.depthTest),
              k.setMask(_.depthWrite),
              z.setMask(_.colorWrite);
            let B = _.stencilWrite;
            V.setTest(B),
              B &&
                (V.setMask(_.stencilWriteMask),
                V.setFunc(_.stencilFunc, _.stencilRef, _.stencilFuncMask),
                V.setOp(_.stencilFail, _.stencilZFail, _.stencilZPass)),
              Ie(_.polygonOffset, _.polygonOffsetFactor, _.polygonOffsetUnits),
              !0 === _.alphaToCoverage ? ne(32926) : ie(32926);
          },
          setFlipSided: ze,
          setCullFace: Ve,
          setLineWidth: function (I) {
            I !== em && (ew && _.lineWidth(I), (em = I));
          },
          setPolygonOffset: Ie,
          setScissorTest: function (_) {
            _ ? ne(3089) : ie(3089);
          },
          activeTexture: function (I) {
            void 0 === I && (I = 33984 + eb - 1),
              eS !== I && (_.activeTexture(I), (eS = I));
          },
          bindTexture: function (I, R, B) {
            void 0 === B && (B = null === eS ? 33984 + eb - 1 : eS);
            let z = eA[B];
            void 0 === z &&
              ((z = { type: void 0, texture: void 0 }), (eA[B] = z)),
              (z.type !== I || z.texture !== R) &&
                (eS !== B && (_.activeTexture(B), (eS = B)),
                _.bindTexture(I, R || eR[I]),
                (z.type = I),
                (z.texture = R));
          },
          unbindTexture: function () {
            let I = eA[eS];
            void 0 !== I &&
              void 0 !== I.type &&
              (_.bindTexture(I.type, null),
              (I.type = void 0),
              (I.texture = void 0));
          },
          compressedTexImage2D: function () {
            try {
              _.compressedTexImage2D.apply(_, arguments);
            } catch (_) {
              console.error("THREE.WebGLState:", _);
            }
          },
          compressedTexImage3D: function () {
            try {
              _.compressedTexImage3D.apply(_, arguments);
            } catch (_) {
              console.error("THREE.WebGLState:", _);
            }
          },
          texImage2D: function () {
            try {
              _.texImage2D.apply(_, arguments);
            } catch (_) {
              console.error("THREE.WebGLState:", _);
            }
          },
          texImage3D: function () {
            try {
              _.texImage3D.apply(_, arguments);
            } catch (_) {
              console.error("THREE.WebGLState:", _);
            }
          },
          updateUBOMapping: function (I, R) {
            let B = G.get(R);
            void 0 === B && ((B = new WeakMap()), G.set(R, B));
            let z = B.get(I);
            void 0 === z &&
              ((z = _.getUniformBlockIndex(R, I.name)), B.set(I, z));
          },
          uniformBlockBinding: function (I, R) {
            let B = G.get(R).get(I);
            j.get(R) !== B &&
              (_.uniformBlockBinding(R, B, I.__bindingPointIndex), j.set(R, B));
          },
          texStorage2D: function () {
            try {
              _.texStorage2D.apply(_, arguments);
            } catch (_) {
              console.error("THREE.WebGLState:", _);
            }
          },
          texStorage3D: function () {
            try {
              _.texStorage3D.apply(_, arguments);
            } catch (_) {
              console.error("THREE.WebGLState:", _);
            }
          },
          texSubImage2D: function () {
            try {
              _.texSubImage2D.apply(_, arguments);
            } catch (_) {
              console.error("THREE.WebGLState:", _);
            }
          },
          texSubImage3D: function () {
            try {
              _.texSubImage3D.apply(_, arguments);
            } catch (_) {
              console.error("THREE.WebGLState:", _);
            }
          },
          compressedTexSubImage2D: function () {
            try {
              _.compressedTexSubImage2D.apply(_, arguments);
            } catch (_) {
              console.error("THREE.WebGLState:", _);
            }
          },
          compressedTexSubImage3D: function () {
            try {
              _.compressedTexSubImage3D.apply(_, arguments);
            } catch (_) {
              console.error("THREE.WebGLState:", _);
            }
          },
          scissor: function (I) {
            !1 === eP.equals(I) && (_.scissor(I.x, I.y, I.z, I.w), eP.copy(I));
          },
          viewport: function (I) {
            !1 === eI.equals(I) && (_.viewport(I.x, I.y, I.z, I.w), eI.copy(I));
          },
          reset: function () {
            _.disable(3042),
              _.disable(2884),
              _.disable(2929),
              _.disable(32823),
              _.disable(3089),
              _.disable(2960),
              _.disable(32926),
              _.blendEquation(32774),
              _.blendFunc(1, 0),
              _.blendFuncSeparate(1, 0, 1, 0),
              _.colorMask(!0, !0, !0, !0),
              _.clearColor(0, 0, 0, 0),
              _.depthMask(!0),
              _.depthFunc(513),
              _.clearDepth(1),
              _.stencilMask(4294967295),
              _.stencilFunc(519, 0, 4294967295),
              _.stencilOp(7680, 7680, 7680),
              _.clearStencil(0),
              _.cullFace(1029),
              _.frontFace(2305),
              _.polygonOffset(0, 0),
              _.activeTexture(33984),
              _.bindFramebuffer(36160, null),
              !0 === B &&
                (_.bindFramebuffer(36009, null),
                _.bindFramebuffer(36008, null)),
              _.useProgram(null),
              _.lineWidth(1),
              _.scissor(0, 0, _.canvas.width, _.canvas.height),
              _.viewport(0, 0, _.canvas.width, _.canvas.height),
              (q = {}),
              (eS = null),
              (eA = {}),
              (X = {}),
              (Q = new WeakMap()),
              ($ = []),
              (et = null),
              (er = !1),
              (es = null),
              (ea = null),
              (en = null),
              (eo = null),
              (el = null),
              (eh = null),
              (ec = null),
              (ed = !1),
              (ep = null),
              (ef = null),
              (em = null),
              (ey = null),
              (ex = null),
              eP.set(0, 0, _.canvas.width, _.canvas.height),
              eI.set(0, 0, _.canvas.width, _.canvas.height),
              z.reset(),
              k.reset(),
              V.reset();
          },
        };
      }
      function WG(_, I, R, B, z, k, V) {
        let j = z.isWebGL2,
          G = z.maxTextures,
          q = z.maxCubemapSize,
          X = z.maxTextureSize,
          Q = z.maxSamples,
          $ = I.has("WEBGL_multisampled_render_to_texture")
            ? I.get("WEBGL_multisampled_render_to_texture")
            : null,
          et =
            !(typeof navigator > "u") &&
            /OculusBrowser/g.test(navigator.userAgent),
          er = new WeakMap(),
          es,
          ea = new WeakMap(),
          en = !1;
        try {
          en =
            "u" > typeof OffscreenCanvas &&
            null !== new OffscreenCanvas(1, 1).getContext("2d");
        } catch {}
        function v(_, I) {
          return en ? new OffscreenCanvas(_, I) : _p("canvas");
        }
        function x(_, I, R, B) {
          let z = 1;
          if (
            ((_.width > B || _.height > B) &&
              (z = B / Math.max(_.width, _.height)),
            z < 1 || !0 === I)
          ) {
            if (
              !(
                ("u" > typeof HTMLImageElement &&
                  _ instanceof HTMLImageElement) ||
                ("u" > typeof HTMLCanvasElement &&
                  _ instanceof HTMLCanvasElement) ||
                ("u" > typeof ImageBitmap && _ instanceof ImageBitmap)
              )
            )
              return (
                "data" in _ &&
                  console.warn(
                    "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                      _.width +
                      "x" +
                      _.height +
                      ")."
                  ),
                _
              );
            {
              let B = I ? my : Math.floor,
                k = B(z * _.width),
                V = B(z * _.height);
              void 0 === es && (es = v(k, V));
              let j = R ? v(k, V) : es;
              return (
                (j.width = k),
                (j.height = V),
                j.getContext("2d").drawImage(_, 0, 0, k, V),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    _.width +
                    "x" +
                    _.height +
                    ") to (" +
                    k +
                    "x" +
                    V +
                    ")."
                ),
                j
              );
            }
          }
          return _;
        }
        function S(_) {
          return YS(_.width) && YS(_.height);
        }
        function A(_, I) {
          return (
            _.generateMipmaps &&
            I &&
            1003 !== _.minFilter &&
            1006 !== _.minFilter
          );
        }
        function E(I) {
          _.generateMipmap(I);
        }
        function b(R, B, z, k, V = !1) {
          if (!1 === j) return B;
          if (null !== R) {
            if (void 0 !== _[R]) return _[R];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                R +
                "'"
            );
          }
          let G = B;
          return (
            6403 === B &&
              (5126 === z && (G = 33326),
              5131 === z && (G = 33325),
              5121 === z && (G = 33321)),
            33319 === B &&
              (5126 === z && (G = 33328),
              5131 === z && (G = 33327),
              5121 === z && (G = 33323)),
            6408 === B &&
              (5126 === z && (G = 34836),
              5131 === z && (G = 34842),
              5121 === z && (G = 3001 === k && !1 === V ? 35907 : 32856),
              32819 === z && (G = 32854),
              32820 === z && (G = 32855)),
            (33325 === G ||
              33326 === G ||
              33327 === G ||
              33328 === G ||
              34842 === G ||
              34836 === G) &&
              I.get("EXT_color_buffer_float"),
            G
          );
        }
        function T(_, I, R) {
          return !0 === A(_, R) ||
            (_.isFramebufferTexture &&
              1003 !== _.minFilter &&
              1006 !== _.minFilter)
            ? Math.log2(Math.max(I.width, I.height)) + 1
            : void 0 !== _.mipmaps && _.mipmaps.length > 0
            ? _.mipmaps.length
            : _.isCompressedTexture && Array.isArray(_.image)
            ? I.mipmaps.length
            : 1;
        }
        function M(_) {
          return 1003 === _ || 1004 === _ || 1005 === _ ? 9728 : 9729;
        }
        function C(_) {
          let I = _.target;
          I.removeEventListener("dispose", C),
            (function (_) {
              let I = B.get(_);
              if (void 0 === I.__webglInit) return;
              let R = _.source,
                z = ea.get(R);
              if (z) {
                let B = z[I.__cacheKey];
                B.usedTimes--,
                  0 === B.usedTimes && O(_),
                  0 === Object.keys(z).length && ea.delete(R);
              }
              B.remove(_);
            })(I),
            I.isVideoTexture && er.delete(I);
        }
        function P(I) {
          let R = I.target;
          R.removeEventListener("dispose", P),
            (function (I) {
              let R = I.texture,
                z = B.get(I),
                k = B.get(R);
              if (
                (void 0 !== k.__webglTexture &&
                  (_.deleteTexture(k.__webglTexture), V.memory.textures--),
                I.depthTexture && I.depthTexture.dispose(),
                I.isWebGLCubeRenderTarget)
              )
                for (let I = 0; I < 6; I++)
                  _.deleteFramebuffer(z.__webglFramebuffer[I]),
                    z.__webglDepthbuffer &&
                      _.deleteRenderbuffer(z.__webglDepthbuffer[I]);
              else {
                if (
                  (_.deleteFramebuffer(z.__webglFramebuffer),
                  z.__webglDepthbuffer &&
                    _.deleteRenderbuffer(z.__webglDepthbuffer),
                  z.__webglMultisampledFramebuffer &&
                    _.deleteFramebuffer(z.__webglMultisampledFramebuffer),
                  z.__webglColorRenderbuffer)
                )
                  for (let I = 0; I < z.__webglColorRenderbuffer.length; I++)
                    z.__webglColorRenderbuffer[I] &&
                      _.deleteRenderbuffer(z.__webglColorRenderbuffer[I]);
                z.__webglDepthRenderbuffer &&
                  _.deleteRenderbuffer(z.__webglDepthRenderbuffer);
              }
              if (I.isWebGLMultipleRenderTargets)
                for (let I = 0, z = R.length; I < z; I++) {
                  let z = B.get(R[I]);
                  z.__webglTexture &&
                    (_.deleteTexture(z.__webglTexture), V.memory.textures--),
                    B.remove(R[I]);
                }
              B.remove(R), B.remove(I);
            })(R);
        }
        function O(I) {
          let R = B.get(I);
          _.deleteTexture(R.__webglTexture);
          let z = I.source,
            k = ea.get(z);
          delete k[R.__cacheKey], V.memory.textures--;
        }
        let eo = 0;
        function Y(_, I) {
          let z,
            k = B.get(_);
          if (
            (_.isVideoTexture &&
              ((z = V.render.frame),
              er.get(_) !== z && (er.set(_, z), _.update())),
            !1 === _.isRenderTargetTexture &&
              _.version > 0 &&
              k.__version !== _.version)
          ) {
            let R = _.image;
            if (null === R)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but no image data found."
              );
            else if (!1 === R.complete)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
              );
            else {
              ie(k, _, I);
              return;
            }
          }
          R.bindTexture(3553, k.__webglTexture, 33984 + I);
        }
        let el = { 1e3: 10497, 1001: 33071, 1002: 33648 },
          eh = {
            1003: 9728,
            1004: 9984,
            1005: 9986,
            1006: 9729,
            1007: 9985,
            1008: 9987,
          };
        function W(R, k, V) {
          if (
            (V
              ? (_.texParameteri(R, 10242, el[k.wrapS]),
                _.texParameteri(R, 10243, el[k.wrapT]),
                (32879 === R || 35866 === R) &&
                  _.texParameteri(R, 32882, el[k.wrapR]),
                _.texParameteri(R, 10240, eh[k.magFilter]),
                _.texParameteri(R, 10241, eh[k.minFilter]))
              : (_.texParameteri(R, 10242, 33071),
                _.texParameteri(R, 10243, 33071),
                (32879 === R || 35866 === R) &&
                  _.texParameteri(R, 32882, 33071),
                (1001 !== k.wrapS || 1001 !== k.wrapT) &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                  ),
                _.texParameteri(R, 10240, M(k.magFilter)),
                _.texParameteri(R, 10241, M(k.minFilter)),
                1003 !== k.minFilter &&
                  1006 !== k.minFilter &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                  )),
            !0 === I.has("EXT_texture_filter_anisotropic"))
          ) {
            let V = I.get("EXT_texture_filter_anisotropic");
            1003 !== k.magFilter &&
              (1005 === k.minFilter || 1008 === k.minFilter) &&
              (1015 !== k.type || !1 !== I.has("OES_texture_float_linear")) &&
              (!1 !== j ||
                1016 !== k.type ||
                !1 !== I.has("OES_texture_half_float_linear")) &&
              (k.anisotropy > 1 || B.get(k).__currentAnisotropy) &&
              (_.texParameterf(
                R,
                V.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(k.anisotropy, z.getMaxAnisotropy())
              ),
              (B.get(k).__currentAnisotropy = k.anisotropy));
          }
        }
        function ne(I, R) {
          let B,
            z = !1;
          void 0 === I.__webglInit &&
            ((I.__webglInit = !0), R.addEventListener("dispose", C));
          let k = R.source,
            j = ea.get(k);
          void 0 === j && ((j = {}), ea.set(k, j));
          let G =
            ((B = []).push(R.wrapS),
            B.push(R.wrapT),
            B.push(R.wrapR || 0),
            B.push(R.magFilter),
            B.push(R.minFilter),
            B.push(R.anisotropy),
            B.push(R.internalFormat),
            B.push(R.format),
            B.push(R.type),
            B.push(R.generateMipmaps),
            B.push(R.premultiplyAlpha),
            B.push(R.flipY),
            B.push(R.unpackAlignment),
            B.push(R.encoding),
            B.join());
          if (G !== I.__cacheKey) {
            void 0 === j[G] &&
              ((j[G] = { texture: _.createTexture(), usedTimes: 0 }),
              V.memory.textures++,
              (z = !0)),
              j[G].usedTimes++;
            let B = j[I.__cacheKey];
            void 0 !== B &&
              (j[I.__cacheKey].usedTimes--, 0 === B.usedTimes && O(R)),
              (I.__cacheKey = G),
              (I.__webglTexture = j[G].texture);
          }
          return z;
        }
        function ie(I, z, V) {
          let G = 3553;
          (z.isDataArrayTexture || z.isCompressedArrayTexture) && (G = 35866),
            z.isData3DTexture && (G = 32879);
          let q = ne(I, z),
            Q = z.source;
          R.bindTexture(G, I.__webglTexture, 33984 + V);
          let $ = B.get(Q);
          if (Q.version !== $.__version || !0 === q) {
            R.activeTexture(33984 + V),
              _.pixelStorei(37440, z.flipY),
              _.pixelStorei(37441, z.premultiplyAlpha),
              _.pixelStorei(3317, z.unpackAlignment),
              _.pixelStorei(37443, 0);
            let I =
                !j &&
                (1001 !== z.wrapS ||
                  1001 !== z.wrapT ||
                  (1003 !== z.minFilter && 1006 !== z.minFilter)) &&
                !1 === S(z.image),
              B = x(z.image, I, !1, X),
              et = S((B = F(z, B))) || j,
              er = k.convert(z.format, z.encoding),
              es = k.convert(z.type),
              ea = b(z.internalFormat, er, es, z.encoding, z.isVideoTexture);
            W(G, z, et);
            let en,
              eo = z.mipmaps,
              el = j && !0 !== z.isVideoTexture,
              eh = void 0 === $.__version || !0 === q,
              ec = T(z, B, et);
            if (z.isDepthTexture)
              (ea = 6402),
                j
                  ? (ea =
                      1015 === z.type
                        ? 36012
                        : 1014 === z.type
                        ? 33190
                        : 1020 === z.type
                        ? 35056
                        : 33189)
                  : 1015 === z.type &&
                    console.error(
                      "WebGLRenderer: Floating point depth texture requires WebGL2."
                    ),
                1026 === z.format &&
                  6402 === ea &&
                  1012 !== z.type &&
                  1014 !== z.type &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                  ),
                  (z.type = 1014),
                  (es = k.convert(z.type))),
                1027 === z.format &&
                  6402 === ea &&
                  ((ea = 34041),
                  1020 !== z.type &&
                    (console.warn(
                      "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                    ),
                    (z.type = 1020),
                    (es = k.convert(z.type)))),
                eh &&
                  (el
                    ? R.texStorage2D(3553, 1, ea, B.width, B.height)
                    : R.texImage2D(
                        3553,
                        0,
                        ea,
                        B.width,
                        B.height,
                        0,
                        er,
                        es,
                        null
                      ));
            else if (z.isDataTexture) {
              if (eo.length > 0 && et) {
                el &&
                  eh &&
                  R.texStorage2D(3553, ec, ea, eo[0].width, eo[0].height);
                for (let _ = 0, I = eo.length; _ < I; _++)
                  (en = eo[_]),
                    el
                      ? R.texSubImage2D(
                          3553,
                          _,
                          0,
                          0,
                          en.width,
                          en.height,
                          er,
                          es,
                          en.data
                        )
                      : R.texImage2D(
                          3553,
                          _,
                          ea,
                          en.width,
                          en.height,
                          0,
                          er,
                          es,
                          en.data
                        );
                z.generateMipmaps = !1;
              } else
                el
                  ? (eh && R.texStorage2D(3553, ec, ea, B.width, B.height),
                    R.texSubImage2D(
                      3553,
                      0,
                      0,
                      0,
                      B.width,
                      B.height,
                      er,
                      es,
                      B.data
                    ))
                  : R.texImage2D(
                      3553,
                      0,
                      ea,
                      B.width,
                      B.height,
                      0,
                      er,
                      es,
                      B.data
                    );
            } else if (z.isCompressedTexture) {
              if (z.isCompressedArrayTexture) {
                el &&
                  eh &&
                  R.texStorage3D(
                    35866,
                    ec,
                    ea,
                    eo[0].width,
                    eo[0].height,
                    B.depth
                  );
                for (let _ = 0, I = eo.length; _ < I; _++)
                  (en = eo[_]),
                    1023 !== z.format
                      ? null !== er
                        ? el
                          ? R.compressedTexSubImage3D(
                              35866,
                              _,
                              0,
                              0,
                              0,
                              en.width,
                              en.height,
                              B.depth,
                              er,
                              en.data,
                              0,
                              0
                            )
                          : R.compressedTexImage3D(
                              35866,
                              _,
                              ea,
                              en.width,
                              en.height,
                              B.depth,
                              0,
                              en.data,
                              0,
                              0
                            )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                          )
                      : el
                      ? R.texSubImage3D(
                          35866,
                          _,
                          0,
                          0,
                          0,
                          en.width,
                          en.height,
                          B.depth,
                          er,
                          es,
                          en.data
                        )
                      : R.texImage3D(
                          35866,
                          _,
                          ea,
                          en.width,
                          en.height,
                          B.depth,
                          0,
                          er,
                          es,
                          en.data
                        );
              } else {
                el &&
                  eh &&
                  R.texStorage2D(3553, ec, ea, eo[0].width, eo[0].height);
                for (let _ = 0, I = eo.length; _ < I; _++)
                  (en = eo[_]),
                    1023 !== z.format
                      ? null !== er
                        ? el
                          ? R.compressedTexSubImage2D(
                              3553,
                              _,
                              0,
                              0,
                              en.width,
                              en.height,
                              er,
                              en.data
                            )
                          : R.compressedTexImage2D(
                              3553,
                              _,
                              ea,
                              en.width,
                              en.height,
                              0,
                              en.data
                            )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                          )
                      : el
                      ? R.texSubImage2D(
                          3553,
                          _,
                          0,
                          0,
                          en.width,
                          en.height,
                          er,
                          es,
                          en.data
                        )
                      : R.texImage2D(
                          3553,
                          _,
                          ea,
                          en.width,
                          en.height,
                          0,
                          er,
                          es,
                          en.data
                        );
              }
            } else if (z.isDataArrayTexture)
              el
                ? (eh &&
                    R.texStorage3D(35866, ec, ea, B.width, B.height, B.depth),
                  R.texSubImage3D(
                    35866,
                    0,
                    0,
                    0,
                    0,
                    B.width,
                    B.height,
                    B.depth,
                    er,
                    es,
                    B.data
                  ))
                : R.texImage3D(
                    35866,
                    0,
                    ea,
                    B.width,
                    B.height,
                    B.depth,
                    0,
                    er,
                    es,
                    B.data
                  );
            else if (z.isData3DTexture)
              el
                ? (eh &&
                    R.texStorage3D(32879, ec, ea, B.width, B.height, B.depth),
                  R.texSubImage3D(
                    32879,
                    0,
                    0,
                    0,
                    0,
                    B.width,
                    B.height,
                    B.depth,
                    er,
                    es,
                    B.data
                  ))
                : R.texImage3D(
                    32879,
                    0,
                    ea,
                    B.width,
                    B.height,
                    B.depth,
                    0,
                    er,
                    es,
                    B.data
                  );
            else if (z.isFramebufferTexture) {
              if (eh) {
                if (el) R.texStorage2D(3553, ec, ea, B.width, B.height);
                else {
                  let _ = B.width,
                    I = B.height;
                  for (let B = 0; B < ec; B++)
                    R.texImage2D(3553, B, ea, _, I, 0, er, es, null),
                      (_ >>= 1),
                      (I >>= 1);
                }
              }
            } else if (eo.length > 0 && et) {
              el &&
                eh &&
                R.texStorage2D(3553, ec, ea, eo[0].width, eo[0].height);
              for (let _ = 0, I = eo.length; _ < I; _++)
                (en = eo[_]),
                  el
                    ? R.texSubImage2D(3553, _, 0, 0, er, es, en)
                    : R.texImage2D(3553, _, ea, er, es, en);
              z.generateMipmaps = !1;
            } else
              el
                ? (eh && R.texStorage2D(3553, ec, ea, B.width, B.height),
                  R.texSubImage2D(3553, 0, 0, 0, er, es, B))
                : R.texImage2D(3553, 0, ea, er, es, B);
            A(z, et) && E(G),
              ($.__version = Q.version),
              z.onUpdate && z.onUpdate(z);
          }
          I.__version = z.version;
        }
        function J(I, z, V, j, G) {
          let q = k.convert(V.format, V.encoding),
            X = k.convert(V.type),
            Q = b(V.internalFormat, q, X, V.encoding);
          B.get(z).__hasExternalTextures ||
            (32879 === G || 35866 === G
              ? R.texImage3D(G, 0, Q, z.width, z.height, z.depth, 0, q, X, null)
              : R.texImage2D(G, 0, Q, z.width, z.height, 0, q, X, null)),
            R.bindFramebuffer(36160, I),
            Ie(z)
              ? $.framebufferTexture2DMultisampleEXT(
                  36160,
                  j,
                  G,
                  B.get(V).__webglTexture,
                  0,
                  Fe(z)
                )
              : (3553 === G || (G >= 34069 && G <= 34074)) &&
                _.framebufferTexture2D(36160, j, G, B.get(V).__webglTexture, 0),
            R.bindFramebuffer(36160, null);
        }
        function we(I, R, B) {
          if (
            (_.bindRenderbuffer(36161, I), R.depthBuffer && !R.stencilBuffer)
          ) {
            let z = 33189;
            if (B || Ie(R)) {
              let I = R.depthTexture;
              I &&
                I.isDepthTexture &&
                (1015 === I.type
                  ? (z = 36012)
                  : 1014 === I.type && (z = 33190));
              let B = Fe(R);
              Ie(R)
                ? $.renderbufferStorageMultisampleEXT(
                    36161,
                    B,
                    z,
                    R.width,
                    R.height
                  )
                : _.renderbufferStorageMultisample(
                    36161,
                    B,
                    z,
                    R.width,
                    R.height
                  );
            } else _.renderbufferStorage(36161, z, R.width, R.height);
            _.framebufferRenderbuffer(36160, 36096, 36161, I);
          } else if (R.depthBuffer && R.stencilBuffer) {
            let z = Fe(R);
            B && !1 === Ie(R)
              ? _.renderbufferStorageMultisample(
                  36161,
                  z,
                  35056,
                  R.width,
                  R.height
                )
              : Ie(R)
              ? $.renderbufferStorageMultisampleEXT(
                  36161,
                  z,
                  35056,
                  R.width,
                  R.height
                )
              : _.renderbufferStorage(36161, 34041, R.width, R.height),
              _.framebufferRenderbuffer(36160, 33306, 36161, I);
          } else {
            let I =
              !0 === R.isWebGLMultipleRenderTargets ? R.texture : [R.texture];
            for (let z = 0; z < I.length; z++) {
              let V = I[z],
                j = k.convert(V.format, V.encoding),
                G = k.convert(V.type),
                q = b(V.internalFormat, j, G, V.encoding),
                X = Fe(R);
              B && !1 === Ie(R)
                ? _.renderbufferStorageMultisample(
                    36161,
                    X,
                    q,
                    R.width,
                    R.height
                  )
                : Ie(R)
                ? $.renderbufferStorageMultisampleEXT(
                    36161,
                    X,
                    q,
                    R.width,
                    R.height
                  )
                : _.renderbufferStorage(36161, q, R.width, R.height);
            }
          }
          _.bindRenderbuffer(36161, null);
        }
        function de(I) {
          let z = B.get(I),
            k = !0 === I.isWebGLCubeRenderTarget;
          if (I.depthTexture && !z.__autoAllocateDepthBuffer) {
            if (k)
              throw Error(
                "target.depthTexture not supported in Cube render targets"
              );
            !(function (I, z) {
              if (z && z.isWebGLCubeRenderTarget)
                throw Error(
                  "Depth Texture with cube render targets is not supported"
                );
              if (
                (R.bindFramebuffer(36160, I),
                !(z.depthTexture && z.depthTexture.isDepthTexture))
              )
                throw Error(
                  "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                );
              (B.get(z.depthTexture).__webglTexture &&
                z.depthTexture.image.width === z.width &&
                z.depthTexture.image.height === z.height) ||
                ((z.depthTexture.image.width = z.width),
                (z.depthTexture.image.height = z.height),
                (z.depthTexture.needsUpdate = !0)),
                Y(z.depthTexture, 0);
              let k = B.get(z.depthTexture).__webglTexture,
                V = Fe(z);
              if (1026 === z.depthTexture.format)
                Ie(z)
                  ? $.framebufferTexture2DMultisampleEXT(
                      36160,
                      36096,
                      3553,
                      k,
                      0,
                      V
                    )
                  : _.framebufferTexture2D(36160, 36096, 3553, k, 0);
              else if (1027 === z.depthTexture.format)
                Ie(z)
                  ? $.framebufferTexture2DMultisampleEXT(
                      36160,
                      33306,
                      3553,
                      k,
                      0,
                      V
                    )
                  : _.framebufferTexture2D(36160, 33306, 3553, k, 0);
              else throw Error("Unknown depthTexture format");
            })(z.__webglFramebuffer, I);
          } else if (k) {
            z.__webglDepthbuffer = [];
            for (let B = 0; B < 6; B++)
              R.bindFramebuffer(36160, z.__webglFramebuffer[B]),
                (z.__webglDepthbuffer[B] = _.createRenderbuffer()),
                we(z.__webglDepthbuffer[B], I, !1);
          } else
            R.bindFramebuffer(36160, z.__webglFramebuffer),
              (z.__webglDepthbuffer = _.createRenderbuffer()),
              we(z.__webglDepthbuffer, I, !1);
          R.bindFramebuffer(36160, null);
        }
        function Fe(_) {
          return Math.min(Q, _.samples);
        }
        function Ie(_) {
          let R = B.get(_);
          return (
            j &&
            _.samples > 0 &&
            !0 === I.has("WEBGL_multisampled_render_to_texture") &&
            !1 !== R.__useRenderToTexture
          );
        }
        function F(_, R) {
          let B = _.encoding,
            z = _.format,
            k = _.type;
          return (
            !0 === _.isCompressedTexture ||
              !0 === _.isVideoTexture ||
              1035 === _.format ||
              (3e3 !== B &&
                (3001 === B
                  ? !1 === j
                    ? !0 === I.has("EXT_sRGB") && 1023 === z
                      ? ((_.format = 1035),
                        (_.minFilter = 1006),
                        (_.generateMipmaps = !1))
                      : (R = rw.sRGBToLinear(R))
                    : (1023 !== z || 1009 !== k) &&
                      console.warn(
                        "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                      )
                  : console.error(
                      "THREE.WebGLTextures: Unsupported texture encoding:",
                      B
                    ))),
            R
          );
        }
        (this.allocateTextureUnit = function () {
          let _ = eo;
          return (
            _ >= G &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  _ +
                  " texture units while this GPU supports only " +
                  G
              ),
            (eo += 1),
            _
          );
        }),
          (this.resetTextureUnits = function () {
            eo = 0;
          }),
          (this.setTexture2D = Y),
          (this.setTexture2DArray = function (_, I) {
            let z = B.get(_);
            if (_.version > 0 && z.__version !== _.version) {
              ie(z, _, I);
              return;
            }
            R.bindTexture(35866, z.__webglTexture, 33984 + I);
          }),
          (this.setTexture3D = function (_, I) {
            let z = B.get(_);
            if (_.version > 0 && z.__version !== _.version) {
              ie(z, _, I);
              return;
            }
            R.bindTexture(32879, z.__webglTexture, 33984 + I);
          }),
          (this.setTextureCube = function (I, z) {
            let V = B.get(I);
            if (I.version > 0 && V.__version !== I.version) {
              (function (I, z, V) {
                if (6 !== z.image.length) return;
                let G = ne(I, z),
                  X = z.source;
                R.bindTexture(34067, I.__webglTexture, 33984 + V);
                let Q = B.get(X);
                if (X.version !== Q.__version || !0 === G) {
                  let I;
                  R.activeTexture(33984 + V),
                    _.pixelStorei(37440, z.flipY),
                    _.pixelStorei(37441, z.premultiplyAlpha),
                    _.pixelStorei(3317, z.unpackAlignment),
                    _.pixelStorei(37443, 0);
                  let B =
                      z.isCompressedTexture || z.image[0].isCompressedTexture,
                    $ = z.image[0] && z.image[0].isDataTexture,
                    et = [];
                  for (let _ = 0; _ < 6; _++)
                    B || $
                      ? (et[_] = $ ? z.image[_].image : z.image[_])
                      : (et[_] = x(z.image[_], !1, !0, q)),
                      (et[_] = F(z, et[_]));
                  let er = et[0],
                    es = S(er) || j,
                    ea = k.convert(z.format, z.encoding),
                    en = k.convert(z.type),
                    eo = b(z.internalFormat, ea, en, z.encoding),
                    el = j && !0 !== z.isVideoTexture,
                    eh = void 0 === Q.__version || !0 === G,
                    ec = T(z, er, es);
                  if ((W(34067, z, es), B)) {
                    el &&
                      eh &&
                      R.texStorage2D(34067, ec, eo, er.width, er.height);
                    for (let _ = 0; _ < 6; _++) {
                      I = et[_].mipmaps;
                      for (let B = 0; B < I.length; B++) {
                        let k = I[B];
                        1023 !== z.format
                          ? null !== ea
                            ? el
                              ? R.compressedTexSubImage2D(
                                  34069 + _,
                                  B,
                                  0,
                                  0,
                                  k.width,
                                  k.height,
                                  ea,
                                  k.data
                                )
                              : R.compressedTexImage2D(
                                  34069 + _,
                                  B,
                                  eo,
                                  k.width,
                                  k.height,
                                  0,
                                  k.data
                                )
                            : console.warn(
                                "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                              )
                          : el
                          ? R.texSubImage2D(
                              34069 + _,
                              B,
                              0,
                              0,
                              k.width,
                              k.height,
                              ea,
                              en,
                              k.data
                            )
                          : R.texImage2D(
                              34069 + _,
                              B,
                              eo,
                              k.width,
                              k.height,
                              0,
                              ea,
                              en,
                              k.data
                            );
                      }
                    }
                  } else {
                    (I = z.mipmaps),
                      el &&
                        eh &&
                        (I.length > 0 && ec++,
                        R.texStorage2D(
                          34067,
                          ec,
                          eo,
                          et[0].width,
                          et[0].height
                        ));
                    for (let _ = 0; _ < 6; _++)
                      if ($) {
                        el
                          ? R.texSubImage2D(
                              34069 + _,
                              0,
                              0,
                              0,
                              et[_].width,
                              et[_].height,
                              ea,
                              en,
                              et[_].data
                            )
                          : R.texImage2D(
                              34069 + _,
                              0,
                              eo,
                              et[_].width,
                              et[_].height,
                              0,
                              ea,
                              en,
                              et[_].data
                            );
                        for (let B = 0; B < I.length; B++) {
                          let z = I[B].image[_].image;
                          el
                            ? R.texSubImage2D(
                                34069 + _,
                                B + 1,
                                0,
                                0,
                                z.width,
                                z.height,
                                ea,
                                en,
                                z.data
                              )
                            : R.texImage2D(
                                34069 + _,
                                B + 1,
                                eo,
                                z.width,
                                z.height,
                                0,
                                ea,
                                en,
                                z.data
                              );
                        }
                      } else {
                        el
                          ? R.texSubImage2D(34069 + _, 0, 0, 0, ea, en, et[_])
                          : R.texImage2D(34069 + _, 0, eo, ea, en, et[_]);
                        for (let B = 0; B < I.length; B++) {
                          let z = I[B];
                          el
                            ? R.texSubImage2D(
                                34069 + _,
                                B + 1,
                                0,
                                0,
                                ea,
                                en,
                                z.image[_]
                              )
                            : R.texImage2D(
                                34069 + _,
                                B + 1,
                                eo,
                                ea,
                                en,
                                z.image[_]
                              );
                        }
                      }
                  }
                  A(z, es) && E(34067),
                    (Q.__version = X.version),
                    z.onUpdate && z.onUpdate(z);
                }
                I.__version = z.version;
              })(V, I, z);
              return;
            }
            R.bindTexture(34067, V.__webglTexture, 33984 + z);
          }),
          (this.rebindTextures = function (_, I, R) {
            let z = B.get(_);
            void 0 !== I && J(z.__webglFramebuffer, _, _.texture, 36064, 3553),
              void 0 !== R && de(_);
          }),
          (this.setupRenderTarget = function (I) {
            let G = I.texture,
              q = B.get(I),
              X = B.get(G);
            I.addEventListener("dispose", P),
              !0 !== I.isWebGLMultipleRenderTargets &&
                (void 0 === X.__webglTexture &&
                  (X.__webglTexture = _.createTexture()),
                (X.__version = G.version),
                V.memory.textures++);
            let Q = !0 === I.isWebGLCubeRenderTarget,
              $ = !0 === I.isWebGLMultipleRenderTargets,
              et = S(I) || j;
            if (Q) {
              q.__webglFramebuffer = [];
              for (let I = 0; I < 6; I++)
                q.__webglFramebuffer[I] = _.createFramebuffer();
            } else {
              if (((q.__webglFramebuffer = _.createFramebuffer()), $)) {
                if (z.drawBuffers) {
                  let R = I.texture;
                  for (let I = 0, z = R.length; I < z; I++) {
                    let z = B.get(R[I]);
                    void 0 === z.__webglTexture &&
                      ((z.__webglTexture = _.createTexture()),
                      V.memory.textures++);
                  }
                } else
                  console.warn(
                    "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
                  );
              }
              if (j && I.samples > 0 && !1 === Ie(I)) {
                let B = $ ? G : [G];
                (q.__webglMultisampledFramebuffer = _.createFramebuffer()),
                  (q.__webglColorRenderbuffer = []),
                  R.bindFramebuffer(36160, q.__webglMultisampledFramebuffer);
                for (let R = 0; R < B.length; R++) {
                  let z = B[R];
                  (q.__webglColorRenderbuffer[R] = _.createRenderbuffer()),
                    _.bindRenderbuffer(36161, q.__webglColorRenderbuffer[R]);
                  let V = k.convert(z.format, z.encoding),
                    j = k.convert(z.type),
                    G = b(
                      z.internalFormat,
                      V,
                      j,
                      z.encoding,
                      !0 === I.isXRRenderTarget
                    ),
                    X = Fe(I);
                  _.renderbufferStorageMultisample(
                    36161,
                    X,
                    G,
                    I.width,
                    I.height
                  ),
                    _.framebufferRenderbuffer(
                      36160,
                      36064 + R,
                      36161,
                      q.__webglColorRenderbuffer[R]
                    );
                }
                _.bindRenderbuffer(36161, null),
                  I.depthBuffer &&
                    ((q.__webglDepthRenderbuffer = _.createRenderbuffer()),
                    we(q.__webglDepthRenderbuffer, I, !0)),
                  R.bindFramebuffer(36160, null);
              }
            }
            if (Q) {
              R.bindTexture(34067, X.__webglTexture), W(34067, G, et);
              for (let _ = 0; _ < 6; _++)
                J(q.__webglFramebuffer[_], I, G, 36064, 34069 + _);
              A(G, et) && E(34067), R.unbindTexture();
            } else if ($) {
              let _ = I.texture;
              for (let z = 0, k = _.length; z < k; z++) {
                let k = _[z],
                  V = B.get(k);
                R.bindTexture(3553, V.__webglTexture),
                  W(3553, k, et),
                  J(q.__webglFramebuffer, I, k, 36064 + z, 3553),
                  A(k, et) && E(3553);
              }
              R.unbindTexture();
            } else {
              let _ = 3553;
              (I.isWebGL3DRenderTarget || I.isWebGLArrayRenderTarget) &&
                (j
                  ? (_ = I.isWebGL3DRenderTarget ? 32879 : 35866)
                  : console.error(
                      "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
                    )),
                R.bindTexture(_, X.__webglTexture),
                W(_, G, et),
                J(q.__webglFramebuffer, I, G, 36064, _),
                A(G, et) && E(_),
                R.unbindTexture();
            }
            I.depthBuffer && de(I);
          }),
          (this.updateRenderTargetMipmap = function (_) {
            let I = S(_) || j,
              z =
                !0 === _.isWebGLMultipleRenderTargets ? _.texture : [_.texture];
            for (let k = 0, V = z.length; k < V; k++) {
              let V = z[k];
              if (A(V, I)) {
                let I = _.isWebGLCubeRenderTarget ? 34067 : 3553,
                  z = B.get(V).__webglTexture;
                R.bindTexture(I, z), E(I), R.unbindTexture();
              }
            }
          }),
          (this.updateMultisampleRenderTarget = function (I) {
            if (j && I.samples > 0 && !1 === Ie(I)) {
              let z = I.isWebGLMultipleRenderTargets ? I.texture : [I.texture],
                k = I.width,
                V = I.height,
                j = 16384,
                G = [],
                q = I.stencilBuffer ? 33306 : 36096,
                X = B.get(I),
                Q = !0 === I.isWebGLMultipleRenderTargets;
              if (Q)
                for (let I = 0; I < z.length; I++)
                  R.bindFramebuffer(36160, X.__webglMultisampledFramebuffer),
                    _.framebufferRenderbuffer(36160, 36064 + I, 36161, null),
                    R.bindFramebuffer(36160, X.__webglFramebuffer),
                    _.framebufferTexture2D(36009, 36064 + I, 3553, null, 0);
              R.bindFramebuffer(36008, X.__webglMultisampledFramebuffer),
                R.bindFramebuffer(36009, X.__webglFramebuffer);
              for (let R = 0; R < z.length; R++) {
                G.push(36064 + R), I.depthBuffer && G.push(q);
                let $ =
                  void 0 !== X.__ignoreDepthValues && X.__ignoreDepthValues;
                if (
                  (!1 === $ &&
                    (I.depthBuffer && (j |= 256),
                    I.stencilBuffer && (j |= 1024)),
                  Q &&
                    _.framebufferRenderbuffer(
                      36008,
                      36064,
                      36161,
                      X.__webglColorRenderbuffer[R]
                    ),
                  !0 === $ &&
                    (_.invalidateFramebuffer(36008, [q]),
                    _.invalidateFramebuffer(36009, [q])),
                  Q)
                ) {
                  let I = B.get(z[R]).__webglTexture;
                  _.framebufferTexture2D(36009, 36064, 3553, I, 0);
                }
                _.blitFramebuffer(0, 0, k, V, 0, 0, k, V, j, 9728),
                  et && _.invalidateFramebuffer(36008, G);
              }
              if (
                (R.bindFramebuffer(36008, null),
                R.bindFramebuffer(36009, null),
                Q)
              )
                for (let I = 0; I < z.length; I++) {
                  R.bindFramebuffer(36160, X.__webglMultisampledFramebuffer),
                    _.framebufferRenderbuffer(
                      36160,
                      36064 + I,
                      36161,
                      X.__webglColorRenderbuffer[I]
                    );
                  let k = B.get(z[I]).__webglTexture;
                  R.bindFramebuffer(36160, X.__webglFramebuffer),
                    _.framebufferTexture2D(36009, 36064 + I, 3553, k, 0);
                }
              R.bindFramebuffer(36009, X.__webglMultisampledFramebuffer);
            }
          }),
          (this.setupDepthRenderbuffer = de),
          (this.setupFrameBufferTexture = J),
          (this.useMultisampledRTT = Ie);
      }
      function qG(_, I, R) {
        let B = R.isWebGL2;
        return {
          convert: function (R, z = null) {
            let k;
            if (1009 === R) return 5121;
            if (1017 === R) return 32819;
            if (1018 === R) return 32820;
            if (1010 === R) return 5120;
            if (1011 === R) return 5122;
            if (1012 === R) return 5123;
            if (1013 === R) return 5124;
            if (1014 === R) return 5125;
            if (1015 === R) return 5126;
            if (1016 === R)
              return B
                ? 5131
                : null !== (k = I.get("OES_texture_half_float"))
                ? k.HALF_FLOAT_OES
                : null;
            if (1021 === R) return 6406;
            if (1023 === R) return 6408;
            if (1024 === R) return 6409;
            if (1025 === R) return 6410;
            if (1026 === R) return 6402;
            if (1027 === R) return 34041;
            if (1035 === R)
              return null !== (k = I.get("EXT_sRGB")) ? k.SRGB_ALPHA_EXT : null;
            if (1028 === R) return 6403;
            if (1029 === R) return 36244;
            if (1030 === R) return 33319;
            if (1031 === R) return 33320;
            if (1033 === R) return 36249;
            if (33776 === R || 33777 === R || 33778 === R || 33779 === R) {
              if (3001 === z) {
                if (null === (k = I.get("WEBGL_compressed_texture_s3tc_srgb")))
                  return null;
                if (33776 === R) return k.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (33777 === R) return k.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (33778 === R) return k.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (33779 === R) return k.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
              } else {
                if (null === (k = I.get("WEBGL_compressed_texture_s3tc")))
                  return null;
                if (33776 === R) return k.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (33777 === R) return k.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (33778 === R) return k.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (33779 === R) return k.COMPRESSED_RGBA_S3TC_DXT5_EXT;
              }
            }
            if (35840 === R || 35841 === R || 35842 === R || 35843 === R) {
              if (null === (k = I.get("WEBGL_compressed_texture_pvrtc")))
                return null;
              if (35840 === R) return k.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (35841 === R) return k.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (35842 === R) return k.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (35843 === R) return k.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
            if (36196 === R)
              return null !== (k = I.get("WEBGL_compressed_texture_etc1"))
                ? k.COMPRESSED_RGB_ETC1_WEBGL
                : null;
            if (37492 === R || 37496 === R) {
              if (null === (k = I.get("WEBGL_compressed_texture_etc")))
                return null;
              if (37492 === R)
                return 3001 === z
                  ? k.COMPRESSED_SRGB8_ETC2
                  : k.COMPRESSED_RGB8_ETC2;
              if (37496 === R)
                return 3001 === z
                  ? k.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                  : k.COMPRESSED_RGBA8_ETC2_EAC;
            }
            if (
              37808 === R ||
              37809 === R ||
              37810 === R ||
              37811 === R ||
              37812 === R ||
              37813 === R ||
              37814 === R ||
              37815 === R ||
              37816 === R ||
              37817 === R ||
              37818 === R ||
              37819 === R ||
              37820 === R ||
              37821 === R
            ) {
              if (null === (k = I.get("WEBGL_compressed_texture_astc")))
                return null;
              if (37808 === R)
                return 3001 === z
                  ? k.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                  : k.COMPRESSED_RGBA_ASTC_4x4_KHR;
              if (37809 === R)
                return 3001 === z
                  ? k.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                  : k.COMPRESSED_RGBA_ASTC_5x4_KHR;
              if (37810 === R)
                return 3001 === z
                  ? k.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                  : k.COMPRESSED_RGBA_ASTC_5x5_KHR;
              if (37811 === R)
                return 3001 === z
                  ? k.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                  : k.COMPRESSED_RGBA_ASTC_6x5_KHR;
              if (37812 === R)
                return 3001 === z
                  ? k.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                  : k.COMPRESSED_RGBA_ASTC_6x6_KHR;
              if (37813 === R)
                return 3001 === z
                  ? k.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                  : k.COMPRESSED_RGBA_ASTC_8x5_KHR;
              if (37814 === R)
                return 3001 === z
                  ? k.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                  : k.COMPRESSED_RGBA_ASTC_8x6_KHR;
              if (37815 === R)
                return 3001 === z
                  ? k.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                  : k.COMPRESSED_RGBA_ASTC_8x8_KHR;
              if (37816 === R)
                return 3001 === z
                  ? k.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                  : k.COMPRESSED_RGBA_ASTC_10x5_KHR;
              if (37817 === R)
                return 3001 === z
                  ? k.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                  : k.COMPRESSED_RGBA_ASTC_10x6_KHR;
              if (37818 === R)
                return 3001 === z
                  ? k.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                  : k.COMPRESSED_RGBA_ASTC_10x8_KHR;
              if (37819 === R)
                return 3001 === z
                  ? k.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                  : k.COMPRESSED_RGBA_ASTC_10x10_KHR;
              if (37820 === R)
                return 3001 === z
                  ? k.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                  : k.COMPRESSED_RGBA_ASTC_12x10_KHR;
              if (37821 === R)
                return 3001 === z
                  ? k.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                  : k.COMPRESSED_RGBA_ASTC_12x12_KHR;
            }
            if (36492 === R) {
              if (null === (k = I.get("EXT_texture_compression_bptc")))
                return null;
              if (36492 === R)
                return 3001 === z
                  ? k.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                  : k.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            }
            if (36283 === R || 36284 === R || 36285 === R || 36286 === R) {
              if (null === (k = I.get("EXT_texture_compression_rgtc")))
                return null;
              if (36492 === R) return k.COMPRESSED_RED_RGTC1_EXT;
              if (36284 === R) return k.COMPRESSED_SIGNED_RED_RGTC1_EXT;
              if (36285 === R) return k.COMPRESSED_RED_GREEN_RGTC2_EXT;
              if (36286 === R) return k.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
            }
            return 1020 === R
              ? B
                ? 34042
                : null !== (k = I.get("WEBGL_depth_texture"))
                ? k.UNSIGNED_INT_24_8_WEBGL
                : null
              : void 0 !== _[R]
              ? _[R]
              : null;
          },
        };
      }
      var nE = class extends aI {
          constructor(_ = []) {
            super(), (this.isArrayCamera = !0), (this.cameras = _);
          }
        },
        nT = class extends sL {
          constructor() {
            super(), (this.isGroup = !0), (this.type = "Group");
          }
        },
        nP = { type: "move" },
        nD = class {
          constructor() {
            (this._targetRay = null), (this._grip = null), (this._hand = null);
          }
          getHandSpace() {
            return (
              null === this._hand &&
                ((this._hand = new nT()),
                (this._hand.matrixAutoUpdate = !1),
                (this._hand.visible = !1),
                (this._hand.joints = {}),
                (this._hand.inputState = { pinching: !1 })),
              this._hand
            );
          }
          getTargetRaySpace() {
            return (
              null === this._targetRay &&
                ((this._targetRay = new nT()),
                (this._targetRay.matrixAutoUpdate = !1),
                (this._targetRay.visible = !1),
                (this._targetRay.hasLinearVelocity = !1),
                (this._targetRay.linearVelocity = new rF()),
                (this._targetRay.hasAngularVelocity = !1),
                (this._targetRay.angularVelocity = new rF())),
              this._targetRay
            );
          }
          getGripSpace() {
            return (
              null === this._grip &&
                ((this._grip = new nT()),
                (this._grip.matrixAutoUpdate = !1),
                (this._grip.visible = !1),
                (this._grip.hasLinearVelocity = !1),
                (this._grip.linearVelocity = new rF()),
                (this._grip.hasAngularVelocity = !1),
                (this._grip.angularVelocity = new rF())),
              this._grip
            );
          }
          dispatchEvent(_) {
            return (
              null !== this._targetRay && this._targetRay.dispatchEvent(_),
              null !== this._grip && this._grip.dispatchEvent(_),
              null !== this._hand && this._hand.dispatchEvent(_),
              this
            );
          }
          connect(_) {
            if (_ && _.hand) {
              let I = this._hand;
              if (I) for (let R of _.hand.values()) this._getHandJoint(I, R);
            }
            return this.dispatchEvent({ type: "connected", data: _ }), this;
          }
          disconnect(_) {
            return (
              this.dispatchEvent({ type: "disconnected", data: _ }),
              null !== this._targetRay && (this._targetRay.visible = !1),
              null !== this._grip && (this._grip.visible = !1),
              null !== this._hand && (this._hand.visible = !1),
              this
            );
          }
          update(_, I, R) {
            let B = null,
              z = null,
              k = null,
              V = this._targetRay,
              j = this._grip,
              G = this._hand;
            if (_ && "visible-blurred" !== I.session.visibilityState) {
              if (G && _.hand) {
                for (let B of ((k = !0), _.hand.values())) {
                  let _ = I.getJointPose(B, R),
                    z = this._getHandJoint(G, B);
                  null !== _ &&
                    (z.matrix.fromArray(_.transform.matrix),
                    z.matrix.decompose(z.position, z.rotation, z.scale),
                    (z.jointRadius = _.radius)),
                    (z.visible = null !== _);
                }
                let B = G.joints["index-finger-tip"],
                  z = G.joints["thumb-tip"],
                  V = B.position.distanceTo(z.position);
                G.inputState.pinching && V > 0.025
                  ? ((G.inputState.pinching = !1),
                    this.dispatchEvent({
                      type: "pinchend",
                      handedness: _.handedness,
                      target: this,
                    }))
                  : !G.inputState.pinching &&
                    V <= 0.015 &&
                    ((G.inputState.pinching = !0),
                    this.dispatchEvent({
                      type: "pinchstart",
                      handedness: _.handedness,
                      target: this,
                    }));
              } else
                null !== j &&
                  _.gripSpace &&
                  null !== (z = I.getPose(_.gripSpace, R)) &&
                  (j.matrix.fromArray(z.transform.matrix),
                  j.matrix.decompose(j.position, j.rotation, j.scale),
                  z.linearVelocity
                    ? ((j.hasLinearVelocity = !0),
                      j.linearVelocity.copy(z.linearVelocity))
                    : (j.hasLinearVelocity = !1),
                  z.angularVelocity
                    ? ((j.hasAngularVelocity = !0),
                      j.angularVelocity.copy(z.angularVelocity))
                    : (j.hasAngularVelocity = !1));
              null !== V &&
                (null === (B = I.getPose(_.targetRaySpace, R)) &&
                  null !== z &&
                  (B = z),
                null !== B &&
                  (V.matrix.fromArray(B.transform.matrix),
                  V.matrix.decompose(V.position, V.rotation, V.scale),
                  B.linearVelocity
                    ? ((V.hasLinearVelocity = !0),
                      V.linearVelocity.copy(B.linearVelocity))
                    : (V.hasLinearVelocity = !1),
                  B.angularVelocity
                    ? ((V.hasAngularVelocity = !0),
                      V.angularVelocity.copy(B.angularVelocity))
                    : (V.hasAngularVelocity = !1),
                  this.dispatchEvent(nP)));
            }
            return (
              null !== V && (V.visible = null !== B),
              null !== j && (j.visible = null !== z),
              null !== G && (G.visible = null !== k),
              this
            );
          }
          _getHandJoint(_, I) {
            if (void 0 === _.joints[I.jointName]) {
              let R = new nT();
              (R.matrixAutoUpdate = !1),
                (R.visible = !1),
                (_.joints[I.jointName] = R),
                _.add(R);
            }
            return _.joints[I.jointName];
          }
        },
        nR = class extends rA {
          constructor(_, I, R, B, z, k, V, j, G, q) {
            if (1026 !== (q = void 0 !== q ? q : 1026) && 1027 !== q)
              throw Error(
                "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
              );
            void 0 === R && 1026 === q && (R = 1014),
              void 0 === R && 1027 === q && (R = 1020),
              super(null, B, z, k, V, j, q, R, G),
              (this.isDepthTexture = !0),
              (this.image = { width: _, height: I }),
              (this.magFilter = void 0 !== V ? V : 1003),
              (this.minFilter = void 0 !== j ? j : 1003),
              (this.flipY = !1),
              (this.generateMipmaps = !1);
          }
        },
        nB = class extends i8 {
          constructor(_, I) {
            super();
            let R = this,
              B = null,
              z = 1,
              k = null,
              V = "local-floor",
              j = 1,
              G = null,
              q = null,
              X = null,
              Q = null,
              $ = null,
              et = null,
              er = I.getContextAttributes(),
              es = null,
              ea = null,
              en = [],
              eo = [],
              el = new Set(),
              eh = new Map(),
              ec = new aI();
            ec.layers.enable(1), (ec.viewport = new rM());
            let ed = new aI();
            ed.layers.enable(2), (ed.viewport = new rM());
            let ep = [ec, ed],
              ef = new nE();
            ef.layers.enable(1), ef.layers.enable(2);
            let em = null,
              ey = null;
            function P(_) {
              let I = eo.indexOf(_.inputSource);
              if (-1 === I) return;
              let R = en[I];
              void 0 !== R &&
                R.dispatchEvent({ type: _.type, data: _.inputSource });
            }
            function D() {
              B.removeEventListener("select", P),
                B.removeEventListener("selectstart", P),
                B.removeEventListener("selectend", P),
                B.removeEventListener("squeeze", P),
                B.removeEventListener("squeezestart", P),
                B.removeEventListener("squeezeend", P),
                B.removeEventListener("end", D),
                B.removeEventListener("inputsourceschange", O);
              for (let _ = 0; _ < en.length; _++) {
                let I = eo[_];
                null !== I && ((eo[_] = null), en[_].disconnect(I));
              }
              (em = null),
                (ey = null),
                _.setRenderTarget(es),
                ($ = null),
                (Q = null),
                (X = null),
                (B = null),
                (ea = null),
                e_.stop(),
                (R.isPresenting = !1),
                R.dispatchEvent({ type: "sessionend" });
            }
            function O(_) {
              for (let I = 0; I < _.removed.length; I++) {
                let R = _.removed[I],
                  B = eo.indexOf(R);
                B >= 0 && ((eo[B] = null), en[B].disconnect(R));
              }
              for (let I = 0; I < _.added.length; I++) {
                let R = _.added[I],
                  B = eo.indexOf(R);
                if (-1 === B) {
                  for (let _ = 0; _ < en.length; _++)
                    if (_ >= eo.length) {
                      eo.push(R), (B = _);
                      break;
                    } else if (null === eo[_]) {
                      (eo[_] = R), (B = _);
                      break;
                    }
                  if (-1 === B) break;
                }
                let z = en[B];
                z && z.connect(R);
              }
            }
            (this.cameraAutoUpdate = !0),
              (this.enabled = !1),
              (this.isPresenting = !1),
              (this.getController = function (_) {
                let I = en[_];
                return (
                  void 0 === I && ((I = new nD()), (en[_] = I)),
                  I.getTargetRaySpace()
                );
              }),
              (this.getControllerGrip = function (_) {
                let I = en[_];
                return (
                  void 0 === I && ((I = new nD()), (en[_] = I)),
                  I.getGripSpace()
                );
              }),
              (this.getHand = function (_) {
                let I = en[_];
                return (
                  void 0 === I && ((I = new nD()), (en[_] = I)),
                  I.getHandSpace()
                );
              }),
              (this.setFramebufferScaleFactor = function (_) {
                (z = _),
                  !0 === R.isPresenting &&
                    console.warn(
                      "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                    );
              }),
              (this.setReferenceSpaceType = function (_) {
                (V = _),
                  !0 === R.isPresenting &&
                    console.warn(
                      "THREE.WebXRManager: Cannot change reference space type while presenting."
                    );
              }),
              (this.getReferenceSpace = function () {
                return G || k;
              }),
              (this.setReferenceSpace = function (_) {
                G = _;
              }),
              (this.getBaseLayer = function () {
                return null !== Q ? Q : $;
              }),
              (this.getBinding = function () {
                return X;
              }),
              (this.getFrame = function () {
                return et;
              }),
              (this.getSession = function () {
                return B;
              }),
              (this.setSession = async function (q) {
                if (null !== (B = q)) {
                  if (
                    ((es = _.getRenderTarget()),
                    B.addEventListener("select", P),
                    B.addEventListener("selectstart", P),
                    B.addEventListener("selectend", P),
                    B.addEventListener("squeeze", P),
                    B.addEventListener("squeezestart", P),
                    B.addEventListener("squeezeend", P),
                    B.addEventListener("end", D),
                    B.addEventListener("inputsourceschange", O),
                    !0 !== er.xrCompatible && (await I.makeXRCompatible()),
                    void 0 === B.renderState.layers ||
                      !1 === _.capabilities.isWebGL2)
                  ) {
                    let R = {
                      antialias:
                        void 0 !== B.renderState.layers || er.antialias,
                      alpha: er.alpha,
                      depth: er.depth,
                      stencil: er.stencil,
                      framebufferScaleFactor: z,
                    };
                    ($ = new XRWebGLLayer(B, I, R)),
                      B.updateRenderState({ baseLayer: $ }),
                      (ea = new rT($.framebufferWidth, $.framebufferHeight, {
                        format: 1023,
                        type: 1009,
                        encoding: _.outputEncoding,
                        stencilBuffer: er.stencil,
                      }));
                  } else {
                    let R = null,
                      k = null,
                      V = null;
                    er.depth &&
                      ((V = er.stencil ? 35056 : 33190),
                      (R = er.stencil ? 1027 : 1026),
                      (k = er.stencil ? 1020 : 1014));
                    let j = {
                      colorFormat: 32856,
                      depthFormat: V,
                      scaleFactor: z,
                    };
                    (Q = (X = new XRWebGLBinding(B, I)).createProjectionLayer(
                      j
                    )),
                      B.updateRenderState({ layers: [Q] }),
                      (ea = new rT(Q.textureWidth, Q.textureHeight, {
                        format: 1023,
                        type: 1009,
                        depthTexture: new nR(
                          Q.textureWidth,
                          Q.textureHeight,
                          k,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          R
                        ),
                        stencilBuffer: er.stencil,
                        encoding: _.outputEncoding,
                        samples: er.antialias ? 4 : 0,
                      })),
                      (_.properties.get(ea).__ignoreDepthValues =
                        Q.ignoreDepthValues);
                  }
                  (ea.isXRRenderTarget = !0),
                    this.setFoveation(j),
                    (G = null),
                    (k = await B.requestReferenceSpace(V)),
                    e_.setContext(B),
                    e_.start(),
                    (R.isPresenting = !0),
                    R.dispatchEvent({ type: "sessionstart" });
                }
              });
            let ex = new rF(),
              eb = new rF();
            function H(_, I) {
              null === I
                ? _.matrixWorld.copy(_.matrix)
                : _.matrixWorld.multiplyMatrices(I.matrixWorld, _.matrix),
                _.matrixWorldInverse.copy(_.matrixWorld).invert();
            }
            (this.updateCamera = function (_) {
              if (null === B) return;
              (ef.near = ed.near = ec.near = _.near),
                (ef.far = ed.far = ec.far = _.far),
                (em !== ef.near || ey !== ef.far) &&
                  (B.updateRenderState({
                    depthNear: ef.near,
                    depthFar: ef.far,
                  }),
                  (em = ef.near),
                  (ey = ef.far));
              let I = _.parent,
                R = ef.cameras;
              H(ef, I);
              for (let _ = 0; _ < R.length; _++) H(R[_], I);
              ef.matrixWorld.decompose(ef.position, ef.quaternion, ef.scale),
                _.matrix.copy(ef.matrix),
                _.matrix.decompose(_.position, _.quaternion, _.scale);
              let z = _.children;
              for (let _ = 0, I = z.length; _ < I; _++)
                z[_].updateMatrixWorld(!0);
              2 === R.length
                ? (function (_, I, R) {
                    ex.setFromMatrixPosition(I.matrixWorld),
                      eb.setFromMatrixPosition(R.matrixWorld);
                    let B = ex.distanceTo(eb),
                      z = I.projectionMatrix.elements,
                      k = R.projectionMatrix.elements,
                      V = z[14] / (z[10] - 1),
                      j = z[14] / (z[10] + 1),
                      G = (z[9] + 1) / z[5],
                      q = (z[9] - 1) / z[5],
                      X = (z[8] - 1) / z[0],
                      Q = (k[8] + 1) / k[0],
                      $ = B / (-X + Q),
                      et = -($ * X);
                    I.matrixWorld.decompose(_.position, _.quaternion, _.scale),
                      _.translateX(et),
                      _.translateZ($),
                      _.matrixWorld.compose(_.position, _.quaternion, _.scale),
                      _.matrixWorldInverse.copy(_.matrixWorld).invert();
                    let er = V + $,
                      es = j + $,
                      ea = V * X - et,
                      en = V * Q + (B - et),
                      eo = ((G * j) / es) * er,
                      el = ((q * j) / es) * er;
                    _.projectionMatrix.makePerspective(ea, en, eo, el, er, es);
                  })(ef, ec, ed)
                : ef.projectionMatrix.copy(ec.projectionMatrix);
            }),
              (this.getCamera = function () {
                return ef;
              }),
              (this.getFoveation = function () {
                if (!(null === Q && null === $)) return j;
              }),
              (this.setFoveation = function (_) {
                (j = _),
                  null !== Q && (Q.fixedFoveation = _),
                  null !== $ &&
                    void 0 !== $.fixedFoveation &&
                    ($.fixedFoveation = _);
              }),
              (this.getPlanes = function () {
                return el;
              });
            let ew = null,
              e_ = new KM();
            e_.setAnimationLoop(function (I, B) {
              if (((q = B.getViewerPose(G || k)), (et = B), null !== q)) {
                let I = q.views;
                null !== $ &&
                  (_.setRenderTargetFramebuffer(ea, $.framebuffer),
                  _.setRenderTarget(ea));
                let R = !1;
                I.length !== ef.cameras.length &&
                  ((ef.cameras.length = 0), (R = !0));
                for (let B = 0; B < I.length; B++) {
                  let z = I[B],
                    k = null;
                  if (null !== $) k = $.getViewport(z);
                  else {
                    let I = X.getViewSubImage(Q, z);
                    (k = I.viewport),
                      0 === B &&
                        (_.setRenderTargetTextures(
                          ea,
                          I.colorTexture,
                          Q.ignoreDepthValues ? void 0 : I.depthStencilTexture
                        ),
                        _.setRenderTarget(ea));
                  }
                  let V = ep[B];
                  void 0 === V &&
                    ((V = new aI()).layers.enable(B),
                    (V.viewport = new rM()),
                    (ep[B] = V)),
                    V.matrix.fromArray(z.transform.matrix),
                    V.projectionMatrix.fromArray(z.projectionMatrix),
                    V.viewport.set(k.x, k.y, k.width, k.height),
                    0 === B && ef.matrix.copy(V.matrix),
                    !0 === R && ef.cameras.push(V);
                }
              }
              for (let _ = 0; _ < en.length; _++) {
                let I = eo[_],
                  R = en[_];
                null !== I && void 0 !== R && R.update(I, B, G || k);
              }
              if ((ew && ew(I, B), B.detectedPlanes)) {
                R.dispatchEvent({
                  type: "planesdetected",
                  data: B.detectedPlanes,
                });
                let _ = null;
                for (let I of el)
                  B.detectedPlanes.has(I) ||
                    (null === _ && (_ = []), _.push(I));
                if (null !== _)
                  for (let I of _)
                    el.delete(I),
                      eh.delete(I),
                      R.dispatchEvent({ type: "planeremoved", data: I });
                for (let _ of B.detectedPlanes)
                  if (el.has(_)) {
                    let I = eh.get(_);
                    _.lastChangedTime > I &&
                      (eh.set(_, _.lastChangedTime),
                      R.dispatchEvent({ type: "planechanged", data: _ }));
                  } else
                    el.add(_),
                      eh.set(_, B.lastChangedTime),
                      R.dispatchEvent({ type: "planeadded", data: _ });
              }
              et = null;
            }),
              (this.setAnimationLoop = function (_) {
                ew = _;
              }),
              (this.dispose = function () {});
          }
        };
      function XG(_, I) {
        function i(R, B) {
          let z, k;
          (R.opacity.value = B.opacity),
            B.color && R.diffuse.value.copy(B.color),
            B.emissive &&
              R.emissive.value
                .copy(B.emissive)
                .multiplyScalar(B.emissiveIntensity),
            B.map && (R.map.value = B.map),
            B.alphaMap && (R.alphaMap.value = B.alphaMap),
            B.bumpMap &&
              ((R.bumpMap.value = B.bumpMap),
              (R.bumpScale.value = B.bumpScale),
              1 === B.side && (R.bumpScale.value *= -1)),
            B.displacementMap &&
              ((R.displacementMap.value = B.displacementMap),
              (R.displacementScale.value = B.displacementScale),
              (R.displacementBias.value = B.displacementBias)),
            B.emissiveMap && (R.emissiveMap.value = B.emissiveMap),
            B.normalMap &&
              ((R.normalMap.value = B.normalMap),
              R.normalScale.value.copy(B.normalScale),
              1 === B.side && R.normalScale.value.negate()),
            B.specularMap && (R.specularMap.value = B.specularMap),
            B.alphaTest > 0 && (R.alphaTest.value = B.alphaTest);
          let V = I.get(B).envMap;
          if (
            (V &&
              ((R.envMap.value = V),
              (R.flipEnvMap.value =
                V.isCubeTexture && !1 === V.isRenderTargetTexture ? -1 : 1),
              (R.reflectivity.value = B.reflectivity),
              (R.ior.value = B.ior),
              (R.refractionRatio.value = B.refractionRatio)),
            B.lightMap)
          ) {
            R.lightMap.value = B.lightMap;
            let I = !0 !== _.physicallyCorrectLights ? Math.PI : 1;
            R.lightMapIntensity.value = B.lightMapIntensity * I;
          }
          B.aoMap &&
            ((R.aoMap.value = B.aoMap),
            (R.aoMapIntensity.value = B.aoMapIntensity)),
            B.map
              ? (z = B.map)
              : B.specularMap
              ? (z = B.specularMap)
              : B.displacementMap
              ? (z = B.displacementMap)
              : B.normalMap
              ? (z = B.normalMap)
              : B.bumpMap
              ? (z = B.bumpMap)
              : B.roughnessMap
              ? (z = B.roughnessMap)
              : B.metalnessMap
              ? (z = B.metalnessMap)
              : B.alphaMap
              ? (z = B.alphaMap)
              : B.emissiveMap
              ? (z = B.emissiveMap)
              : B.clearcoatMap
              ? (z = B.clearcoatMap)
              : B.clearcoatNormalMap
              ? (z = B.clearcoatNormalMap)
              : B.clearcoatRoughnessMap
              ? (z = B.clearcoatRoughnessMap)
              : B.iridescenceMap
              ? (z = B.iridescenceMap)
              : B.iridescenceThicknessMap
              ? (z = B.iridescenceThicknessMap)
              : B.specularIntensityMap
              ? (z = B.specularIntensityMap)
              : B.specularColorMap
              ? (z = B.specularColorMap)
              : B.transmissionMap
              ? (z = B.transmissionMap)
              : B.thicknessMap
              ? (z = B.thicknessMap)
              : B.sheenColorMap
              ? (z = B.sheenColorMap)
              : B.sheenRoughnessMap && (z = B.sheenRoughnessMap),
            void 0 !== z &&
              (z.isWebGLRenderTarget && (z = z.texture),
              !0 === z.matrixAutoUpdate && z.updateMatrix(),
              R.uvTransform.value.copy(z.matrix)),
            B.aoMap ? (k = B.aoMap) : B.lightMap && (k = B.lightMap),
            void 0 !== k &&
              (k.isWebGLRenderTarget && (k = k.texture),
              !0 === k.matrixAutoUpdate && k.updateMatrix(),
              R.uv2Transform.value.copy(k.matrix));
        }
        return {
          refreshFogUniforms: function (I, R) {
            R.color.getRGB(I.fogColor.value, QM(_)),
              R.isFog
                ? ((I.fogNear.value = R.near), (I.fogFar.value = R.far))
                : R.isFogExp2 && (I.fogDensity.value = R.density);
          },
          refreshMaterialUniforms: function (_, R, B, z, k) {
            let V, j;
            R.isMeshBasicMaterial || R.isMeshLambertMaterial
              ? i(_, R)
              : R.isMeshToonMaterial
              ? (i(_, R),
                R.gradientMap && (_.gradientMap.value = R.gradientMap))
              : R.isMeshPhongMaterial
              ? (i(_, R),
                _.specular.value.copy(R.specular),
                (_.shininess.value = Math.max(R.shininess, 1e-4)))
              : R.isMeshStandardMaterial
              ? (i(_, R),
                (_.roughness.value = R.roughness),
                (_.metalness.value = R.metalness),
                R.roughnessMap && (_.roughnessMap.value = R.roughnessMap),
                R.metalnessMap && (_.metalnessMap.value = R.metalnessMap),
                I.get(R).envMap &&
                  (_.envMapIntensity.value = R.envMapIntensity),
                R.isMeshPhysicalMaterial &&
                  ((_.ior.value = R.ior),
                  R.sheen > 0 &&
                    (_.sheenColor.value
                      .copy(R.sheenColor)
                      .multiplyScalar(R.sheen),
                    (_.sheenRoughness.value = R.sheenRoughness),
                    R.sheenColorMap &&
                      (_.sheenColorMap.value = R.sheenColorMap),
                    R.sheenRoughnessMap &&
                      (_.sheenRoughnessMap.value = R.sheenRoughnessMap)),
                  R.clearcoat > 0 &&
                    ((_.clearcoat.value = R.clearcoat),
                    (_.clearcoatRoughness.value = R.clearcoatRoughness),
                    R.clearcoatMap && (_.clearcoatMap.value = R.clearcoatMap),
                    R.clearcoatRoughnessMap &&
                      (_.clearcoatRoughnessMap.value = R.clearcoatRoughnessMap),
                    R.clearcoatNormalMap &&
                      (_.clearcoatNormalScale.value.copy(
                        R.clearcoatNormalScale
                      ),
                      (_.clearcoatNormalMap.value = R.clearcoatNormalMap),
                      1 === R.side && _.clearcoatNormalScale.value.negate())),
                  R.iridescence > 0 &&
                    ((_.iridescence.value = R.iridescence),
                    (_.iridescenceIOR.value = R.iridescenceIOR),
                    (_.iridescenceThicknessMinimum.value =
                      R.iridescenceThicknessRange[0]),
                    (_.iridescenceThicknessMaximum.value =
                      R.iridescenceThicknessRange[1]),
                    R.iridescenceMap &&
                      (_.iridescenceMap.value = R.iridescenceMap),
                    R.iridescenceThicknessMap &&
                      (_.iridescenceThicknessMap.value =
                        R.iridescenceThicknessMap)),
                  R.transmission > 0 &&
                    ((_.transmission.value = R.transmission),
                    (_.transmissionSamplerMap.value = k.texture),
                    _.transmissionSamplerSize.value.set(k.width, k.height),
                    R.transmissionMap &&
                      (_.transmissionMap.value = R.transmissionMap),
                    (_.thickness.value = R.thickness),
                    R.thicknessMap && (_.thicknessMap.value = R.thicknessMap),
                    (_.attenuationDistance.value = R.attenuationDistance),
                    _.attenuationColor.value.copy(R.attenuationColor)),
                  (_.specularIntensity.value = R.specularIntensity),
                  _.specularColor.value.copy(R.specularColor),
                  R.specularIntensityMap &&
                    (_.specularIntensityMap.value = R.specularIntensityMap),
                  R.specularColorMap &&
                    (_.specularColorMap.value = R.specularColorMap)))
              : R.isMeshMatcapMaterial
              ? (i(_, R), R.matcap && (_.matcap.value = R.matcap))
              : R.isMeshDepthMaterial
              ? i(_, R)
              : R.isMeshDistanceMaterial
              ? (i(_, R),
                _.referencePosition.value.copy(R.referencePosition),
                (_.nearDistance.value = R.nearDistance),
                (_.farDistance.value = R.farDistance))
              : R.isMeshNormalMaterial
              ? i(_, R)
              : R.isLineBasicMaterial
              ? (_.diffuse.value.copy(R.color),
                (_.opacity.value = R.opacity),
                R.isLineDashedMaterial &&
                  ((_.dashSize.value = R.dashSize),
                  (_.totalSize.value = R.dashSize + R.gapSize),
                  (_.scale.value = R.scale)))
              : R.isPointsMaterial
              ? (_.diffuse.value.copy(R.color),
                (_.opacity.value = R.opacity),
                (_.size.value = R.size * B),
                (_.scale.value = 0.5 * z),
                R.map && (_.map.value = R.map),
                R.alphaMap && (_.alphaMap.value = R.alphaMap),
                R.alphaTest > 0 && (_.alphaTest.value = R.alphaTest),
                R.map ? (V = R.map) : R.alphaMap && (V = R.alphaMap),
                void 0 !== V &&
                  (!0 === V.matrixAutoUpdate && V.updateMatrix(),
                  _.uvTransform.value.copy(V.matrix)))
              : R.isSpriteMaterial
              ? (_.diffuse.value.copy(R.color),
                (_.opacity.value = R.opacity),
                (_.rotation.value = R.rotation),
                R.map && (_.map.value = R.map),
                R.alphaMap && (_.alphaMap.value = R.alphaMap),
                R.alphaTest > 0 && (_.alphaTest.value = R.alphaTest),
                R.map ? (j = R.map) : R.alphaMap && (j = R.alphaMap),
                void 0 !== j &&
                  (!0 === j.matrixAutoUpdate && j.updateMatrix(),
                  _.uvTransform.value.copy(j.matrix)))
              : R.isShadowMaterial
              ? (_.color.value.copy(R.color), (_.opacity.value = R.opacity))
              : R.isShaderMaterial && (R.uniformsNeedUpdate = !1);
          },
        };
      }
      function QG(_, I, R, B) {
        let z = {},
          k = {},
          V = [],
          j = R.isWebGL2 ? _.getParameter(35375) : 0;
        function m(_) {
          let I = { boundary: 0, storage: 0 };
          return (
            "number" == typeof _
              ? ((I.boundary = 4), (I.storage = 4))
              : _.isVector2
              ? ((I.boundary = 8), (I.storage = 8))
              : _.isVector3 || _.isColor
              ? ((I.boundary = 16), (I.storage = 12))
              : _.isVector4
              ? ((I.boundary = 16), (I.storage = 16))
              : _.isMatrix3
              ? ((I.boundary = 48), (I.storage = 48))
              : _.isMatrix4
              ? ((I.boundary = 64), (I.storage = 64))
              : _.isTexture
              ? console.warn(
                  "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
                )
              : console.warn(
                  "THREE.WebGLRenderer: Unsupported uniform value type.",
                  _
                ),
            I
          );
        }
        function g(I) {
          let R = I.target;
          R.removeEventListener("dispose", g);
          let B = V.indexOf(R.__bindingPointIndex);
          V.splice(B, 1),
            _.deleteBuffer(z[R.id]),
            delete z[R.id],
            delete k[R.id];
        }
        return {
          bind: function (_, I) {
            let R = I.program;
            B.uniformBlockBinding(_, R);
          },
          update: function (R, G) {
            let q,
              X,
              Q,
              $,
              et = z[R.id];
            void 0 === et &&
              ((function (_) {
                let I = _.uniforms,
                  R = 0,
                  B = 0;
                for (let _ = 0, z = I.length; _ < z; _++) {
                  let z = I[_],
                    k = { boundary: 0, storage: 0 },
                    V = Array.isArray(z.value) ? z.value : [z.value];
                  for (let _ = 0, I = V.length; _ < I; _++) {
                    let I = m(V[_]);
                    (k.boundary += I.boundary), (k.storage += I.storage);
                  }
                  if (
                    ((z.__data = new Float32Array(
                      k.storage / Float32Array.BYTES_PER_ELEMENT
                    )),
                    (z.__offset = R),
                    _ > 0)
                  ) {
                    let _ = 16 - (B = R % 16);
                    0 !== B &&
                      _ - k.boundary < 0 &&
                      ((R += 16 - B), (z.__offset = R));
                  }
                  R += k.storage;
                }
                (B = R % 16) > 0 && (R += 16 - B),
                  (_.__size = R),
                  (_.__cache = {});
              })(R),
              (q = (function () {
                for (let _ = 0; _ < j; _++)
                  if (-1 === V.indexOf(_)) return V.push(_), _;
                return (
                  console.error(
                    "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
                  ),
                  0
                );
              })()),
              (R.__bindingPointIndex = q),
              (X = _.createBuffer()),
              (Q = R.__size),
              ($ = R.usage),
              _.bindBuffer(35345, X),
              _.bufferData(35345, Q, $),
              _.bindBuffer(35345, null),
              _.bindBufferBase(35345, q, X),
              (et = X),
              (z[R.id] = et),
              R.addEventListener("dispose", g));
            let er = G.program;
            B.updateUBOMapping(R, er);
            let es = I.render.frame;
            k[R.id] !== es &&
              ((function (I) {
                let R = z[I.id],
                  B = I.uniforms,
                  k = I.__cache;
                _.bindBuffer(35345, R);
                for (let I = 0, R = B.length; I < R; I++) {
                  let R = B[I];
                  if (
                    !0 ===
                    (function (_, I, R) {
                      let B = _.value;
                      if (void 0 === R[I]) {
                        if ("number" == typeof B) R[I] = B;
                        else {
                          let _ = Array.isArray(B) ? B : [B],
                            z = [];
                          for (let I = 0; I < _.length; I++)
                            z.push(_[I].clone());
                          R[I] = z;
                        }
                        return !0;
                      }
                      if ("number" == typeof B) {
                        if (R[I] !== B) return (R[I] = B), !0;
                      } else {
                        let _ = Array.isArray(R[I]) ? R[I] : [R[I]],
                          z = Array.isArray(B) ? B : [B];
                        for (let I = 0; I < _.length; I++) {
                          let R = _[I];
                          if (!1 === R.equals(z[I])) return R.copy(z[I]), !0;
                        }
                      }
                      return !1;
                    })(R, I, k)
                  ) {
                    let I = R.__offset,
                      B = Array.isArray(R.value) ? R.value : [R.value],
                      z = 0;
                    for (let k = 0; k < B.length; k++) {
                      let V = B[k],
                        j = m(V);
                      "number" == typeof V
                        ? ((R.__data[0] = V),
                          _.bufferSubData(35345, I + z, R.__data))
                        : V.isMatrix3
                        ? ((R.__data[0] = V.elements[0]),
                          (R.__data[1] = V.elements[1]),
                          (R.__data[2] = V.elements[2]),
                          (R.__data[3] = V.elements[0]),
                          (R.__data[4] = V.elements[3]),
                          (R.__data[5] = V.elements[4]),
                          (R.__data[6] = V.elements[5]),
                          (R.__data[7] = V.elements[0]),
                          (R.__data[8] = V.elements[6]),
                          (R.__data[9] = V.elements[7]),
                          (R.__data[10] = V.elements[8]),
                          (R.__data[11] = V.elements[0]))
                        : (V.toArray(R.__data, z),
                          (z += j.storage / Float32Array.BYTES_PER_ELEMENT));
                    }
                    _.bufferSubData(35345, I, R.__data);
                  }
                }
                _.bindBuffer(35345, null);
              })(R),
              (k[R.id] = es));
          },
          dispose: function () {
            for (let I in z) _.deleteBuffer(z[I]);
            (V = []), (z = {}), (k = {});
          },
        };
      }
      function Dw(_ = {}) {
        let I,
          R,
          B,
          z,
          k,
          V,
          j,
          G,
          q,
          X,
          Q,
          $,
          et,
          er,
          es,
          ea,
          en,
          eo,
          el,
          eh,
          ec,
          ed,
          ep,
          ef,
          em;
        this.isWebGLRenderer = !0;
        let ey =
            void 0 !== _.canvas
              ? _.canvas
              : (((em = _p("canvas")).style.display = "block"), em),
          ex = void 0 !== _.context ? _.context : null,
          eb = void 0 === _.depth || _.depth,
          ew = void 0 === _.stencil || _.stencil,
          e_ = void 0 !== _.antialias && _.antialias,
          eS = void 0 === _.premultipliedAlpha || _.premultipliedAlpha,
          eA = void 0 !== _.preserveDrawingBuffer && _.preserveDrawingBuffer,
          eC = void 0 !== _.powerPreference ? _.powerPreference : "default",
          eT =
            void 0 !== _.failIfMajorPerformanceCaveat &&
            _.failIfMajorPerformanceCaveat,
          eP;
        eP =
          null !== ex
            ? ex.getContextAttributes().alpha
            : void 0 !== _.alpha && _.alpha;
        let eI = null,
          eR = null,
          eB = [],
          ez = [];
        (this.domElement = ey),
          (this.debug = { checkShaderErrors: !0 }),
          (this.autoClear = !0),
          (this.autoClearColor = !0),
          (this.autoClearDepth = !0),
          (this.autoClearStencil = !0),
          (this.sortObjects = !0),
          (this.clippingPlanes = []),
          (this.localClippingEnabled = !1),
          (this.outputEncoding = 3e3),
          (this.physicallyCorrectLights = !1),
          (this.toneMapping = 0),
          (this.toneMappingExposure = 1);
        let eF = this,
          ek = !1,
          eU = 0,
          eV = 0,
          ej = null,
          eH = -1,
          eW = null,
          eq = new rM(),
          eX = new rM(),
          eQ = null,
          eZ = ey.width,
          eK = ey.height,
          eJ = 1,
          e$ = null,
          e0 = null,
          e3 = new rM(0, 0, eZ, eK),
          e4 = new rM(0, 0, eZ, eK),
          e5 = !1,
          e6 = new aW(),
          e8 = !1,
          e9 = !1,
          e7 = null,
          te = new sa(),
          tt = new rs(),
          tr = new rF(),
          ts = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0,
          };
        function Z() {
          return null === ej ? eJ : 1;
        }
        let ta = ex;
        function ne(_, I) {
          for (let R = 0; R < _.length; R++) {
            let B = _[R],
              z = ey.getContext(B, I);
            if (null !== z) return z;
          }
          return null;
        }
        try {
          if (
            ("setAttribute" in ey &&
              ey.setAttribute("data-engine", "three.js r149"),
            ey.addEventListener("webglcontextlost", Je, !1),
            ey.addEventListener("webglcontextrestored", st, !1),
            ey.addEventListener("webglcontextcreationerror", Nt, !1),
            null === ta)
          ) {
            let _ = ["webgl2", "webgl", "experimental-webgl"];
            if (
              (!0 === eF.isWebGL1Renderer && _.shift(),
              (ta = ne(_, {
                alpha: !0,
                depth: eb,
                stencil: ew,
                antialias: e_,
                premultipliedAlpha: eS,
                preserveDrawingBuffer: eA,
                powerPreference: eC,
                failIfMajorPerformanceCaveat: eT,
              })),
              null === ta)
            )
              throw ne(_)
                ? Error(
                    "Error creating WebGL context with your selected attributes."
                  )
                : Error("Error creating WebGL context.");
          }
          void 0 === ta.getShaderPrecisionFormat &&
            (ta.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
        } catch (_) {
          throw (console.error("THREE.WebGLRenderer: " + _.message), _);
        }
        function Ge() {
          (I = new yU(ta)),
            (R = new hU(ta, I, _)),
            I.init(R),
            (ed = new qG(ta, I, R)),
            (B = new HG(ta, I, R)),
            (z = new bU()),
            (k = new IG()),
            (V = new WG(ta, I, B, k, R, ed, z)),
            (j = new fU(eF)),
            (G = new gU(eF)),
            (q = new Pk(ta, R)),
            (ep = new cU(ta, I, q, R)),
            (X = new vU(ta, q, z, ep)),
            (Q = new _U(ta, X, q, z)),
            (el = new AU(ta, R, V)),
            (ea = new dU(k)),
            ($ = new OG(eF, j, G, I, R, ep, ea)),
            (et = new XG(eF, k)),
            (er = new LG()),
            (es = new zG(I, R)),
            (eo = new lU(eF, j, G, B, Q, eP, eS)),
            (en = new jG(eF, Q, R)),
            (ef = new QG(ta, z, R, B)),
            (eh = new uU(ta, I, z, R)),
            (ec = new xU(ta, I, z, R)),
            (z.programs = $.programs),
            (eF.capabilities = R),
            (eF.extensions = I),
            (eF.properties = k),
            (eF.renderLists = er),
            (eF.shadowMap = en),
            (eF.state = B),
            (eF.info = z);
        }
        Ge();
        let tn = new nB(eF, ta);
        function Je(_) {
          _.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            (ek = !0);
        }
        function st() {
          console.log("THREE.WebGLRenderer: Context Restored."), (ek = !1);
          let _ = z.autoReset,
            I = en.enabled,
            R = en.autoUpdate,
            B = en.needsUpdate,
            k = en.type;
          Ge(),
            (z.autoReset = _),
            (en.enabled = I),
            (en.autoUpdate = R),
            (en.needsUpdate = B),
            (en.type = k);
        }
        function Nt(_) {
          console.error(
            "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
            _.statusMessage
          );
        }
        function fr(_) {
          let I,
            R = _.target;
          R.removeEventListener("dispose", fr),
            void 0 !== (I = k.get(R).programs) &&
              (I.forEach(function (_) {
                $.releaseProgram(_);
              }),
              R.isShaderMaterial && $.releaseShaderCache(R)),
            k.remove(R);
        }
        (this.xr = tn),
          (this.getContext = function () {
            return ta;
          }),
          (this.getContextAttributes = function () {
            return ta.getContextAttributes();
          }),
          (this.forceContextLoss = function () {
            let _ = I.get("WEBGL_lose_context");
            _ && _.loseContext();
          }),
          (this.forceContextRestore = function () {
            let _ = I.get("WEBGL_lose_context");
            _ && _.restoreContext();
          }),
          (this.getPixelRatio = function () {
            return eJ;
          }),
          (this.setPixelRatio = function (_) {
            void 0 !== _ && ((eJ = _), this.setSize(eZ, eK, !1));
          }),
          (this.getSize = function (_) {
            return _.set(eZ, eK);
          }),
          (this.setSize = function (_, I, R) {
            if (tn.isPresenting) {
              console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting."
              );
              return;
            }
            (eZ = _),
              (eK = I),
              (ey.width = Math.floor(_ * eJ)),
              (ey.height = Math.floor(I * eJ)),
              !1 !== R &&
                ((ey.style.width = _ + "px"), (ey.style.height = I + "px")),
              this.setViewport(0, 0, _, I);
          }),
          (this.getDrawingBufferSize = function (_) {
            return _.set(eZ * eJ, eK * eJ).floor();
          }),
          (this.setDrawingBufferSize = function (_, I, R) {
            (eZ = _),
              (eK = I),
              (eJ = R),
              (ey.width = Math.floor(_ * R)),
              (ey.height = Math.floor(I * R)),
              this.setViewport(0, 0, _, I);
          }),
          (this.getCurrentViewport = function (_) {
            return _.copy(eq);
          }),
          (this.getViewport = function (_) {
            return _.copy(e3);
          }),
          (this.setViewport = function (_, I, R, z) {
            _.isVector4 ? e3.set(_.x, _.y, _.z, _.w) : e3.set(_, I, R, z),
              B.viewport(eq.copy(e3).multiplyScalar(eJ).floor());
          }),
          (this.getScissor = function (_) {
            return _.copy(e4);
          }),
          (this.setScissor = function (_, I, R, z) {
            _.isVector4 ? e4.set(_.x, _.y, _.z, _.w) : e4.set(_, I, R, z),
              B.scissor(eX.copy(e4).multiplyScalar(eJ).floor());
          }),
          (this.getScissorTest = function () {
            return e5;
          }),
          (this.setScissorTest = function (_) {
            B.setScissorTest((e5 = _));
          }),
          (this.setOpaqueSort = function (_) {
            e$ = _;
          }),
          (this.setTransparentSort = function (_) {
            e0 = _;
          }),
          (this.getClearColor = function (_) {
            return _.copy(eo.getClearColor());
          }),
          (this.setClearColor = function () {
            eo.setClearColor.apply(eo, arguments);
          }),
          (this.getClearAlpha = function () {
            return eo.getClearAlpha();
          }),
          (this.setClearAlpha = function () {
            eo.setClearAlpha.apply(eo, arguments);
          }),
          (this.clear = function (_ = !0, I = !0, R = !0) {
            let B = 0;
            _ && (B |= 16384), I && (B |= 256), R && (B |= 1024), ta.clear(B);
          }),
          (this.clearColor = function () {
            this.clear(!0, !1, !1);
          }),
          (this.clearDepth = function () {
            this.clear(!1, !0, !1);
          }),
          (this.clearStencil = function () {
            this.clear(!1, !1, !0);
          }),
          (this.dispose = function () {
            ey.removeEventListener("webglcontextlost", Je, !1),
              ey.removeEventListener("webglcontextrestored", st, !1),
              ey.removeEventListener("webglcontextcreationerror", Nt, !1),
              er.dispose(),
              es.dispose(),
              k.dispose(),
              j.dispose(),
              G.dispose(),
              Q.dispose(),
              ep.dispose(),
              ef.dispose(),
              $.dispose(),
              tn.dispose(),
              tn.removeEventListener("sessionstart", je),
              tn.removeEventListener("sessionend", He),
              e7 && (e7.dispose(), (e7 = null)),
              tl.stop();
          }),
          (this.renderBufferDirect = function (_, I, z, Q, $, er) {
            null === I && (I = ts);
            let es = $.isMesh && 0 > $.matrixWorld.determinant(),
              en = (function (_, I, z, q, X) {
                var Q;
                !0 !== I.isScene && (I = ts), V.resetTextureUnits();
                let $ = I.fog,
                  er = q.isMeshStandardMaterial ? I.environment : null,
                  es =
                    null === ej
                      ? eF.outputEncoding
                      : !0 === ej.isXRRenderTarget
                      ? ej.texture.encoding
                      : 3e3,
                  en = (q.isMeshStandardMaterial ? G : j).get(q.envMap || er),
                  eo =
                    !0 === q.vertexColors &&
                    !!z.attributes.color &&
                    4 === z.attributes.color.itemSize,
                  eh = !!q.normalMap && !!z.attributes.tangent,
                  ec = !!z.morphAttributes.position,
                  ed = !!z.morphAttributes.normal,
                  ep = !!z.morphAttributes.color,
                  em = q.toneMapped ? eF.toneMapping : 0,
                  ey =
                    z.morphAttributes.position ||
                    z.morphAttributes.normal ||
                    z.morphAttributes.color,
                  ex = void 0 !== ey ? ey.length : 0,
                  eb = k.get(q),
                  ew = eR.state.lights;
                if (!0 === e8 && (!0 === e9 || _ !== eW)) {
                  let I = _ === eW && q.id === eH;
                  ea.setState(q, _, I);
                }
                let e_ = !1;
                q.version === eb.__version
                  ? ((eb.needsLights &&
                      eb.lightsStateVersion !== ew.state.version) ||
                      eb.outputEncoding !== es ||
                      (X.isInstancedMesh && !1 === eb.instancing) ||
                      (!X.isInstancedMesh && !0 === eb.instancing) ||
                      (X.isSkinnedMesh && !1 === eb.skinning) ||
                      (!X.isSkinnedMesh && !0 === eb.skinning) ||
                      eb.envMap !== en ||
                      (!0 === q.fog && eb.fog !== $) ||
                      (void 0 !== eb.numClippingPlanes &&
                        (eb.numClippingPlanes !== ea.numPlanes ||
                          eb.numIntersection !== ea.numIntersection)) ||
                      eb.vertexAlphas !== eo ||
                      eb.vertexTangents !== eh ||
                      eb.morphTargets !== ec ||
                      eb.morphNormals !== ed ||
                      eb.morphColors !== ep ||
                      eb.toneMapping !== em ||
                      (!0 === R.isWebGL2 && eb.morphTargetsCount !== ex)) &&
                    (e_ = !0)
                  : ((e_ = !0), (eb.__version = q.version));
                let eS = eb.currentProgram;
                !0 === e_ && (eS = Nn(q, I, X));
                let eA = !1,
                  eC = !1,
                  eT = !1,
                  eP = eS.getUniforms(),
                  eI = eb.uniforms;
                if (
                  (B.useProgram(eS.program) &&
                    ((eA = !0), (eC = !0), (eT = !0)),
                  q.id !== eH && ((eH = q.id), (eC = !0)),
                  eA || eW !== _)
                ) {
                  if (
                    (eP.setValue(ta, "projectionMatrix", _.projectionMatrix),
                    R.logarithmicDepthBuffer &&
                      eP.setValue(
                        ta,
                        "logDepthBufFC",
                        2 / (Math.log(_.far + 1) / Math.LN2)
                      ),
                    eW !== _ && ((eW = _), (eC = !0), (eT = !0)),
                    q.isShaderMaterial ||
                      q.isMeshPhongMaterial ||
                      q.isMeshToonMaterial ||
                      q.isMeshStandardMaterial ||
                      q.envMap)
                  ) {
                    let I = eP.map.cameraPosition;
                    void 0 !== I &&
                      I.setValue(ta, tr.setFromMatrixPosition(_.matrixWorld));
                  }
                  (q.isMeshPhongMaterial ||
                    q.isMeshToonMaterial ||
                    q.isMeshLambertMaterial ||
                    q.isMeshBasicMaterial ||
                    q.isMeshStandardMaterial ||
                    q.isShaderMaterial) &&
                    eP.setValue(
                      ta,
                      "isOrthographic",
                      !0 === _.isOrthographicCamera
                    ),
                    (q.isMeshPhongMaterial ||
                      q.isMeshToonMaterial ||
                      q.isMeshLambertMaterial ||
                      q.isMeshBasicMaterial ||
                      q.isMeshStandardMaterial ||
                      q.isShaderMaterial ||
                      q.isShadowMaterial ||
                      X.isSkinnedMesh) &&
                      eP.setValue(ta, "viewMatrix", _.matrixWorldInverse);
                }
                if (X.isSkinnedMesh) {
                  eP.setOptional(ta, X, "bindMatrix"),
                    eP.setOptional(ta, X, "bindMatrixInverse");
                  let _ = X.skeleton;
                  _ &&
                    (R.floatVertexTextures
                      ? (null === _.boneTexture && _.computeBoneTexture(),
                        eP.setValue(ta, "boneTexture", _.boneTexture, V),
                        eP.setValue(ta, "boneTextureSize", _.boneTextureSize))
                      : console.warn(
                          "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
                        ));
                }
                let eB = z.morphAttributes;
                if (
                  ((void 0 !== eB.position ||
                    void 0 !== eB.normal ||
                    (void 0 !== eB.color && !0 === R.isWebGL2)) &&
                    el.update(X, z, q, eS),
                  (eC || eb.receiveShadow !== X.receiveShadow) &&
                    ((eb.receiveShadow = X.receiveShadow),
                    eP.setValue(ta, "receiveShadow", X.receiveShadow)),
                  q.isMeshGouraudMaterial &&
                    null !== q.envMap &&
                    ((eI.envMap.value = en),
                    (eI.flipEnvMap.value =
                      en.isCubeTexture && !1 === en.isRenderTargetTexture
                        ? -1
                        : 1)),
                  eC &&
                    (eP.setValue(
                      ta,
                      "toneMappingExposure",
                      eF.toneMappingExposure
                    ),
                    eb.needsLights &&
                      ((Q = eT),
                      (eI.ambientLightColor.needsUpdate = Q),
                      (eI.lightProbe.needsUpdate = Q),
                      (eI.directionalLights.needsUpdate = Q),
                      (eI.directionalLightShadows.needsUpdate = Q),
                      (eI.pointLights.needsUpdate = Q),
                      (eI.pointLightShadows.needsUpdate = Q),
                      (eI.spotLights.needsUpdate = Q),
                      (eI.spotLightShadows.needsUpdate = Q),
                      (eI.rectAreaLights.needsUpdate = Q),
                      (eI.hemisphereLights.needsUpdate = Q)),
                    $ && !0 === q.fog && et.refreshFogUniforms(eI, $),
                    et.refreshMaterialUniforms(eI, q, eJ, eK, e7),
                    nu.upload(ta, eb.uniformsList, eI, V)),
                  q.isShaderMaterial &&
                    !0 === q.uniformsNeedUpdate &&
                    (nu.upload(ta, eb.uniformsList, eI, V),
                    (q.uniformsNeedUpdate = !1)),
                  q.isSpriteMaterial && eP.setValue(ta, "center", X.center),
                  eP.setValue(ta, "modelViewMatrix", X.modelViewMatrix),
                  eP.setValue(ta, "normalMatrix", X.normalMatrix),
                  eP.setValue(ta, "modelMatrix", X.matrixWorld),
                  X.previousModelViewMatrix &&
                    eP.setValue(
                      ta,
                      "previousModelViewMatrix",
                      X.previousModelViewMatrix
                    ),
                  _.previousProjectionMatrix &&
                    eP.setValue(
                      ta,
                      "previousProjectionMatrix",
                      _.previousProjectionMatrix
                    ),
                  q.isShaderMaterial || q.isRawShaderMaterial)
                ) {
                  let _ = q.uniformsGroups;
                  for (let I = 0, B = _.length; I < B; I++)
                    if (R.isWebGL2) {
                      let R = _[I];
                      ef.update(R, eS), ef.bind(R, eS);
                    } else
                      console.warn(
                        "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
                      );
                }
                return eS;
              })(_, I, z, Q, $);
            B.setMaterial(Q, es);
            let eo = z.index,
              ed = 1;
            !0 === Q.wireframe && ((eo = X.getWireframeAttribute(z)), (ed = 2));
            let em = z.drawRange,
              ey = z.attributes.position,
              ex = em.start * ed,
              eb = (em.start + em.count) * ed;
            null !== er &&
              ((ex = Math.max(ex, er.start * ed)),
              (eb = Math.min(eb, (er.start + er.count) * ed))),
              null !== eo
                ? ((ex = Math.max(ex, 0)), (eb = Math.min(eb, eo.count)))
                : null != ey &&
                  ((ex = Math.max(ex, 0)), (eb = Math.min(eb, ey.count)));
            let ew = eb - ex;
            if (ew < 0 || ew === 1 / 0) return;
            ep.setup($, Q, en, z, eo);
            let e_,
              eS = eh;
            if (
              (null !== eo && ((e_ = q.get(eo)), (eS = ec).setIndex(e_)),
              $.isMesh)
            )
              !0 === Q.wireframe
                ? (B.setLineWidth(Q.wireframeLinewidth * Z()), eS.setMode(1))
                : eS.setMode(4);
            else if ($.isLine) {
              let _ = Q.linewidth;
              void 0 === _ && (_ = 1),
                B.setLineWidth(_ * Z()),
                $.isLineSegments
                  ? eS.setMode(1)
                  : $.isLineLoop
                  ? eS.setMode(2)
                  : eS.setMode(3);
            } else $.isPoints ? eS.setMode(0) : $.isSprite && eS.setMode(4);
            if ($.isInstancedMesh) eS.renderInstances(ex, ew, $.count);
            else if (z.isInstancedBufferGeometry) {
              let _ =
                  void 0 !== z._maxInstanceCount ? z._maxInstanceCount : 1 / 0,
                I = Math.min(z.instanceCount, _);
              eS.renderInstances(ex, ew, I);
            } else eS.render(ex, ew);
          }),
          (this.compile = function (_, I) {
            function ve(_, I, R) {
              !0 === _.transparent && 2 === _.side && !1 === _.forceSinglePass
                ? ((_.side = 1),
                  (_.needsUpdate = !0),
                  Nn(_, I, R),
                  (_.side = 0),
                  (_.needsUpdate = !0),
                  Nn(_, I, R),
                  (_.side = 2))
                : Nn(_, I, R);
            }
            (eR = es.get(_)).init(),
              ez.push(eR),
              _.traverseVisible(function (_) {
                _.isLight &&
                  _.layers.test(I.layers) &&
                  (eR.pushLight(_), _.castShadow && eR.pushShadow(_));
              }),
              eR.setupLights(eF.physicallyCorrectLights),
              _.traverse(function (I) {
                let R = I.material;
                if (R) {
                  if (Array.isArray(R))
                    for (let B = 0; B < R.length; B++) ve(R[B], _, I);
                  else ve(R, _, I);
                }
              }),
              ez.pop(),
              (eR = null);
          });
        let to = null;
        function je() {
          tl.stop();
        }
        function He() {
          tl.start();
        }
        let tl = new KM();
        function Gr(_, z, k, j) {
          let G,
            q,
            X,
            Q = _.opaque,
            $ = _.transmissive,
            et = _.transparent;
          eR.setupLightsView(k),
            !0 === e8 && ea.setGlobalState(eF.clippingPlanes, k),
            $.length > 0 &&
              ((G = R.isWebGL2),
              null === e7 &&
                (e7 = new rT(1, 1, {
                  generateMipmaps: !0,
                  type: I.has("EXT_color_buffer_half_float") ? 1016 : 1009,
                  minFilter: 1008,
                  samples: G && !0 === e_ ? 4 : 0,
                })),
              eF.getDrawingBufferSize(tt),
              G ? e7.setSize(tt.x, tt.y) : e7.setSize(my(tt.x), my(tt.y)),
              (q = eF.getRenderTarget()),
              eF.setRenderTarget(e7),
              eF.clear(),
              (X = eF.toneMapping),
              (eF.toneMapping = 0),
              Pr(Q, z, k),
              (eF.toneMapping = X),
              V.updateMultisampleRenderTarget(e7),
              V.updateRenderTargetMipmap(e7),
              eF.setRenderTarget(q)),
            j && B.viewport(eq.copy(j)),
            Q.length > 0 && Pr(Q, z, k),
            $.length > 0 && Pr($, z, k),
            et.length > 0 && Pr(et, z, k),
            B.buffers.depth.setTest(!0),
            B.buffers.depth.setMask(!0),
            B.buffers.color.setMask(!0),
            B.setPolygonOffset(!1);
        }
        function Pr(_, I, R) {
          let B = !0 === I.isScene ? I.overrideMaterial : null;
          for (let z = 0, k = _.length; z < k; z++) {
            let k = _[z],
              V = k.object,
              j = k.geometry,
              G = null === B ? k.material : B,
              q = k.group;
            V.layers.test(R.layers) &&
              (V.onBeforeRender(eF, I, R, j, G, q),
              V.modelViewMatrix.multiplyMatrices(
                R.matrixWorldInverse,
                V.matrixWorld
              ),
              V.normalMatrix.getNormalMatrix(V.modelViewMatrix),
              G.onBeforeRender(eF, I, R, j, V, q),
              !0 === G.transparent && 2 === G.side && !1 === G.forceSinglePass
                ? ((G.side = 1),
                  (G.needsUpdate = !0),
                  eF.renderBufferDirect(R, I, j, G, V, q),
                  (G.side = 0),
                  (G.needsUpdate = !0),
                  eF.renderBufferDirect(R, I, j, G, V, q),
                  (G.side = 2))
                : eF.renderBufferDirect(R, I, j, G, V, q),
              V.onAfterRender(eF, I, R, j, G, q));
          }
        }
        function Nn(_, I, R) {
          !0 !== I.isScene && (I = ts);
          let B = k.get(_),
            z = eR.state.lights,
            V = eR.state.shadowsArray,
            q = z.state.version,
            X = $.getParameters(_, z.state, V, I, R),
            Q = $.getProgramCacheKey(X),
            et = B.programs;
          (B.environment = _.isMeshStandardMaterial ? I.environment : null),
            (B.fog = I.fog),
            (B.envMap = (_.isMeshStandardMaterial ? G : j).get(
              _.envMap || B.environment
            )),
            void 0 === et &&
              (_.addEventListener("dispose", fr),
              (et = new Map()),
              (B.programs = et));
          let er = et.get(Q);
          if (void 0 !== er) {
            if (B.currentProgram === er && B.lightsStateVersion === q)
              return sp(_, X), er;
          } else
            (X.uniforms = $.getUniforms(_)),
              _.onBuild(R, X, eF),
              _.onBeforeCompile(X, eF),
              (er = $.acquireProgram(X, Q)),
              et.set(Q, er),
              (B.uniforms = X.uniforms);
          let es = B.uniforms;
          ((_.isShaderMaterial || _.isRawShaderMaterial) &&
            !0 !== _.clipping) ||
            (es.clippingPlanes = ea.uniform),
            sp(_, X),
            (B.needsLights =
              _.isMeshLambertMaterial ||
              _.isMeshToonMaterial ||
              _.isMeshPhongMaterial ||
              _.isMeshStandardMaterial ||
              _.isShadowMaterial ||
              (_.isShaderMaterial && !0 === _.lights)),
            (B.lightsStateVersion = q),
            B.needsLights &&
              ((es.ambientLightColor.value = z.state.ambient),
              (es.lightProbe.value = z.state.probe),
              (es.directionalLights.value = z.state.directional),
              (es.directionalLightShadows.value = z.state.directionalShadow),
              (es.spotLights.value = z.state.spot),
              (es.spotLightShadows.value = z.state.spotShadow),
              (es.rectAreaLights.value = z.state.rectArea),
              (es.ltc_1.value = z.state.rectAreaLTC1),
              (es.ltc_2.value = z.state.rectAreaLTC2),
              (es.pointLights.value = z.state.point),
              (es.pointLightShadows.value = z.state.pointShadow),
              (es.hemisphereLights.value = z.state.hemi),
              (es.directionalShadowMap.value = z.state.directionalShadowMap),
              (es.directionalShadowMatrix.value =
                z.state.directionalShadowMatrix),
              (es.spotShadowMap.value = z.state.spotShadowMap),
              (es.spotLightMatrix.value = z.state.spotLightMatrix),
              (es.spotLightMap.value = z.state.spotLightMap),
              (es.pointShadowMap.value = z.state.pointShadowMap),
              (es.pointShadowMatrix.value = z.state.pointShadowMatrix));
          let en = er.getUniforms(),
            eo = nu.seqWithValue(en.seq, es);
          return (B.currentProgram = er), (B.uniformsList = eo), er;
        }
        function sp(_, I) {
          let R = k.get(_);
          (R.outputEncoding = I.outputEncoding),
            (R.instancing = I.instancing),
            (R.skinning = I.skinning),
            (R.morphTargets = I.morphTargets),
            (R.morphNormals = I.morphNormals),
            (R.morphColors = I.morphColors),
            (R.morphTargetsCount = I.morphTargetsCount),
            (R.numClippingPlanes = I.numClippingPlanes),
            (R.numIntersection = I.numClipIntersection),
            (R.vertexAlphas = I.vertexAlphas),
            (R.vertexTangents = I.vertexTangents),
            (R.toneMapping = I.toneMapping);
        }
        tl.setAnimationLoop(function (_) {
          to && to(_);
        }),
          "u" > typeof self && tl.setContext(self),
          (this.setAnimationLoop = function (_) {
            (to = _),
              tn.setAnimationLoop(_),
              null === _ ? tl.stop() : tl.start();
          }),
          tn.addEventListener("sessionstart", je),
          tn.addEventListener("sessionend", He),
          (this.render = function (_, I) {
            if (void 0 !== I && !0 !== I.isCamera) {
              console.error(
                "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
              );
              return;
            }
            if (!0 === ek) return;
            !0 === _.matrixWorldAutoUpdate && _.updateMatrixWorld(),
              null === I.parent &&
                !0 === I.matrixWorldAutoUpdate &&
                I.updateMatrixWorld(),
              !0 === tn.enabled &&
                !0 === tn.isPresenting &&
                (!0 === tn.cameraAutoUpdate && tn.updateCamera(I),
                (I = tn.getCamera())),
              !0 === _.isScene && _.onBeforeRender(eF, _, I, ej),
              (eR = es.get(_, ez.length)).init(),
              ez.push(eR),
              te.multiplyMatrices(I.projectionMatrix, I.matrixWorldInverse),
              e6.setFromProjectionMatrix(te),
              (e9 = this.localClippingEnabled),
              (e8 = ea.init(this.clippingPlanes, e9)),
              (eI = er.get(_, eB.length)).init(),
              eB.push(eI),
              (function Ur(_, I, R, B) {
                if (!1 === _.visible) return;
                if (_.layers.test(I.layers)) {
                  if (_.isGroup) R = _.renderOrder;
                  else if (_.isLOD) !0 === _.autoUpdate && _.update(I);
                  else if (_.isLight)
                    eR.pushLight(_), _.castShadow && eR.pushShadow(_);
                  else if (_.isSprite) {
                    if (!_.frustumCulled || e6.intersectsSprite(_)) {
                      B &&
                        tr
                          .setFromMatrixPosition(_.matrixWorld)
                          .applyMatrix4(te);
                      let I = Q.update(_),
                        z = _.material;
                      z.visible && eI.push(_, I, z, R, tr.z, null);
                    }
                  } else if (
                    (_.isMesh || _.isLine || _.isPoints) &&
                    (_.isSkinnedMesh &&
                      _.skeleton.frame !== z.render.frame &&
                      (_.skeleton.update(),
                      (_.skeleton.frame = z.render.frame)),
                    !_.frustumCulled || e6.intersectsObject(_))
                  ) {
                    B &&
                      tr.setFromMatrixPosition(_.matrixWorld).applyMatrix4(te);
                    let I = Q.update(_),
                      z = _.material;
                    if (Array.isArray(z)) {
                      let B = I.groups;
                      for (let k = 0, V = B.length; k < V; k++) {
                        let V = B[k],
                          j = z[V.materialIndex];
                        j && j.visible && eI.push(_, I, j, R, tr.z, V);
                      }
                    } else z.visible && eI.push(_, I, z, R, tr.z, null);
                  }
                }
                let k = _.children;
                for (let _ = 0, z = k.length; _ < z; _++) Ur(k[_], I, R, B);
              })(_, I, 0, eF.sortObjects),
              eI.finish(),
              !0 === eF.sortObjects && eI.sort(e$, e0),
              !0 === e8 && ea.beginShadows();
            let R = eR.state.shadowsArray;
            if (
              (en.render(R, _, I),
              !0 === e8 && ea.endShadows(),
              !0 === this.info.autoReset && this.info.reset(),
              eo.render(eI, _),
              eR.setupLights(eF.physicallyCorrectLights),
              I.isArrayCamera)
            ) {
              let R = I.cameras;
              for (let I = 0, B = R.length; I < B; I++) {
                let B = R[I];
                Gr(eI, _, B, B.viewport);
              }
            } else Gr(eI, _, I);
            null !== ej &&
              (V.updateMultisampleRenderTarget(ej),
              V.updateRenderTargetMipmap(ej)),
              !0 === _.isScene && _.onAfterRender(eF, _, I),
              ep.resetDefaultState(),
              (eH = -1),
              (eW = null),
              ez.pop(),
              (eR = ez.length > 0 ? ez[ez.length - 1] : null),
              eB.pop(),
              (eI = eB.length > 0 ? eB[eB.length - 1] : null);
          }),
          (this.getActiveCubeFace = function () {
            return eU;
          }),
          (this.getActiveMipmapLevel = function () {
            return eV;
          }),
          (this.getRenderTarget = function () {
            return ej;
          }),
          (this.setRenderTargetTextures = function (_, R, B) {
            (k.get(_.texture).__webglTexture = R),
              (k.get(_.depthTexture).__webglTexture = B);
            let z = k.get(_);
            (z.__hasExternalTextures = !0),
              z.__hasExternalTextures &&
                ((z.__autoAllocateDepthBuffer = void 0 === B),
                z.__autoAllocateDepthBuffer ||
                  (!0 === I.has("WEBGL_multisampled_render_to_texture") &&
                    (console.warn(
                      "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                    ),
                    (z.__useRenderToTexture = !1))));
          }),
          (this.setRenderTargetFramebuffer = function (_, I) {
            let R = k.get(_);
            (R.__webglFramebuffer = I),
              (R.__useDefaultFramebuffer = void 0 === I);
          }),
          (this.setRenderTarget = function (_, I = 0, z = 0) {
            (ej = _), (eU = I), (eV = z);
            let j = !0,
              G = null,
              q = !1,
              X = !1;
            if (_) {
              let z = k.get(_);
              void 0 !== z.__useDefaultFramebuffer
                ? (B.bindFramebuffer(36160, null), (j = !1))
                : void 0 === z.__webglFramebuffer
                ? V.setupRenderTarget(_)
                : z.__hasExternalTextures &&
                  V.rebindTextures(
                    _,
                    k.get(_.texture).__webglTexture,
                    k.get(_.depthTexture).__webglTexture
                  );
              let Q = _.texture;
              (Q.isData3DTexture ||
                Q.isDataArrayTexture ||
                Q.isCompressedArrayTexture) &&
                (X = !0);
              let $ = k.get(_).__webglFramebuffer;
              _.isWebGLCubeRenderTarget
                ? ((G = $[I]), (q = !0))
                : (G =
                    R.isWebGL2 &&
                    _.samples > 0 &&
                    !1 === V.useMultisampledRTT(_)
                      ? k.get(_).__webglMultisampledFramebuffer
                      : $),
                eq.copy(_.viewport),
                eX.copy(_.scissor),
                (eQ = _.scissorTest);
            } else
              eq.copy(e3).multiplyScalar(eJ).floor(),
                eX.copy(e4).multiplyScalar(eJ).floor(),
                (eQ = e5);
            if (
              (B.bindFramebuffer(36160, G) &&
                R.drawBuffers &&
                j &&
                B.drawBuffers(_, G),
              B.viewport(eq),
              B.scissor(eX),
              B.setScissorTest(eQ),
              q)
            ) {
              let R = k.get(_.texture);
              ta.framebufferTexture2D(
                36160,
                36064,
                34069 + I,
                R.__webglTexture,
                z
              );
            } else if (X) {
              let R = k.get(_.texture),
                B = I || 0;
              ta.framebufferTextureLayer(
                36160,
                36064,
                R.__webglTexture,
                z || 0,
                B
              );
            }
            eH = -1;
          }),
          (this.readRenderTargetPixels = function (_, z, V, j, G, q, X) {
            if (!(_ && _.isWebGLRenderTarget)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
              );
              return;
            }
            let Q = k.get(_).__webglFramebuffer;
            if ((_.isWebGLCubeRenderTarget && void 0 !== X && (Q = Q[X]), Q)) {
              B.bindFramebuffer(36160, Q);
              try {
                let B = _.texture,
                  k = B.format,
                  X = B.type;
                if (1023 !== k && ed.convert(k) !== ta.getParameter(35739)) {
                  console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                  );
                  return;
                }
                let Q =
                  1016 === X &&
                  (I.has("EXT_color_buffer_half_float") ||
                    (R.isWebGL2 && I.has("EXT_color_buffer_float")));
                if (
                  1009 !== X &&
                  ed.convert(X) !== ta.getParameter(35738) &&
                  !(
                    1015 === X &&
                    (R.isWebGL2 ||
                      I.has("OES_texture_float") ||
                      I.has("WEBGL_color_buffer_float"))
                  ) &&
                  !Q
                ) {
                  console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                  );
                  return;
                }
                z >= 0 &&
                  z <= _.width - j &&
                  V >= 0 &&
                  V <= _.height - G &&
                  ta.readPixels(z, V, j, G, ed.convert(k), ed.convert(X), q);
              } finally {
                let _ = null !== ej ? k.get(ej).__webglFramebuffer : null;
                B.bindFramebuffer(36160, _);
              }
            }
          }),
          (this.copyFramebufferToTexture = function (_, I, R = 0) {
            let z = Math.pow(2, -R),
              k = Math.floor(I.image.width * z),
              j = Math.floor(I.image.height * z);
            V.setTexture2D(I, 0),
              ta.copyTexSubImage2D(3553, R, 0, 0, _.x, _.y, k, j),
              B.unbindTexture();
          }),
          (this.copyTextureToTexture = function (_, I, R, z = 0) {
            let k = I.image.width,
              j = I.image.height,
              G = ed.convert(R.format),
              q = ed.convert(R.type);
            V.setTexture2D(R, 0),
              ta.pixelStorei(37440, R.flipY),
              ta.pixelStorei(37441, R.premultiplyAlpha),
              ta.pixelStorei(3317, R.unpackAlignment),
              I.isDataTexture
                ? ta.texSubImage2D(3553, z, _.x, _.y, k, j, G, q, I.image.data)
                : I.isCompressedTexture
                ? ta.compressedTexSubImage2D(
                    3553,
                    z,
                    _.x,
                    _.y,
                    I.mipmaps[0].width,
                    I.mipmaps[0].height,
                    G,
                    I.mipmaps[0].data
                  )
                : ta.texSubImage2D(3553, z, _.x, _.y, G, q, I.image),
              0 === z && R.generateMipmaps && ta.generateMipmap(3553),
              B.unbindTexture();
          }),
          (this.copyTextureToTexture3D = function (_, I, R, z, k = 0) {
            if (eF.isWebGL1Renderer) {
              console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
              );
              return;
            }
            let j = _.max.x - _.min.x + 1,
              G = _.max.y - _.min.y + 1,
              q = _.max.z - _.min.z + 1,
              X = ed.convert(z.format),
              Q = ed.convert(z.type),
              $;
            if (z.isData3DTexture) V.setTexture3D(z, 0), ($ = 32879);
            else if (z.isDataArrayTexture)
              V.setTexture2DArray(z, 0), ($ = 35866);
            else {
              console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
              );
              return;
            }
            ta.pixelStorei(37440, z.flipY),
              ta.pixelStorei(37441, z.premultiplyAlpha),
              ta.pixelStorei(3317, z.unpackAlignment);
            let et = ta.getParameter(3314),
              er = ta.getParameter(32878),
              es = ta.getParameter(3316),
              ea = ta.getParameter(3315),
              en = ta.getParameter(32877),
              eo = R.isCompressedTexture ? R.mipmaps[0] : R.image;
            ta.pixelStorei(3314, eo.width),
              ta.pixelStorei(32878, eo.height),
              ta.pixelStorei(3316, _.min.x),
              ta.pixelStorei(3315, _.min.y),
              ta.pixelStorei(32877, _.min.z),
              R.isDataTexture || R.isData3DTexture
                ? ta.texSubImage3D($, k, I.x, I.y, I.z, j, G, q, X, Q, eo.data)
                : R.isCompressedArrayTexture
                ? (console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                  ),
                  ta.compressedTexSubImage3D(
                    $,
                    k,
                    I.x,
                    I.y,
                    I.z,
                    j,
                    G,
                    q,
                    X,
                    eo.data
                  ))
                : ta.texSubImage3D($, k, I.x, I.y, I.z, j, G, q, X, Q, eo),
              ta.pixelStorei(3314, et),
              ta.pixelStorei(32878, er),
              ta.pixelStorei(3316, es),
              ta.pixelStorei(3315, ea),
              ta.pixelStorei(32877, en),
              0 === k && z.generateMipmaps && ta.generateMipmap($),
              B.unbindTexture();
          }),
          (this.initTexture = function (_) {
            _.isCubeTexture
              ? V.setTextureCube(_, 0)
              : _.isData3DTexture
              ? V.setTexture3D(_, 0)
              : _.isDataArrayTexture || _.isCompressedArrayTexture
              ? V.setTexture2DArray(_, 0)
              : V.setTexture2D(_, 0),
              B.unbindTexture();
          }),
          (this.resetState = function () {
            (eU = 0), (eV = 0), (ej = null), B.reset(), ep.reset();
          }),
          "u" > typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
      }
      (class extends Dw {}).prototype.isWebGL1Renderer = !0;
      var nL = class {
          constructor(_, I = 1, R = 1e3) {
            (this.isFog = !0),
              (this.name = ""),
              (this.color = new ry(_)),
              (this.near = I),
              (this.far = R);
          }
          clone() {
            return new nL(this.color, this.near, this.far);
          }
          toJSON() {
            return {
              type: "Fog",
              color: this.color.getHex(),
              near: this.near,
              far: this.far,
            };
          }
        },
        nz = class extends sL {
          constructor() {
            super(),
              (this.isScene = !0),
              (this.type = "Scene"),
              (this.background = null),
              (this.environment = null),
              (this.fog = null),
              (this.backgroundBlurriness = 0),
              (this.backgroundIntensity = 1),
              (this.overrideMaterial = null),
              "u" > typeof __THREE_DEVTOOLS__ &&
                __THREE_DEVTOOLS__.dispatchEvent(
                  new CustomEvent("observe", { detail: this })
                );
          }
          copy(_, I) {
            return (
              super.copy(_, I),
              null !== _.background && (this.background = _.background.clone()),
              null !== _.environment &&
                (this.environment = _.environment.clone()),
              null !== _.fog && (this.fog = _.fog.clone()),
              (this.backgroundBlurriness = _.backgroundBlurriness),
              (this.backgroundIntensity = _.backgroundIntensity),
              null !== _.overrideMaterial &&
                (this.overrideMaterial = _.overrideMaterial.clone()),
              (this.matrixAutoUpdate = _.matrixAutoUpdate),
              this
            );
          }
          toJSON(_) {
            let I = super.toJSON(_);
            return (
              null !== this.fog && (I.object.fog = this.fog.toJSON()),
              this.backgroundBlurriness > 0 &&
                (I.object.backgroundBlurriness = this.backgroundBlurriness),
              1 !== this.backgroundIntensity &&
                (I.object.backgroundIntensity = this.backgroundIntensity),
              I
            );
          }
          get autoUpdate() {
            return (
              console.warn(
                "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."
              ),
              this.matrixWorldAutoUpdate
            );
          }
          set autoUpdate(_) {
            console.warn(
              "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."
            ),
              (this.matrixWorldAutoUpdate = _);
          }
        },
        nF = class {
          constructor(_, I) {
            (this.isInterleavedBuffer = !0),
              (this.array = _),
              (this.stride = I),
              (this.count = void 0 !== _ ? _.length / I : 0),
              (this.usage = 35044),
              (this.updateRange = { offset: 0, count: -1 }),
              (this.version = 0),
              (this.uuid = ms());
          }
          onUploadCallback() {}
          set needsUpdate(_) {
            !0 === _ && this.version++;
          }
          setUsage(_) {
            return (this.usage = _), this;
          }
          copy(_) {
            return (
              (this.array = new _.array.constructor(_.array)),
              (this.count = _.count),
              (this.stride = _.stride),
              (this.usage = _.usage),
              this
            );
          }
          copyAt(_, I, R) {
            (_ *= this.stride), (R *= I.stride);
            for (let B = 0, z = this.stride; B < z; B++)
              this.array[_ + B] = I.array[R + B];
            return this;
          }
          set(_, I = 0) {
            return this.array.set(_, I), this;
          }
          clone(_) {
            void 0 === _.arrayBuffers && (_.arrayBuffers = {}),
              void 0 === this.array.buffer._uuid &&
                (this.array.buffer._uuid = ms()),
              void 0 === _.arrayBuffers[this.array.buffer._uuid] &&
                (_.arrayBuffers[this.array.buffer._uuid] =
                  this.array.slice(0).buffer);
            let I = new this.array.constructor(
                _.arrayBuffers[this.array.buffer._uuid]
              ),
              R = new this.constructor(I, this.stride);
            return R.setUsage(this.usage), R;
          }
          onUpload(_) {
            return (this.onUploadCallback = _), this;
          }
          toJSON(_) {
            return (
              void 0 === _.arrayBuffers && (_.arrayBuffers = {}),
              void 0 === this.array.buffer._uuid &&
                (this.array.buffer._uuid = ms()),
              void 0 === _.arrayBuffers[this.array.buffer._uuid] &&
                (_.arrayBuffers[this.array.buffer._uuid] = Array.from(
                  new Uint32Array(this.array.buffer)
                )),
              {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride,
              }
            );
          }
        },
        nN = new rF(),
        nk = class {
          constructor(_, I, R, B = !1) {
            (this.isInterleavedBufferAttribute = !0),
              (this.name = ""),
              (this.data = _),
              (this.itemSize = I),
              (this.offset = R),
              (this.normalized = B);
          }
          get count() {
            return this.data.count;
          }
          get array() {
            return this.data.array;
          }
          set needsUpdate(_) {
            this.data.needsUpdate = _;
          }
          applyMatrix4(_) {
            for (let I = 0, R = this.data.count; I < R; I++)
              nN.fromBufferAttribute(this, I),
                nN.applyMatrix4(_),
                this.setXYZ(I, nN.x, nN.y, nN.z);
            return this;
          }
          applyNormalMatrix(_) {
            for (let I = 0, R = this.count; I < R; I++)
              nN.fromBufferAttribute(this, I),
                nN.applyNormalMatrix(_),
                this.setXYZ(I, nN.x, nN.y, nN.z);
            return this;
          }
          transformDirection(_) {
            for (let I = 0, R = this.count; I < R; I++)
              nN.fromBufferAttribute(this, I),
                nN.transformDirection(_),
                this.setXYZ(I, nN.x, nN.y, nN.z);
            return this;
          }
          setX(_, I) {
            return (
              this.normalized && (I = br(I, this.array)),
              (this.data.array[_ * this.data.stride + this.offset] = I),
              this
            );
          }
          setY(_, I) {
            return (
              this.normalized && (I = br(I, this.array)),
              (this.data.array[_ * this.data.stride + this.offset + 1] = I),
              this
            );
          }
          setZ(_, I) {
            return (
              this.normalized && (I = br(I, this.array)),
              (this.data.array[_ * this.data.stride + this.offset + 2] = I),
              this
            );
          }
          setW(_, I) {
            return (
              this.normalized && (I = br(I, this.array)),
              (this.data.array[_ * this.data.stride + this.offset + 3] = I),
              this
            );
          }
          getX(_) {
            let I = this.data.array[_ * this.data.stride + this.offset];
            return this.normalized && (I = ya(I, this.array)), I;
          }
          getY(_) {
            let I = this.data.array[_ * this.data.stride + this.offset + 1];
            return this.normalized && (I = ya(I, this.array)), I;
          }
          getZ(_) {
            let I = this.data.array[_ * this.data.stride + this.offset + 2];
            return this.normalized && (I = ya(I, this.array)), I;
          }
          getW(_) {
            let I = this.data.array[_ * this.data.stride + this.offset + 3];
            return this.normalized && (I = ya(I, this.array)), I;
          }
          setXY(_, I, R) {
            return (
              (_ = _ * this.data.stride + this.offset),
              this.normalized &&
                ((I = br(I, this.array)), (R = br(R, this.array))),
              (this.data.array[_ + 0] = I),
              (this.data.array[_ + 1] = R),
              this
            );
          }
          setXYZ(_, I, R, B) {
            return (
              (_ = _ * this.data.stride + this.offset),
              this.normalized &&
                ((I = br(I, this.array)),
                (R = br(R, this.array)),
                (B = br(B, this.array))),
              (this.data.array[_ + 0] = I),
              (this.data.array[_ + 1] = R),
              (this.data.array[_ + 2] = B),
              this
            );
          }
          setXYZW(_, I, R, B, z) {
            return (
              (_ = _ * this.data.stride + this.offset),
              this.normalized &&
                ((I = br(I, this.array)),
                (R = br(R, this.array)),
                (B = br(B, this.array)),
                (z = br(z, this.array))),
              (this.data.array[_ + 0] = I),
              (this.data.array[_ + 1] = R),
              (this.data.array[_ + 2] = B),
              (this.data.array[_ + 3] = z),
              this
            );
          }
          clone(_) {
            if (void 0 !== _)
              return (
                void 0 === _.interleavedBuffers && (_.interleavedBuffers = {}),
                void 0 === _.interleavedBuffers[this.data.uuid] &&
                  (_.interleavedBuffers[this.data.uuid] = this.data.clone(_)),
                new nk(
                  _.interleavedBuffers[this.data.uuid],
                  this.itemSize,
                  this.offset,
                  this.normalized
                )
              );
            {
              console.log(
                "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
              );
              let _ = [];
              for (let I = 0; I < this.count; I++) {
                let R = I * this.data.stride + this.offset;
                for (let I = 0; I < this.itemSize; I++)
                  _.push(this.data.array[R + I]);
              }
              return new s0(
                new this.array.constructor(_),
                this.itemSize,
                this.normalized
              );
            }
          }
          toJSON(_) {
            if (void 0 !== _)
              return (
                void 0 === _.interleavedBuffers && (_.interleavedBuffers = {}),
                void 0 === _.interleavedBuffers[this.data.uuid] &&
                  (_.interleavedBuffers[this.data.uuid] = this.data.toJSON(_)),
                {
                  isInterleavedBufferAttribute: !0,
                  itemSize: this.itemSize,
                  data: this.data.uuid,
                  offset: this.offset,
                  normalized: this.normalized,
                }
              );
            {
              console.log(
                "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
              );
              let _ = [];
              for (let I = 0; I < this.count; I++) {
                let R = I * this.data.stride + this.offset;
                for (let I = 0; I < this.itemSize; I++)
                  _.push(this.data.array[R + I]);
              }
              return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: _,
                normalized: this.normalized,
              };
            }
          }
        },
        nU = class extends sL {
          constructor() {
            super(), (this.isBone = !0), (this.type = "Bone");
          }
        },
        nV = class extends rA {
          constructor(
            _ = null,
            I = 1,
            R = 1,
            B,
            z,
            k,
            V,
            j,
            G = 1003,
            q = 1003,
            X,
            Q
          ) {
            super(null, k, V, j, G, q, B, z, X, Q),
              (this.isDataTexture = !0),
              (this.image = { data: _, width: I, height: R }),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1);
          }
        },
        nj = new sa(),
        nH = new sa(),
        nW = class {
          constructor(_ = [], I = []) {
            (this.uuid = ms()),
              (this.bones = _.slice(0)),
              (this.boneInverses = I),
              (this.boneMatrices = null),
              (this.boneTexture = null),
              (this.boneTextureSize = 0),
              (this.frame = -1),
              this.init();
          }
          init() {
            let _ = this.bones,
              I = this.boneInverses;
            if (
              ((this.boneMatrices = new Float32Array(16 * _.length)),
              0 === I.length)
            )
              this.calculateInverses();
            else if (_.length !== I.length) {
              console.warn(
                "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
              ),
                (this.boneInverses = []);
              for (let _ = 0, I = this.bones.length; _ < I; _++)
                this.boneInverses.push(new sa());
            }
          }
          calculateInverses() {
            this.boneInverses.length = 0;
            for (let _ = 0, I = this.bones.length; _ < I; _++) {
              let I = new sa();
              this.bones[_] && I.copy(this.bones[_].matrixWorld).invert(),
                this.boneInverses.push(I);
            }
          }
          pose() {
            for (let _ = 0, I = this.bones.length; _ < I; _++) {
              let I = this.bones[_];
              I && I.matrixWorld.copy(this.boneInverses[_]).invert();
            }
            for (let _ = 0, I = this.bones.length; _ < I; _++) {
              let I = this.bones[_];
              I &&
                (I.parent && I.parent.isBone
                  ? (I.matrix.copy(I.parent.matrixWorld).invert(),
                    I.matrix.multiply(I.matrixWorld))
                  : I.matrix.copy(I.matrixWorld),
                I.matrix.decompose(I.position, I.quaternion, I.scale));
            }
          }
          update() {
            let _ = this.bones,
              I = this.boneInverses,
              R = this.boneMatrices,
              B = this.boneTexture;
            for (let B = 0, z = _.length; B < z; B++) {
              let z = _[B] ? _[B].matrixWorld : nH;
              nj.multiplyMatrices(z, I[B]), nj.toArray(R, 16 * B);
            }
            null !== B && (B.needsUpdate = !0);
          }
          clone() {
            return new nW(this.bones, this.boneInverses);
          }
          computeBoneTexture() {
            let _ = Math.sqrt(4 * this.bones.length);
            _ = Math.max((_ = qM(_)), 4);
            let I = new Float32Array(_ * _ * 4);
            I.set(this.boneMatrices);
            let R = new nV(I, _, _, 1023, 1015);
            return (
              (R.needsUpdate = !0),
              (this.boneMatrices = I),
              (this.boneTexture = R),
              (this.boneTextureSize = _),
              this
            );
          }
          getBoneByName(_) {
            for (let I = 0, R = this.bones.length; I < R; I++) {
              let R = this.bones[I];
              if (R.name === _) return R;
            }
          }
          dispose() {
            null !== this.boneTexture &&
              (this.boneTexture.dispose(), (this.boneTexture = null));
          }
          fromJSON(_, I) {
            this.uuid = _.uuid;
            for (let R = 0, B = _.bones.length; R < B; R++) {
              let B = _.bones[R],
                z = I[B];
              void 0 === z &&
                (console.warn("THREE.Skeleton: No bone found with UUID:", B),
                (z = new nU())),
                this.bones.push(z),
                this.boneInverses.push(new sa().fromArray(_.boneInverses[R]));
            }
            return this.init(), this;
          }
          toJSON() {
            let _ = {
              metadata: {
                version: 4.5,
                type: "Skeleton",
                generator: "Skeleton.toJSON",
              },
              bones: [],
              boneInverses: [],
            };
            _.uuid = this.uuid;
            let I = this.bones,
              R = this.boneInverses;
            for (let B = 0, z = I.length; B < z; B++) {
              let z = I[B];
              _.bones.push(z.uuid);
              let k = R[B];
              _.boneInverses.push(k.toArray());
            }
            return _;
          }
        },
        nq = class extends s0 {
          constructor(_, I, R, B = 1) {
            super(_, I, R),
              (this.isInstancedBufferAttribute = !0),
              (this.meshPerAttribute = B);
          }
          copy(_) {
            return (
              super.copy(_), (this.meshPerAttribute = _.meshPerAttribute), this
            );
          }
          toJSON() {
            let _ = super.toJSON();
            return (
              (_.meshPerAttribute = this.meshPerAttribute),
              (_.isInstancedBufferAttribute = !0),
              _
            );
          }
        },
        nY = new sa(),
        nX = new sa(),
        nQ = [],
        nZ = new sa(),
        nK = new aw(),
        nJ = class extends aw {
          constructor(_, I, R) {
            super(_, I),
              (this.isInstancedMesh = !0),
              (this.instanceMatrix = new nq(new Float32Array(16 * R), 16)),
              (this.instanceColor = null),
              (this.count = R),
              (this.frustumCulled = !1);
            for (let _ = 0; _ < R; _++) this.setMatrixAt(_, nZ);
          }
          copy(_, I) {
            return (
              super.copy(_, I),
              this.instanceMatrix.copy(_.instanceMatrix),
              null !== _.instanceColor &&
                (this.instanceColor = _.instanceColor.clone()),
              (this.count = _.count),
              this
            );
          }
          getColorAt(_, I) {
            I.fromArray(this.instanceColor.array, 3 * _);
          }
          getMatrixAt(_, I) {
            I.fromArray(this.instanceMatrix.array, 16 * _);
          }
          raycast(_, I) {
            let R = this.matrixWorld,
              B = this.count;
            if (
              ((nK.geometry = this.geometry),
              (nK.material = this.material),
              void 0 !== nK.material)
            )
              for (let z = 0; z < B; z++) {
                this.getMatrixAt(z, nY),
                  nX.multiplyMatrices(R, nY),
                  (nK.matrixWorld = nX),
                  nK.raycast(_, nQ);
                for (let _ = 0, R = nQ.length; _ < R; _++) {
                  let R = nQ[_];
                  (R.instanceId = z), (R.object = this), I.push(R);
                }
                nQ.length = 0;
              }
          }
          setColorAt(_, I) {
            null === this.instanceColor &&
              (this.instanceColor = new nq(
                new Float32Array(3 * this.instanceMatrix.count),
                3
              )),
              I.toArray(this.instanceColor.array, 3 * _);
          }
          setMatrixAt(_, I) {
            I.toArray(this.instanceMatrix.array, 16 * _);
          }
          updateMorphTargets() {}
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
        },
        n$ = class extends sZ {
          constructor(_) {
            super(),
              (this.isLineBasicMaterial = !0),
              (this.type = "LineBasicMaterial"),
              (this.color = new ry(16777215)),
              (this.linewidth = 1),
              (this.linecap = "round"),
              (this.linejoin = "round"),
              (this.fog = !0),
              this.setValues(_);
          }
          copy(_) {
            return (
              super.copy(_),
              this.color.copy(_.color),
              (this.linewidth = _.linewidth),
              (this.linecap = _.linecap),
              (this.linejoin = _.linejoin),
              (this.fog = _.fog),
              this
            );
          }
        },
        n0 = new rF(),
        n2 = new rF(),
        n3 = new sa(),
        n4 = new ss(),
        n5 = new r5(),
        n6 = class extends sL {
          constructor(_ = new ai(), I = new n$()) {
            super(),
              (this.isLine = !0),
              (this.type = "Line"),
              (this.geometry = _),
              (this.material = I),
              this.updateMorphTargets();
          }
          copy(_, I) {
            return (
              super.copy(_, I),
              (this.material = _.material),
              (this.geometry = _.geometry),
              this
            );
          }
          computeLineDistances() {
            let _ = this.geometry;
            if (null === _.index) {
              let I = _.attributes.position,
                R = [0];
              for (let _ = 1, B = I.count; _ < B; _++)
                n0.fromBufferAttribute(I, _ - 1),
                  n2.fromBufferAttribute(I, _),
                  (R[_] = R[_ - 1]),
                  (R[_] += n0.distanceTo(n2));
              _.setAttribute("lineDistance", new s4(R, 1));
            } else
              console.warn(
                "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
            return this;
          }
          raycast(_, I) {
            let R = this.geometry,
              B = this.matrixWorld,
              z = _.params.Line.threshold,
              k = R.drawRange;
            if (
              (null === R.boundingSphere && R.computeBoundingSphere(),
              n5.copy(R.boundingSphere),
              n5.applyMatrix4(B),
              (n5.radius += z),
              !1 === _.ray.intersectsSphere(n5))
            )
              return;
            n3.copy(B).invert(), n4.copy(_.ray).applyMatrix4(n3);
            let V = z / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              j = V * V,
              G = new rF(),
              q = new rF(),
              X = new rF(),
              Q = new rF(),
              $ = this.isLineSegments ? 2 : 1,
              et = R.index,
              er = R.attributes.position;
            if (null !== et) {
              let R = Math.max(0, k.start),
                B = Math.min(et.count, k.start + k.count);
              for (let z = R, k = B - 1; z < k; z += $) {
                let R = et.getX(z),
                  B = et.getX(z + 1);
                if (
                  (G.fromBufferAttribute(er, R),
                  q.fromBufferAttribute(er, B),
                  n4.distanceSqToSegment(G, q, Q, X) > j)
                )
                  continue;
                Q.applyMatrix4(this.matrixWorld);
                let k = _.ray.origin.distanceTo(Q);
                k < _.near ||
                  k > _.far ||
                  I.push({
                    distance: k,
                    point: X.clone().applyMatrix4(this.matrixWorld),
                    index: z,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            } else {
              let R = Math.max(0, k.start),
                B = Math.min(er.count, k.start + k.count);
              for (let z = R, k = B - 1; z < k; z += $) {
                if (
                  (G.fromBufferAttribute(er, z),
                  q.fromBufferAttribute(er, z + 1),
                  n4.distanceSqToSegment(G, q, Q, X) > j)
                )
                  continue;
                Q.applyMatrix4(this.matrixWorld);
                let R = _.ray.origin.distanceTo(Q);
                R < _.near ||
                  R > _.far ||
                  I.push({
                    distance: R,
                    point: X.clone().applyMatrix4(this.matrixWorld),
                    index: z,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            }
          }
          updateMorphTargets() {
            let _ = this.geometry.morphAttributes,
              I = Object.keys(_);
            if (I.length > 0) {
              let R = _[I[0]];
              if (void 0 !== R) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let _ = 0, I = R.length; _ < I; _++) {
                  let I = R[_].name || String(_);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[I] = _);
                }
              }
            }
          }
        },
        n8 = new rF(),
        n9 = new rF(),
        n7 = class extends n6 {
          constructor(_, I) {
            super(_, I),
              (this.isLineSegments = !0),
              (this.type = "LineSegments");
          }
          computeLineDistances() {
            let _ = this.geometry;
            if (null === _.index) {
              let I = _.attributes.position,
                R = [];
              for (let _ = 0, B = I.count; _ < B; _ += 2)
                n8.fromBufferAttribute(I, _),
                  n9.fromBufferAttribute(I, _ + 1),
                  (R[_] = 0 === _ ? 0 : R[_ - 1]),
                  (R[_ + 1] = R[_] + n8.distanceTo(n9));
              _.setAttribute("lineDistance", new s4(R, 1));
            } else
              console.warn(
                "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
              );
            return this;
          }
        },
        ot = class extends rA {
          constructor(_, I, R, B, z, k, V, j, G) {
            super(_, I, R, B, z, k, V, j, G),
              (this.isVideoTexture = !0),
              (this.minFilter = void 0 !== k ? k : 1006),
              (this.magFilter = void 0 !== z ? z : 1006),
              (this.generateMipmaps = !1);
            let q = this;
            "requestVideoFrameCallback" in _ &&
              _.requestVideoFrameCallback(function h() {
                (q.needsUpdate = !0), _.requestVideoFrameCallback(h);
              });
          }
          clone() {
            return new this.constructor(this.image).copy(this);
          }
          update() {
            let _ = this.image;
            "requestVideoFrameCallback" in _ == !1 &&
              _.readyState >= _.HAVE_CURRENT_DATA &&
              (this.needsUpdate = !0);
          }
        },
        oi = class extends rA {
          constructor(_, I, R, B, z, k, V, j, G) {
            super(_, I, R, B, z, k, V, j, G),
              (this.isCanvasTexture = !0),
              (this.needsUpdate = !0);
          }
        },
        or = class {
          constructor() {
            (this.type = "Curve"), (this.arcLengthDivisions = 200);
          }
          getPoint() {
            return (
              console.warn("THREE.Curve: .getPoint() not implemented."), null
            );
          }
          getPointAt(_, I) {
            let R = this.getUtoTmapping(_);
            return this.getPoint(R, I);
          }
          getPoints(_ = 5) {
            let I = [];
            for (let R = 0; R <= _; R++) I.push(this.getPoint(R / _));
            return I;
          }
          getSpacedPoints(_ = 5) {
            let I = [];
            for (let R = 0; R <= _; R++) I.push(this.getPointAt(R / _));
            return I;
          }
          getLength() {
            let _ = this.getLengths();
            return _[_.length - 1];
          }
          getLengths(_ = this.arcLengthDivisions) {
            if (
              this.cacheArcLengths &&
              this.cacheArcLengths.length === _ + 1 &&
              !this.needsUpdate
            )
              return this.cacheArcLengths;
            this.needsUpdate = !1;
            let I = [],
              R,
              B = this.getPoint(0),
              z = 0;
            I.push(0);
            for (let k = 1; k <= _; k++)
              I.push((z += (R = this.getPoint(k / _)).distanceTo(B))), (B = R);
            return (this.cacheArcLengths = I), I;
          }
          updateArcLengths() {
            (this.needsUpdate = !0), this.getLengths();
          }
          getUtoTmapping(_, I) {
            let R = this.getLengths(),
              B = 0,
              z = R.length,
              k;
            k = I || _ * R[z - 1];
            let V = 0,
              j = z - 1,
              G;
            for (; V <= j; )
              if ((G = R[(B = Math.floor(V + (j - V) / 2))] - k) < 0) V = B + 1;
              else if (G > 0) j = B - 1;
              else {
                j = B;
                break;
              }
            if (R[(B = j)] === k) return B / (z - 1);
            let q = R[B],
              X = R[B + 1] - q;
            return (B + (k - q) / X) / (z - 1);
          }
          getTangent(_, I) {
            let R = _ - 1e-4,
              B = _ + 1e-4;
            R < 0 && (R = 0), B > 1 && (B = 1);
            let z = this.getPoint(R),
              k = this.getPoint(B),
              V = I || (z.isVector2 ? new rs() : new rF());
            return V.copy(k).sub(z).normalize(), V;
          }
          getTangentAt(_, I) {
            let R = this.getUtoTmapping(_);
            return this.getTangent(R, I);
          }
          computeFrenetFrames(_, I) {
            let R = new rF(),
              B = [],
              z = [],
              k = [],
              V = new rF(),
              j = new sa();
            for (let I = 0; I <= _; I++) {
              let R = I / _;
              B[I] = this.getTangentAt(R, new rF());
            }
            (z[0] = new rF()), (k[0] = new rF());
            let G = Number.MAX_VALUE,
              q = Math.abs(B[0].x),
              X = Math.abs(B[0].y),
              Q = Math.abs(B[0].z);
            q <= G && ((G = q), R.set(1, 0, 0)),
              X <= G && ((G = X), R.set(0, 1, 0)),
              Q <= G && R.set(0, 0, 1),
              V.crossVectors(B[0], R).normalize(),
              z[0].crossVectors(B[0], V),
              k[0].crossVectors(B[0], z[0]);
            for (let I = 1; I <= _; I++) {
              if (
                ((z[I] = z[I - 1].clone()),
                (k[I] = k[I - 1].clone()),
                V.crossVectors(B[I - 1], B[I]),
                V.length() > Number.EPSILON)
              ) {
                V.normalize();
                let _ = Math.acos(gi(B[I - 1].dot(B[I]), -1, 1));
                z[I].applyMatrix4(j.makeRotationAxis(V, _));
              }
              k[I].crossVectors(B[I], z[I]);
            }
            if (!0 === I) {
              let I = Math.acos(gi(z[0].dot(z[_]), -1, 1));
              (I /= _), B[0].dot(V.crossVectors(z[0], z[_])) > 0 && (I = -I);
              for (let R = 1; R <= _; R++)
                z[R].applyMatrix4(j.makeRotationAxis(B[R], I * R)),
                  k[R].crossVectors(B[R], z[R]);
            }
            return { tangents: B, normals: z, binormals: k };
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(_) {
            return (this.arcLengthDivisions = _.arcLengthDivisions), this;
          }
          toJSON() {
            let _ = {
              metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON",
              },
            };
            return (
              (_.arcLengthDivisions = this.arcLengthDivisions),
              (_.type = this.type),
              _
            );
          }
          fromJSON(_) {
            return (this.arcLengthDivisions = _.arcLengthDivisions), this;
          }
        },
        oo = class extends or {
          constructor(
            _ = 0,
            I = 0,
            R = 1,
            B = 1,
            z = 0,
            k = 2 * Math.PI,
            V = !1,
            j = 0
          ) {
            super(),
              (this.isEllipseCurve = !0),
              (this.type = "EllipseCurve"),
              (this.aX = _),
              (this.aY = I),
              (this.xRadius = R),
              (this.yRadius = B),
              (this.aStartAngle = z),
              (this.aEndAngle = k),
              (this.aClockwise = V),
              (this.aRotation = j);
          }
          getPoint(_, I) {
            let R = I || new rs(),
              B = 2 * Math.PI,
              z = this.aEndAngle - this.aStartAngle,
              k = Math.abs(z) < Number.EPSILON;
            for (; z < 0; ) z += B;
            for (; z > B; ) z -= B;
            z < Number.EPSILON && (z = k ? 0 : B),
              !0 !== this.aClockwise || k || (z === B ? (z = -B) : (z -= B));
            let V = this.aStartAngle + _ * z,
              j = this.aX + this.xRadius * Math.cos(V),
              G = this.aY + this.yRadius * Math.sin(V);
            if (0 !== this.aRotation) {
              let _ = Math.cos(this.aRotation),
                I = Math.sin(this.aRotation),
                R = j - this.aX,
                B = G - this.aY;
              (j = R * _ - B * I + this.aX), (G = R * I + B * _ + this.aY);
            }
            return R.set(j, G);
          }
          copy(_) {
            return (
              super.copy(_),
              (this.aX = _.aX),
              (this.aY = _.aY),
              (this.xRadius = _.xRadius),
              (this.yRadius = _.yRadius),
              (this.aStartAngle = _.aStartAngle),
              (this.aEndAngle = _.aEndAngle),
              (this.aClockwise = _.aClockwise),
              (this.aRotation = _.aRotation),
              this
            );
          }
          toJSON() {
            let _ = super.toJSON();
            return (
              (_.aX = this.aX),
              (_.aY = this.aY),
              (_.xRadius = this.xRadius),
              (_.yRadius = this.yRadius),
              (_.aStartAngle = this.aStartAngle),
              (_.aEndAngle = this.aEndAngle),
              (_.aClockwise = this.aClockwise),
              (_.aRotation = this.aRotation),
              _
            );
          }
          fromJSON(_) {
            return (
              super.fromJSON(_),
              (this.aX = _.aX),
              (this.aY = _.aY),
              (this.xRadius = _.xRadius),
              (this.yRadius = _.yRadius),
              (this.aStartAngle = _.aStartAngle),
              (this.aEndAngle = _.aEndAngle),
              (this.aClockwise = _.aClockwise),
              (this.aRotation = _.aRotation),
              this
            );
          }
        },
        ol = class extends oo {
          constructor(_, I, R, B, z, k) {
            super(_, I, R, R, B, z, k),
              (this.isArcCurve = !0),
              (this.type = "ArcCurve");
          }
        };
      function Ow() {
        let _ = 0,
          I = 0,
          R = 0,
          B = 0;
        function i(z, k, V, j) {
          (_ = z),
            (I = V),
            (R = -3 * z + 3 * k - 2 * V - j),
            (B = 2 * z - 2 * k + V + j);
        }
        return {
          initCatmullRom: function (_, I, R, B, z) {
            i(I, R, z * (R - _), z * (B - I));
          },
          initNonuniformCatmullRom: function (_, I, R, B, z, k, V) {
            let j = (I - _) / z - (R - _) / (z + k) + (R - I) / k,
              G = (R - I) / k - (B - I) / (k + V) + (B - R) / V;
            i(I, R, (j *= k), (G *= k));
          },
          calc: function (z) {
            let k = z * z;
            return _ + I * z + R * k + B * (k * z);
          },
        };
      }
      var oh = new rF(),
        oc = new Ow(),
        od = new Ow(),
        ou = new Ow(),
        op = class extends or {
          constructor(_ = [], I = !1, R = "centripetal", B = 0.5) {
            super(),
              (this.isCatmullRomCurve3 = !0),
              (this.type = "CatmullRomCurve3"),
              (this.points = _),
              (this.closed = I),
              (this.curveType = R),
              (this.tension = B);
          }
          getPoint(_, I = new rF()) {
            let R,
              B,
              z = this.points,
              k = z.length,
              V = (k - (this.closed ? 0 : 1)) * _,
              j = Math.floor(V),
              G = V - j;
            this.closed
              ? (j += j > 0 ? 0 : (Math.floor(Math.abs(j) / k) + 1) * k)
              : 0 === G && j === k - 1 && ((j = k - 2), (G = 1)),
              this.closed || j > 0
                ? (R = z[(j - 1) % k])
                : (oh.subVectors(z[0], z[1]).add(z[0]), (R = oh));
            let q = z[j % k],
              X = z[(j + 1) % k];
            if (
              (this.closed || j + 2 < k
                ? (B = z[(j + 2) % k])
                : (oh.subVectors(z[k - 1], z[k - 2]).add(z[k - 1]), (B = oh)),
              "centripetal" === this.curveType || "chordal" === this.curveType)
            ) {
              let _ = "chordal" === this.curveType ? 0.5 : 0.25,
                I = Math.pow(R.distanceToSquared(q), _),
                z = Math.pow(q.distanceToSquared(X), _),
                k = Math.pow(X.distanceToSquared(B), _);
              z < 1e-4 && (z = 1),
                I < 1e-4 && (I = z),
                k < 1e-4 && (k = z),
                oc.initNonuniformCatmullRom(R.x, q.x, X.x, B.x, I, z, k),
                od.initNonuniformCatmullRom(R.y, q.y, X.y, B.y, I, z, k),
                ou.initNonuniformCatmullRom(R.z, q.z, X.z, B.z, I, z, k);
            } else
              "catmullrom" === this.curveType &&
                (oc.initCatmullRom(R.x, q.x, X.x, B.x, this.tension),
                od.initCatmullRom(R.y, q.y, X.y, B.y, this.tension),
                ou.initCatmullRom(R.z, q.z, X.z, B.z, this.tension));
            return I.set(oc.calc(G), od.calc(G), ou.calc(G)), I;
          }
          copy(_) {
            super.copy(_), (this.points = []);
            for (let I = 0, R = _.points.length; I < R; I++) {
              let R = _.points[I];
              this.points.push(R.clone());
            }
            return (
              (this.closed = _.closed),
              (this.curveType = _.curveType),
              (this.tension = _.tension),
              this
            );
          }
          toJSON() {
            let _ = super.toJSON();
            _.points = [];
            for (let I = 0, R = this.points.length; I < R; I++) {
              let R = this.points[I];
              _.points.push(R.toArray());
            }
            return (
              (_.closed = this.closed),
              (_.curveType = this.curveType),
              (_.tension = this.tension),
              _
            );
          }
          fromJSON(_) {
            super.fromJSON(_), (this.points = []);
            for (let I = 0, R = _.points.length; I < R; I++) {
              let R = _.points[I];
              this.points.push(new rF().fromArray(R));
            }
            return (
              (this.closed = _.closed),
              (this.curveType = _.curveType),
              (this.tension = _.tension),
              this
            );
          }
        };
      function EM(_, I, R, B, z) {
        let k = (B - I) * 0.5,
          V = (z - R) * 0.5,
          j = _ * _;
        return (
          (2 * R - 2 * B + k + V) * (_ * j) +
          (-3 * R + 3 * B - 2 * k - V) * j +
          k * _ +
          R
        );
      }
      function bp(_, I, R, B) {
        let z;
        return (z = 1 - _) * z * I + 2 * (1 - _) * _ * R + _ * _ * B;
      }
      function Sp(_, I, R, B, z) {
        let k, V;
        return (
          (k = 1 - _) * k * k * I +
          3 * (V = 1 - _) * V * _ * R +
          3 * (1 - _) * _ * _ * B +
          _ * _ * _ * z
        );
      }
      var of = class extends or {
          constructor(_ = new rs(), I = new rs(), R = new rs(), B = new rs()) {
            super(),
              (this.isCubicBezierCurve = !0),
              (this.type = "CubicBezierCurve"),
              (this.v0 = _),
              (this.v1 = I),
              (this.v2 = R),
              (this.v3 = B);
          }
          getPoint(_, I = new rs()) {
            let R = this.v0,
              B = this.v1,
              z = this.v2,
              k = this.v3;
            return (
              I.set(Sp(_, R.x, B.x, z.x, k.x), Sp(_, R.y, B.y, z.y, k.y)), I
            );
          }
          copy(_) {
            return (
              super.copy(_),
              this.v0.copy(_.v0),
              this.v1.copy(_.v1),
              this.v2.copy(_.v2),
              this.v3.copy(_.v3),
              this
            );
          }
          toJSON() {
            let _ = super.toJSON();
            return (
              (_.v0 = this.v0.toArray()),
              (_.v1 = this.v1.toArray()),
              (_.v2 = this.v2.toArray()),
              (_.v3 = this.v3.toArray()),
              _
            );
          }
          fromJSON(_) {
            return (
              super.fromJSON(_),
              this.v0.fromArray(_.v0),
              this.v1.fromArray(_.v1),
              this.v2.fromArray(_.v2),
              this.v3.fromArray(_.v3),
              this
            );
          }
        },
        om = class extends or {
          constructor(_ = new rF(), I = new rF(), R = new rF(), B = new rF()) {
            super(),
              (this.isCubicBezierCurve3 = !0),
              (this.type = "CubicBezierCurve3"),
              (this.v0 = _),
              (this.v1 = I),
              (this.v2 = R),
              (this.v3 = B);
          }
          getPoint(_, I = new rF()) {
            let R = this.v0,
              B = this.v1,
              z = this.v2,
              k = this.v3;
            return (
              I.set(
                Sp(_, R.x, B.x, z.x, k.x),
                Sp(_, R.y, B.y, z.y, k.y),
                Sp(_, R.z, B.z, z.z, k.z)
              ),
              I
            );
          }
          copy(_) {
            return (
              super.copy(_),
              this.v0.copy(_.v0),
              this.v1.copy(_.v1),
              this.v2.copy(_.v2),
              this.v3.copy(_.v3),
              this
            );
          }
          toJSON() {
            let _ = super.toJSON();
            return (
              (_.v0 = this.v0.toArray()),
              (_.v1 = this.v1.toArray()),
              (_.v2 = this.v2.toArray()),
              (_.v3 = this.v3.toArray()),
              _
            );
          }
          fromJSON(_) {
            return (
              super.fromJSON(_),
              this.v0.fromArray(_.v0),
              this.v1.fromArray(_.v1),
              this.v2.fromArray(_.v2),
              this.v3.fromArray(_.v3),
              this
            );
          }
        },
        og = class extends or {
          constructor(_ = new rs(), I = new rs()) {
            super(),
              (this.isLineCurve = !0),
              (this.type = "LineCurve"),
              (this.v1 = _),
              (this.v2 = I);
          }
          getPoint(_, I = new rs()) {
            return (
              1 === _
                ? I.copy(this.v2)
                : (I.copy(this.v2).sub(this.v1),
                  I.multiplyScalar(_).add(this.v1)),
              I
            );
          }
          getPointAt(_, I) {
            return this.getPoint(_, I);
          }
          getTangent(_, I) {
            let R = I || new rs();
            return R.copy(this.v2).sub(this.v1).normalize(), R;
          }
          copy(_) {
            return super.copy(_), this.v1.copy(_.v1), this.v2.copy(_.v2), this;
          }
          toJSON() {
            let _ = super.toJSON();
            return (_.v1 = this.v1.toArray()), (_.v2 = this.v2.toArray()), _;
          }
          fromJSON(_) {
            return (
              super.fromJSON(_),
              this.v1.fromArray(_.v1),
              this.v2.fromArray(_.v2),
              this
            );
          }
        },
        ox = class extends or {
          constructor(_ = new rF(), I = new rF()) {
            super(),
              (this.isLineCurve3 = !0),
              (this.type = "LineCurve3"),
              (this.v1 = _),
              (this.v2 = I);
          }
          getPoint(_, I = new rF()) {
            return (
              1 === _
                ? I.copy(this.v2)
                : (I.copy(this.v2).sub(this.v1),
                  I.multiplyScalar(_).add(this.v1)),
              I
            );
          }
          getPointAt(_, I) {
            return this.getPoint(_, I);
          }
          copy(_) {
            return super.copy(_), this.v1.copy(_.v1), this.v2.copy(_.v2), this;
          }
          toJSON() {
            let _ = super.toJSON();
            return (_.v1 = this.v1.toArray()), (_.v2 = this.v2.toArray()), _;
          }
          fromJSON(_) {
            return (
              super.fromJSON(_),
              this.v1.fromArray(_.v1),
              this.v2.fromArray(_.v2),
              this
            );
          }
        },
        ob = class extends or {
          constructor(_ = new rs(), I = new rs(), R = new rs()) {
            super(),
              (this.isQuadraticBezierCurve = !0),
              (this.type = "QuadraticBezierCurve"),
              (this.v0 = _),
              (this.v1 = I),
              (this.v2 = R);
          }
          getPoint(_, I = new rs()) {
            let R = this.v0,
              B = this.v1,
              z = this.v2;
            return I.set(bp(_, R.x, B.x, z.x), bp(_, R.y, B.y, z.y)), I;
          }
          copy(_) {
            return (
              super.copy(_),
              this.v0.copy(_.v0),
              this.v1.copy(_.v1),
              this.v2.copy(_.v2),
              this
            );
          }
          toJSON() {
            let _ = super.toJSON();
            return (
              (_.v0 = this.v0.toArray()),
              (_.v1 = this.v1.toArray()),
              (_.v2 = this.v2.toArray()),
              _
            );
          }
          fromJSON(_) {
            return (
              super.fromJSON(_),
              this.v0.fromArray(_.v0),
              this.v1.fromArray(_.v1),
              this.v2.fromArray(_.v2),
              this
            );
          }
        },
        ow = class extends or {
          constructor(_ = new rF(), I = new rF(), R = new rF()) {
            super(),
              (this.isQuadraticBezierCurve3 = !0),
              (this.type = "QuadraticBezierCurve3"),
              (this.v0 = _),
              (this.v1 = I),
              (this.v2 = R);
          }
          getPoint(_, I = new rF()) {
            let R = this.v0,
              B = this.v1,
              z = this.v2;
            return (
              I.set(
                bp(_, R.x, B.x, z.x),
                bp(_, R.y, B.y, z.y),
                bp(_, R.z, B.z, z.z)
              ),
              I
            );
          }
          copy(_) {
            return (
              super.copy(_),
              this.v0.copy(_.v0),
              this.v1.copy(_.v1),
              this.v2.copy(_.v2),
              this
            );
          }
          toJSON() {
            let _ = super.toJSON();
            return (
              (_.v0 = this.v0.toArray()),
              (_.v1 = this.v1.toArray()),
              (_.v2 = this.v2.toArray()),
              _
            );
          }
          fromJSON(_) {
            return (
              super.fromJSON(_),
              this.v0.fromArray(_.v0),
              this.v1.fromArray(_.v1),
              this.v2.fromArray(_.v2),
              this
            );
          }
        },
        o_ = class extends or {
          constructor(_ = []) {
            super(),
              (this.isSplineCurve = !0),
              (this.type = "SplineCurve"),
              (this.points = _);
          }
          getPoint(_, I = new rs()) {
            let R = this.points,
              B = (R.length - 1) * _,
              z = Math.floor(B),
              k = B - z,
              V = R[0 === z ? z : z - 1],
              j = R[z],
              G = R[z > R.length - 2 ? R.length - 1 : z + 1],
              q = R[z > R.length - 3 ? R.length - 1 : z + 2];
            return (
              I.set(EM(k, V.x, j.x, G.x, q.x), EM(k, V.y, j.y, G.y, q.y)), I
            );
          }
          copy(_) {
            super.copy(_), (this.points = []);
            for (let I = 0, R = _.points.length; I < R; I++) {
              let R = _.points[I];
              this.points.push(R.clone());
            }
            return this;
          }
          toJSON() {
            let _ = super.toJSON();
            _.points = [];
            for (let I = 0, R = this.points.length; I < R; I++) {
              let R = this.points[I];
              _.points.push(R.toArray());
            }
            return _;
          }
          fromJSON(_) {
            super.fromJSON(_), (this.points = []);
            for (let I = 0, R = _.points.length; I < R; I++) {
              let R = _.points[I];
              this.points.push(new rs().fromArray(R));
            }
            return this;
          }
        },
        oS = Object.freeze({
          __proto__: null,
          ArcCurve: ol,
          CatmullRomCurve3: op,
          CubicBezierCurve: of,
          CubicBezierCurve3: om,
          EllipseCurve: oo,
          LineCurve: og,
          LineCurve3: ox,
          QuadraticBezierCurve: ob,
          QuadraticBezierCurve3: ow,
          SplineCurve: o_,
        }),
        oA = class extends or {
          constructor() {
            super(),
              (this.type = "CurvePath"),
              (this.curves = []),
              (this.autoClose = !1);
          }
          add(_) {
            this.curves.push(_);
          }
          closePath() {
            let _ = this.curves[0].getPoint(0),
              I = this.curves[this.curves.length - 1].getPoint(1);
            _.equals(I) || this.curves.push(new og(I, _));
          }
          getPoint(_, I) {
            let R = _ * this.getLength(),
              B = this.getCurveLengths(),
              z = 0;
            for (; z < B.length; ) {
              if (B[z] >= R) {
                let _ = B[z] - R,
                  k = this.curves[z],
                  V = k.getLength(),
                  j = 0 === V ? 0 : 1 - _ / V;
                return k.getPointAt(j, I);
              }
              z++;
            }
            return null;
          }
          getLength() {
            let _ = this.getCurveLengths();
            return _[_.length - 1];
          }
          updateArcLengths() {
            (this.needsUpdate = !0),
              (this.cacheLengths = null),
              this.getCurveLengths();
          }
          getCurveLengths() {
            if (
              this.cacheLengths &&
              this.cacheLengths.length === this.curves.length
            )
              return this.cacheLengths;
            let _ = [],
              I = 0;
            for (let R = 0, B = this.curves.length; R < B; R++)
              _.push((I += this.curves[R].getLength()));
            return (this.cacheLengths = _), _;
          }
          getSpacedPoints(_ = 40) {
            let I = [];
            for (let R = 0; R <= _; R++) I.push(this.getPoint(R / _));
            return this.autoClose && I.push(I[0]), I;
          }
          getPoints(_ = 12) {
            let I = [],
              R;
            for (let B = 0, z = this.curves; B < z.length; B++) {
              let k = z[B],
                V = k.isEllipseCurve
                  ? 2 * _
                  : k.isLineCurve || k.isLineCurve3
                  ? 1
                  : k.isSplineCurve
                  ? _ * k.points.length
                  : _,
                j = k.getPoints(V);
              for (let _ = 0; _ < j.length; _++) {
                let B = j[_];
                (R && R.equals(B)) || (I.push(B), (R = B));
              }
            }
            return (
              this.autoClose &&
                I.length > 1 &&
                !I[I.length - 1].equals(I[0]) &&
                I.push(I[0]),
              I
            );
          }
          copy(_) {
            super.copy(_), (this.curves = []);
            for (let I = 0, R = _.curves.length; I < R; I++) {
              let R = _.curves[I];
              this.curves.push(R.clone());
            }
            return (this.autoClose = _.autoClose), this;
          }
          toJSON() {
            let _ = super.toJSON();
            (_.autoClose = this.autoClose), (_.curves = []);
            for (let I = 0, R = this.curves.length; I < R; I++) {
              let R = this.curves[I];
              _.curves.push(R.toJSON());
            }
            return _;
          }
          fromJSON(_) {
            super.fromJSON(_),
              (this.autoClose = _.autoClose),
              (this.curves = []);
            for (let I = 0, R = _.curves.length; I < R; I++) {
              let R = _.curves[I];
              this.curves.push(new oS[R.type]().fromJSON(R));
            }
            return this;
          }
        },
        oM = class extends oA {
          constructor(_) {
            super(),
              (this.type = "Path"),
              (this.currentPoint = new rs()),
              _ && this.setFromPoints(_);
          }
          setFromPoints(_) {
            this.moveTo(_[0].x, _[0].y);
            for (let I = 1, R = _.length; I < R; I++)
              this.lineTo(_[I].x, _[I].y);
            return this;
          }
          moveTo(_, I) {
            return this.currentPoint.set(_, I), this;
          }
          lineTo(_, I) {
            let R = new og(this.currentPoint.clone(), new rs(_, I));
            return this.curves.push(R), this.currentPoint.set(_, I), this;
          }
          quadraticCurveTo(_, I, R, B) {
            let z = new ob(
              this.currentPoint.clone(),
              new rs(_, I),
              new rs(R, B)
            );
            return this.curves.push(z), this.currentPoint.set(R, B), this;
          }
          bezierCurveTo(_, I, R, B, z, k) {
            let V = new of(
              this.currentPoint.clone(),
              new rs(_, I),
              new rs(R, B),
              new rs(z, k)
            );
            return this.curves.push(V), this.currentPoint.set(z, k), this;
          }
          splineThru(_) {
            let I = [this.currentPoint.clone()].concat(_),
              R = new o_(I);
            return (
              this.curves.push(R), this.currentPoint.copy(_[_.length - 1]), this
            );
          }
          arc(_, I, R, B, z, k) {
            let V = this.currentPoint.x,
              j = this.currentPoint.y;
            return this.absarc(_ + V, I + j, R, B, z, k), this;
          }
          absarc(_, I, R, B, z, k) {
            return this.absellipse(_, I, R, R, B, z, k), this;
          }
          ellipse(_, I, R, B, z, k, V, j) {
            let G = this.currentPoint.x,
              q = this.currentPoint.y;
            return this.absellipse(_ + G, I + q, R, B, z, k, V, j), this;
          }
          absellipse(_, I, R, B, z, k, V, j) {
            let G = new oo(_, I, R, B, z, k, V, j);
            if (this.curves.length > 0) {
              let _ = G.getPoint(0);
              _.equals(this.currentPoint) || this.lineTo(_.x, _.y);
            }
            this.curves.push(G);
            let q = G.getPoint(1);
            return this.currentPoint.copy(q), this;
          }
          copy(_) {
            return super.copy(_), this.currentPoint.copy(_.currentPoint), this;
          }
          toJSON() {
            let _ = super.toJSON();
            return (_.currentPoint = this.currentPoint.toArray()), _;
          }
          fromJSON(_) {
            return (
              super.fromJSON(_),
              this.currentPoint.fromArray(_.currentPoint),
              this
            );
          }
        },
        oE = class extends ai {
          constructor(
            _ = [new rs(0, -0.5), new rs(0.5, 0), new rs(0, 0.5)],
            I = 12,
            R = 0,
            B = 2 * Math.PI
          ) {
            super(),
              (this.type = "LatheGeometry"),
              (this.parameters = {
                points: _,
                segments: I,
                phiStart: R,
                phiLength: B,
              }),
              (I = Math.floor(I)),
              (B = gi(B, 0, 2 * Math.PI));
            let z = [],
              k = [],
              V = [],
              j = [],
              G = [],
              q = 1 / I,
              X = new rF(),
              Q = new rs(),
              $ = new rF(),
              et = new rF(),
              er = new rF(),
              es = 0,
              ea = 0;
            for (let I = 0; I <= _.length - 1; I++)
              switch (I) {
                case 0:
                  (es = _[I + 1].x - _[I].x),
                    (ea = _[I + 1].y - _[I].y),
                    ($.x = 1 * ea),
                    ($.y = -es),
                    ($.z = 0 * ea),
                    er.copy($),
                    $.normalize(),
                    j.push($.x, $.y, $.z);
                  break;
                case _.length - 1:
                  j.push(er.x, er.y, er.z);
                  break;
                default:
                  (es = _[I + 1].x - _[I].x),
                    (ea = _[I + 1].y - _[I].y),
                    ($.x = 1 * ea),
                    ($.y = -es),
                    ($.z = 0 * ea),
                    et.copy($),
                    ($.x += er.x),
                    ($.y += er.y),
                    ($.z += er.z),
                    $.normalize(),
                    j.push($.x, $.y, $.z),
                    er.copy(et);
              }
            for (let z = 0; z <= I; z++) {
              let $ = R + z * q * B,
                et = Math.sin($),
                er = Math.cos($);
              for (let R = 0; R <= _.length - 1; R++) {
                (X.x = _[R].x * et),
                  (X.y = _[R].y),
                  (X.z = _[R].x * er),
                  k.push(X.x, X.y, X.z),
                  (Q.x = z / I),
                  (Q.y = R / (_.length - 1)),
                  V.push(Q.x, Q.y);
                let B = j[3 * R + 0] * et,
                  q = j[3 * R + 1],
                  $ = j[3 * R + 0] * er;
                G.push(B, q, $);
              }
            }
            for (let R = 0; R < I; R++)
              for (let I = 0; I < _.length - 1; I++) {
                let B = I + R * _.length,
                  k = B + _.length,
                  V = B + _.length + 1,
                  j = B + 1;
                z.push(B, k, j), z.push(V, j, k);
              }
            this.setIndex(z),
              this.setAttribute("position", new s4(k, 3)),
              this.setAttribute("uv", new s4(V, 2)),
              this.setAttribute("normal", new s4(G, 3));
          }
          static fromJSON(_) {
            return new oE(_.points, _.segments, _.phiStart, _.phiLength);
          }
        },
        oC = class extends ai {
          constructor(
            _ = 1,
            I = 1,
            R = 1,
            B = 32,
            z = 1,
            k = !1,
            V = 0,
            j = 2 * Math.PI
          ) {
            super(),
              (this.type = "CylinderGeometry"),
              (this.parameters = {
                radiusTop: _,
                radiusBottom: I,
                height: R,
                radialSegments: B,
                heightSegments: z,
                openEnded: k,
                thetaStart: V,
                thetaLength: j,
              });
            let G = this;
            (B = Math.floor(B)), (z = Math.floor(z));
            let q = [],
              X = [],
              Q = [],
              $ = [],
              et = 0,
              er = [],
              es = R / 2,
              ea = 0;
            function x(R) {
              let z = et,
                k = new rs(),
                er = new rF(),
                en = 0,
                eo = !0 === R ? _ : I,
                el = !0 === R ? 1 : -1;
              for (let _ = 1; _ <= B; _++)
                X.push(0, es * el, 0), Q.push(0, el, 0), $.push(0.5, 0.5), et++;
              let eh = et;
              for (let _ = 0; _ <= B; _++) {
                let I = (_ / B) * j + V,
                  R = Math.cos(I),
                  z = Math.sin(I);
                (er.x = eo * z),
                  (er.y = es * el),
                  (er.z = eo * R),
                  X.push(er.x, er.y, er.z),
                  Q.push(0, el, 0),
                  (k.x = 0.5 * R + 0.5),
                  (k.y = 0.5 * z * el + 0.5),
                  $.push(k.x, k.y),
                  et++;
              }
              for (let _ = 0; _ < B; _++) {
                let I = z + _,
                  B = eh + _;
                !0 === R ? q.push(B, B + 1, I) : q.push(B + 1, B, I), (en += 3);
              }
              G.addGroup(ea, en, !0 === R ? 1 : 2), (ea += en);
            }
            (function () {
              let k = new rF(),
                en = new rF(),
                eo = 0,
                el = (I - _) / R;
              for (let G = 0; G <= z; G++) {
                let q = [],
                  ea = G / z,
                  eo = ea * (I - _) + _;
                for (let _ = 0; _ <= B; _++) {
                  let I = _ / B,
                    z = I * j + V,
                    G = Math.sin(z),
                    er = Math.cos(z);
                  (en.x = eo * G),
                    (en.y = -ea * R + es),
                    (en.z = eo * er),
                    X.push(en.x, en.y, en.z),
                    k.set(G, el, er).normalize(),
                    Q.push(k.x, k.y, k.z),
                    $.push(I, 1 - ea),
                    q.push(et++);
                }
                er.push(q);
              }
              for (let _ = 0; _ < B; _++)
                for (let I = 0; I < z; I++) {
                  let R = er[I][_],
                    B = er[I + 1][_],
                    z = er[I + 1][_ + 1],
                    k = er[I][_ + 1];
                  q.push(R, B, k), q.push(B, z, k), (eo += 6);
                }
              G.addGroup(ea, eo, 0), (ea += eo);
            })(),
              !1 === k && (_ > 0 && x(!0), I > 0 && x(!1)),
              this.setIndex(q),
              this.setAttribute("position", new s4(X, 3)),
              this.setAttribute("normal", new s4(Q, 3)),
              this.setAttribute("uv", new s4($, 2));
          }
          static fromJSON(_) {
            return new oC(
              _.radiusTop,
              _.radiusBottom,
              _.height,
              _.radialSegments,
              _.heightSegments,
              _.openEnded,
              _.thetaStart,
              _.thetaLength
            );
          }
        },
        oT = class extends oC {
          constructor(
            _ = 1,
            I = 1,
            R = 32,
            B = 1,
            z = !1,
            k = 0,
            V = 2 * Math.PI
          ) {
            super(0, _, I, R, B, z, k, V),
              (this.type = "ConeGeometry"),
              (this.parameters = {
                radius: _,
                height: I,
                radialSegments: R,
                heightSegments: B,
                openEnded: z,
                thetaStart: k,
                thetaLength: V,
              });
          }
          static fromJSON(_) {
            return new oT(
              _.radius,
              _.height,
              _.radialSegments,
              _.heightSegments,
              _.openEnded,
              _.thetaStart,
              _.thetaLength
            );
          }
        },
        oP = class extends ai {
          constructor(_ = [], I = [], R = 1, B = 0) {
            super(),
              (this.type = "PolyhedronGeometry"),
              (this.parameters = {
                vertices: _,
                indices: I,
                radius: R,
                detail: B,
              });
            let z = [],
              k = [];
            function d(_) {
              z.push(_.x, _.y, _.z);
            }
            function f(I, R) {
              let B = 3 * I;
              (R.x = _[B + 0]), (R.y = _[B + 1]), (R.z = _[B + 2]);
            }
            function m(_, I, R, B) {
              B < 0 && 1 === _.x && (k[I] = _.x - 1),
                0 === R.x && 0 === R.z && (k[I] = B / 2 / Math.PI + 0.5);
            }
            function g(_) {
              return Math.atan2(_.z, -_.x);
            }
            (function (_) {
              let R = new rF(),
                B = new rF(),
                z = new rF();
              for (let k = 0; k < I.length; k += 3)
                f(I[k + 0], R),
                  f(I[k + 1], B),
                  f(I[k + 2], z),
                  (function (_, I, R, B) {
                    let z = B + 1,
                      k = [];
                    for (let B = 0; B <= z; B++) {
                      k[B] = [];
                      let V = _.clone().lerp(R, B / z),
                        j = I.clone().lerp(R, B / z),
                        G = z - B;
                      for (let _ = 0; _ <= G; _++)
                        0 === _ && B === z
                          ? (k[B][_] = V)
                          : (k[B][_] = V.clone().lerp(j, _ / G));
                    }
                    for (let _ = 0; _ < z; _++)
                      for (let I = 0; I < 2 * (z - _) - 1; I++) {
                        let R = Math.floor(I / 2);
                        I % 2 == 0
                          ? (d(k[_][R + 1]), d(k[_ + 1][R]), d(k[_][R]))
                          : (d(k[_][R + 1]),
                            d(k[_ + 1][R + 1]),
                            d(k[_ + 1][R]));
                      }
                  })(R, B, z, _);
            })(B),
              (function (_) {
                let I = new rF();
                for (let R = 0; R < z.length; R += 3)
                  (I.x = z[R + 0]),
                    (I.y = z[R + 1]),
                    (I.z = z[R + 2]),
                    I.normalize().multiplyScalar(_),
                    (z[R + 0] = I.x),
                    (z[R + 1] = I.y),
                    (z[R + 2] = I.z);
              })(R),
              (function () {
                let _ = new rF();
                for (let I = 0; I < z.length; I += 3) {
                  (_.x = z[I + 0]), (_.y = z[I + 1]), (_.z = z[I + 2]);
                  let R = g(_) / 2 / Math.PI + 0.5,
                    B =
                      Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z)) /
                        Math.PI +
                      0.5;
                  k.push(R, 1 - B);
                }
                (function () {
                  let _ = new rF(),
                    I = new rF(),
                    R = new rF(),
                    B = new rF(),
                    V = new rs(),
                    j = new rs(),
                    G = new rs();
                  for (let q = 0, X = 0; q < z.length; q += 9, X += 6) {
                    _.set(z[q + 0], z[q + 1], z[q + 2]),
                      I.set(z[q + 3], z[q + 4], z[q + 5]),
                      R.set(z[q + 6], z[q + 7], z[q + 8]),
                      V.set(k[X + 0], k[X + 1]),
                      j.set(k[X + 2], k[X + 3]),
                      G.set(k[X + 4], k[X + 5]),
                      B.copy(_).add(I).add(R).divideScalar(3);
                    let Q = g(B);
                    m(V, X + 0, _, Q), m(j, X + 2, I, Q), m(G, X + 4, R, Q);
                  }
                })(),
                  (function () {
                    for (let _ = 0; _ < k.length; _ += 6) {
                      let I = k[_ + 0],
                        R = k[_ + 2],
                        B = k[_ + 4],
                        z = Math.max(I, R, B),
                        V = Math.min(I, R, B);
                      z > 0.9 &&
                        V < 0.1 &&
                        (I < 0.2 && (k[_ + 0] += 1),
                        R < 0.2 && (k[_ + 2] += 1),
                        B < 0.2 && (k[_ + 4] += 1));
                    }
                  })();
              })(),
              this.setAttribute("position", new s4(z, 3)),
              this.setAttribute("normal", new s4(z.slice(), 3)),
              this.setAttribute("uv", new s4(k, 2)),
              0 === B ? this.computeVertexNormals() : this.normalizeNormals();
          }
          static fromJSON(_) {
            return new oP(_.vertices, _.indices, _.radius, _.details);
          }
        },
        oD = class extends oP {
          constructor(_ = 1, I = 0) {
            let R = (1 + Math.sqrt(5)) / 2,
              B = 1 / R;
            super(
              [
                -1,
                -1,
                -1,
                -1,
                -1,
                1,
                -1,
                1,
                -1,
                -1,
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                1,
                1,
                1,
                -1,
                1,
                1,
                1,
                0,
                -B,
                -R,
                0,
                -B,
                R,
                0,
                B,
                -R,
                0,
                B,
                R,
                -B,
                -R,
                0,
                -B,
                R,
                0,
                B,
                -R,
                0,
                B,
                R,
                0,
                -R,
                0,
                -B,
                R,
                0,
                -B,
                -R,
                0,
                B,
                R,
                0,
                B,
              ],
              [
                3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15,
                17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0,
                12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2,
                16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4,
                14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19,
                5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
              ],
              _,
              I
            ),
              (this.type = "DodecahedronGeometry"),
              (this.parameters = { radius: _, detail: I });
          }
          static fromJSON(_) {
            return new oD(_.radius, _.detail);
          }
        },
        oR = class extends oM {
          constructor(_) {
            super(_),
              (this.uuid = ms()),
              (this.type = "Shape"),
              (this.holes = []);
          }
          getPointsHoles(_) {
            let I = [];
            for (let R = 0, B = this.holes.length; R < B; R++)
              I[R] = this.holes[R].getPoints(_);
            return I;
          }
          extractPoints(_) {
            return { shape: this.getPoints(_), holes: this.getPointsHoles(_) };
          }
          copy(_) {
            super.copy(_), (this.holes = []);
            for (let I = 0, R = _.holes.length; I < R; I++) {
              let R = _.holes[I];
              this.holes.push(R.clone());
            }
            return this;
          }
          toJSON() {
            let _ = super.toJSON();
            (_.uuid = this.uuid), (_.holes = []);
            for (let I = 0, R = this.holes.length; I < R; I++) {
              let R = this.holes[I];
              _.holes.push(R.toJSON());
            }
            return _;
          }
          fromJSON(_) {
            super.fromJSON(_), (this.uuid = _.uuid), (this.holes = []);
            for (let I = 0, R = _.holes.length; I < R; I++) {
              let R = _.holes[I];
              this.holes.push(new oM().fromJSON(R));
            }
            return this;
          }
        },
        oL = {
          triangulate: function (_, I, R = 2) {
            let B,
              z,
              k,
              V,
              j,
              G,
              q,
              X = I && I.length,
              Q = X ? I[0] * R : _.length,
              $ = tC(_, 0, Q, R, !0),
              et = [];
            if (!$ || $.next === $.prev) return et;
            if (
              (X &&
                ($ = (function (_, I, R, B) {
                  let z = [],
                    k,
                    V,
                    j,
                    G,
                    q;
                  for (k = 0, V = I.length; k < V; k++)
                    (j = I[k] * B),
                      (G = k < V - 1 ? I[k + 1] * B : _.length),
                      (q = tC(_, j, G, B, !1)) === q.next && (q.steiner = !0),
                      z.push(
                        (function (_) {
                          let I = _,
                            R = _;
                          do
                            (I.x < R.x || (I.x === R.x && I.y < R.y)) &&
                              (R = I),
                              (I = I.next);
                          while (I !== _);
                          return R;
                        })(q)
                      );
                  for (z.sort(f4), k = 0; k < z.length; k++)
                    R = (function (_, I) {
                      let R = (function (_, I) {
                        let R = I,
                          B = -1 / 0,
                          z,
                          k = _.x,
                          V = _.y;
                        do {
                          if (V <= R.y && V >= R.next.y && R.next.y !== R.y) {
                            let _ =
                              R.x +
                              ((V - R.y) * (R.next.x - R.x)) / (R.next.y - R.y);
                            if (
                              _ <= k &&
                              _ > B &&
                              ((B = _),
                              (z = R.x < R.next.x ? R : R.next),
                              _ === k)
                            )
                              return z;
                          }
                          R = R.next;
                        } while (R !== I);
                        if (!z) return null;
                        let j = z,
                          G = z.x,
                          q = z.y,
                          X = 1 / 0,
                          Q;
                        R = z;
                        do {
                          var $, et;
                          k >= R.x &&
                            R.x >= G &&
                            k !== R.x &&
                            zu(
                              V < q ? k : B,
                              V,
                              G,
                              q,
                              V < q ? B : k,
                              V,
                              R.x,
                              R.y
                            ) &&
                            ((Q = Math.abs(V - R.y) / (k - R.x)),
                            Ip(R, _) &&
                              (Q < X ||
                                (Q === X &&
                                  (R.x > z.x ||
                                    (R.x === z.x &&
                                      (($ = z),
                                      (et = R),
                                      0 > jr($.prev, $, et.prev) &&
                                        0 > jr(et.next, $, $.next)))))) &&
                              ((z = R), (X = Q))),
                            (R = R.next);
                        } while (R !== j);
                        return z;
                      })(_, I);
                      if (!R) return I;
                      let B = iC(R, _);
                      return Dc(B, B.next), Dc(R, R.next);
                    })(z[k], R);
                  return R;
                })(_, I, $, R)),
              _.length > 80 * R)
            ) {
              (B = k = _[0]), (z = V = _[1]);
              for (let I = R; I < Q; I += R)
                (j = _[I]),
                  (G = _[I + 1]),
                  j < B && (B = j),
                  G < z && (z = G),
                  j > k && (k = j),
                  G > V && (V = G);
              q = 0 !== (q = Math.max(k - B, V - z)) ? 32767 / q : 0;
            }
            return (
              (function Op(_, I, R, B, z, k, V) {
                if (!_) return;
                !V &&
                  k &&
                  (function (_, I, R, B) {
                    let z = _;
                    do
                      0 === z.z && (z.z = cw(z.x, z.y, I, R, B)),
                        (z.prevZ = z.prev),
                        (z.nextZ = z.next),
                        (z = z.next);
                    while (z !== _);
                    (z.prevZ.nextZ = null),
                      (z.prevZ = null),
                      (function (_) {
                        let I,
                          R,
                          B,
                          z,
                          k,
                          V,
                          j,
                          G,
                          q = 1;
                        do {
                          for (R = _, _ = null, k = null, V = 0; R; ) {
                            for (
                              V++, B = R, j = 0, I = 0;
                              I < q && (j++, (B = B.nextZ));
                              I++
                            );
                            for (G = q; j > 0 || (G > 0 && B); )
                              0 !== j && (0 === G || !B || R.z <= B.z)
                                ? ((z = R), (R = R.nextZ), j--)
                                : ((z = B), (B = B.nextZ), G--),
                                k ? (k.nextZ = z) : (_ = z),
                                (z.prevZ = k),
                                (k = z);
                            R = B;
                          }
                          (k.nextZ = null), (q *= 2);
                        } while (V > 1);
                      })(z);
                  })(_, B, z, k);
                let j = _,
                  G,
                  q;
                for (; _.prev !== _.next; ) {
                  if (
                    ((G = _.prev),
                    (q = _.next),
                    k
                      ? (function (_, I, R, B) {
                          let z = _.prev,
                            k = _.next;
                          if (jr(z, _, k) >= 0) return !1;
                          let V = z.x,
                            j = _.x,
                            G = k.x,
                            q = z.y,
                            X = _.y,
                            Q = k.y,
                            $ = V < j ? (V < G ? V : G) : j < G ? j : G,
                            et = q < X ? (q < Q ? q : Q) : X < Q ? X : Q,
                            er = V > j ? (V > G ? V : G) : j > G ? j : G,
                            es = q > X ? (q > Q ? q : Q) : X > Q ? X : Q,
                            ea = cw($, et, I, R, B),
                            en = cw(er, es, I, R, B),
                            eo = _.prevZ,
                            el = _.nextZ;
                          for (; eo && eo.z >= ea && el && el.z <= en; ) {
                            if (
                              (eo.x >= $ &&
                                eo.x <= er &&
                                eo.y >= et &&
                                eo.y <= es &&
                                eo !== z &&
                                eo !== k &&
                                zu(V, q, j, X, G, Q, eo.x, eo.y) &&
                                jr(eo.prev, eo, eo.next) >= 0) ||
                              ((eo = eo.prevZ),
                              el.x >= $ &&
                                el.x <= er &&
                                el.y >= et &&
                                el.y <= es &&
                                el !== z &&
                                el !== k &&
                                zu(V, q, j, X, G, Q, el.x, el.y) &&
                                jr(el.prev, el, el.next) >= 0)
                            )
                              return !1;
                            el = el.nextZ;
                          }
                          for (; eo && eo.z >= ea; ) {
                            if (
                              eo.x >= $ &&
                              eo.x <= er &&
                              eo.y >= et &&
                              eo.y <= es &&
                              eo !== z &&
                              eo !== k &&
                              zu(V, q, j, X, G, Q, eo.x, eo.y) &&
                              jr(eo.prev, eo, eo.next) >= 0
                            )
                              return !1;
                            eo = eo.prevZ;
                          }
                          for (; el && el.z <= en; ) {
                            if (
                              el.x >= $ &&
                              el.x <= er &&
                              el.y >= et &&
                              el.y <= es &&
                              el !== z &&
                              el !== k &&
                              zu(V, q, j, X, G, Q, el.x, el.y) &&
                              jr(el.prev, el, el.next) >= 0
                            )
                              return !1;
                            el = el.nextZ;
                          }
                          return !0;
                        })(_, B, z, k)
                      : (function (_) {
                          let I = _.prev,
                            R = _.next;
                          if (jr(I, _, R) >= 0) return !1;
                          let B = I.x,
                            z = _.x,
                            k = R.x,
                            V = I.y,
                            j = _.y,
                            G = R.y,
                            q = B < z ? (B < k ? B : k) : z < k ? z : k,
                            X = V < j ? (V < G ? V : G) : j < G ? j : G,
                            Q = B > z ? (B > k ? B : k) : z > k ? z : k,
                            $ = V > j ? (V > G ? V : G) : j > G ? j : G,
                            et = R.next;
                          for (; et !== I; ) {
                            if (
                              et.x >= q &&
                              et.x <= Q &&
                              et.y >= X &&
                              et.y <= $ &&
                              zu(B, V, z, j, k, G, et.x, et.y) &&
                              jr(et.prev, et, et.next) >= 0
                            )
                              return !1;
                            et = et.next;
                          }
                          return !0;
                        })(_))
                  ) {
                    I.push((G.i / R) | 0),
                      I.push((_.i / R) | 0),
                      I.push((q.i / R) | 0),
                      Rp(_),
                      (_ = q.next),
                      (j = q.next);
                    continue;
                  }
                  if ((_ = q) === j) {
                    V
                      ? 1 === V
                        ? Op(
                            (_ = (function (_, I, R) {
                              let B = _;
                              do {
                                let z = B.prev,
                                  k = B.next.next;
                                !jy(z, k) &&
                                  rC(z, B, B.next, k) &&
                                  Ip(z, k) &&
                                  Ip(k, z) &&
                                  (I.push((z.i / R) | 0),
                                  I.push((B.i / R) | 0),
                                  I.push((k.i / R) | 0),
                                  Rp(B),
                                  Rp(B.next),
                                  (B = _ = k)),
                                  (B = B.next);
                              } while (B !== _);
                              return Dc(B);
                            })(Dc(_), I, R)),
                            I,
                            R,
                            B,
                            z,
                            k,
                            2
                          )
                        : 2 === V &&
                          (function (_, I, R, B, z, k) {
                            let V = _;
                            do {
                              let _ = V.next.next;
                              for (; _ !== V.prev; ) {
                                var j, G;
                                if (
                                  V.i !== _.i &&
                                  ((j = V),
                                  (G = _),
                                  j.next.i !== G.i &&
                                    j.prev.i !== G.i &&
                                    !(function (_, I) {
                                      let R = _;
                                      do {
                                        if (
                                          R.i !== _.i &&
                                          R.next.i !== _.i &&
                                          R.i !== I.i &&
                                          R.next.i !== I.i &&
                                          rC(R, R.next, _, I)
                                        )
                                          return !0;
                                        R = R.next;
                                      } while (R !== _);
                                      return !1;
                                    })(j, G) &&
                                    ((Ip(j, G) &&
                                      Ip(G, j) &&
                                      (function (_, I) {
                                        let R = _,
                                          B = !1,
                                          z = (_.x + I.x) / 2,
                                          k = (_.y + I.y) / 2;
                                        do
                                          R.y > k != R.next.y > k &&
                                            R.next.y !== R.y &&
                                            z <
                                              ((R.next.x - R.x) * (k - R.y)) /
                                                (R.next.y - R.y) +
                                                R.x &&
                                            (B = !B),
                                            (R = R.next);
                                        while (R !== _);
                                        return B;
                                      })(j, G) &&
                                      (jr(j.prev, j, G.prev) ||
                                        jr(j, G.prev, G))) ||
                                      (jy(j, G) &&
                                        jr(j.prev, j, j.next) > 0 &&
                                        jr(G.prev, G, G.next) > 0)))
                                ) {
                                  let j = iC(V, _);
                                  (V = Dc(V, V.next)),
                                    (j = Dc(j, j.next)),
                                    Op(V, I, R, B, z, k, 0),
                                    Op(j, I, R, B, z, k, 0);
                                  return;
                                }
                                _ = _.next;
                              }
                              V = V.next;
                            } while (V !== _);
                          })(_, I, R, B, z, k)
                      : Op(Dc(_), I, R, B, z, k, 1);
                    break;
                  }
                }
              })($, et, R, B, z, q, 0),
              et
            );
          },
        };
      function tC(_, I, R, B, z) {
        let k, V;
        if (
          z ===
          (function (_, I, R, B) {
            let z = 0;
            for (let k = I, V = R - B; k < R; k += B)
              (z += (_[V] - _[k]) * (_[k + 1] + _[V + 1])), (V = k);
            return z;
          })(_, I, R, B) >
            0
        )
          for (k = I; k < R; k += B) V = TM(k, _[k], _[k + 1], V);
        else for (k = R - B; k >= I; k -= B) V = TM(k, _[k], _[k + 1], V);
        return V && jy(V, V.next) && (Rp(V), (V = V.next)), V;
      }
      function Dc(_, I) {
        if (!_) return _;
        I || (I = _);
        let R = _,
          B;
        do
          if (
            ((B = !1),
            !R.steiner && (jy(R, R.next) || 0 === jr(R.prev, R, R.next)))
          ) {
            if ((Rp(R), (R = I = R.prev) === R.next)) break;
            B = !0;
          } else R = R.next;
        while (B || R !== I);
        return I;
      }
      function f4(_, I) {
        return _.x - I.x;
      }
      function cw(_, I, R, B, z) {
        return (
          (_ =
            ((_ =
              ((_ =
                ((_ = ((_ = ((_ - R) * z) | 0) | (_ << 8)) & 16711935) |
                  (_ << 4)) &
                252645135) |
                (_ << 2)) &
              858993459) |
              (_ << 1)) &
            1431655765) |
          ((I =
            ((I =
              ((I =
                ((I = ((I = ((I - B) * z) | 0) | (I << 8)) & 16711935) |
                  (I << 4)) &
                252645135) |
                (I << 2)) &
              858993459) |
              (I << 1)) &
            1431655765) <<
            1)
        );
      }
      function zu(_, I, R, B, z, k, V, j) {
        return (
          (z - V) * (I - j) >= (_ - V) * (k - j) &&
          (_ - V) * (B - j) >= (R - V) * (I - j) &&
          (R - V) * (k - j) >= (z - V) * (B - j)
        );
      }
      function jr(_, I, R) {
        return (I.y - _.y) * (R.x - I.x) - (I.x - _.x) * (R.y - I.y);
      }
      function jy(_, I) {
        return _.x === I.x && _.y === I.y;
      }
      function rC(_, I, R, B) {
        let z = oy(jr(_, I, R)),
          k = oy(jr(_, I, B)),
          V = oy(jr(R, B, _)),
          j = oy(jr(R, B, I));
        return !!(
          (z !== k && V !== j) ||
          (0 === z && sy(_, R, I)) ||
          (0 === k && sy(_, B, I)) ||
          (0 === V && sy(R, _, B)) ||
          (0 === j && sy(R, I, B))
        );
      }
      function sy(_, I, R) {
        return (
          I.x <= Math.max(_.x, R.x) &&
          I.x >= Math.min(_.x, R.x) &&
          I.y <= Math.max(_.y, R.y) &&
          I.y >= Math.min(_.y, R.y)
        );
      }
      function oy(_) {
        return _ > 0 ? 1 : _ < 0 ? -1 : 0;
      }
      function Ip(_, I) {
        return 0 > jr(_.prev, _, _.next)
          ? jr(_, I, _.next) >= 0 && jr(_, _.prev, I) >= 0
          : 0 > jr(_, I, _.prev) || 0 > jr(_, _.next, I);
      }
      function iC(_, I) {
        let R = new uw(_.i, _.x, _.y),
          B = new uw(I.i, I.x, I.y),
          z = _.next,
          k = I.prev;
        return (
          (_.next = I),
          (I.prev = _),
          (R.next = z),
          (z.prev = R),
          (B.next = R),
          (R.prev = B),
          (k.next = B),
          (B.prev = k),
          B
        );
      }
      function TM(_, I, R, B) {
        let z = new uw(_, I, R);
        return (
          B
            ? ((z.next = B.next), (z.prev = B), (B.next.prev = z), (B.next = z))
            : ((z.prev = z), (z.next = z)),
          z
        );
      }
      function Rp(_) {
        (_.next.prev = _.prev),
          (_.prev.next = _.next),
          _.prevZ && (_.prevZ.nextZ = _.nextZ),
          _.nextZ && (_.nextZ.prevZ = _.prevZ);
      }
      function uw(_, I, R) {
        (this.i = _),
          (this.x = I),
          (this.y = R),
          (this.prev = null),
          (this.next = null),
          (this.z = 0),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1);
      }
      var oz = class {
        static area(_) {
          let I = _.length,
            R = 0;
          for (let B = I - 1, z = 0; z < I; B = z++)
            R += _[B].x * _[z].y - _[z].x * _[B].y;
          return 0.5 * R;
        }
        static isClockWise(_) {
          return 0 > oz.area(_);
        }
        static triangulateShape(_, I) {
          let R = [],
            B = [],
            z = [];
          MM(_), CM(R, _);
          let k = _.length;
          I.forEach(MM);
          for (let _ = 0; _ < I.length; _++)
            B.push(k), (k += I[_].length), CM(R, I[_]);
          let V = oL.triangulate(R, B);
          for (let _ = 0; _ < V.length; _ += 3) z.push(V.slice(_, _ + 3));
          return z;
        }
      };
      function MM(_) {
        let I = _.length;
        I > 2 && _[I - 1].equals(_[0]) && _.pop();
      }
      function CM(_, I) {
        for (let R = 0; R < I.length; R++) _.push(I[R].x), _.push(I[R].y);
      }
      var oF = class extends oP {
          constructor(_ = 1, I = 0) {
            let R = (1 + Math.sqrt(5)) / 2;
            super(
              [
                -1,
                R,
                0,
                1,
                R,
                0,
                -1,
                -R,
                0,
                1,
                -R,
                0,
                0,
                -1,
                R,
                0,
                1,
                R,
                0,
                -1,
                -R,
                0,
                1,
                -R,
                R,
                0,
                -1,
                R,
                0,
                1,
                -R,
                0,
                -1,
                -R,
                0,
                1,
              ],
              [
                0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11,
                4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3,
                6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
              ],
              _,
              I
            ),
              (this.type = "IcosahedronGeometry"),
              (this.parameters = { radius: _, detail: I });
          }
          static fromJSON(_) {
            return new oF(_.radius, _.detail);
          }
        },
        oN = class extends ai {
          constructor(
            _ = 1,
            I = 32,
            R = 16,
            B = 0,
            z = 2 * Math.PI,
            k = 0,
            V = Math.PI
          ) {
            super(),
              (this.type = "SphereGeometry"),
              (this.parameters = {
                radius: _,
                widthSegments: I,
                heightSegments: R,
                phiStart: B,
                phiLength: z,
                thetaStart: k,
                thetaLength: V,
              }),
              (I = Math.max(3, Math.floor(I))),
              (R = Math.max(2, Math.floor(R)));
            let j = Math.min(k + V, Math.PI),
              G = 0,
              q = [],
              X = new rF(),
              Q = new rF(),
              $ = [],
              et = [],
              er = [],
              es = [];
            for (let $ = 0; $ <= R; $++) {
              let ea = [],
                en = $ / R,
                eo = 0;
              0 == $ && 0 == k
                ? (eo = 0.5 / I)
                : $ == R && j == Math.PI && (eo = -0.5 / I);
              for (let R = 0; R <= I; R++) {
                let j = R / I;
                (X.x = -_ * Math.cos(B + j * z) * Math.sin(k + en * V)),
                  (X.y = _ * Math.cos(k + en * V)),
                  (X.z = _ * Math.sin(B + j * z) * Math.sin(k + en * V)),
                  et.push(X.x, X.y, X.z),
                  Q.copy(X).normalize(),
                  er.push(Q.x, Q.y, Q.z),
                  es.push(j + eo, 1 - en),
                  ea.push(G++);
              }
              q.push(ea);
            }
            for (let _ = 0; _ < R; _++)
              for (let B = 0; B < I; B++) {
                let I = q[_][B + 1],
                  z = q[_][B],
                  V = q[_ + 1][B],
                  G = q[_ + 1][B + 1];
                (0 !== _ || k > 0) && $.push(I, z, G),
                  (_ !== R - 1 || j < Math.PI) && $.push(z, V, G);
              }
            this.setIndex($),
              this.setAttribute("position", new s4(et, 3)),
              this.setAttribute("normal", new s4(er, 3)),
              this.setAttribute("uv", new s4(es, 2));
          }
          static fromJSON(_) {
            return new oN(
              _.radius,
              _.widthSegments,
              _.heightSegments,
              _.phiStart,
              _.phiLength,
              _.thetaStart,
              _.thetaLength
            );
          }
        },
        ok = class extends ai {
          constructor(_ = 1, I = 0.4, R = 12, B = 48, z = 2 * Math.PI) {
            super(),
              (this.type = "TorusGeometry"),
              (this.parameters = {
                radius: _,
                tube: I,
                radialSegments: R,
                tubularSegments: B,
                arc: z,
              }),
              (R = Math.floor(R)),
              (B = Math.floor(B));
            let k = [],
              V = [],
              j = [],
              G = [],
              q = new rF(),
              X = new rF(),
              Q = new rF();
            for (let k = 0; k <= R; k++)
              for (let $ = 0; $ <= B; $++) {
                let et = ($ / B) * z,
                  er = (k / R) * Math.PI * 2;
                (X.x = (_ + I * Math.cos(er)) * Math.cos(et)),
                  (X.y = (_ + I * Math.cos(er)) * Math.sin(et)),
                  (X.z = I * Math.sin(er)),
                  V.push(X.x, X.y, X.z),
                  (q.x = _ * Math.cos(et)),
                  (q.y = _ * Math.sin(et)),
                  Q.subVectors(X, q).normalize(),
                  j.push(Q.x, Q.y, Q.z),
                  G.push($ / B),
                  G.push(k / R);
              }
            for (let _ = 1; _ <= R; _++)
              for (let I = 1; I <= B; I++) {
                let R = (B + 1) * _ + I - 1,
                  z = (B + 1) * (_ - 1) + I - 1,
                  V = (B + 1) * (_ - 1) + I,
                  j = (B + 1) * _ + I;
                k.push(R, z, j), k.push(z, V, j);
              }
            this.setIndex(k),
              this.setAttribute("position", new s4(V, 3)),
              this.setAttribute("normal", new s4(j, 3)),
              this.setAttribute("uv", new s4(G, 2));
          }
          static fromJSON(_) {
            return new ok(
              _.radius,
              _.tube,
              _.radialSegments,
              _.tubularSegments,
              _.arc
            );
          }
        },
        oU = class extends ai {
          constructor(_ = 1, I = 0.4, R = 64, B = 8, z = 2, k = 3) {
            super(),
              (this.type = "TorusKnotGeometry"),
              (this.parameters = {
                radius: _,
                tube: I,
                tubularSegments: R,
                radialSegments: B,
                p: z,
                q: k,
              }),
              (R = Math.floor(R)),
              (B = Math.floor(B));
            let V = [],
              j = [],
              G = [],
              q = [],
              X = new rF(),
              Q = new rF(),
              $ = new rF(),
              et = new rF(),
              er = new rF(),
              es = new rF(),
              ea = new rF();
            for (let V = 0; V <= R; ++V) {
              let en = (V / R) * z * Math.PI * 2;
              v(en, z, k, _, $),
                v(en + 0.01, z, k, _, et),
                es.subVectors(et, $),
                ea.addVectors(et, $),
                er.crossVectors(es, ea),
                ea.crossVectors(er, es),
                er.normalize(),
                ea.normalize();
              for (let _ = 0; _ <= B; ++_) {
                let z = (_ / B) * Math.PI * 2,
                  k = -I * Math.cos(z),
                  et = I * Math.sin(z);
                (X.x = $.x + (k * ea.x + et * er.x)),
                  (X.y = $.y + (k * ea.y + et * er.y)),
                  (X.z = $.z + (k * ea.z + et * er.z)),
                  j.push(X.x, X.y, X.z),
                  Q.subVectors(X, $).normalize(),
                  G.push(Q.x, Q.y, Q.z),
                  q.push(V / R),
                  q.push(_ / B);
              }
            }
            for (let _ = 1; _ <= R; _++)
              for (let I = 1; I <= B; I++) {
                let R = (B + 1) * (_ - 1) + (I - 1),
                  z = (B + 1) * _ + (I - 1),
                  k = (B + 1) * _ + I,
                  j = (B + 1) * (_ - 1) + I;
                V.push(R, z, j), V.push(z, k, j);
              }
            function v(_, I, R, B, z) {
              let k = Math.cos(_),
                V = Math.sin(_),
                j = (R / I) * _,
                G = Math.cos(j);
              (z.x = B * (2 + G) * 0.5 * k),
                (z.y = B * (2 + G) * V * 0.5),
                (z.z = B * Math.sin(j) * 0.5);
            }
            this.setIndex(V),
              this.setAttribute("position", new s4(j, 3)),
              this.setAttribute("normal", new s4(G, 3)),
              this.setAttribute("uv", new s4(q, 2));
          }
          static fromJSON(_) {
            return new oU(
              _.radius,
              _.tube,
              _.tubularSegments,
              _.radialSegments,
              _.p,
              _.q
            );
          }
        };
      function nl(_, I, R) {
        return nC(_)
          ? new _.constructor(_.subarray(I, void 0 !== R ? R : _.length))
          : _.slice(I, R);
      }
      function ay(_, I, R) {
        return _ && (R || _.constructor !== I)
          ? "number" == typeof I.BYTES_PER_ELEMENT
            ? new I(_)
            : Array.prototype.slice.call(_)
          : _;
      }
      function nC(_) {
        return ArrayBuffer.isView(_) && !(_ instanceof DataView);
      }
      function PM(_, I, R) {
        let B = _.length,
          z = new _.constructor(B);
        for (let k = 0, V = 0; V !== B; ++k) {
          let B = R[k] * I;
          for (let R = 0; R !== I; ++R) z[V++] = _[B + R];
        }
        return z;
      }
      function sC(_, I, R, B) {
        let z = 1,
          k = _[0];
        for (; void 0 !== k && void 0 === k[B]; ) k = _[z++];
        if (void 0 === k) return;
        let V = k[B];
        if (void 0 !== V) {
          if (Array.isArray(V))
            do
              void 0 !== (V = k[B]) && (I.push(k.time), R.push.apply(R, V)),
                (k = _[z++]);
            while (void 0 !== k);
          else if (void 0 !== V.toArray)
            do
              void 0 !== (V = k[B]) && (I.push(k.time), V.toArray(R, R.length)),
                (k = _[z++]);
            while (void 0 !== k);
          else
            do
              void 0 !== (V = k[B]) && (I.push(k.time), R.push(V)),
                (k = _[z++]);
            while (void 0 !== k);
        }
      }
      var oV = class {
          constructor(_, I, R, B) {
            (this.parameterPositions = _),
              (this._cachedIndex = 0),
              (this.resultBuffer = void 0 !== B ? B : new I.constructor(R)),
              (this.sampleValues = I),
              (this.valueSize = R),
              (this.settings = null),
              (this.DefaultSettings_ = {});
          }
          evaluate(_) {
            let I = this.parameterPositions,
              R = this._cachedIndex,
              B = I[R],
              z = I[R - 1];
            e: {
              t: {
                let k;
                i: {
                  r: if (!(_ < B)) {
                    for (let k = R + 2; ; ) {
                      if (void 0 === B) {
                        if (_ < z) break r;
                        return (
                          (R = I.length),
                          (this._cachedIndex = R),
                          this.copySampleValue_(R - 1)
                        );
                      }
                      if (R === k) break;
                      if (((z = B), _ < (B = I[++R]))) break t;
                    }
                    k = I.length;
                    break i;
                  }
                  if (!(_ >= z)) {
                    let V = I[1];
                    _ < V && ((R = 2), (z = V));
                    for (let k = R - 2; ; ) {
                      if (void 0 === z)
                        return (
                          (this._cachedIndex = 0), this.copySampleValue_(0)
                        );
                      if (R === k) break;
                      if (((B = z), _ >= (z = I[--R - 1]))) break t;
                    }
                    (k = R), (R = 0);
                    break i;
                  }
                  break e;
                }
                for (; R < k; ) {
                  let B = (R + k) >>> 1;
                  _ < I[B] ? (k = B) : (R = B + 1);
                }
                if (((B = I[R]), void 0 === (z = I[R - 1])))
                  return (this._cachedIndex = 0), this.copySampleValue_(0);
                if (void 0 === B)
                  return (
                    (R = I.length),
                    (this._cachedIndex = R),
                    this.copySampleValue_(R - 1)
                  );
              }
              (this._cachedIndex = R), this.intervalChanged_(R, z, B);
            }
            return this.interpolate_(R, z, _, B);
          }
          getSettings_() {
            return this.settings || this.DefaultSettings_;
          }
          copySampleValue_(_) {
            let I = this.resultBuffer,
              R = this.sampleValues,
              B = this.valueSize,
              z = _ * B;
            for (let _ = 0; _ !== B; ++_) I[_] = R[z + _];
            return I;
          }
          interpolate_() {
            throw Error("call to abstract method");
          }
          intervalChanged_() {}
        },
        oj = class extends oV {
          constructor(_, I, R, B) {
            super(_, I, R, B),
              (this._weightPrev = -0),
              (this._offsetPrev = -0),
              (this._weightNext = -0),
              (this._offsetNext = -0),
              (this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 });
          }
          intervalChanged_(_, I, R) {
            let B = this.parameterPositions,
              z = _ - 2,
              k = _ + 1,
              V = B[z],
              j = B[k];
            if (void 0 === V)
              switch (this.getSettings_().endingStart) {
                case 2401:
                  (z = _), (V = 2 * I - R);
                  break;
                case 2402:
                  (z = B.length - 2), (V = I + B[z] - B[z + 1]);
                  break;
                default:
                  (z = _), (V = R);
              }
            if (void 0 === j)
              switch (this.getSettings_().endingEnd) {
                case 2401:
                  (k = _), (j = 2 * R - I);
                  break;
                case 2402:
                  (k = 1), (j = R + B[1] - B[0]);
                  break;
                default:
                  (k = _ - 1), (j = I);
              }
            let G = (R - I) * 0.5,
              q = this.valueSize;
            (this._weightPrev = G / (I - V)),
              (this._weightNext = G / (j - R)),
              (this._offsetPrev = z * q),
              (this._offsetNext = k * q);
          }
          interpolate_(_, I, R, B) {
            let z = this.resultBuffer,
              k = this.sampleValues,
              V = this.valueSize,
              j = _ * V,
              G = j - V,
              q = this._offsetPrev,
              X = this._offsetNext,
              Q = this._weightPrev,
              $ = this._weightNext,
              et = (R - I) / (B - I),
              er = et * et,
              es = er * et,
              ea = -Q * es + 2 * Q * er - Q * et,
              en = (1 + Q) * es + (-1.5 - 2 * Q) * er + (-0.5 + Q) * et + 1,
              eo = (-1 - $) * es + (1.5 + $) * er + 0.5 * et,
              el = $ * es - $ * er;
            for (let _ = 0; _ !== V; ++_)
              z[_] =
                ea * k[q + _] + en * k[G + _] + eo * k[j + _] + el * k[X + _];
            return z;
          }
        },
        oH = class extends oV {
          constructor(_, I, R, B) {
            super(_, I, R, B);
          }
          interpolate_(_, I, R, B) {
            let z = this.resultBuffer,
              k = this.sampleValues,
              V = this.valueSize,
              j = _ * V,
              G = j - V,
              q = (R - I) / (B - I),
              X = 1 - q;
            for (let _ = 0; _ !== V; ++_) z[_] = k[G + _] * X + k[j + _] * q;
            return z;
          }
        },
        oW = class extends oV {
          constructor(_, I, R, B) {
            super(_, I, R, B);
          }
          interpolate_(_) {
            return this.copySampleValue_(_ - 1);
          }
        },
        oq = class {
          constructor(_, I, R, B) {
            if (void 0 === _)
              throw Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === I || 0 === I.length)
              throw Error(
                "THREE.KeyframeTrack: no keyframes in track named " + _
              );
            (this.name = _),
              (this.times = ay(I, this.TimeBufferType)),
              (this.values = ay(R, this.ValueBufferType)),
              this.setInterpolation(B || this.DefaultInterpolation);
          }
          static toJSON(_) {
            let I = _.constructor,
              R;
            if (I.toJSON !== this.toJSON) R = I.toJSON(_);
            else {
              R = {
                name: _.name,
                times: ay(_.times, Array),
                values: ay(_.values, Array),
              };
              let I = _.getInterpolation();
              I !== _.DefaultInterpolation && (R.interpolation = I);
            }
            return (R.type = _.ValueTypeName), R;
          }
          InterpolantFactoryMethodDiscrete(_) {
            return new oW(this.times, this.values, this.getValueSize(), _);
          }
          InterpolantFactoryMethodLinear(_) {
            return new oH(this.times, this.values, this.getValueSize(), _);
          }
          InterpolantFactoryMethodSmooth(_) {
            return new oj(this.times, this.values, this.getValueSize(), _);
          }
          setInterpolation(_) {
            let I;
            switch (_) {
              case 2300:
                I = this.InterpolantFactoryMethodDiscrete;
                break;
              case 2301:
                I = this.InterpolantFactoryMethodLinear;
                break;
              case 2302:
                I = this.InterpolantFactoryMethodSmooth;
            }
            if (void 0 === I) {
              let I =
                "unsupported interpolation for " +
                this.ValueTypeName +
                " keyframe track named " +
                this.name;
              if (void 0 === this.createInterpolant) {
                if (_ !== this.DefaultInterpolation)
                  this.setInterpolation(this.DefaultInterpolation);
                else throw Error(I);
              }
              return console.warn("THREE.KeyframeTrack:", I), this;
            }
            return (this.createInterpolant = I), this;
          }
          getInterpolation() {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return 2300;
              case this.InterpolantFactoryMethodLinear:
                return 2301;
              case this.InterpolantFactoryMethodSmooth:
                return 2302;
            }
          }
          getValueSize() {
            return this.values.length / this.times.length;
          }
          shift(_) {
            if (0 !== _) {
              let I = this.times;
              for (let R = 0, B = I.length; R !== B; ++R) I[R] += _;
            }
            return this;
          }
          scale(_) {
            if (1 !== _) {
              let I = this.times;
              for (let R = 0, B = I.length; R !== B; ++R) I[R] *= _;
            }
            return this;
          }
          trim(_, I) {
            let R = this.times,
              B = R.length,
              z = 0,
              k = B - 1;
            for (; z !== B && R[z] < _; ) ++z;
            for (; -1 !== k && R[k] > I; ) --k;
            if ((++k, 0 !== z || k !== B)) {
              z >= k && (z = (k = Math.max(k, 1)) - 1);
              let _ = this.getValueSize();
              (this.times = nl(R, z, k)),
                (this.values = nl(this.values, z * _, k * _));
            }
            return this;
          }
          validate() {
            let _ = !0,
              I = this.getValueSize();
            I - Math.floor(I) != 0 &&
              (console.error(
                "THREE.KeyframeTrack: Invalid value size in track.",
                this
              ),
              (_ = !1));
            let R = this.times,
              B = this.values,
              z = R.length;
            0 === z &&
              (console.error("THREE.KeyframeTrack: Track is empty.", this),
              (_ = !1));
            let k = null;
            for (let I = 0; I !== z; I++) {
              let B = R[I];
              if ("number" == typeof B && isNaN(B)) {
                console.error(
                  "THREE.KeyframeTrack: Time is not a valid number.",
                  this,
                  I,
                  B
                ),
                  (_ = !1);
                break;
              }
              if (null !== k && k > B) {
                console.error(
                  "THREE.KeyframeTrack: Out of order keys.",
                  this,
                  I,
                  B,
                  k
                ),
                  (_ = !1);
                break;
              }
              k = B;
            }
            if (void 0 !== B && nC(B))
              for (let I = 0, R = B.length; I !== R; ++I) {
                let R = B[I];
                if (isNaN(R)) {
                  console.error(
                    "THREE.KeyframeTrack: Value is not a valid number.",
                    this,
                    I,
                    R
                  ),
                    (_ = !1);
                  break;
                }
              }
            return _;
          }
          optimize() {
            let _ = nl(this.times),
              I = nl(this.values),
              R = this.getValueSize(),
              B = 2302 === this.getInterpolation(),
              z = _.length - 1,
              k = 1;
            for (let V = 1; V < z; ++V) {
              let z = !1,
                j = _[V];
              if (j !== _[V + 1] && (1 !== V || j !== _[0])) {
                if (B) z = !0;
                else {
                  let _ = V * R,
                    B = _ - R,
                    k = _ + R;
                  for (let V = 0; V !== R; ++V) {
                    let R = I[_ + V];
                    if (R !== I[B + V] || R !== I[k + V]) {
                      z = !0;
                      break;
                    }
                  }
                }
              }
              if (z) {
                if (V !== k) {
                  _[k] = _[V];
                  let B = V * R,
                    z = k * R;
                  for (let _ = 0; _ !== R; ++_) I[z + _] = I[B + _];
                }
                ++k;
              }
            }
            if (z > 0) {
              _[k] = _[z];
              for (let _ = z * R, B = k * R, V = 0; V !== R; ++V)
                I[B + V] = I[_ + V];
              ++k;
            }
            return (
              k !== _.length
                ? ((this.times = nl(_, 0, k)), (this.values = nl(I, 0, k * R)))
                : ((this.times = _), (this.values = I)),
              this
            );
          }
          clone() {
            let _ = nl(this.times, 0),
              I = nl(this.values, 0),
              R = new this.constructor(this.name, _, I);
            return (R.createInterpolant = this.createInterpolant), R;
          }
        };
      (oq.prototype.TimeBufferType = Float32Array),
        (oq.prototype.ValueBufferType = Float32Array),
        (oq.prototype.DefaultInterpolation = 2301);
      var oY = class extends oq {};
      (oY.prototype.ValueTypeName = "bool"),
        (oY.prototype.ValueBufferType = Array),
        (oY.prototype.DefaultInterpolation = 2300),
        (oY.prototype.InterpolantFactoryMethodLinear = void 0),
        (oY.prototype.InterpolantFactoryMethodSmooth = void 0);
      var oX = class extends oq {};
      oX.prototype.ValueTypeName = "color";
      var oQ = class extends oq {};
      oQ.prototype.ValueTypeName = "number";
      var oZ = class extends oV {
          constructor(_, I, R, B) {
            super(_, I, R, B);
          }
          interpolate_(_, I, R, B) {
            let z = this.resultBuffer,
              k = this.sampleValues,
              V = this.valueSize,
              j = (R - I) / (B - I),
              G = _ * V;
            for (let _ = G + V; G !== _; G += 4)
              rz.slerpFlat(z, 0, k, G - V, k, G, j);
            return z;
          }
        },
        oK = class extends oq {
          InterpolantFactoryMethodLinear(_) {
            return new oZ(this.times, this.values, this.getValueSize(), _);
          }
        };
      (oK.prototype.ValueTypeName = "quaternion"),
        (oK.prototype.DefaultInterpolation = 2301),
        (oK.prototype.InterpolantFactoryMethodSmooth = void 0);
      var oJ = class extends oq {};
      (oJ.prototype.ValueTypeName = "string"),
        (oJ.prototype.ValueBufferType = Array),
        (oJ.prototype.DefaultInterpolation = 2300),
        (oJ.prototype.InterpolantFactoryMethodLinear = void 0),
        (oJ.prototype.InterpolantFactoryMethodSmooth = void 0);
      var o$ = class extends oq {};
      o$.prototype.ValueTypeName = "vector";
      var o0 = class {
          constructor(_, I = -1, R, B = 2500) {
            (this.name = _),
              (this.tracks = R),
              (this.duration = I),
              (this.blendMode = B),
              (this.uuid = ms()),
              this.duration < 0 && this.resetDuration();
          }
          static parse(_) {
            let I = [],
              R = _.tracks,
              B = 1 / (_.fps || 1);
            for (let _ = 0, z = R.length; _ !== z; ++_)
              I.push(
                (function (_) {
                  if (void 0 === _.type)
                    throw Error(
                      "THREE.KeyframeTrack: track type undefined, can not parse"
                    );
                  let I = (function (_) {
                    switch (_.toLowerCase()) {
                      case "scalar":
                      case "double":
                      case "float":
                      case "number":
                      case "integer":
                        return oQ;
                      case "vector":
                      case "vector2":
                      case "vector3":
                      case "vector4":
                        return o$;
                      case "color":
                        return oX;
                      case "quaternion":
                        return oK;
                      case "bool":
                      case "boolean":
                        return oY;
                      case "string":
                        return oJ;
                    }
                    throw Error(
                      "THREE.KeyframeTrack: Unsupported typeName: " + _
                    );
                  })(_.type);
                  if (void 0 === _.times) {
                    let I = [],
                      R = [];
                    sC(_.keys, I, R, "value"), (_.times = I), (_.values = R);
                  }
                  return void 0 !== I.parse
                    ? I.parse(_)
                    : new I(_.name, _.times, _.values, _.interpolation);
                })(R[_]).scale(B)
              );
            let z = new this(_.name, _.duration, I, _.blendMode);
            return (z.uuid = _.uuid), z;
          }
          static toJSON(_) {
            let I = [],
              R = _.tracks,
              B = {
                name: _.name,
                duration: _.duration,
                tracks: I,
                uuid: _.uuid,
                blendMode: _.blendMode,
              };
            for (let _ = 0, B = R.length; _ !== B; ++_) I.push(oq.toJSON(R[_]));
            return B;
          }
          static CreateFromMorphTargetSequence(_, I, R, B) {
            let z = I.length,
              k = [];
            for (let _ = 0; _ < z; _++) {
              let V = [],
                j = [];
              V.push((_ + z - 1) % z, _, (_ + 1) % z), j.push(0, 1, 0);
              let G = (function (_) {
                let I = _.length,
                  R = Array(I);
                for (let _ = 0; _ !== I; ++_) R[_] = _;
                return (
                  R.sort(function (I, R) {
                    return _[I] - _[R];
                  }),
                  R
                );
              })(V);
              (V = PM(V, 1, G)),
                (j = PM(j, 1, G)),
                B || 0 !== V[0] || (V.push(z), j.push(j[0])),
                k.push(
                  new oQ(
                    ".morphTargetInfluences[" + I[_].name + "]",
                    V,
                    j
                  ).scale(1 / R)
                );
            }
            return new this(_, -1, k);
          }
          static findByName(_, I) {
            let R = _;
            Array.isArray(_) ||
              (R = (_.geometry && _.geometry.animations) || _.animations);
            for (let _ = 0; _ < R.length; _++) if (R[_].name === I) return R[_];
            return null;
          }
          static CreateClipsFromMorphTargetSequences(_, I, R) {
            let B = {},
              z = /^([\w-]*?)([\d]+)$/;
            for (let I = 0, R = _.length; I < R; I++) {
              let R = _[I],
                k = R.name.match(z);
              if (k && k.length > 1) {
                let _ = k[1],
                  I = B[_];
                I || (B[_] = I = []), I.push(R);
              }
            }
            let k = [];
            for (let _ in B)
              k.push(this.CreateFromMorphTargetSequence(_, B[_], I, R));
            return k;
          }
          static parseAnimation(_, I) {
            if (!_)
              return (
                console.error(
                  "THREE.AnimationClip: No animation in JSONLoader data."
                ),
                null
              );
            let r = function (_, I, R, B, z) {
                if (0 !== R.length) {
                  let k = [],
                    V = [];
                  sC(R, k, V, B), 0 !== k.length && z.push(new _(I, k, V));
                }
              },
              R = [],
              B = _.name || "default",
              z = _.fps || 30,
              k = _.blendMode,
              V = _.length || -1,
              j = _.hierarchy || [];
            for (let _ = 0; _ < j.length; _++) {
              let B = j[_].keys;
              if (!(!B || 0 === B.length)) {
                if (B[0].morphTargets) {
                  let _ = {},
                    I;
                  for (I = 0; I < B.length; I++)
                    if (B[I].morphTargets)
                      for (let R = 0; R < B[I].morphTargets.length; R++)
                        _[B[I].morphTargets[R]] = -1;
                  for (let z in _) {
                    let _ = [],
                      k = [];
                    for (let R = 0; R !== B[I].morphTargets.length; ++R) {
                      let R = B[I];
                      _.push(R.time), k.push(R.morphTarget === z ? 1 : 0);
                    }
                    R.push(new oQ(".morphTargetInfluence[" + z + "]", _, k));
                  }
                  V = _.length * z;
                } else {
                  let z = ".bones[" + I[_].name + "]";
                  r(o$, z + ".position", B, "pos", R),
                    r(oK, z + ".quaternion", B, "rot", R),
                    r(o$, z + ".scale", B, "scl", R);
                }
              }
            }
            return 0 === R.length ? null : new this(B, V, R, k);
          }
          resetDuration() {
            let _ = this.tracks,
              I = 0;
            for (let R = 0, B = _.length; R !== B; ++R) {
              let _ = this.tracks[R];
              I = Math.max(I, _.times[_.times.length - 1]);
            }
            return (this.duration = I), this;
          }
          trim() {
            for (let _ = 0; _ < this.tracks.length; _++)
              this.tracks[_].trim(0, this.duration);
            return this;
          }
          validate() {
            let _ = !0;
            for (let I = 0; I < this.tracks.length; I++)
              _ = _ && this.tracks[I].validate();
            return _;
          }
          optimize() {
            for (let _ = 0; _ < this.tracks.length; _++)
              this.tracks[_].optimize();
            return this;
          }
          clone() {
            let _ = [];
            for (let I = 0; I < this.tracks.length; I++)
              _.push(this.tracks[I].clone());
            return new this.constructor(
              this.name,
              this.duration,
              _,
              this.blendMode
            );
          }
          toJSON() {
            return this.constructor.toJSON(this);
          }
        },
        o1 = {
          enabled: !1,
          files: {},
          add: function (_, I) {
            !1 !== this.enabled && (this.files[_] = I);
          },
          get: function (_) {
            if (!1 !== this.enabled) return this.files[_];
          },
          remove: function (_) {
            delete this.files[_];
          },
          clear: function () {
            this.files = {};
          },
        },
        o2 = class {
          constructor(_, I, R) {
            let B = this,
              z = !1,
              k = 0,
              V = 0,
              j,
              G = [];
            (this.onStart = void 0),
              (this.onLoad = _),
              (this.onProgress = I),
              (this.onError = R),
              (this.itemStart = function (_) {
                V++,
                  !1 === z && void 0 !== B.onStart && B.onStart(_, k, V),
                  (z = !0);
              }),
              (this.itemEnd = function (_) {
                k++,
                  void 0 !== B.onProgress && B.onProgress(_, k, V),
                  k === V && ((z = !1), void 0 !== B.onLoad && B.onLoad());
              }),
              (this.itemError = function (_) {
                void 0 !== B.onError && B.onError(_);
              }),
              (this.resolveURL = function (_) {
                return j ? j(_) : _;
              }),
              (this.setURLModifier = function (_) {
                return (j = _), this;
              }),
              (this.addHandler = function (_, I) {
                return G.push(_, I), this;
              }),
              (this.removeHandler = function (_) {
                let I = G.indexOf(_);
                return -1 !== I && G.splice(I, 2), this;
              }),
              (this.getHandler = function (_) {
                for (let I = 0, R = G.length; I < R; I += 2) {
                  let R = G[I],
                    B = G[I + 1];
                  if ((R.global && (R.lastIndex = 0), R.test(_))) return B;
                }
                return null;
              });
          }
        },
        o3 = new o2(),
        o4 = class {
          constructor(_) {
            (this.manager = void 0 !== _ ? _ : o3),
              (this.crossOrigin = "anonymous"),
              (this.withCredentials = !1),
              (this.path = ""),
              (this.resourcePath = ""),
              (this.requestHeader = {});
          }
          load() {}
          loadAsync(_, I) {
            let R = this;
            return new Promise(function (B, z) {
              R.load(_, B, I, z);
            });
          }
          parse() {}
          setCrossOrigin(_) {
            return (this.crossOrigin = _), this;
          }
          setWithCredentials(_) {
            return (this.withCredentials = _), this;
          }
          setPath(_) {
            return (this.path = _), this;
          }
          setResourcePath(_) {
            return (this.resourcePath = _), this;
          }
          setRequestHeader(_) {
            return (this.requestHeader = _), this;
          }
        },
        o5 = {},
        o6 = class extends Error {
          constructor(_, I) {
            super(_), (this.response = I);
          }
        },
        o8 = class extends o4 {
          constructor(_) {
            super(_);
          }
          load(_, I, R, B) {
            void 0 === _ && (_ = ""),
              void 0 !== this.path && (_ = this.path + _),
              (_ = this.manager.resolveURL(_));
            let z = o1.get(_);
            if (void 0 !== z)
              return (
                this.manager.itemStart(_),
                setTimeout(() => {
                  I && I(z), this.manager.itemEnd(_);
                }, 0),
                z
              );
            if (void 0 !== o5[_]) {
              o5[_].push({ onLoad: I, onProgress: R, onError: B });
              return;
            }
            (o5[_] = []), o5[_].push({ onLoad: I, onProgress: R, onError: B });
            let k = new Request(_, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin",
              }),
              V = this.mimeType,
              j = this.responseType;
            fetch(k)
              .then((I) => {
                if (200 === I.status || 0 === I.status) {
                  if (
                    (0 === I.status &&
                      console.warn("THREE.FileLoader: HTTP Status 0 received."),
                    typeof ReadableStream > "u" ||
                      void 0 === I.body ||
                      void 0 === I.body.getReader)
                  )
                    return I;
                  let R = o5[_],
                    B = I.body.getReader(),
                    z =
                      I.headers.get("Content-Length") ||
                      I.headers.get("X-File-Size"),
                    k = z ? parseInt(z) : 0,
                    V = 0 !== k,
                    j = 0,
                    G = new ReadableStream({
                      start(_) {
                        (function v() {
                          B.read().then(({ done: I, value: B }) => {
                            if (I) _.close();
                            else {
                              j += B.byteLength;
                              let I = new ProgressEvent("progress", {
                                lengthComputable: V,
                                loaded: j,
                                total: k,
                              });
                              for (let _ = 0, B = R.length; _ < B; _++) {
                                let B = R[_];
                                B.onProgress && B.onProgress(I);
                              }
                              _.enqueue(B), v();
                            }
                          });
                        })();
                      },
                    });
                  return new Response(G);
                }
                throw new o6(
                  `fetch for "${I.url}" responded with ${I.status}: ${I.statusText}`,
                  I
                );
              })
              .then((_) => {
                switch (j) {
                  case "arraybuffer":
                    return _.arrayBuffer();
                  case "blob":
                    return _.blob();
                  case "document":
                    return _.text().then((_) =>
                      new DOMParser().parseFromString(_, V)
                    );
                  case "json":
                    return _.json();
                  default:
                    if (void 0 === V) return _.text();
                    {
                      let I = /charset="?([^;"\s]*)"?/i.exec(V),
                        R = I && I[1] ? I[1].toLowerCase() : void 0,
                        B = new TextDecoder(R);
                      return _.arrayBuffer().then((_) => B.decode(_));
                    }
                }
              })
              .then((I) => {
                o1.add(_, I);
                let R = o5[_];
                delete o5[_];
                for (let _ = 0, B = R.length; _ < B; _++) {
                  let B = R[_];
                  B.onLoad && B.onLoad(I);
                }
              })
              .catch((I) => {
                let R = o5[_];
                if (void 0 === R) throw (this.manager.itemError(_), I);
                delete o5[_];
                for (let _ = 0, B = R.length; _ < B; _++) {
                  let B = R[_];
                  B.onError && B.onError(I);
                }
                this.manager.itemError(_);
              })
              .finally(() => {
                this.manager.itemEnd(_);
              }),
              this.manager.itemStart(_);
          }
          setResponseType(_) {
            return (this.responseType = _), this;
          }
          setMimeType(_) {
            return (this.mimeType = _), this;
          }
        },
        o9 = class extends o4 {
          constructor(_) {
            super(_);
          }
          load(_, I, R, B) {
            void 0 !== this.path && (_ = this.path + _),
              (_ = this.manager.resolveURL(_));
            let z = this,
              k = o1.get(_);
            if (void 0 !== k)
              return (
                z.manager.itemStart(_),
                setTimeout(function () {
                  I && I(k), z.manager.itemEnd(_);
                }, 0),
                k
              );
            let V = _p("img");
            function l() {
              c(), o1.add(_, this), I && I(this), z.manager.itemEnd(_);
            }
            function u(I) {
              c(), B && B(I), z.manager.itemError(_), z.manager.itemEnd(_);
            }
            function c() {
              V.removeEventListener("load", l, !1),
                V.removeEventListener("error", u, !1);
            }
            return (
              V.addEventListener("load", l, !1),
              V.addEventListener("error", u, !1),
              "data:" !== _.slice(0, 5) &&
                void 0 !== this.crossOrigin &&
                (V.crossOrigin = this.crossOrigin),
              z.manager.itemStart(_),
              (V.src = _),
              V
            );
          }
        },
        o7 = class extends o4 {
          constructor(_) {
            super(_);
          }
          load(_, I, R, B) {
            let z = new rA(),
              k = new o9(this.manager);
            return (
              k.setCrossOrigin(this.crossOrigin),
              k.setPath(this.path),
              k.load(
                _,
                function (_) {
                  (z.image = _), (z.needsUpdate = !0), void 0 !== I && I(z);
                },
                R,
                B
              ),
              z
            );
          }
        },
        le = class extends sL {
          constructor(_, I = 1) {
            super(),
              (this.isLight = !0),
              (this.type = "Light"),
              (this.color = new ry(_)),
              (this.intensity = I);
          }
          dispose() {}
          copy(_, I) {
            return (
              super.copy(_, I),
              this.color.copy(_.color),
              (this.intensity = _.intensity),
              this
            );
          }
          toJSON(_) {
            let I = super.toJSON(_);
            return (
              (I.object.color = this.color.getHex()),
              (I.object.intensity = this.intensity),
              void 0 !== this.groundColor &&
                (I.object.groundColor = this.groundColor.getHex()),
              void 0 !== this.distance && (I.object.distance = this.distance),
              void 0 !== this.angle && (I.object.angle = this.angle),
              void 0 !== this.decay && (I.object.decay = this.decay),
              void 0 !== this.penumbra && (I.object.penumbra = this.penumbra),
              void 0 !== this.shadow &&
                (I.object.shadow = this.shadow.toJSON()),
              I
            );
          }
        },
        lt = class extends le {
          constructor(_, I, R) {
            super(_, R),
              (this.isHemisphereLight = !0),
              (this.type = "HemisphereLight"),
              this.position.copy(sL.DEFAULT_UP),
              this.updateMatrix(),
              (this.groundColor = new ry(I));
          }
          copy(_, I) {
            return super.copy(_, I), this.groundColor.copy(_.groundColor), this;
          }
        },
        li = new sa(),
        lr = new rF(),
        ls = new rF(),
        ln = class {
          constructor(_) {
            (this.camera = _),
              (this.bias = 0),
              (this.normalBias = 0),
              (this.radius = 1),
              (this.blurSamples = 8),
              (this.mapSize = new rs(512, 512)),
              (this.map = null),
              (this.mapPass = null),
              (this.matrix = new sa()),
              (this.autoUpdate = !0),
              (this.needsUpdate = !1),
              (this._frustum = new aW()),
              (this._frameExtents = new rs(1, 1)),
              (this._viewportCount = 1),
              (this._viewports = [new rM(0, 0, 1, 1)]);
          }
          getViewportCount() {
            return this._viewportCount;
          }
          getFrustum() {
            return this._frustum;
          }
          updateMatrices(_) {
            let I = this.camera,
              R = this.matrix;
            lr.setFromMatrixPosition(_.matrixWorld),
              I.position.copy(lr),
              ls.setFromMatrixPosition(_.target.matrixWorld),
              I.lookAt(ls),
              I.updateMatrixWorld(),
              li.multiplyMatrices(I.projectionMatrix, I.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(li),
              R.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
              R.multiply(li);
          }
          getViewport(_) {
            return this._viewports[_];
          }
          getFrameExtents() {
            return this._frameExtents;
          }
          dispose() {
            this.map && this.map.dispose(),
              this.mapPass && this.mapPass.dispose();
          }
          copy(_) {
            return (
              (this.camera = _.camera.clone()),
              (this.bias = _.bias),
              (this.radius = _.radius),
              this.mapSize.copy(_.mapSize),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          toJSON() {
            let _ = {};
            return (
              0 !== this.bias && (_.bias = this.bias),
              0 !== this.normalBias && (_.normalBias = this.normalBias),
              1 !== this.radius && (_.radius = this.radius),
              (512 !== this.mapSize.x || 512 !== this.mapSize.y) &&
                (_.mapSize = this.mapSize.toArray()),
              (_.camera = this.camera.toJSON(!1).object),
              delete _.camera.matrix,
              _
            );
          }
        },
        lo = class extends ln {
          constructor() {
            super(new aI(50, 1, 0.5, 500)),
              (this.isSpotLightShadow = !0),
              (this.focus = 1);
          }
          updateMatrices(_) {
            let I = this.camera,
              R = 2 * ri * _.angle * this.focus,
              B = this.mapSize.width / this.mapSize.height,
              z = _.distance || I.far;
            (R !== I.fov || B !== I.aspect || z !== I.far) &&
              ((I.fov = R),
              (I.aspect = B),
              (I.far = z),
              I.updateProjectionMatrix()),
              super.updateMatrices(_);
          }
          copy(_) {
            return super.copy(_), (this.focus = _.focus), this;
          }
        },
        ll = class extends le {
          constructor(_, I, R = 0, B = Math.PI / 3, z = 0, k = 2) {
            super(_, I),
              (this.isSpotLight = !0),
              (this.type = "SpotLight"),
              this.position.copy(sL.DEFAULT_UP),
              this.updateMatrix(),
              (this.target = new sL()),
              (this.distance = R),
              (this.angle = B),
              (this.penumbra = z),
              (this.decay = k),
              (this.map = null),
              (this.shadow = new lo());
          }
          get power() {
            return this.intensity * Math.PI;
          }
          set power(_) {
            this.intensity = _ / Math.PI;
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(_, I) {
            return (
              super.copy(_, I),
              (this.distance = _.distance),
              (this.angle = _.angle),
              (this.penumbra = _.penumbra),
              (this.decay = _.decay),
              (this.target = _.target.clone()),
              (this.shadow = _.shadow.clone()),
              this
            );
          }
        },
        lh = new sa(),
        lc = new rF(),
        ld = new rF(),
        lu = class extends ln {
          constructor() {
            super(new aI(90, 1, 0.5, 500)),
              (this.isPointLightShadow = !0),
              (this._frameExtents = new rs(4, 2)),
              (this._viewportCount = 6),
              (this._viewports = [
                new rM(2, 1, 1, 1),
                new rM(0, 1, 1, 1),
                new rM(3, 1, 1, 1),
                new rM(1, 1, 1, 1),
                new rM(3, 0, 1, 1),
                new rM(1, 0, 1, 1),
              ]),
              (this._cubeDirections = [
                new rF(1, 0, 0),
                new rF(-1, 0, 0),
                new rF(0, 0, 1),
                new rF(0, 0, -1),
                new rF(0, 1, 0),
                new rF(0, -1, 0),
              ]),
              (this._cubeUps = [
                new rF(0, 1, 0),
                new rF(0, 1, 0),
                new rF(0, 1, 0),
                new rF(0, 1, 0),
                new rF(0, 0, 1),
                new rF(0, 0, -1),
              ]);
          }
          updateMatrices(_, I = 0) {
            let R = this.camera,
              B = this.matrix,
              z = _.distance || R.far;
            z !== R.far && ((R.far = z), R.updateProjectionMatrix()),
              lc.setFromMatrixPosition(_.matrixWorld),
              R.position.copy(lc),
              ld.copy(R.position),
              ld.add(this._cubeDirections[I]),
              R.up.copy(this._cubeUps[I]),
              R.lookAt(ld),
              R.updateMatrixWorld(),
              B.makeTranslation(-lc.x, -lc.y, -lc.z),
              lh.multiplyMatrices(R.projectionMatrix, R.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(lh);
          }
        },
        lp = class extends le {
          constructor(_, I, R = 0, B = 2) {
            super(_, I),
              (this.isPointLight = !0),
              (this.type = "PointLight"),
              (this.distance = R),
              (this.decay = B),
              (this.shadow = new lu());
          }
          get power() {
            return 4 * this.intensity * Math.PI;
          }
          set power(_) {
            this.intensity = _ / (4 * Math.PI);
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(_, I) {
            return (
              super.copy(_, I),
              (this.distance = _.distance),
              (this.decay = _.decay),
              (this.shadow = _.shadow.clone()),
              this
            );
          }
        },
        lf = class extends ln {
          constructor() {
            super(new aK(-5, 5, 5, -5, 0.5, 500)),
              (this.isDirectionalLightShadow = !0);
          }
        },
        lm = class extends le {
          constructor(_, I) {
            super(_, I),
              (this.isDirectionalLight = !0),
              (this.type = "DirectionalLight"),
              this.position.copy(sL.DEFAULT_UP),
              this.updateMatrix(),
              (this.target = new sL()),
              (this.shadow = new lf());
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(_) {
            return (
              super.copy(_),
              (this.target = _.target.clone()),
              (this.shadow = _.shadow.clone()),
              this
            );
          }
        },
        lg = class extends ai {
          constructor() {
            super(),
              (this.isInstancedBufferGeometry = !0),
              (this.type = "InstancedBufferGeometry"),
              (this.instanceCount = 1 / 0);
          }
          copy(_) {
            return super.copy(_), (this.instanceCount = _.instanceCount), this;
          }
          toJSON() {
            let _ = super.toJSON();
            return (
              (_.instanceCount = this.instanceCount),
              (_.isInstancedBufferGeometry = !0),
              _
            );
          }
        },
        lv = class extends o4 {
          constructor(_) {
            super(_);
          }
          load(_, I, R, B) {
            let z = this,
              k = new o8(z.manager);
            k.setPath(z.path),
              k.setRequestHeader(z.requestHeader),
              k.setWithCredentials(z.withCredentials),
              k.load(
                _,
                function (R) {
                  try {
                    I(z.parse(JSON.parse(R)));
                  } catch (I) {
                    B ? B(I) : console.error(I), z.manager.itemError(_);
                  }
                },
                R,
                B
              );
          }
          parse(_) {
            let I = {},
              R = {};
            function i(_, B) {
              if (void 0 !== I[B]) return I[B];
              let z = _.interleavedBuffers[B],
                k = (function (_, I) {
                  if (void 0 !== R[I]) return R[I];
                  let B = _.arrayBuffers[I],
                    z = new Uint32Array(B).buffer;
                  return (R[I] = z), z;
                })(_, z.buffer),
                V = Fg(z.type, k),
                j = new nF(V, z.stride);
              return (j.uuid = z.uuid), (I[B] = j), j;
            }
            let B = _.isInstancedBufferGeometry ? new lg() : new ai(),
              z = _.data.index;
            if (void 0 !== z) {
              let _ = Fg(z.type, z.array);
              B.setIndex(new s0(_, 1));
            }
            let k = _.data.attributes;
            for (let I in k) {
              let R = k[I],
                z;
              if (R.isInterleavedBufferAttribute) {
                let I = i(_.data, R.data);
                z = new nk(I, R.itemSize, R.offset, R.normalized);
              } else {
                let _ = Fg(R.type, R.array);
                z = new (R.isInstancedBufferAttribute ? nq : s0)(
                  _,
                  R.itemSize,
                  R.normalized
                );
              }
              void 0 !== R.name && (z.name = R.name),
                void 0 !== R.usage && z.setUsage(R.usage),
                void 0 !== R.updateRange &&
                  ((z.updateRange.offset = R.updateRange.offset),
                  (z.updateRange.count = R.updateRange.count)),
                B.setAttribute(I, z);
            }
            let V = _.data.morphAttributes;
            if (V)
              for (let I in V) {
                let R = V[I],
                  z = [];
                for (let I = 0, B = R.length; I < B; I++) {
                  let B = R[I],
                    k;
                  if (B.isInterleavedBufferAttribute) {
                    let I = i(_.data, B.data);
                    k = new nk(I, B.itemSize, B.offset, B.normalized);
                  } else {
                    let _ = Fg(B.type, B.array);
                    k = new s0(_, B.itemSize, B.normalized);
                  }
                  void 0 !== B.name && (k.name = B.name), z.push(k);
                }
                B.morphAttributes[I] = z;
              }
            _.data.morphTargetsRelative && (B.morphTargetsRelative = !0);
            let j = _.data.groups || _.data.drawcalls || _.data.offsets;
            if (void 0 !== j)
              for (let _ = 0, I = j.length; _ !== I; ++_) {
                let I = j[_];
                B.addGroup(I.start, I.count, I.materialIndex);
              }
            let G = _.data.boundingSphere;
            if (void 0 !== G) {
              let _ = new rF();
              void 0 !== G.center && _.fromArray(G.center),
                (B.boundingSphere = new r5(_, G.radius));
            }
            return (
              _.name && (B.name = _.name),
              _.userData && (B.userData = _.userData),
              B
            );
          }
        },
        ly = class {
          constructor(_ = !0) {
            (this.autoStart = _),
              (this.startTime = 0),
              (this.oldTime = 0),
              (this.elapsedTime = 0),
              (this.running = !1);
          }
          start() {
            (this.startTime = RM()),
              (this.oldTime = this.startTime),
              (this.elapsedTime = 0),
              (this.running = !0);
          }
          stop() {
            this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
          }
          getElapsedTime() {
            return this.getDelta(), this.elapsedTime;
          }
          getDelta() {
            let _ = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
              let I = RM();
              (_ = (I - this.oldTime) / 1e3),
                (this.oldTime = I),
                (this.elapsedTime += _);
            }
            return _;
          }
        };
      function RM() {
        return (typeof performance > "u" ? Date : performance).now();
      }
      var lx = class {
          constructor(_, I, R) {
            let B, z, k;
            switch (((this.binding = _), (this.valueSize = R), I)) {
              case "quaternion":
                (B = this._slerp),
                  (z = this._slerpAdditive),
                  (k = this._setAdditiveIdentityQuaternion),
                  (this.buffer = new Float64Array(6 * R)),
                  (this._workIndex = 5);
                break;
              case "string":
              case "bool":
                (B = this._select),
                  (z = this._select),
                  (k = this._setAdditiveIdentityOther),
                  (this.buffer = Array(5 * R));
                break;
              default:
                (B = this._lerp),
                  (z = this._lerpAdditive),
                  (k = this._setAdditiveIdentityNumeric),
                  (this.buffer = new Float64Array(5 * R));
            }
            (this._mixBufferRegion = B),
              (this._mixBufferRegionAdditive = z),
              (this._setIdentity = k),
              (this._origIndex = 3),
              (this._addIndex = 4),
              (this.cumulativeWeight = 0),
              (this.cumulativeWeightAdditive = 0),
              (this.useCount = 0),
              (this.referenceCount = 0);
          }
          accumulate(_, I) {
            let R = this.buffer,
              B = this.valueSize,
              z = _ * B + B,
              k = this.cumulativeWeight;
            if (0 === k) {
              for (let _ = 0; _ !== B; ++_) R[z + _] = R[_];
              k = I;
            } else {
              k += I;
              let _ = I / k;
              this._mixBufferRegion(R, z, 0, _, B);
            }
            this.cumulativeWeight = k;
          }
          accumulateAdditive(_) {
            let I = this.buffer,
              R = this.valueSize,
              B = R * this._addIndex;
            0 === this.cumulativeWeightAdditive && this._setIdentity(),
              this._mixBufferRegionAdditive(I, B, 0, _, R),
              (this.cumulativeWeightAdditive += _);
          }
          apply(_) {
            let I = this.valueSize,
              R = this.buffer,
              B = _ * I + I,
              z = this.cumulativeWeight,
              k = this.cumulativeWeightAdditive,
              V = this.binding;
            if (
              ((this.cumulativeWeight = 0),
              (this.cumulativeWeightAdditive = 0),
              z < 1)
            ) {
              let _ = I * this._origIndex;
              this._mixBufferRegion(R, B, _, 1 - z, I);
            }
            k > 0 &&
              this._mixBufferRegionAdditive(R, B, this._addIndex * I, 1, I);
            for (let _ = I, z = I + I; _ !== z; ++_)
              if (R[_] !== R[_ + I]) {
                V.setValue(R, B);
                break;
              }
          }
          saveOriginalState() {
            let _ = this.binding,
              I = this.buffer,
              R = this.valueSize,
              B = R * this._origIndex;
            _.getValue(I, B);
            for (let _ = R; _ !== B; ++_) I[_] = I[B + (_ % R)];
            this._setIdentity(),
              (this.cumulativeWeight = 0),
              (this.cumulativeWeightAdditive = 0);
          }
          restoreOriginalState() {
            let _ = 3 * this.valueSize;
            this.binding.setValue(this.buffer, _);
          }
          _setAdditiveIdentityNumeric() {
            let _ = this._addIndex * this.valueSize,
              I = _ + this.valueSize;
            for (let R = _; R < I; R++) this.buffer[R] = 0;
          }
          _setAdditiveIdentityQuaternion() {
            this._setAdditiveIdentityNumeric(),
              (this.buffer[this._addIndex * this.valueSize + 3] = 1);
          }
          _setAdditiveIdentityOther() {
            let _ = this._origIndex * this.valueSize,
              I = this._addIndex * this.valueSize;
            for (let R = 0; R < this.valueSize; R++)
              this.buffer[I + R] = this.buffer[_ + R];
          }
          _select(_, I, R, B, z) {
            if (B >= 0.5) for (let B = 0; B !== z; ++B) _[I + B] = _[R + B];
          }
          _slerp(_, I, R, B) {
            rz.slerpFlat(_, I, _, I, _, R, B);
          }
          _slerpAdditive(_, I, R, B, z) {
            let k = this._workIndex * z;
            rz.multiplyQuaternionsFlat(_, k, _, I, _, R),
              rz.slerpFlat(_, I, _, I, _, k, B);
          }
          _lerp(_, I, R, B, z) {
            let k = 1 - B;
            for (let V = 0; V !== z; ++V) {
              let z = I + V;
              _[z] = _[z] * k + _[R + V] * B;
            }
          }
          _lerpAdditive(_, I, R, B, z) {
            for (let k = 0; k !== z; ++k) {
              let z = I + k;
              _[z] = _[z] + _[R + k] * B;
            }
          }
        },
        lw = "\\[\\]\\.:\\/",
        l_ = RegExp("[" + lw + "]", "g"),
        lS = "[^" + lw + "]",
        lC = "[^" + lw.replace("\\.", "") + "]",
        lT = RegExp(
          "^" +
            /((?:WC+[\/:])*)/.source.replace("WC", lS) +
            /(WCOD+)?/.source.replace("WCOD", lC) +
            /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", lS) +
            /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", lS) +
            "$"
        ),
        lP = ["material", "materials", "bones", "map"],
        lI = class {
          constructor(_, I, R) {
            let B = R || lR.parseTrackName(I);
            (this._targetGroup = _), (this._bindings = _.subscribe_(I, B));
          }
          getValue(_, I) {
            this.bind();
            let R = this._targetGroup.nCachedObjects_,
              B = this._bindings[R];
            void 0 !== B && B.getValue(_, I);
          }
          setValue(_, I) {
            let R = this._bindings;
            for (
              let B = this._targetGroup.nCachedObjects_, z = R.length;
              B !== z;
              ++B
            )
              R[B].setValue(_, I);
          }
          bind() {
            let _ = this._bindings;
            for (
              let I = this._targetGroup.nCachedObjects_, R = _.length;
              I !== R;
              ++I
            )
              _[I].bind();
          }
          unbind() {
            let _ = this._bindings;
            for (
              let I = this._targetGroup.nCachedObjects_, R = _.length;
              I !== R;
              ++I
            )
              _[I].unbind();
          }
        },
        lR = class {
          constructor(_, I, R) {
            (this.path = I),
              (this.parsedPath = R || lR.parseTrackName(I)),
              (this.node = lR.findNode(_, this.parsedPath.nodeName) || _),
              (this.rootNode = _),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
          static create(_, I, R) {
            return _ && _.isAnimationObjectGroup
              ? new lR.Composite(_, I, R)
              : new lR(_, I, R);
          }
          static sanitizeNodeName(_) {
            return _.replace(/\s/g, "_").replace(l_, "");
          }
          static parseTrackName(_) {
            let I = lT.exec(_);
            if (null === I)
              throw Error("PropertyBinding: Cannot parse trackName: " + _);
            let R = {
                nodeName: I[2],
                objectName: I[3],
                objectIndex: I[4],
                propertyName: I[5],
                propertyIndex: I[6],
              },
              B = R.nodeName && R.nodeName.lastIndexOf(".");
            if (void 0 !== B && -1 !== B) {
              let _ = R.nodeName.substring(B + 1);
              -1 !== lP.indexOf(_) &&
                ((R.nodeName = R.nodeName.substring(0, B)), (R.objectName = _));
            }
            if (null === R.propertyName || 0 === R.propertyName.length)
              throw Error(
                "PropertyBinding: can not parse propertyName from trackName: " +
                  _
              );
            return R;
          }
          static findNode(_, I) {
            if (
              void 0 === I ||
              "" === I ||
              "." === I ||
              -1 === I ||
              I === _.name ||
              I === _.uuid
            )
              return _;
            if (_.skeleton) {
              let R = _.skeleton.getBoneByName(I);
              if (void 0 !== R) return R;
            }
            if (_.children) {
              let r = function (_) {
                  for (let R = 0; R < _.length; R++) {
                    let B = _[R];
                    if (B.name === I || B.uuid === I) return B;
                    let z = r(B.children);
                    if (z) return z;
                  }
                  return null;
                },
                R = r(_.children);
              if (R) return R;
            }
            return null;
          }
          _getValue_unavailable() {}
          _setValue_unavailable() {}
          _getValue_direct(_, I) {
            _[I] = this.targetObject[this.propertyName];
          }
          _getValue_array(_, I) {
            let R = this.resolvedProperty;
            for (let B = 0, z = R.length; B !== z; ++B) _[I++] = R[B];
          }
          _getValue_arrayElement(_, I) {
            _[I] = this.resolvedProperty[this.propertyIndex];
          }
          _getValue_toArray(_, I) {
            this.resolvedProperty.toArray(_, I);
          }
          _setValue_direct(_, I) {
            this.targetObject[this.propertyName] = _[I];
          }
          _setValue_direct_setNeedsUpdate(_, I) {
            (this.targetObject[this.propertyName] = _[I]),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_direct_setMatrixWorldNeedsUpdate(_, I) {
            (this.targetObject[this.propertyName] = _[I]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _setValue_array(_, I) {
            let R = this.resolvedProperty;
            for (let B = 0, z = R.length; B !== z; ++B) R[B] = _[I++];
          }
          _setValue_array_setNeedsUpdate(_, I) {
            let R = this.resolvedProperty;
            for (let B = 0, z = R.length; B !== z; ++B) R[B] = _[I++];
            this.targetObject.needsUpdate = !0;
          }
          _setValue_array_setMatrixWorldNeedsUpdate(_, I) {
            let R = this.resolvedProperty;
            for (let B = 0, z = R.length; B !== z; ++B) R[B] = _[I++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
          }
          _setValue_arrayElement(_, I) {
            this.resolvedProperty[this.propertyIndex] = _[I];
          }
          _setValue_arrayElement_setNeedsUpdate(_, I) {
            (this.resolvedProperty[this.propertyIndex] = _[I]),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_arrayElement_setMatrixWorldNeedsUpdate(_, I) {
            (this.resolvedProperty[this.propertyIndex] = _[I]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _setValue_fromArray(_, I) {
            this.resolvedProperty.fromArray(_, I);
          }
          _setValue_fromArray_setNeedsUpdate(_, I) {
            this.resolvedProperty.fromArray(_, I),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_fromArray_setMatrixWorldNeedsUpdate(_, I) {
            this.resolvedProperty.fromArray(_, I),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _getValue_unbound(_, I) {
            this.bind(), this.getValue(_, I);
          }
          _setValue_unbound(_, I) {
            this.bind(), this.setValue(_, I);
          }
          bind() {
            let _ = this.node,
              I = this.parsedPath,
              R = I.objectName,
              B = I.propertyName,
              z = I.propertyIndex;
            if (
              (_ ||
                ((_ = lR.findNode(this.rootNode, I.nodeName) || this.rootNode),
                (this.node = _)),
              (this.getValue = this._getValue_unavailable),
              (this.setValue = this._setValue_unavailable),
              !_)
            ) {
              console.error(
                "THREE.PropertyBinding: Trying to update node for track: " +
                  this.path +
                  " but it wasn't found."
              );
              return;
            }
            if (R) {
              let B = I.objectIndex;
              switch (R) {
                case "materials":
                  if (!_.material) {
                    console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this
                    );
                    return;
                  }
                  if (!_.material.materials) {
                    console.error(
                      "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                      this
                    );
                    return;
                  }
                  _ = _.material.materials;
                  break;
                case "bones":
                  if (!_.skeleton) {
                    console.error(
                      "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                      this
                    );
                    return;
                  }
                  _ = _.skeleton.bones;
                  for (let I = 0; I < _.length; I++)
                    if (_[I].name === B) {
                      B = I;
                      break;
                    }
                  break;
                case "map":
                  if ("map" in _) {
                    _ = _.map;
                    break;
                  }
                  if (!_.material) {
                    console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this
                    );
                    return;
                  }
                  if (!_.material.map) {
                    console.error(
                      "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
                      this
                    );
                    return;
                  }
                  _ = _.material.map;
                  break;
                default:
                  if (void 0 === _[R]) {
                    console.error(
                      "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                      this
                    );
                    return;
                  }
                  _ = _[R];
              }
              if (void 0 !== B) {
                if (void 0 === _[B]) {
                  console.error(
                    "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                    this,
                    _
                  );
                  return;
                }
                _ = _[B];
              }
            }
            let k = _[B];
            if (void 0 === k) {
              console.error(
                "THREE.PropertyBinding: Trying to update property for track: " +
                  I.nodeName +
                  "." +
                  B +
                  " but it wasn't found.",
                _
              );
              return;
            }
            let V = this.Versioning.None;
            (this.targetObject = _),
              void 0 !== _.needsUpdate
                ? (V = this.Versioning.NeedsUpdate)
                : void 0 !== _.matrixWorldNeedsUpdate &&
                  (V = this.Versioning.MatrixWorldNeedsUpdate);
            let j = this.BindingType.Direct;
            if (void 0 !== z) {
              if ("morphTargetInfluences" === B) {
                if (!_.geometry) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                    this
                  );
                  return;
                }
                if (!_.geometry.morphAttributes) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this
                  );
                  return;
                }
                void 0 !== _.morphTargetDictionary[z] &&
                  (z = _.morphTargetDictionary[z]);
              }
              (j = this.BindingType.ArrayElement),
                (this.resolvedProperty = k),
                (this.propertyIndex = z);
            } else
              void 0 !== k.fromArray && void 0 !== k.toArray
                ? ((j = this.BindingType.HasFromToArray),
                  (this.resolvedProperty = k))
                : Array.isArray(k)
                ? ((j = this.BindingType.EntireArray),
                  (this.resolvedProperty = k))
                : (this.propertyName = B);
            (this.getValue = this.GetterByBindingType[j]),
              (this.setValue = this.SetterByBindingTypeAndVersioning[j][V]);
          }
          unbind() {
            (this.node = null),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
        };
      (lR.Composite = lI),
        (lR.prototype.BindingType = {
          Direct: 0,
          EntireArray: 1,
          ArrayElement: 2,
          HasFromToArray: 3,
        }),
        (lR.prototype.Versioning = {
          None: 0,
          NeedsUpdate: 1,
          MatrixWorldNeedsUpdate: 2,
        }),
        (lR.prototype.GetterByBindingType = [
          lR.prototype._getValue_direct,
          lR.prototype._getValue_array,
          lR.prototype._getValue_arrayElement,
          lR.prototype._getValue_toArray,
        ]),
        (lR.prototype.SetterByBindingTypeAndVersioning = [
          [
            lR.prototype._setValue_direct,
            lR.prototype._setValue_direct_setNeedsUpdate,
            lR.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
          ],
          [
            lR.prototype._setValue_array,
            lR.prototype._setValue_array_setNeedsUpdate,
            lR.prototype._setValue_array_setMatrixWorldNeedsUpdate,
          ],
          [
            lR.prototype._setValue_arrayElement,
            lR.prototype._setValue_arrayElement_setNeedsUpdate,
            lR.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
          ],
          [
            lR.prototype._setValue_fromArray,
            lR.prototype._setValue_fromArray_setNeedsUpdate,
            lR.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
          ],
        ]);
      var lL = class {
          constructor(_, I, R = null, B = I.blendMode) {
            (this._mixer = _),
              (this._clip = I),
              (this._localRoot = R),
              (this.blendMode = B);
            let z = I.tracks,
              k = z.length,
              V = Array(k),
              j = { endingStart: 2400, endingEnd: 2400 };
            for (let _ = 0; _ !== k; ++_) {
              let I = z[_].createInterpolant(null);
              (V[_] = I), (I.settings = j);
            }
            (this._interpolantSettings = j),
              (this._interpolants = V),
              (this._propertyBindings = Array(k)),
              (this._cacheIndex = null),
              (this._byClipCacheIndex = null),
              (this._timeScaleInterpolant = null),
              (this._weightInterpolant = null),
              (this.loop = 2201),
              (this._loopCount = -1),
              (this._startTime = null),
              (this.time = 0),
              (this.timeScale = 1),
              (this._effectiveTimeScale = 1),
              (this.weight = 1),
              (this._effectiveWeight = 1),
              (this.repetitions = 1 / 0),
              (this.paused = !1),
              (this.enabled = !0),
              (this.clampWhenFinished = !1),
              (this.zeroSlopeAtStart = !0),
              (this.zeroSlopeAtEnd = !0);
          }
          play() {
            return this._mixer._activateAction(this), this;
          }
          stop() {
            return this._mixer._deactivateAction(this), this.reset();
          }
          reset() {
            return (
              (this.paused = !1),
              (this.enabled = !0),
              (this.time = 0),
              (this._loopCount = -1),
              (this._startTime = null),
              this.stopFading().stopWarping()
            );
          }
          isRunning() {
            return (
              this.enabled &&
              !this.paused &&
              0 !== this.timeScale &&
              null === this._startTime &&
              this._mixer._isActiveAction(this)
            );
          }
          isScheduled() {
            return this._mixer._isActiveAction(this);
          }
          startAt(_) {
            return (this._startTime = _), this;
          }
          setLoop(_, I) {
            return (this.loop = _), (this.repetitions = I), this;
          }
          setEffectiveWeight(_) {
            return (
              (this.weight = _),
              (this._effectiveWeight = this.enabled ? _ : 0),
              this.stopFading()
            );
          }
          getEffectiveWeight() {
            return this._effectiveWeight;
          }
          fadeIn(_) {
            return this._scheduleFading(_, 0, 1);
          }
          fadeOut(_) {
            return this._scheduleFading(_, 1, 0);
          }
          crossFadeFrom(_, I, R) {
            if ((_.fadeOut(I), this.fadeIn(I), R)) {
              let R = this._clip.duration,
                B = _._clip.duration;
              _.warp(1, B / R, I), this.warp(R / B, 1, I);
            }
            return this;
          }
          crossFadeTo(_, I, R) {
            return _.crossFadeFrom(this, I, R);
          }
          stopFading() {
            let _ = this._weightInterpolant;
            return (
              null !== _ &&
                ((this._weightInterpolant = null),
                this._mixer._takeBackControlInterpolant(_)),
              this
            );
          }
          setEffectiveTimeScale(_) {
            return (
              (this.timeScale = _),
              (this._effectiveTimeScale = this.paused ? 0 : _),
              this.stopWarping()
            );
          }
          getEffectiveTimeScale() {
            return this._effectiveTimeScale;
          }
          setDuration(_) {
            return (
              (this.timeScale = this._clip.duration / _), this.stopWarping()
            );
          }
          syncWith(_) {
            return (
              (this.time = _.time),
              (this.timeScale = _.timeScale),
              this.stopWarping()
            );
          }
          halt(_) {
            return this.warp(this._effectiveTimeScale, 0, _);
          }
          warp(_, I, R) {
            let B = this._mixer,
              z = B.time,
              k = this.timeScale,
              V = this._timeScaleInterpolant;
            null === V &&
              ((V = B._lendControlInterpolant()),
              (this._timeScaleInterpolant = V));
            let j = V.parameterPositions,
              G = V.sampleValues;
            return (
              (j[0] = z), (j[1] = z + R), (G[0] = _ / k), (G[1] = I / k), this
            );
          }
          stopWarping() {
            let _ = this._timeScaleInterpolant;
            return (
              null !== _ &&
                ((this._timeScaleInterpolant = null),
                this._mixer._takeBackControlInterpolant(_)),
              this
            );
          }
          getMixer() {
            return this._mixer;
          }
          getClip() {
            return this._clip;
          }
          getRoot() {
            return this._localRoot || this._mixer._root;
          }
          _update(_, I, R, B) {
            if (!this.enabled) {
              this._updateWeight(_);
              return;
            }
            let z = this._startTime;
            if (null !== z) {
              let B = (_ - z) * R;
              B < 0 || 0 === R
                ? (I = 0)
                : ((this._startTime = null), (I = R * B));
            }
            I *= this._updateTimeScale(_);
            let k = this._updateTime(I),
              V = this._updateWeight(_);
            if (V > 0) {
              let _ = this._interpolants,
                I = this._propertyBindings;
              if (2501 === this.blendMode)
                for (let R = 0, B = _.length; R !== B; ++R)
                  _[R].evaluate(k), I[R].accumulateAdditive(V);
              else
                for (let R = 0, z = _.length; R !== z; ++R)
                  _[R].evaluate(k), I[R].accumulate(B, V);
            }
          }
          _updateWeight(_) {
            let I = 0;
            if (this.enabled) {
              I = this.weight;
              let R = this._weightInterpolant;
              if (null !== R) {
                let B = R.evaluate(_)[0];
                (I *= B),
                  _ > R.parameterPositions[1] &&
                    (this.stopFading(), 0 === B && (this.enabled = !1));
              }
            }
            return (this._effectiveWeight = I), I;
          }
          _updateTimeScale(_) {
            let I = 0;
            if (!this.paused) {
              I = this.timeScale;
              let R = this._timeScaleInterpolant;
              null !== R &&
                ((I *= R.evaluate(_)[0]),
                _ > R.parameterPositions[1] &&
                  (this.stopWarping(),
                  0 === I ? (this.paused = !0) : (this.timeScale = I)));
            }
            return (this._effectiveTimeScale = I), I;
          }
          _updateTime(_) {
            let I = this._clip.duration,
              R = this.loop,
              B = this.time + _,
              z = this._loopCount,
              k = 2202 === R;
            if (0 === _) return -1 === z ? B : k && (1 & z) == 1 ? I - B : B;
            if (2200 === R) {
              -1 === z && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
              e: {
                if (B >= I) B = I;
                else if (B < 0) B = 0;
                else {
                  this.time = B;
                  break e;
                }
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (this.time = B),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: _ < 0 ? -1 : 1,
                  });
              }
            } else {
              if (
                (-1 === z &&
                  (_ >= 0
                    ? ((z = 0), this._setEndings(!0, 0 === this.repetitions, k))
                    : this._setEndings(0 === this.repetitions, !0, k)),
                B >= I || B < 0)
              ) {
                let R = Math.floor(B / I);
                (B -= I * R), (z += Math.abs(R));
                let V = this.repetitions - z;
                if (V <= 0)
                  this.clampWhenFinished
                    ? (this.paused = !0)
                    : (this.enabled = !1),
                    (B = _ > 0 ? I : 0),
                    (this.time = B),
                    this._mixer.dispatchEvent({
                      type: "finished",
                      action: this,
                      direction: _ > 0 ? 1 : -1,
                    });
                else {
                  if (1 === V) {
                    let I = _ < 0;
                    this._setEndings(I, !I, k);
                  } else this._setEndings(!1, !1, k);
                  (this._loopCount = z),
                    (this.time = B),
                    this._mixer.dispatchEvent({
                      type: "loop",
                      action: this,
                      loopDelta: R,
                    });
                }
              } else this.time = B;
              if (k && (1 & z) == 1) return I - B;
            }
            return B;
          }
          _setEndings(_, I, R) {
            let B = this._interpolantSettings;
            R
              ? ((B.endingStart = 2401), (B.endingEnd = 2401))
              : (_
                  ? (B.endingStart = this.zeroSlopeAtStart ? 2401 : 2400)
                  : (B.endingStart = 2402),
                I
                  ? (B.endingEnd = this.zeroSlopeAtEnd ? 2401 : 2400)
                  : (B.endingEnd = 2402));
          }
          _scheduleFading(_, I, R) {
            let B = this._mixer,
              z = B.time,
              k = this._weightInterpolant;
            null === k &&
              ((k = B._lendControlInterpolant()),
              (this._weightInterpolant = k));
            let V = k.parameterPositions,
              j = k.sampleValues;
            return (V[0] = z), (j[0] = I), (V[1] = z + _), (j[1] = R), this;
          }
        },
        lz = new Float32Array(1),
        lF = class extends i8 {
          constructor(_) {
            super(),
              (this._root = _),
              this._initMemoryManager(),
              (this._accuIndex = 0),
              (this.time = 0),
              (this.timeScale = 1);
          }
          _bindAction(_, I) {
            let R = _._localRoot || this._root,
              B = _._clip.tracks,
              z = B.length,
              k = _._propertyBindings,
              V = _._interpolants,
              j = R.uuid,
              G = this._bindingsByRootAndName,
              q = G[j];
            void 0 === q && ((q = {}), (G[j] = q));
            for (let _ = 0; _ !== z; ++_) {
              let z = B[_],
                G = z.name,
                X = q[G];
              if (void 0 !== X) ++X.referenceCount, (k[_] = X);
              else {
                if (void 0 !== (X = k[_])) {
                  null === X._cacheIndex &&
                    (++X.referenceCount, this._addInactiveBinding(X, j, G));
                  continue;
                }
                let B = I && I._propertyBindings[_].binding.parsedPath;
                (X = new lx(
                  lR.create(R, G, B),
                  z.ValueTypeName,
                  z.getValueSize()
                )),
                  ++X.referenceCount,
                  this._addInactiveBinding(X, j, G),
                  (k[_] = X);
              }
              V[_].resultBuffer = X.buffer;
            }
          }
          _activateAction(_) {
            if (!this._isActiveAction(_)) {
              if (null === _._cacheIndex) {
                let I = (_._localRoot || this._root).uuid,
                  R = _._clip.uuid,
                  B = this._actionsByClip[R];
                this._bindAction(_, B && B.knownActions[0]),
                  this._addInactiveAction(_, R, I);
              }
              let I = _._propertyBindings;
              for (let _ = 0, R = I.length; _ !== R; ++_) {
                let R = I[_];
                0 == R.useCount++ &&
                  (this._lendBinding(R), R.saveOriginalState());
              }
              this._lendAction(_);
            }
          }
          _deactivateAction(_) {
            if (this._isActiveAction(_)) {
              let I = _._propertyBindings;
              for (let _ = 0, R = I.length; _ !== R; ++_) {
                let R = I[_];
                0 == --R.useCount &&
                  (R.restoreOriginalState(), this._takeBackBinding(R));
              }
              this._takeBackAction(_);
            }
          }
          _initMemoryManager() {
            (this._actions = []),
              (this._nActiveActions = 0),
              (this._actionsByClip = {}),
              (this._bindings = []),
              (this._nActiveBindings = 0),
              (this._bindingsByRootAndName = {}),
              (this._controlInterpolants = []),
              (this._nActiveControlInterpolants = 0);
            let _ = this;
            this.stats = {
              actions: {
                get total() {
                  return _._actions.length;
                },
                get inUse() {
                  return _._nActiveActions;
                },
              },
              bindings: {
                get total() {
                  return _._bindings.length;
                },
                get inUse() {
                  return _._nActiveBindings;
                },
              },
              controlInterpolants: {
                get total() {
                  return _._controlInterpolants.length;
                },
                get inUse() {
                  return _._nActiveControlInterpolants;
                },
              },
            };
          }
          _isActiveAction(_) {
            let I = _._cacheIndex;
            return null !== I && I < this._nActiveActions;
          }
          _addInactiveAction(_, I, R) {
            let B = this._actions,
              z = this._actionsByClip,
              k = z[I];
            if (void 0 === k)
              (k = { knownActions: [_], actionByRoot: {} }),
                (_._byClipCacheIndex = 0),
                (z[I] = k);
            else {
              let I = k.knownActions;
              (_._byClipCacheIndex = I.length), I.push(_);
            }
            (_._cacheIndex = B.length), B.push(_), (k.actionByRoot[R] = _);
          }
          _removeInactiveAction(_) {
            let I = this._actions,
              R = I[I.length - 1],
              B = _._cacheIndex;
            (R._cacheIndex = B), (I[B] = R), I.pop(), (_._cacheIndex = null);
            let z = _._clip.uuid,
              k = this._actionsByClip,
              V = k[z],
              j = V.knownActions,
              G = j[j.length - 1],
              q = _._byClipCacheIndex;
            (G._byClipCacheIndex = q),
              (j[q] = G),
              j.pop(),
              (_._byClipCacheIndex = null);
            let X = V.actionByRoot,
              Q = (_._localRoot || this._root).uuid;
            delete X[Q],
              0 === j.length && delete k[z],
              this._removeInactiveBindingsForAction(_);
          }
          _removeInactiveBindingsForAction(_) {
            let I = _._propertyBindings;
            for (let _ = 0, R = I.length; _ !== R; ++_) {
              let R = I[_];
              0 == --R.referenceCount && this._removeInactiveBinding(R);
            }
          }
          _lendAction(_) {
            let I = this._actions,
              R = _._cacheIndex,
              B = this._nActiveActions++,
              z = I[B];
            (_._cacheIndex = B), (I[B] = _), (z._cacheIndex = R), (I[R] = z);
          }
          _takeBackAction(_) {
            let I = this._actions,
              R = _._cacheIndex,
              B = --this._nActiveActions,
              z = I[B];
            (_._cacheIndex = B), (I[B] = _), (z._cacheIndex = R), (I[R] = z);
          }
          _addInactiveBinding(_, I, R) {
            let B = this._bindingsByRootAndName,
              z = this._bindings,
              k = B[I];
            void 0 === k && ((k = {}), (B[I] = k)),
              (k[R] = _),
              (_._cacheIndex = z.length),
              z.push(_);
          }
          _removeInactiveBinding(_) {
            let I = this._bindings,
              R = _.binding,
              B = R.rootNode.uuid,
              z = R.path,
              k = this._bindingsByRootAndName,
              V = k[B],
              j = I[I.length - 1],
              G = _._cacheIndex;
            (j._cacheIndex = G),
              (I[G] = j),
              I.pop(),
              delete V[z],
              0 === Object.keys(V).length && delete k[B];
          }
          _lendBinding(_) {
            let I = this._bindings,
              R = _._cacheIndex,
              B = this._nActiveBindings++,
              z = I[B];
            (_._cacheIndex = B), (I[B] = _), (z._cacheIndex = R), (I[R] = z);
          }
          _takeBackBinding(_) {
            let I = this._bindings,
              R = _._cacheIndex,
              B = --this._nActiveBindings,
              z = I[B];
            (_._cacheIndex = B), (I[B] = _), (z._cacheIndex = R), (I[R] = z);
          }
          _lendControlInterpolant() {
            let _ = this._controlInterpolants,
              I = this._nActiveControlInterpolants++,
              R = _[I];
            return (
              void 0 === R &&
                (((R = new oH(
                  new Float32Array(2),
                  new Float32Array(2),
                  1,
                  lz
                )).__cacheIndex = I),
                (_[I] = R)),
              R
            );
          }
          _takeBackControlInterpolant(_) {
            let I = this._controlInterpolants,
              R = _.__cacheIndex,
              B = --this._nActiveControlInterpolants,
              z = I[B];
            (_.__cacheIndex = B), (I[B] = _), (z.__cacheIndex = R), (I[R] = z);
          }
          clipAction(_, I, R) {
            let B = I || this._root,
              z = B.uuid,
              k = "string" == typeof _ ? o0.findByName(B, _) : _,
              V = null !== k ? k.uuid : _,
              j = this._actionsByClip[V],
              G = null;
            if (
              (void 0 === R && (R = null !== k ? k.blendMode : 2500),
              void 0 !== j)
            ) {
              let _ = j.actionByRoot[z];
              if (void 0 !== _ && _.blendMode === R) return _;
              (G = j.knownActions[0]), null === k && (k = G._clip);
            }
            if (null === k) return null;
            let q = new lL(this, k, I, R);
            return this._bindAction(q, G), this._addInactiveAction(q, V, z), q;
          }
          existingAction(_, I) {
            let R = I || this._root,
              B = R.uuid,
              z = "string" == typeof _ ? o0.findByName(R, _) : _,
              k = z ? z.uuid : _,
              V = this._actionsByClip[k];
            return (void 0 !== V && V.actionByRoot[B]) || null;
          }
          stopAllAction() {
            let _ = this._actions,
              I = this._nActiveActions;
            for (let R = I - 1; R >= 0; --R) _[R].stop();
            return this;
          }
          update(_) {
            _ *= this.timeScale;
            let I = this._actions,
              R = this._nActiveActions,
              B = (this.time += _),
              z = Math.sign(_),
              k = (this._accuIndex ^= 1);
            for (let V = 0; V !== R; ++V) I[V]._update(B, _, z, k);
            let V = this._bindings,
              j = this._nActiveBindings;
            for (let _ = 0; _ !== j; ++_) V[_].apply(k);
            return this;
          }
          setTime(_) {
            this.time = 0;
            for (let _ = 0; _ < this._actions.length; _++)
              this._actions[_].time = 0;
            return this.update(_);
          }
          getRoot() {
            return this._root;
          }
          uncacheClip(_) {
            let I = this._actions,
              R = _.uuid,
              B = this._actionsByClip,
              z = B[R];
            if (void 0 !== z) {
              let _ = z.knownActions;
              for (let R = 0, B = _.length; R !== B; ++R) {
                let B = _[R];
                this._deactivateAction(B);
                let z = B._cacheIndex,
                  k = I[I.length - 1];
                (B._cacheIndex = null),
                  (B._byClipCacheIndex = null),
                  (k._cacheIndex = z),
                  (I[z] = k),
                  I.pop(),
                  this._removeInactiveBindingsForAction(B);
              }
              delete B[R];
            }
          }
          uncacheRoot(_) {
            let I = _.uuid,
              R = this._actionsByClip;
            for (let _ in R) {
              let B = R[_].actionByRoot[I];
              void 0 !== B &&
                (this._deactivateAction(B), this._removeInactiveAction(B));
            }
            let B = this._bindingsByRootAndName[I];
            if (void 0 !== B)
              for (let _ in B) {
                let I = B[_];
                I.restoreOriginalState(), this._removeInactiveBinding(I);
              }
          }
          uncacheAction(_, I) {
            let R = this.existingAction(_, I);
            null !== R &&
              (this._deactivateAction(R), this._removeInactiveAction(R));
          }
        },
        lk = class {
          constructor(_) {
            this.value = _;
          }
          clone() {
            return new lk(
              void 0 === this.value.clone ? this.value : this.value.clone()
            );
          }
        },
        lV = class {
          constructor(_, I, R = 0, B = 1 / 0) {
            (this.ray = new ss(_, I)),
              (this.near = R),
              (this.far = B),
              (this.camera = null),
              (this.layers = new sv()),
              (this.params = {
                Mesh: {},
                Line: { threshold: 1 },
                LOD: {},
                Points: { threshold: 1 },
                Sprite: {},
              });
          }
          set(_, I) {
            this.ray.set(_, I);
          }
          setFromCamera(_, I) {
            I.isPerspectiveCamera
              ? (this.ray.origin.setFromMatrixPosition(I.matrixWorld),
                this.ray.direction
                  .set(_.x, _.y, 0.5)
                  .unproject(I)
                  .sub(this.ray.origin)
                  .normalize(),
                (this.camera = I))
              : I.isOrthographicCamera
              ? (this.ray.origin
                  .set(_.x, _.y, (I.near + I.far) / (I.near - I.far))
                  .unproject(I),
                this.ray.direction
                  .set(0, 0, -1)
                  .transformDirection(I.matrixWorld),
                (this.camera = I))
              : console.error(
                  "THREE.Raycaster: Unsupported camera type: " + I.type
                );
          }
          intersectObject(_, I = !0, R = []) {
            return ww(_, this, R, I), R.sort(LM), R;
          }
          intersectObjects(_, I = !0, R = []) {
            for (let B = 0, z = _.length; B < z; B++) ww(_[B], this, R, I);
            return R.sort(LM), R;
          }
        };
      function LM(_, I) {
        return _.distance - I.distance;
      }
      function ww(_, I, R, B) {
        if ((_.layers.test(I.layers) && _.raycast(I, R), !0 === B)) {
          let B = _.children;
          for (let _ = 0, z = B.length; _ < z; _++) ww(B[_], I, R, !0);
        }
      }
      var lj = class {
          constructor(_ = 1, I = 0, R = 0) {
            return (this.radius = _), (this.phi = I), (this.theta = R), this;
          }
          set(_, I, R) {
            return (this.radius = _), (this.phi = I), (this.theta = R), this;
          }
          copy(_) {
            return (
              (this.radius = _.radius),
              (this.phi = _.phi),
              (this.theta = _.theta),
              this
            );
          }
          makeSafe() {
            return (
              (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))),
              this
            );
          }
          setFromVector3(_) {
            return this.setFromCartesianCoords(_.x, _.y, _.z);
          }
          setFromCartesianCoords(_, I, R) {
            return (
              (this.radius = Math.sqrt(_ * _ + I * I + R * R)),
              0 === this.radius
                ? ((this.theta = 0), (this.phi = 0))
                : ((this.theta = Math.atan2(_, R)),
                  (this.phi = Math.acos(gi(I / this.radius, -1, 1)))),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
        },
        lH = new rs(),
        lW = class {
          constructor(_ = new rs(1 / 0, 1 / 0), I = new rs(-1 / 0, -1 / 0)) {
            (this.isBox2 = !0), (this.min = _), (this.max = I);
          }
          set(_, I) {
            return this.min.copy(_), this.max.copy(I), this;
          }
          setFromPoints(_) {
            this.makeEmpty();
            for (let I = 0, R = _.length; I < R; I++) this.expandByPoint(_[I]);
            return this;
          }
          setFromCenterAndSize(_, I) {
            let R = lH.copy(I).multiplyScalar(0.5);
            return this.min.copy(_).sub(R), this.max.copy(_).add(R), this;
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(_) {
            return this.min.copy(_.min), this.max.copy(_.max), this;
          }
          makeEmpty() {
            return (
              (this.min.x = this.min.y = 1 / 0),
              (this.max.x = this.max.y = -1 / 0),
              this
            );
          }
          isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y;
          }
          getCenter(_) {
            return this.isEmpty()
              ? _.set(0, 0)
              : _.addVectors(this.min, this.max).multiplyScalar(0.5);
          }
          getSize(_) {
            return this.isEmpty()
              ? _.set(0, 0)
              : _.subVectors(this.max, this.min);
          }
          expandByPoint(_) {
            return this.min.min(_), this.max.max(_), this;
          }
          expandByVector(_) {
            return this.min.sub(_), this.max.add(_), this;
          }
          expandByScalar(_) {
            return this.min.addScalar(-_), this.max.addScalar(_), this;
          }
          containsPoint(_) {
            return !(
              _.x < this.min.x ||
              _.x > this.max.x ||
              _.y < this.min.y ||
              _.y > this.max.y
            );
          }
          containsBox(_) {
            return (
              this.min.x <= _.min.x &&
              _.max.x <= this.max.x &&
              this.min.y <= _.min.y &&
              _.max.y <= this.max.y
            );
          }
          getParameter(_, I) {
            return I.set(
              (_.x - this.min.x) / (this.max.x - this.min.x),
              (_.y - this.min.y) / (this.max.y - this.min.y)
            );
          }
          intersectsBox(_) {
            return !(
              _.max.x < this.min.x ||
              _.min.x > this.max.x ||
              _.max.y < this.min.y ||
              _.min.y > this.max.y
            );
          }
          clampPoint(_, I) {
            return I.copy(_).clamp(this.min, this.max);
          }
          distanceToPoint(_) {
            return lH.copy(_).clamp(this.min, this.max).sub(_).length();
          }
          intersect(_) {
            return this.min.max(_.min), this.max.min(_.max), this;
          }
          union(_) {
            return this.min.min(_.min), this.max.max(_.max), this;
          }
          translate(_) {
            return this.min.add(_), this.max.add(_), this;
          }
          equals(_) {
            return _.min.equals(this.min) && _.max.equals(this.max);
          }
        },
        lq = new rF(),
        lY = new rF(),
        lX = class {
          constructor(_ = new rF(), I = new rF()) {
            (this.start = _), (this.end = I);
          }
          set(_, I) {
            return this.start.copy(_), this.end.copy(I), this;
          }
          copy(_) {
            return this.start.copy(_.start), this.end.copy(_.end), this;
          }
          getCenter(_) {
            return _.addVectors(this.start, this.end).multiplyScalar(0.5);
          }
          delta(_) {
            return _.subVectors(this.end, this.start);
          }
          distanceSq() {
            return this.start.distanceToSquared(this.end);
          }
          distance() {
            return this.start.distanceTo(this.end);
          }
          at(_, I) {
            return this.delta(I).multiplyScalar(_).add(this.start);
          }
          closestPointToPointParameter(_, I) {
            lq.subVectors(_, this.start), lY.subVectors(this.end, this.start);
            let R = lY.dot(lY),
              B = lY.dot(lq) / R;
            return I && (B = gi(B, 0, 1)), B;
          }
          closestPointToPoint(_, I, R) {
            let B = this.closestPointToPointParameter(_, I);
            return this.delta(R).multiplyScalar(B).add(this.start);
          }
          applyMatrix4(_) {
            return this.start.applyMatrix4(_), this.end.applyMatrix4(_), this;
          }
          equals(_) {
            return _.start.equals(this.start) && _.end.equals(this.end);
          }
          clone() {
            return new this.constructor().copy(this);
          }
        },
        lQ = new rF(),
        lZ = class extends sL {
          constructor(_, I) {
            super(),
              (this.light = _),
              (this.matrix = _.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.color = I),
              (this.type = "SpotLightHelper");
            let R = new ai(),
              B = [
                0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0,
                0, 1, 1, 0, 0, 0, 0, -1, 1,
              ];
            for (let _ = 0, I = 1; _ < 32; _++, I++) {
              let R = (_ / 32) * Math.PI * 2,
                z = (I / 32) * Math.PI * 2;
              B.push(Math.cos(R), Math.sin(R), 1, Math.cos(z), Math.sin(z), 1);
            }
            R.setAttribute("position", new s4(B, 3));
            let z = new n$({ fog: !1, toneMapped: !1 });
            (this.cone = new n7(R, z)), this.add(this.cone), this.update();
          }
          dispose() {
            this.cone.geometry.dispose(), this.cone.material.dispose();
          }
          update() {
            this.light.updateWorldMatrix(!0, !1),
              this.light.target.updateWorldMatrix(!0, !1);
            let _ = this.light.distance ? this.light.distance : 1e3,
              I = _ * Math.tan(this.light.angle);
            this.cone.scale.set(I, I, _),
              lQ.setFromMatrixPosition(this.light.target.matrixWorld),
              this.cone.lookAt(lQ),
              void 0 !== this.color
                ? this.cone.material.color.set(this.color)
                : this.cone.material.color.copy(this.light.color);
          }
        },
        lK = class extends aw {
          constructor(_, I, R) {
            super(
              new oN(I, 4, 2),
              new sK({ wireframe: !0, fog: !1, toneMapped: !1 })
            ),
              (this.light = _),
              (this.color = R),
              (this.type = "PointLightHelper"),
              (this.matrix = this.light.matrixWorld),
              (this.matrixAutoUpdate = !1),
              this.update();
          }
          dispose() {
            this.geometry.dispose(), this.material.dispose();
          }
          update() {
            this.light.updateWorldMatrix(!0, !1),
              void 0 !== this.color
                ? this.material.color.set(this.color)
                : this.material.color.copy(this.light.color);
          }
        },
        lJ = new rF(),
        l$ = new rF(),
        l0 = new rF(),
        l1 = class extends sL {
          constructor(_, I, R) {
            super(),
              (this.light = _),
              (this.matrix = _.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.color = R),
              (this.type = "DirectionalLightHelper"),
              void 0 === I && (I = 1);
            let B = new ai();
            B.setAttribute(
              "position",
              new s4([-I, I, 0, I, I, 0, I, -I, 0, -I, -I, 0, -I, I, 0], 3)
            );
            let z = new n$({ fog: !1, toneMapped: !1 });
            (this.lightPlane = new n6(B, z)),
              this.add(this.lightPlane),
              (B = new ai()).setAttribute(
                "position",
                new s4([0, 0, 0, 0, 0, 1], 3)
              ),
              (this.targetLine = new n6(B, z)),
              this.add(this.targetLine),
              this.update();
          }
          dispose() {
            this.lightPlane.geometry.dispose(),
              this.lightPlane.material.dispose(),
              this.targetLine.geometry.dispose(),
              this.targetLine.material.dispose();
          }
          update() {
            this.light.updateWorldMatrix(!0, !1),
              this.light.target.updateWorldMatrix(!0, !1),
              lJ.setFromMatrixPosition(this.light.matrixWorld),
              l$.setFromMatrixPosition(this.light.target.matrixWorld),
              l0.subVectors(l$, lJ),
              this.lightPlane.lookAt(l$),
              void 0 !== this.color
                ? (this.lightPlane.material.color.set(this.color),
                  this.targetLine.material.color.set(this.color))
                : (this.lightPlane.material.color.copy(this.light.color),
                  this.targetLine.material.color.copy(this.light.color)),
              this.targetLine.lookAt(l$),
              (this.targetLine.scale.z = l0.length());
          }
        },
        l2 = new rF(),
        l3 = new aP(),
        l4 = class extends n7 {
          constructor(_) {
            let I = new ai(),
              R = new n$({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
              B = [],
              z = [],
              k = {};
            function a(_, I) {
              l(_), l(I);
            }
            function l(_) {
              B.push(0, 0, 0),
                z.push(0, 0, 0),
                void 0 === k[_] && (k[_] = []),
                k[_].push(B.length / 3 - 1);
            }
            a("n1", "n2"),
              a("n2", "n4"),
              a("n4", "n3"),
              a("n3", "n1"),
              a("f1", "f2"),
              a("f2", "f4"),
              a("f4", "f3"),
              a("f3", "f1"),
              a("n1", "f1"),
              a("n2", "f2"),
              a("n3", "f3"),
              a("n4", "f4"),
              a("p", "n1"),
              a("p", "n2"),
              a("p", "n3"),
              a("p", "n4"),
              a("u1", "u2"),
              a("u2", "u3"),
              a("u3", "u1"),
              a("c", "t"),
              a("p", "c"),
              a("cn1", "cn2"),
              a("cn3", "cn4"),
              a("cf1", "cf2"),
              a("cf3", "cf4"),
              I.setAttribute("position", new s4(B, 3)),
              I.setAttribute("color", new s4(z, 3)),
              super(I, R),
              (this.type = "CameraHelper"),
              (this.camera = _),
              this.camera.updateProjectionMatrix &&
                this.camera.updateProjectionMatrix(),
              (this.matrix = _.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.pointMap = k),
              this.update();
            let V = new ry(16755200),
              j = new ry(16711680),
              G = new ry(43775),
              q = new ry(16777215),
              X = new ry(3355443);
            this.setColors(V, j, G, q, X);
          }
          setColors(_, I, R, B, z) {
            let k = this.geometry.getAttribute("color");
            k.setXYZ(0, _.r, _.g, _.b),
              k.setXYZ(1, _.r, _.g, _.b),
              k.setXYZ(2, _.r, _.g, _.b),
              k.setXYZ(3, _.r, _.g, _.b),
              k.setXYZ(4, _.r, _.g, _.b),
              k.setXYZ(5, _.r, _.g, _.b),
              k.setXYZ(6, _.r, _.g, _.b),
              k.setXYZ(7, _.r, _.g, _.b),
              k.setXYZ(8, _.r, _.g, _.b),
              k.setXYZ(9, _.r, _.g, _.b),
              k.setXYZ(10, _.r, _.g, _.b),
              k.setXYZ(11, _.r, _.g, _.b),
              k.setXYZ(12, _.r, _.g, _.b),
              k.setXYZ(13, _.r, _.g, _.b),
              k.setXYZ(14, _.r, _.g, _.b),
              k.setXYZ(15, _.r, _.g, _.b),
              k.setXYZ(16, _.r, _.g, _.b),
              k.setXYZ(17, _.r, _.g, _.b),
              k.setXYZ(18, _.r, _.g, _.b),
              k.setXYZ(19, _.r, _.g, _.b),
              k.setXYZ(20, _.r, _.g, _.b),
              k.setXYZ(21, _.r, _.g, _.b),
              k.setXYZ(22, _.r, _.g, _.b),
              k.setXYZ(23, _.r, _.g, _.b),
              k.setXYZ(24, I.r, I.g, I.b),
              k.setXYZ(25, I.r, I.g, I.b),
              k.setXYZ(26, I.r, I.g, I.b),
              k.setXYZ(27, I.r, I.g, I.b),
              k.setXYZ(28, I.r, I.g, I.b),
              k.setXYZ(29, I.r, I.g, I.b),
              k.setXYZ(30, I.r, I.g, I.b),
              k.setXYZ(31, I.r, I.g, I.b),
              k.setXYZ(32, R.r, R.g, R.b),
              k.setXYZ(33, R.r, R.g, R.b),
              k.setXYZ(34, R.r, R.g, R.b),
              k.setXYZ(35, R.r, R.g, R.b),
              k.setXYZ(36, R.r, R.g, R.b),
              k.setXYZ(37, R.r, R.g, R.b),
              k.setXYZ(38, B.r, B.g, B.b),
              k.setXYZ(39, B.r, B.g, B.b),
              k.setXYZ(40, z.r, z.g, z.b),
              k.setXYZ(41, z.r, z.g, z.b),
              k.setXYZ(42, z.r, z.g, z.b),
              k.setXYZ(43, z.r, z.g, z.b),
              k.setXYZ(44, z.r, z.g, z.b),
              k.setXYZ(45, z.r, z.g, z.b),
              k.setXYZ(46, z.r, z.g, z.b),
              k.setXYZ(47, z.r, z.g, z.b),
              k.setXYZ(48, z.r, z.g, z.b),
              k.setXYZ(49, z.r, z.g, z.b),
              (k.needsUpdate = !0);
          }
          update() {
            let _ = this.geometry,
              I = this.pointMap;
            l3.projectionMatrixInverse.copy(
              this.camera.projectionMatrixInverse
            ),
              ti("c", I, _, l3, 0, 0, -1),
              ti("t", I, _, l3, 0, 0, 1),
              ti("n1", I, _, l3, -1, -1, -1),
              ti("n2", I, _, l3, 1, -1, -1),
              ti("n3", I, _, l3, -1, 1, -1),
              ti("n4", I, _, l3, 1, 1, -1),
              ti("f1", I, _, l3, -1, -1, 1),
              ti("f2", I, _, l3, 1, -1, 1),
              ti("f3", I, _, l3, -1, 1, 1),
              ti("f4", I, _, l3, 1, 1, 1),
              ti("u1", I, _, l3, 0.7, 1.1, -1),
              ti("u2", I, _, l3, -0.7, 1.1, -1),
              ti("u3", I, _, l3, 0, 2, -1),
              ti("cf1", I, _, l3, -1, 0, 1),
              ti("cf2", I, _, l3, 1, 0, 1),
              ti("cf3", I, _, l3, 0, -1, 1),
              ti("cf4", I, _, l3, 0, 1, 1),
              ti("cn1", I, _, l3, -1, 0, -1),
              ti("cn2", I, _, l3, 1, 0, -1),
              ti("cn3", I, _, l3, 0, -1, -1),
              ti("cn4", I, _, l3, 0, 1, -1),
              (_.getAttribute("position").needsUpdate = !0);
          }
          dispose() {
            this.geometry.dispose(), this.material.dispose();
          }
        };
      function ti(_, I, R, B, z, k, V) {
        l2.set(z, k, V).unproject(B);
        let j = I[_];
        if (void 0 !== j) {
          let _ = R.getAttribute("position");
          for (let I = 0, R = j.length; I < R; I++)
            _.setXYZ(j[I], l2.x, l2.y, l2.z);
        }
      }
      var l5 = class extends n7 {
          constructor(_, I = 16776960) {
            let R = new Uint16Array([
                0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2,
                6, 3, 7,
              ]),
              B = new ai();
            B.setIndex(new s0(R, 1)),
              B.setAttribute(
                "position",
                new s4(
                  [
                    1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1,
                    -1, -1, -1, 1, -1, -1,
                  ],
                  3
                )
              ),
              super(B, new n$({ color: I, toneMapped: !1 })),
              (this.box = _),
              (this.type = "Box3Helper"),
              this.geometry.computeBoundingSphere();
          }
          updateMatrixWorld(_) {
            let I = this.box;
            I.isEmpty() ||
              (I.getCenter(this.position),
              I.getSize(this.scale),
              this.scale.multiplyScalar(0.5),
              super.updateMatrixWorld(_));
          }
          dispose() {
            this.geometry.dispose(), this.material.dispose();
          }
        },
        l6 = class extends n7 {
          constructor(_ = 1) {
            let I = [0, 0, 0, _, 0, 0, 0, 0, 0, 0, _, 0, 0, 0, 0, 0, 0, _],
              R = new ai();
            R.setAttribute("position", new s4(I, 3)),
              R.setAttribute(
                "color",
                new s4(
                  [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
                  3
                )
              ),
              super(R, new n$({ vertexColors: !0, toneMapped: !1 })),
              (this.type = "AxesHelper");
          }
          setColors(_, I, R) {
            let B = new ry(),
              z = this.geometry.attributes.color.array;
            return (
              B.set(_),
              B.toArray(z, 0),
              B.toArray(z, 3),
              B.set(I),
              B.toArray(z, 6),
              B.toArray(z, 9),
              B.set(R),
              B.toArray(z, 12),
              B.toArray(z, 15),
              (this.geometry.attributes.color.needsUpdate = !0),
              this
            );
          }
          dispose() {
            this.geometry.dispose(), this.material.dispose();
          }
        },
        l8 = (function () {
          let _ = new ArrayBuffer(4),
            I = new Float32Array(_),
            R = new Uint32Array(_),
            B = new Uint32Array(512),
            z = new Uint32Array(512);
          for (let _ = 0; _ < 256; ++_) {
            let I = _ - 127;
            I < -27
              ? ((B[_] = 0),
                (B[256 | _] = 32768),
                (z[_] = 24),
                (z[256 | _] = 24))
              : I < -14
              ? ((B[_] = 1024 >> (-I - 14)),
                (B[256 | _] = (1024 >> (-I - 14)) | 32768),
                (z[_] = -I - 1),
                (z[256 | _] = -I - 1))
              : I <= 15
              ? ((B[_] = (I + 15) << 10),
                (B[256 | _] = ((I + 15) << 10) | 32768),
                (z[_] = 13),
                (z[256 | _] = 13))
              : I < 128
              ? ((B[_] = 31744),
                (B[256 | _] = 64512),
                (z[_] = 24),
                (z[256 | _] = 24))
              : ((B[_] = 31744),
                (B[256 | _] = 64512),
                (z[_] = 13),
                (z[256 | _] = 13));
          }
          let k = new Uint32Array(2048),
            V = new Uint32Array(64),
            j = new Uint32Array(64);
          for (let _ = 1; _ < 1024; ++_) {
            let I = _ << 13,
              R = 0;
            for (; (8388608 & I) == 0; ) (I <<= 1), (R -= 8388608);
            (I &= -8388609), (R += 947912704), (k[_] = I | R);
          }
          for (let _ = 1024; _ < 2048; ++_)
            k[_] = 939524096 + ((_ - 1024) << 13);
          for (let _ = 1; _ < 31; ++_) V[_] = _ << 23;
          (V[31] = 1199570944), (V[32] = 2147483648);
          for (let _ = 33; _ < 63; ++_) V[_] = 2147483648 + ((_ - 32) << 23);
          V[63] = 3347054592;
          for (let _ = 1; _ < 64; ++_) 32 !== _ && (j[_] = 1024);
          return {
            floatView: I,
            uint32View: R,
            baseTable: B,
            shiftTable: z,
            mantissaTable: k,
            exponentTable: V,
            offsetTable: j,
          };
        })(),
        l9 = Object.freeze({
          __proto__: null,
          fromHalfFloat: function (_) {
            let I = _ >> 10;
            return (
              (l8.uint32View[0] =
                l8.mantissaTable[l8.offsetTable[I] + (1023 & _)] +
                l8.exponentTable[I]),
              l8.floatView[0]
            );
          },
          toHalfFloat: function (_) {
            Math.abs(_) > 65504 &&
              console.warn(
                "THREE.DataUtils.toHalfFloat(): Value out of range."
              ),
              (_ = gi(_, -65504, 65504)),
              (l8.floatView[0] = _);
            let I = l8.uint32View[0],
              R = (I >> 23) & 511;
            return l8.baseTable[R] + ((8388607 & I) >> l8.shiftTable[R]);
          },
        });
      "u" > typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("register", { detail: { revision: "149" } })
        ),
        "u" > typeof window &&
          (window.__THREE__
            ? console.warn(
                "WARNING: Multiple instances of Three.js being imported."
              )
            : (window.__THREE__ = "149"));
      var l7 = Symbol("target"),
        he = Symbol("unsubscribe");
      function zp(_) {
        return (
          _ instanceof Date ||
          _ instanceof Set ||
          _ instanceof Map ||
          _ instanceof WeakSet ||
          _ instanceof WeakMap ||
          ArrayBuffer.isView(_)
        );
      }
      var hi = Array.isArray;
      function Ic(_) {
        return "symbol" == typeof _;
      }
      var hr = {
        after: (_, I) =>
          hi(_) ? _.slice(I.length) : "" === I ? _ : _.slice(I.length + 1),
        concat: (_, I) =>
          hi(_)
            ? ((_ = [..._]), I && _.push(I), _)
            : I && void 0 !== I.toString
            ? ("" !== _ && (_ += "."), Ic(I) ? _ + I.toString() : _ + I)
            : _,
        initial: (_) => {
          if (hi(_)) return _.slice(0, -1);
          if ("" === _) return _;
          let I = _.lastIndexOf(".");
          return -1 === I ? "" : _.slice(0, I);
        },
        last: (_) => {
          if (hi(_)) return _[_.length - 1] || "";
          if ("" === _) return _;
          let I = _.lastIndexOf(".");
          return -1 === I ? _ : _.slice(I + 1);
        },
        walk: (_, I) => {
          if (hi(_)) for (let R of _) I(R);
          else if ("" !== _) {
            let R = 0,
              B = _.indexOf(".");
            if (-1 === B) I(_);
            else
              for (; R < _.length; )
                -1 === B && (B = _.length),
                  I(_.slice(R, B)),
                  (R = B + 1),
                  (B = _.indexOf(".", R));
          }
        },
        get(_, I) {
          return (
            this.walk(I, (I) => {
              _ && (_ = _[I]);
            }),
            _
          );
        },
      };
      function Hy(_, I, R) {
        return (
          _.isUnsubscribed ||
          (I.ignoreSymbols && Ic(R)) ||
          (I.ignoreUnderscores && "_" === R.charAt(0)) ||
          ("ignoreKeys" in I && I.ignoreKeys.includes(R))
        );
      }
      var ha = class {
        constructor(_) {
          (this._equals = _),
            (this._proxyCache = new WeakMap()),
            (this._pathCache = new WeakMap()),
            (this.isUnsubscribed = !1);
        }
        _getDescriptorCache() {
          return (
            void 0 === this._descriptorCache &&
              (this._descriptorCache = new WeakMap()),
            this._descriptorCache
          );
        }
        _getProperties(_) {
          let I = this._getDescriptorCache(),
            R = I.get(_);
          return void 0 === R && ((R = {}), I.set(_, R)), R;
        }
        _getOwnPropertyDescriptor(_, I) {
          if (this.isUnsubscribed)
            return Reflect.getOwnPropertyDescriptor(_, I);
          let R = this._getProperties(_),
            B = R[I];
          return (
            void 0 === B &&
              ((B = Reflect.getOwnPropertyDescriptor(_, I)), (R[I] = B)),
            B
          );
        }
        getProxy(_, I, R, B) {
          if (this.isUnsubscribed) return _;
          let z = _[B],
            k = z || _;
          this._pathCache.set(k, I);
          let V = this._proxyCache.get(k);
          return (
            void 0 === V &&
              ((V = void 0 === z ? new Proxy(_, R) : _),
              this._proxyCache.set(k, V)),
            V
          );
        }
        getPath(_) {
          return this.isUnsubscribed ? void 0 : this._pathCache.get(_);
        }
        isDetached(_, I) {
          return !Object.is(_, hr.get(I, this.getPath(_)));
        }
        defineProperty(_, I, R) {
          return (
            !!Reflect.defineProperty(_, I, R) &&
            (this.isUnsubscribed || (this._getProperties(_)[I] = R), !0)
          );
        }
        setProperty(_, I, R, B, z) {
          if (!this._equals(z, R) || !(I in _)) {
            let z = this._getOwnPropertyDescriptor(_, I);
            return void 0 !== z && "set" in z
              ? Reflect.set(_, I, R, B)
              : Reflect.set(_, I, R);
          }
          return !0;
        }
        deleteProperty(_, I, R) {
          if (Reflect.deleteProperty(_, I)) {
            if (!this.isUnsubscribed) {
              let B = this._getDescriptorCache().get(_);
              B && (delete B[I], this._pathCache.delete(R));
            }
            return !0;
          }
          return !1;
        }
        isSameDescriptor(_, I, R) {
          let B = this._getOwnPropertyDescriptor(I, R);
          return (
            void 0 !== _ &&
            void 0 !== B &&
            Object.is(_.value, B.value) &&
            (_.writable || !1) === (B.writable || !1) &&
            (_.enumerable || !1) === (B.enumerable || !1) &&
            (_.configurable || !1) === (B.configurable || !1) &&
            _.get === B.get &&
            _.set === B.set
          );
        }
        isGetInvariant(_, I) {
          let R = this._getOwnPropertyDescriptor(_, I);
          return void 0 !== R && !0 !== R.configurable && !0 !== R.writable;
        }
        unsubscribe() {
          (this._descriptorCache = null),
            (this._pathCache = null),
            (this._proxyCache = null),
            (this.isUnsubscribed = !0);
        }
      };
      function dh(_) {
        return "[object Object]" === toString.call(_);
      }
      function fh() {
        return !0;
      }
      function xl(_, I) {
        return _.length !== I.length || _.some((_, R) => I[R] !== _);
      }
      var ho = new Set([
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "toLocaleString",
          "toString",
          "valueOf",
        ]),
        hl = new Set([
          "concat",
          "includes",
          "indexOf",
          "join",
          "keys",
          "lastIndexOf",
        ]),
        hh = {
          push: fh,
          pop: fh,
          shift: fh,
          unshift: fh,
          copyWithin: xl,
          reverse: xl,
          sort: xl,
          splice: xl,
          flat: xl,
          fill: xl,
        },
        hc = new Set([...ho, ...hl, ...Object.keys(hh)]);
      function ph(_, I) {
        if (_.size !== I.size) return !0;
        for (let R of _) if (!I.has(R)) return !0;
        return !1;
      }
      var hd = ["keys", "values", "entries"],
        hu = new Set(["has", "toString"]),
        hp = { add: ph, clear: ph, delete: ph, forEach: ph },
        hf = new Set([...hu, ...Object.keys(hp), ...hd]);
      function mh(_, I) {
        let R;
        if (_.size !== I.size) return !0;
        for (let [B, z] of _)
          if ((R = I.get(B)) !== z || (void 0 === R && !I.has(B))) return !0;
        return !1;
      }
      var hx = new Set([...hu, "get"]),
        hw = { set: mh, clear: mh, delete: mh, forEach: mh },
        h_ = new Set([...hx, ...Object.keys(hw), ...hd]),
        hS = class {
          constructor(_, I, R, B) {
            (this._path = I),
              (this._isChanged = !1),
              (this._clonedCache = new Set()),
              (this._hasOnValidate = B),
              (this._changes = B ? [] : null),
              (this.clone = void 0 === I ? _ : this._shallowClone(_));
          }
          static isHandledMethod(_) {
            return ho.has(_);
          }
          _shallowClone(_) {
            let I = _;
            if (dh(_)) I = { ..._ };
            else if (hi(_)) I = [..._];
            else if (_ instanceof Date) I = new Date(_);
            else if (_ instanceof Set)
              I = new Set([..._].map((_) => this._shallowClone(_)));
            else if (_ instanceof Map)
              for (let [R, B] of ((I = new Map()), _.entries()))
                I.set(R, this._shallowClone(B));
            return this._clonedCache.add(I), I;
          }
          preferredThisArg(_, I, R, B) {
            return _
              ? (hi(B)
                  ? (this._onIsChanged = hh[I])
                  : B instanceof Set
                  ? (this._onIsChanged = hp[I])
                  : B instanceof Map && (this._onIsChanged = hw[I]),
                B)
              : R;
          }
          update(_, I, R) {
            let B = hr.after(_, this._path);
            if ("length" !== I) {
              let _ = this.clone;
              hr.walk(B, (I) => {
                _ &&
                  _[I] &&
                  (this._clonedCache.has(_[I]) ||
                    (_[I] = this._shallowClone(_[I])),
                  (_ = _[I]));
              }),
                this._hasOnValidate &&
                  this._changes.push({ path: B, property: I, previous: R }),
                _ && _[I] && (_[I] = R);
            }
            this._isChanged = !0;
          }
          undo(_) {
            let I;
            for (let R = this._changes.length - 1; -1 !== R; R--)
              (I = this._changes[R]),
                (hr.get(_, I.path)[I.property] = I.previous);
          }
          isChanged(_) {
            return void 0 === this._onIsChanged
              ? this._isChanged
              : this._onIsChanged(this.clone, _);
          }
        },
        hA = class extends hS {
          static isHandledMethod(_) {
            return hc.has(_);
          }
        },
        hE = class extends hS {
          undo(_) {
            _.setTime(this.clone.getTime());
          }
          isChanged(_, I) {
            return !I(this.clone.valueOf(), _.valueOf());
          }
        },
        hC = class extends hS {
          static isHandledMethod(_) {
            return hf.has(_);
          }
          undo(_) {
            for (let I of this.clone) _.add(I);
            for (let I of _) this.clone.has(I) || _.delete(I);
          }
        },
        hT = class extends hS {
          static isHandledMethod(_) {
            return h_.has(_);
          }
          undo(_) {
            for (let [I, R] of this.clone.entries()) _.set(I, R);
            for (let I of _.keys()) this.clone.has(I) || _.delete(I);
          }
        },
        hP = class extends hS {
          constructor(_, I, R, B) {
            super(void 0, I, R, B),
              (this._arg1 = R[0]),
              (this._weakValue = _.has(this._arg1));
          }
          isChanged(_) {
            return this._weakValue !== _.has(this._arg1);
          }
          undo(_) {
            this._weakValue && !_.has(this._arg1)
              ? _.add(this._arg1)
              : _.delete(this._arg1);
          }
        },
        hD = class extends hS {
          constructor(_, I, R, B) {
            super(void 0, I, R, B),
              (this._weakKey = R[0]),
              (this._weakHas = _.has(this._weakKey)),
              (this._weakValue = _.get(this._weakKey));
          }
          isChanged(_) {
            return this._weakValue !== _.get(this._weakKey);
          }
          undo(_) {
            let I = _.has(this._weakKey);
            this._weakHas && !I
              ? _.set(this._weakKey, this._weakValue)
              : !this._weakHas && I
              ? _.delete(this._weakKey)
              : this._weakValue !== _.get(this._weakKey) &&
                _.set(this._weakKey, this._weakValue);
          }
        },
        hO = class {
          constructor(_) {
            (this._stack = []), (this._hasOnValidate = _);
          }
          static isHandledType(_) {
            return dh(_) || hi(_) || zp(_);
          }
          static isHandledMethod(_, I) {
            return dh(_)
              ? hS.isHandledMethod(I)
              : hi(_)
              ? hA.isHandledMethod(I)
              : _ instanceof Set
              ? hC.isHandledMethod(I)
              : _ instanceof Map
              ? hT.isHandledMethod(I)
              : zp(_);
          }
          get isCloning() {
            return this._stack.length > 0;
          }
          start(_, I, R) {
            let B = hS;
            hi(_)
              ? (B = hA)
              : _ instanceof Date
              ? (B = hE)
              : _ instanceof Set
              ? (B = hC)
              : _ instanceof Map
              ? (B = hT)
              : _ instanceof WeakSet
              ? (B = hP)
              : _ instanceof WeakMap && (B = hD),
              this._stack.push(new B(_, I, R, this._hasOnValidate));
          }
          update(_, I, R) {
            this._stack[this._stack.length - 1].update(_, I, R);
          }
          preferredThisArg(_, I, R) {
            let { name: B } = _,
              z = hO.isHandledMethod(R, B);
            return this._stack[this._stack.length - 1].preferredThisArg(
              z,
              B,
              I,
              R
            );
          }
          isChanged(_, I, R) {
            return this._stack[this._stack.length - 1].isChanged(_, I, R);
          }
          undo(_) {
            void 0 !== this._previousClone && this._previousClone.undo(_);
          }
          stop() {
            return (
              (this._previousClone = this._stack.pop()),
              this._previousClone.clone
            );
          }
        },
        hL = {
          equals: Object.is,
          isShallow: !1,
          pathAsArray: !1,
          ignoreSymbols: !1,
          ignoreUnderscores: !1,
          ignoreDetached: !1,
          details: !1,
        },
        Gw = (_, I, R = {}) => {
          R = { ...hL, ...R };
          let B = Symbol("ProxyTarget"),
            { equals: z, isShallow: k, ignoreDetached: V, details: j } = R,
            G = new ha(z),
            q = "function" == typeof R.onValidate,
            X = new hO(q),
            h = (_, I, B, z, k) =>
              !q ||
              X.isCloning ||
              !0 === R.onValidate(hr.concat(G.getPath(_), I), B, z, k),
            d = (I, B, z, k) => {
              Hy(G, R, B) ||
                (V && G.isDetached(I, _)) ||
                f(G.getPath(I), B, z, k);
            },
            f = (_, R, B, z, k) => {
              X.isCloning ? X.update(_, R, z) : I(hr.concat(_, R), B, z, k);
            },
            p = (_) => _ && (_[B] || _),
            m = (I, z, j, q) =>
              ("object" == typeof I ? null === I : "function" != typeof I) ||
              I instanceof RegExp ||
              "constructor" === j ||
              (k && !hO.isHandledMethod(z, j)) ||
              Hy(G, R, j) ||
              G.isGetInvariant(z, j) ||
              (V && G.isDetached(z, _))
                ? I
                : (void 0 === q && (q = G.getPath(z)),
                  G.getProxy(I, hr.concat(q, j), Q, B)),
            Q = {
              get(_, I, R) {
                if (Ic(I)) {
                  if (I === B || I === l7) return _;
                  if (
                    I === he &&
                    !G.isUnsubscribed &&
                    0 === G.getPath(_).length
                  )
                    return G.unsubscribe(), _;
                }
                return m(
                  zp(_) ? Reflect.get(_, I) : Reflect.get(_, I, R),
                  _,
                  I
                );
              },
              set(_, I, R, k) {
                R = p(R);
                let V = _[B] || _,
                  j = V[I];
                if (z(j, R) && I in _) return !0;
                let q = h(_, I, R, j);
                return q && G.setProperty(V, I, R, k, j)
                  ? (d(_, I, _[I], j), !0)
                  : !q;
              },
              defineProperty(_, I, R) {
                if (!G.isSameDescriptor(R, _, I)) {
                  let B = _[I];
                  h(_, I, R.value, B) &&
                    G.defineProperty(_, I, R, B) &&
                    d(_, I, R.value, B);
                }
                return !0;
              },
              deleteProperty(_, I) {
                if (!Reflect.has(_, I)) return !0;
                let R = Reflect.get(_, I),
                  B = h(_, I, void 0, R);
                return B && G.deleteProperty(_, I, R)
                  ? (d(_, I, void 0, R), !0)
                  : !B;
              },
              apply(I, R, k) {
                let V = R[B] || R;
                if (G.isUnsubscribed) return Reflect.apply(I, V, k);
                if (
                  (!1 === j || (!0 !== j && !j.includes(I.name))) &&
                  hO.isHandledType(V)
                ) {
                  var q;
                  let B = hr.initial(G.getPath(I)),
                    j = hO.isHandledMethod(V, I.name);
                  X.start(V, B, k);
                  let $ = Reflect.apply(
                      I,
                      X.preferredThisArg(I, R, V),
                      j ? k.map((_) => p(_)) : k
                    ),
                    et = X.isChanged(V, z),
                    er = X.stop();
                  if (
                    (hO.isHandledType($) &&
                      j &&
                      (R instanceof Map &&
                        "get" === I.name &&
                        (B = hr.concat(B, k[0])),
                      ($ = G.getProxy($, B, Q))),
                    et)
                  ) {
                    let R = { name: I.name, args: k, result: $ },
                      z = X.isCloning ? hr.initial(B) : B,
                      j = X.isCloning ? hr.last(B) : "";
                    h(hr.get(_, z), j, V, er, R)
                      ? f(z, j, V, er, R)
                      : X.undo(V);
                  }
                  return (R instanceof Map || R instanceof Set) &&
                    "object" == typeof (q = $) &&
                    "function" == typeof q.next
                    ? (function (_, I, R, B, z) {
                        let k = _.next;
                        if ("entries" === I.name)
                          _.next = function () {
                            let _ = k.call(this);
                            return (
                              !1 === _.done &&
                                ((_.value[0] = z(_.value[0], I, _.value[0], B)),
                                (_.value[1] = z(_.value[1], I, _.value[0], B))),
                              _
                            );
                          };
                        else if ("values" === I.name) {
                          let V = R[l7].keys();
                          _.next = function () {
                            let _ = k.call(this);
                            return (
                              !1 === _.done &&
                                (_.value = z(_.value, I, V.next().value, B)),
                              _
                            );
                          };
                        } else
                          _.next = function () {
                            let _ = k.call(this);
                            return (
                              !1 === _.done &&
                                (_.value = z(_.value, I, _.value, B)),
                              _
                            );
                          };
                        return _;
                      })($, I, R, B, m)
                    : $;
                }
                return Reflect.apply(I, R, k);
              },
            },
            $ = G.getProxy(_, R.pathAsArray ? [] : "", Q);
          return (I = I.bind($)), q && (R.onValidate = R.onValidate.bind($)), $;
        };
      (Gw.target = (_) => (_ && _[l7]) || _),
        (Gw.unsubscribe = (_) => _[he] || _);
      var hz =
          "object" == typeof global &&
          global &&
          global.Object === Object &&
          global,
        hF = "object" == typeof self && self && self.Object === Object && self,
        hN = hz || hF || Function("return this")(),
        hk = hN.Symbol,
        hV = Object.prototype,
        hj = hV.hasOwnProperty,
        hG = hV.toString,
        hH = hk ? hk.toStringTag : void 0,
        dC = function (_) {
          var I = hj.call(_, hH),
            R = _[hH];
          try {
            _[hH] = void 0;
            var B = !0;
          } catch {}
          var z = hG.call(_);
          return B && (I ? (_[hH] = R) : delete _[hH]), z;
        },
        hW = Object.prototype.toString,
        hq = hk ? hk.toStringTag : void 0,
        os = function (_) {
          return null == _
            ? void 0 === _
              ? "[object Undefined]"
              : "[object Null]"
            : hq && hq in Object(_)
            ? dC(_)
            : hW.call(_);
        },
        rn = function (_) {
          return null != _ && "object" == typeof _;
        },
        bl = function (_) {
          return "symbol" == typeof _ || (rn(_) && "[object Symbol]" == os(_));
        },
        Yy = function (_, I) {
          for (
            var R = -1, B = null == _ ? 0 : _.length, z = Array(B);
            ++R < B;

          )
            z[R] = I(_[R], R, _);
          return z;
        },
        hY = Array.isArray,
        hX = 1 / 0,
        hQ = hk ? hk.prototype : void 0,
        hZ = hQ ? hQ.toString : void 0,
        vC = function yC(_) {
          if ("string" == typeof _) return _;
          if (hY(_)) return Yy(_, yC) + "";
          if (bl(_)) return hZ ? hZ.call(_) : "";
          var I = _ + "";
          return "0" == I && 1 / _ == -hX ? "-0" : I;
        },
        hK = /\s/,
        xC = function (_) {
          for (var I = _.length; I-- && hK.test(_.charAt(I)); );
          return I;
        },
        hJ = /^\s+/,
        bi = function (_) {
          var I = typeof _;
          return null != _ && ("object" == I || "function" == I);
        },
        h$ = 0 / 0,
        h0 = /^[-+]0x[0-9a-f]+$/i,
        h2 = /^0b[01]+$/i,
        h3 = /^0o[0-7]+$/i,
        h4 = parseInt,
        Hw = function (_) {
          if ("number" == typeof _) return _;
          if (bl(_)) return h$;
          if (bi(_)) {
            var I,
              R = "function" == typeof _.valueOf ? _.valueOf() : _;
            _ = bi(R) ? R + "" : R;
          }
          if ("string" != typeof _) return 0 === _ ? _ : +_;
          _ = (I = _) && I.slice(0, xC(I) + 1).replace(hJ, "");
          var B = h2.test(_);
          return B || h3.test(_)
            ? h4(_.slice(2), B ? 2 : 8)
            : h0.test(_)
            ? h$
            : +_;
        },
        Xy = function (_) {
          if (!bi(_)) return !1;
          var I = os(_);
          return (
            "[object Function]" == I ||
            "[object GeneratorFunction]" == I ||
            "[object AsyncFunction]" == I ||
            "[object Proxy]" == I
          );
        },
        h5 = hN["__core-js_shared__"],
        h6 = (ux = /[^.]+$/.exec((h5 && h5.keys && h5.keys.IE_PROTO) || ""))
          ? "Symbol(src)_1." + ux
          : "",
        h8 = Function.prototype.toString,
        Sa = function (_) {
          if (null != _) {
            try {
              return h8.call(_);
            } catch {}
            try {
              return _ + "";
            } catch {}
          }
          return "";
        },
        h9 = /^\[object .+?Constructor\]$/,
        h7 = Object.prototype,
        ce = Function.prototype.toString,
        ct = h7.hasOwnProperty,
        cr = RegExp(
          "^" +
            ce
              .call(ct)
              .replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
              .replace(
                /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                "$1.*?"
              ) +
            "$"
        ),
        Fn = function (_, I) {
          var R,
            B = _?.[I];
          return bi((R = B)) &&
            (!h6 || !(h6 in R)) &&
            (Xy(R) ? cr : h9).test(Sa(R))
            ? B
            : void 0;
        },
        cs = Fn(hN, "WeakMap"),
        ca = Object.create,
        cn = (function () {
          function n() {}
          return function (_) {
            if (!bi(_)) return {};
            if (ca) return ca(_);
            n.prototype = _;
            var I = new n();
            return (n.prototype = void 0), I;
          };
        })(),
        PC = function (_, I, R) {
          switch (R.length) {
            case 0:
              return _.call(I);
            case 1:
              return _.call(I, R[0]);
            case 2:
              return _.call(I, R[0], R[1]);
            case 3:
              return _.call(I, R[0], R[1], R[2]);
          }
          return _.apply(I, R);
        },
        DC = function (_, I) {
          var R = -1,
            B = _.length;
          for (I || (I = Array(B)); ++R < B; ) I[R] = _[R];
          return I;
        },
        cl = Date.now,
        ch = (function () {
          try {
            var _ = Fn(Object, "defineProperty");
            return _({}, "", {}), _;
          } catch {}
        })(),
        cc = ch
          ? function (_, I) {
              return ch(_, "toString", {
                configurable: !0,
                enumerable: !1,
                value: function () {
                  return I;
                },
                writable: !0,
              });
            }
          : function (_) {
              return _;
            },
        cd =
          ((u_ = 0),
          (uS = 0),
          function () {
            var _ = cl(),
              I = 16 - (_ - uS);
            if (((uS = _), I > 0)) {
              if (++u_ >= 800) return arguments[0];
            } else u_ = 0;
            return cc.apply(void 0, arguments);
          }),
        BC = function (_, I) {
          for (
            var R = -1, B = null == _ ? 0 : _.length;
            ++R < B && !1 !== I(_[R], R, _);

          );
          return _;
        },
        cp = /^(?:0|[1-9]\d*)$/,
        bh = function (_, I) {
          var R = typeof _;
          return (
            !!(I = I ?? 9007199254740991) &&
            ("number" == R || ("symbol" != R && cp.test(_))) &&
            _ > -1 &&
            _ % 1 == 0 &&
            _ < I
          );
        },
        Zy = function (_, I, R) {
          "__proto__" == I && ch
            ? ch(_, I, {
                configurable: !0,
                enumerable: !0,
                value: R,
                writable: !0,
              })
            : (_[I] = R);
        },
        Sh = function (_, I) {
          return _ === I || (_ != _ && I != I);
        },
        cf = Object.prototype.hasOwnProperty,
        wh = function (_, I, R) {
          var B = _[I];
          (cf.call(_, I) && Sh(B, R) && (void 0 !== R || I in _)) ||
            Zy(_, I, R);
        },
        Mo = function (_, I, R, B) {
          var z = !R;
          R || (R = {});
          for (var k = -1, V = I.length; ++k < V; ) {
            var j = I[k],
              G = B ? B(R[j], _[j], j, R, _) : void 0;
            void 0 === G && (G = _[j]), z ? Zy(R, j, G) : wh(R, j, G);
          }
          return R;
        },
        cg = Math.max,
        Ah = function (_) {
          return (
            "number" == typeof _ &&
            _ > -1 &&
            _ % 1 == 0 &&
            _ <= 9007199254740991
          );
        },
        Jy = function (_) {
          return null != _ && Ah(_.length) && !Xy(_);
        },
        cv = Object.prototype,
        _h = function (_) {
          var I = _ && _.constructor;
          return _ === (("function" == typeof I && I.prototype) || cv);
        },
        kC = function (_, I) {
          for (var R = -1, B = Array(_); ++R < _; ) B[R] = I(R);
          return B;
        },
        Ww = function (_) {
          return rn(_) && "[object Arguments]" == os(_);
        },
        cy = Object.prototype,
        cx = cy.hasOwnProperty,
        cS = cy.propertyIsEnumerable,
        cA = Ww(
          (function () {
            return arguments;
          })()
        )
          ? Ww
          : function (_) {
              return rn(_) && cx.call(_, "callee") && !cS.call(_, "callee");
            },
        cC =
          "object" == typeof exports && exports && !exports.nodeType && exports,
        cT =
          cC &&
          "object" == typeof module &&
          module &&
          !module.nodeType &&
          module,
        cR = cT && cT.exports === cC ? hN.Buffer : void 0,
        cL =
          (cR ? cR.isBuffer : void 0) ||
          function () {
            return !1;
          },
        cz = {};
      (cz["[object Float32Array]"] =
        cz["[object Float64Array]"] =
        cz["[object Int8Array]"] =
        cz["[object Int16Array]"] =
        cz["[object Int32Array]"] =
        cz["[object Uint8Array]"] =
        cz["[object Uint8ClampedArray]"] =
        cz["[object Uint16Array]"] =
        cz["[object Uint32Array]"] =
          !0),
        (cz["[object Arguments]"] =
          cz["[object Array]"] =
          cz["[object ArrayBuffer]"] =
          cz["[object Boolean]"] =
          cz["[object DataView]"] =
          cz["[object Date]"] =
          cz["[object Error]"] =
          cz["[object Function]"] =
          cz["[object Map]"] =
          cz["[object Number]"] =
          cz["[object Object]"] =
          cz["[object RegExp]"] =
          cz["[object Set]"] =
          cz["[object String]"] =
          cz["[object WeakMap]"] =
            !1);
      var Th = function (_) {
          return function (I) {
            return _(I);
          };
        },
        cF =
          "object" == typeof exports && exports && !exports.nodeType && exports,
        cN =
          cF &&
          "object" == typeof module &&
          module &&
          !module.nodeType &&
          module,
        ck = cN && cN.exports === cF && hz.process,
        cV = (function () {
          try {
            return (
              (cN && cN.require && cN.require("util").types) ||
              (ck && ck.binding && ck.binding("util"))
            );
          } catch {}
        })(),
        cj = cV && cV.isTypedArray,
        cH = cj
          ? Th(cj)
          : function (_) {
              return rn(_) && Ah(_.length) && !!cz[os(_)];
            },
        cW = Object.prototype.hasOwnProperty,
        ev = function (_, I) {
          var R = hY(_),
            B = !R && cA(_),
            z = !R && !B && cL(_),
            k = !R && !B && !z && cH(_),
            V = R || B || z || k,
            j = V ? kC(_.length, String) : [],
            G = j.length;
          for (var q in _)
            (I || cW.call(_, q)) &&
              !(
                V &&
                ("length" == q ||
                  (z && ("offset" == q || "parent" == q)) ||
                  (k &&
                    ("buffer" == q ||
                      "byteLength" == q ||
                      "byteOffset" == q)) ||
                  bh(q, G))
              ) &&
              j.push(q);
          return j;
        },
        tv = function (_, I) {
          return function (R) {
            return _(I(R));
          };
        },
        cq = tv(Object.keys, Object),
        cY = Object.prototype.hasOwnProperty,
        XC = function (_) {
          if (!_h(_)) return cq(_);
          var I = [];
          for (var R in Object(_))
            cY.call(_, R) && "constructor" != R && I.push(R);
          return I;
        },
        Mh = function (_) {
          return Jy(_) ? ev(_) : XC(_);
        },
        QC = function (_) {
          var I = [];
          if (null != _) for (var R in Object(_)) I.push(R);
          return I;
        },
        cX = Object.prototype.hasOwnProperty,
        KC = function (_) {
          if (!bi(_)) return QC(_);
          var I = _h(_),
            R = [];
          for (var B in _)
            ("constructor" == B && (I || !cX.call(_, B))) || R.push(B);
          return R;
        },
        bs = function (_) {
          return Jy(_) ? ev(_, !0) : KC(_);
        },
        cQ = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        cZ = /^\w*$/,
        ZC = function (_, I) {
          if (hY(_)) return !1;
          var R = typeof _;
          return (
            !!(
              "number" == R ||
              "symbol" == R ||
              "boolean" == R ||
              null == _ ||
              bl(_)
            ) ||
            cZ.test(_) ||
            !cQ.test(_) ||
            (null != I && _ in Object(I))
          );
        },
        cK = Fn(Object, "create"),
        cJ = Object.prototype.hasOwnProperty,
        c$ = Object.prototype.hasOwnProperty;
      function Ch(_) {
        var I = -1,
          R = null == _ ? 0 : _.length;
        for (this.clear(); ++I < R; ) {
          var B = _[I];
          this.set(B[0], B[1]);
        }
      }
      (Ch.prototype.clear = function () {
        (this.__data__ = cK ? cK(null) : {}), (this.size = 0);
      }),
        (Ch.prototype.delete = function (_) {
          var I = this.has(_) && delete this.__data__[_];
          return (this.size -= I ? 1 : 0), I;
        }),
        (Ch.prototype.get = function (_) {
          var I = this.__data__;
          if (cK) {
            var R = I[_];
            return "__lodash_hash_undefined__" === R ? void 0 : R;
          }
          return cJ.call(I, _) ? I[_] : void 0;
        }),
        (Ch.prototype.has = function (_) {
          var I = this.__data__;
          return cK ? void 0 !== I[_] : c$.call(I, _);
        }),
        (Ch.prototype.set = function (_, I) {
          var R = this.__data__;
          return (
            (this.size += this.has(_) ? 0 : 1),
            (R[_] = cK && void 0 === I ? "__lodash_hash_undefined__" : I),
            this
          );
        });
      var Sl = function (_, I) {
          for (var R = _.length; R--; ) if (Sh(_[R][0], I)) return R;
          return -1;
        },
        c1 = Array.prototype.splice;
      function Ph(_) {
        var I = -1,
          R = null == _ ? 0 : _.length;
        for (this.clear(); ++I < R; ) {
          var B = _[I];
          this.set(B[0], B[1]);
        }
      }
      (Ph.prototype.clear = function () {
        (this.__data__ = []), (this.size = 0);
      }),
        (Ph.prototype.delete = function (_) {
          var I = this.__data__,
            R = Sl(I, _);
          return (
            !(R < 0) &&
            (R == I.length - 1 ? I.pop() : c1.call(I, R, 1), --this.size, !0)
          );
        }),
        (Ph.prototype.get = function (_) {
          var I = this.__data__,
            R = Sl(I, _);
          return R < 0 ? void 0 : I[R][1];
        }),
        (Ph.prototype.has = function (_) {
          return Sl(this.__data__, _) > -1;
        }),
        (Ph.prototype.set = function (_, I) {
          var R = this.__data__,
            B = Sl(R, _);
          return B < 0 ? (++this.size, R.push([_, I])) : (R[B][1] = I), this;
        });
      var c2 = Fn(hN, "Map"),
        cP = function (_) {
          var I = typeof _;
          return "string" == I ||
            "number" == I ||
            "symbol" == I ||
            "boolean" == I
            ? "__proto__" !== _
            : null === _;
        },
        _l = function (_, I) {
          var R = _.__data__;
          return cP(I) ? R["string" == typeof I ? "string" : "hash"] : R.map;
        };
      function Dh(_) {
        var I = -1,
          R = null == _ ? 0 : _.length;
        for (this.clear(); ++I < R; ) {
          var B = _[I];
          this.set(B[0], B[1]);
        }
      }
      function Xw(_, I) {
        if ("function" != typeof _ || (null != I && "function" != typeof I))
          throw TypeError("Expected a function");
        var e = function () {
          var R = arguments,
            B = I ? I.apply(this, R) : R[0],
            z = e.cache;
          if (z.has(B)) return z.get(B);
          var k = _.apply(this, R);
          return (e.cache = z.set(B, k) || z), k;
        };
        return (e.cache = new (Xw.Cache || Dh)()), e;
      }
      (Dh.prototype.clear = function () {
        (this.size = 0),
          (this.__data__ = {
            hash: new Ch(),
            map: new (c2 || Ph)(),
            string: new Ch(),
          });
      }),
        (Dh.prototype.delete = function (_) {
          var I = _l(this, _).delete(_);
          return (this.size -= I ? 1 : 0), I;
        }),
        (Dh.prototype.get = function (_) {
          return _l(this, _).get(_);
        }),
        (Dh.prototype.has = function (_) {
          return _l(this, _).has(_);
        }),
        (Dh.prototype.set = function (_, I) {
          var R = _l(this, _),
            B = R.size;
          return R.set(_, I), (this.size += R.size == B ? 0 : 1), this;
        }),
        (Xw.Cache = Dh);
      var c3 =
          /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
        c4 = /\\(\\)?/g,
        c5 =
          ((uC = (uA = Xw(
            function (_) {
              var I = [];
              return (
                46 === _.charCodeAt(0) && I.push(""),
                _.replace(c3, function (_, R, B, z) {
                  I.push(B ? z.replace(c4, "$1") : R || _);
                }),
                I
              );
            },
            function (_) {
              return 500 === uC.size && uC.clear(), _;
            }
          )).cache),
          uA),
        Ss = function (_, I) {
          return hY(_) ? _ : ZC(_, I) ? [_] : c5(null == _ ? "" : vC(_));
        },
        c6 = 1 / 0,
        El = function (_) {
          if ("string" == typeof _ || bl(_)) return _;
          var I = _ + "";
          return "0" == I && 1 / _ == -c6 ? "-0" : I;
        },
        rv = function (_, I) {
          I = Ss(I, _);
          for (var R = 0, B = I.length; null != _ && R < B; ) _ = _[El(I[R++])];
          return R && R == B ? _ : void 0;
        },
        Oh = function (_, I) {
          for (var R = -1, B = I.length, z = _.length; ++R < B; )
            _[z + R] = I[R];
          return _;
        },
        c8 = hk ? hk.isConcatSpreadable : void 0,
        xP = function (_) {
          return hY(_) || cA(_) || !!(c8 && _ && _[c8]);
        },
        SP = function bP(_, I, R, B, z) {
          var k = -1,
            V = _.length;
          for (R || (R = xP), z || (z = []); ++k < V; ) {
            var j = _[k];
            I > 0 && R(j)
              ? I > 1
                ? bP(j, I - 1, R, B, z)
                : Oh(z, j)
              : B || (z[z.length] = j);
          }
          return z;
        },
        iv = function (_) {
          var I;
          return cd(
            ((I = cg(((I = void 0), _.length - 1), 0)),
            function () {
              for (
                var R,
                  B = arguments,
                  z = -1,
                  k = cg(B.length - I, 0),
                  V = Array(k);
                ++z < k;

              )
                V[z] = B[I + z];
              z = -1;
              for (var j = Array(I + 1); ++z < I; ) j[z] = B[z];
              return (
                (j[I] = (null == (R = V) ? 0 : R.length) ? SP(R, 1) : []),
                PC(_, this, j)
              );
            }),
            _ + ""
          );
        },
        c9 = tv(Object.getPrototypeOf, Object),
        c7 = Object.prototype,
        dt = Function.prototype.toString,
        di = c7.hasOwnProperty,
        ds = dt.call(Object),
        _P = function (_) {
          if (!rn(_) || "[object Object]" != os(_)) return !1;
          var I = c9(_);
          if (null === I) return !0;
          var R = di.call(I, "constructor") && I.constructor;
          return "function" == typeof R && R instanceof R && dt.call(R) == ds;
        },
        EP = function (_, I, R) {
          var B = -1,
            z = _.length;
          I < 0 && (I = -I > z ? 0 : z + I),
            (R = R > z ? z : R) < 0 && (R += z),
            (z = I > R ? 0 : (R - I) >>> 0),
            (I >>>= 0);
          for (var k = Array(z); ++B < z; ) k[B] = _[B + I];
          return k;
        };
      function Rh(_) {
        var I = (this.__data__ = new Ph(_));
        this.size = I.size;
      }
      (Rh.prototype.clear = function () {
        (this.__data__ = new Ph()), (this.size = 0);
      }),
        (Rh.prototype.delete = function (_) {
          var I = this.__data__,
            R = I.delete(_);
          return (this.size = I.size), R;
        }),
        (Rh.prototype.get = function (_) {
          return this.__data__.get(_);
        }),
        (Rh.prototype.has = function (_) {
          return this.__data__.has(_);
        }),
        (Rh.prototype.set = function (_, I) {
          var R = this.__data__;
          if (R instanceof Ph) {
            var B = R.__data__;
            if (!c2 || B.length < 199)
              return B.push([_, I]), (this.size = ++R.size), this;
            R = this.__data__ = new Dh(B);
          }
          return R.set(_, I), (this.size = R.size), this;
        });
      var da =
          "object" == typeof exports && exports && !exports.nodeType && exports,
        dn =
          da &&
          "object" == typeof module &&
          module &&
          !module.nodeType &&
          module,
        dl = dn && dn.exports === da ? hN.Buffer : void 0,
        dc = dl ? dl.allocUnsafe : void 0,
        FP = function (_, I) {
          if (I) return _.slice();
          var R = _.length,
            B = dc ? dc(R) : new _.constructor(R);
          return _.copy(B), B;
        },
        kP = function (_, I) {
          for (
            var R = -1, B = null == _ ? 0 : _.length, z = 0, k = [];
            ++R < B;

          ) {
            var V = _[R];
            I(V, R, _) && (k[z++] = V);
          }
          return k;
        },
        nv = function () {
          return [];
        },
        du = Object.prototype.propertyIsEnumerable,
        dp = Object.getOwnPropertySymbols,
        df = dp
          ? function (_) {
              return null == _
                ? []
                : kP(dp((_ = Object(_))), function (I) {
                    return du.call(_, I);
                  });
            }
          : nv,
        dm = Object.getOwnPropertySymbols
          ? function (_) {
              for (var I = []; _; ) Oh(I, df(_)), (_ = c9(_));
              return I;
            }
          : nv,
        ov = function (_, I, R) {
          var B = I(_);
          return hY(_) ? B : Oh(B, R(_));
        },
        Yp = function (_) {
          return ov(_, Mh, df);
        },
        av = function (_) {
          return ov(_, bs, dm);
        },
        dy = Fn(hN, "DataView"),
        dx = Fn(hN, "Promise"),
        dw = Fn(hN, "Set"),
        dS = "[object Map]",
        dT = "[object Promise]",
        dP = "[object Set]",
        dL = "[object WeakMap]",
        dz = "[object DataView]",
        dF = Sa(dy),
        dN = Sa(c2),
        dk = Sa(dx),
        dV = Sa(dw),
        dj = Sa(cs),
        dG = os;
      ((dy && dG(new dy(new ArrayBuffer(1))) != dz) ||
        (c2 && dG(new c2()) != dS) ||
        (dx && dG(dx.resolve()) != dT) ||
        (dw && dG(new dw()) != dP) ||
        (cs && dG(new cs()) != dL)) &&
        (dG = function (_) {
          var I = os(_),
            R = "[object Object]" == I ? _.constructor : void 0,
            B = R ? Sa(R) : "";
          if (B)
            switch (B) {
              case dF:
                return dz;
              case dN:
                return dS;
              case dk:
                return dT;
              case dV:
                return dP;
              case dj:
                return dL;
            }
          return I;
        });
      var dH = dG,
        dW = Object.prototype.hasOwnProperty,
        YP = function (_) {
          var I = _.length,
            R = new _.constructor(I);
          return (
            I &&
              "string" == typeof _[0] &&
              dW.call(_, "index") &&
              ((R.index = _.index), (R.input = _.input)),
            R
          );
        },
        dq = hN.Uint8Array,
        Fh = function (_) {
          var I = new _.constructor(_.byteLength);
          return new dq(I).set(new dq(_)), I;
        },
        XP = function (_, I) {
          var R = I ? Fh(_.buffer) : _.buffer;
          return new _.constructor(R, _.byteOffset, _.byteLength);
        },
        dY = /\w*$/,
        QP = function (_) {
          var I = new _.constructor(_.source, dY.exec(_));
          return (I.lastIndex = _.lastIndex), I;
        },
        dX = hk ? hk.prototype : void 0,
        dQ = dX ? dX.valueOf : void 0,
        $P = function (_, I) {
          var R = I ? Fh(_.buffer) : _.buffer;
          return new _.constructor(R, _.byteOffset, _.length);
        },
        e2 = function (_, I, R) {
          var B = _.constructor;
          switch (I) {
            case "[object ArrayBuffer]":
              return Fh(_);
            case "[object Boolean]":
            case "[object Date]":
              return new B(+_);
            case "[object DataView]":
              return XP(_, R);
            case "[object Float32Array]":
            case "[object Float64Array]":
            case "[object Int8Array]":
            case "[object Int16Array]":
            case "[object Int32Array]":
            case "[object Uint8Array]":
            case "[object Uint8ClampedArray]":
            case "[object Uint16Array]":
            case "[object Uint32Array]":
              return $P(_, R);
            case "[object Map]":
            case "[object Set]":
              return new B();
            case "[object Number]":
            case "[object String]":
              return new B(_);
            case "[object RegExp]":
              return QP(_);
            case "[object Symbol]":
              return dQ ? Object(dQ.call(_)) : {};
          }
        },
        dZ = cV && cV.isMap,
        dK = dZ
          ? Th(dZ)
          : function (_) {
              return rn(_) && "[object Map]" == dH(_);
            },
        dJ = cV && cV.isSet,
        d$ = dJ
          ? Th(dJ)
          : function (_) {
              return rn(_) && "[object Set]" == dH(_);
            },
        d0 = "[object Arguments]",
        d2 = "[object Function]",
        d3 = "[object Object]",
        d4 = {};
      (d4[d0] =
        d4["[object Array]"] =
        d4["[object ArrayBuffer]"] =
        d4["[object DataView]"] =
        d4["[object Boolean]"] =
        d4["[object Date]"] =
        d4["[object Float32Array]"] =
        d4["[object Float64Array]"] =
        d4["[object Int8Array]"] =
        d4["[object Int16Array]"] =
        d4["[object Int32Array]"] =
        d4["[object Map]"] =
        d4["[object Number]"] =
        d4[d3] =
        d4["[object RegExp]"] =
        d4["[object Set]"] =
        d4["[object String]"] =
        d4["[object Symbol]"] =
        d4["[object Uint8Array]"] =
        d4["[object Uint8ClampedArray]"] =
        d4["[object Uint16Array]"] =
        d4["[object Uint32Array]"] =
          !0),
        (d4["[object Error]"] = d4[d2] = d4["[object WeakMap]"] = !1);
      var dv = function hv(_, I, R, B, z, k) {
          var V,
            j = 1 & I,
            G = 2 & I,
            q = 4 & I;
          if ((R && (V = z ? R(_, B, z, k) : R(_)), void 0 !== V)) return V;
          if (!bi(_)) return _;
          var X = hY(_);
          if (X) {
            if (((V = YP(_)), !j)) return DC(_, V);
          } else {
            var Q,
              $,
              et,
              er,
              es = dH(_),
              ea = es == d2 || "[object GeneratorFunction]" == es;
            if (cL(_)) return FP(_, j);
            if (es == d3 || es == d0 || (ea && !z)) {
              if (
                ((V =
                  G || ea
                    ? {}
                    : "function" != typeof _.constructor || _h(_)
                    ? {}
                    : cn(c9(_))),
                !j)
              )
                return G
                  ? (($ = (Q = V) && Mo(_, bs(_), Q)), Mo(_, dm(_), $))
                  : ((er = (et = V) && Mo(_, Mh(_), et)), Mo(_, df(_), er));
            } else {
              if (!d4[es]) return z ? _ : {};
              V = e2(_, es, j);
            }
          }
          k || (k = new Rh());
          var en = k.get(_);
          if (en) return en;
          k.set(_, V),
            d$(_)
              ? _.forEach(function (B) {
                  V.add(hv(B, I, R, B, _, k));
                })
              : dK(_) &&
                _.forEach(function (B, z) {
                  V.set(z, hv(B, I, R, z, _, k));
                });
          var eo = q ? (G ? av : Yp) : G ? bs : Mh,
            el = X ? void 0 : eo(_);
          return (
            BC(el || _, function (B, z) {
              el && (B = _[(z = B)]), wh(V, z, hv(B, I, R, z, _, k));
            }),
            V
          );
        },
        Ea = function (_) {
          return dv(_, 5);
        };
      function fv(_) {
        var I = -1,
          R = null == _ ? 0 : _.length;
        for (this.__data__ = new Dh(); ++I < R; ) this.add(_[I]);
      }
      (fv.prototype.add = fv.prototype.push =
        function (_) {
          return this.__data__.set(_, "__lodash_hash_undefined__"), this;
        }),
        (fv.prototype.has = function (_) {
          return this.__data__.has(_);
        });
      var p2 = function (_, I) {
          for (var R = -1, B = null == _ ? 0 : _.length; ++R < B; )
            if (I(_[R], R, _)) return !0;
          return !1;
        },
        pv = function (_, I, R, B, z, k) {
          var V = 1 & R,
            j = _.length,
            G = I.length;
          if (j != G && !(V && G > j)) return !1;
          var q = k.get(_),
            X = k.get(I);
          if (q && X) return q == I && X == _;
          var Q = -1,
            $ = !0,
            et = 2 & R ? new fv() : void 0;
          for (k.set(_, I), k.set(I, _); ++Q < j; ) {
            var er = _[Q],
              es = I[Q];
            if (B) var ea = V ? B(es, er, Q, I, _, k) : B(er, es, Q, _, I, k);
            if (void 0 !== ea) {
              if (ea) continue;
              $ = !1;
              break;
            }
            if (et) {
              if (
                !p2(I, function (_, I) {
                  if (!et.has(I) && (er === _ || z(er, _, R, B, k)))
                    return et.push(I);
                })
              ) {
                $ = !1;
                break;
              }
            } else if (!(er === es || z(er, es, R, B, k))) {
              $ = !1;
              break;
            }
          }
          return k.delete(_), k.delete(I), $;
        },
        g2 = function (_) {
          var I = -1,
            R = Array(_.size);
          return (
            _.forEach(function (_, B) {
              R[++I] = [B, _];
            }),
            R
          );
        },
        y2 = function (_) {
          var I = -1,
            R = Array(_.size);
          return (
            _.forEach(function (_) {
              R[++I] = _;
            }),
            R
          );
        },
        d5 = hk ? hk.prototype : void 0,
        d6 = d5 ? d5.valueOf : void 0,
        x2 = function (_, I, R, B, z, k, V) {
          switch (R) {
            case "[object DataView]":
              if (_.byteLength != I.byteLength || _.byteOffset != I.byteOffset)
                break;
              (_ = _.buffer), (I = I.buffer);
            case "[object ArrayBuffer]":
              return !(
                _.byteLength != I.byteLength || !k(new dq(_), new dq(I))
              );
            case "[object Boolean]":
            case "[object Date]":
            case "[object Number]":
              return Sh(+_, +I);
            case "[object Error]":
              return _.name == I.name && _.message == I.message;
            case "[object RegExp]":
            case "[object String]":
              return _ == I + "";
            case "[object Map]":
              var j = g2;
            case "[object Set]":
              var G = 1 & B;
              if ((j || (j = y2), _.size != I.size && !G)) break;
              var q = V.get(_);
              if (q) return q == I;
              (B |= 2), V.set(_, I);
              var X = pv(j(_), j(I), B, z, k, V);
              return V.delete(_), X;
            case "[object Symbol]":
              if (d6) return d6.call(_) == d6.call(I);
          }
          return !1;
        },
        d8 = Object.prototype.hasOwnProperty,
        b2 = function (_, I, R, B, z, k) {
          var V = 1 & R,
            j = Yp(_),
            G = j.length;
          if (G != Yp(I).length && !V) return !1;
          for (var q = G; q--; ) {
            var X = j[q];
            if (!(V ? X in I : d8.call(I, X))) return !1;
          }
          var Q = k.get(_),
            $ = k.get(I);
          if (Q && $) return Q == I && $ == _;
          var et = !0;
          k.set(_, I), k.set(I, _);
          for (var er = V; ++q < G; ) {
            var es = _[(X = j[q])],
              ea = I[X];
            if (B) var en = V ? B(ea, es, X, I, _, k) : B(es, ea, X, _, I, k);
            if (!(void 0 === en ? es === ea || z(es, ea, R, B, k) : en)) {
              et = !1;
              break;
            }
            er || (er = "constructor" == X);
          }
          if (et && !er) {
            var eo = _.constructor,
              el = I.constructor;
            eo != el &&
              "constructor" in _ &&
              "constructor" in I &&
              !(
                "function" == typeof eo &&
                eo instanceof eo &&
                "function" == typeof el &&
                el instanceof el
              ) &&
              (et = !1);
          }
          return k.delete(_), k.delete(I), et;
        },
        d9 = "[object Arguments]",
        d7 = "[object Array]",
        ue = "[object Object]",
        ut = Object.prototype.hasOwnProperty,
        _2 = function (_, I, R, B, z, k) {
          var V = hY(_),
            j = hY(I),
            G = V ? d7 : dH(_),
            q = j ? d7 : dH(I);
          (G = G == d9 ? ue : G), (q = q == d9 ? ue : q);
          var X = G == ue,
            Q = q == ue,
            $ = G == q;
          if ($ && cL(_)) {
            if (!cL(I)) return !1;
            (V = !0), (X = !1);
          }
          if ($ && !X)
            return (
              k || (k = new Rh()),
              V || cH(_) ? pv(_, I, R, B, z, k) : x2(_, I, G, R, B, z, k)
            );
          if (!(1 & R)) {
            var et = X && ut.call(_, "__wrapped__"),
              er = Q && ut.call(I, "__wrapped__");
            if (et || er) {
              var es = et ? _.value() : _,
                ea = er ? I.value() : I;
              return k || (k = new Rh()), z(es, ea, R, B, k);
            }
          }
          return !!$ && (k || (k = new Rh()), b2(_, I, R, B, z, k));
        },
        M2 = function (_, I) {
          return null != _ && I in Object(_);
        },
        C2 = function (_, I, R) {
          I = Ss(I, _);
          for (var B = -1, z = I.length, k = !1; ++B < z; ) {
            var V = El(I[B]);
            if (!(k = null != _ && R(_, V))) break;
            _ = _[V];
          }
          return k || ++B != z
            ? k
            : !!(z = null == _ ? 0 : _.length) &&
                Ah(z) &&
                bh(V, z) &&
                (hY(_) || cA(_));
        },
        gv = function () {
          return hN.Date.now();
        },
        ur = Math.max,
        us = Math.min,
        Nc = function (_, I, R) {
          var B,
            z,
            k,
            V,
            j,
            G,
            q = 0,
            X = !1,
            Q = !1,
            $ = !0;
          if ("function" != typeof _) throw TypeError("Expected a function");
          function f(I) {
            var R = B,
              k = z;
            return (B = z = void 0), (q = I), (V = _.apply(k, R));
          }
          function g(_) {
            var R = _ - G,
              B = _ - q;
            return void 0 === G || R >= I || R < 0 || (Q && B >= k);
          }
          function y() {
            var _,
              R,
              B,
              z = gv();
            if (g(z)) return v(z);
            j = setTimeout(
              y,
              ((_ = z - G), (R = z - q), (B = I - _), Q ? us(B, k - R) : B)
            );
          }
          function v(_) {
            return (j = void 0), $ && B ? f(_) : ((B = z = void 0), V);
          }
          function w() {
            var _,
              R = gv(),
              k = g(R);
            if (((B = arguments), (z = this), (G = R), k)) {
              if (void 0 === j)
                return (q = _ = G), (j = setTimeout(y, I)), X ? f(_) : V;
              if (Q) return clearTimeout(j), (j = setTimeout(y, I)), f(G);
            }
            return void 0 === j && (j = setTimeout(y, I)), V;
          }
          return (
            (I = Hw(I) || 0),
            bi(R) &&
              ((X = !!R.leading),
              (k = (Q = "maxWait" in R) ? ur(Hw(R.maxWait) || 0, I) : k),
              ($ = "trailing" in R ? !!R.trailing : $)),
            (w.cancel = function () {
              void 0 !== j && clearTimeout(j),
                (q = 0),
                (B = G = z = j = void 0);
            }),
            (w.flush = function () {
              return void 0 === j ? V : v(gv());
            }),
            w
          );
        },
        D2 = function (_) {
          var I = null == _ ? 0 : _.length;
          return I ? _[I - 1] : void 0;
        },
        Xp = function (_, I) {
          return (function E2(_, I, R, B, z) {
            return (
              _ === I ||
              (null != _ && null != I && (rn(_) || rn(I))
                ? _2(_, I, R, B, E2, z)
                : _ != _ && I != I)
            );
          })(_, I);
        },
        I2 = function (_, I) {
          var R, B;
          return (
            (I = Ss(I, _)),
            (R = _),
            null == (_ = (B = I).length < 2 ? R : rv(R, EP(B, 0, -1))) ||
              delete _[El(D2(I))]
          );
        },
        R2 = function (_) {
          return _P(_) ? void 0 : _;
        },
        ua = iv(function (_, I) {
          var R = {};
          if (null == _) return R;
          var B = !1;
          (I = Yy(I, function (I) {
            return (I = Ss(I, _)), B || (B = I.length > 1), I;
          })),
            Mo(_, av(_), R),
            B && (R = dv(R, 7, R2));
          for (var z = I.length; z--; ) I2(R, I[z]);
          return R;
        }),
        L2 = function (_, I, R, B) {
          if (!bi(_)) return _;
          I = Ss(I, _);
          for (
            var z = -1, k = I.length, V = k - 1, j = _;
            null != j && ++z < k;

          ) {
            var G = El(I[z]),
              q = R;
            if ("__proto__" === G || "constructor" === G || "prototype" === G)
              break;
            if (z != V) {
              var X = j[G];
              void 0 === (q = B ? B(X, G, j) : void 0) &&
                (q = bi(X) ? X : bh(I[z + 1]) ? [] : {});
            }
            wh(j, G, q), (j = j[G]);
          }
          return _;
        },
        B2 = function (_, I, R) {
          for (var B = -1, z = I.length, k = {}; ++B < z; ) {
            var V = I[B],
              j = rv(_, V);
            R(j, V) && L2(k, Ss(V, _), j);
          }
          return k;
        },
        uo = iv(function (_, I) {
          return null == _
            ? {}
            : B2(_, I, function (I, R) {
                return null != _ && C2(_, R, M2);
              });
        }),
        Kw = function (_, I, R) {
          var B = !0,
            z = !0;
          if ("function" != typeof _) throw TypeError("Expected a function");
          return (
            bi(R) &&
              ((B = "leading" in R ? !!R.leading : B),
              (z = "trailing" in R ? !!R.trailing : z)),
            Nc(_, I, { leading: B, maxWait: I, trailing: z })
          );
        };
      function yv(_) {
        for (let I of Object.keys(_)) void 0 === _[I] && delete _[I];
        return _;
      }
      function _n(_, I) {
        return Object.setPrototypeOf(_, I), _;
      }
      var ul =
          (!(typeof window > "u") &&
            window.navigator.userAgent.toLowerCase().includes(" electron/") &&
            (() => {
              if (typeof window > "u") return;
              let _ = new URLSearchParams(window.location.search).get(
                "desktop-app-version"
              );
              return _
                ? (window.localStorage.setItem("desktop-app-version", _), _)
                : window.localStorage.getItem("desktop-app-version") ?? "0.0.6";
            })(),
          !(typeof window > "u") &&
            window.navigator.platform.toUpperCase().includes("MAC")),
        uc =
          !(typeof window > "u") &&
          (/iPad|iPhone|iPod/.test(window.navigator.userAgent) ||
            (ul && "ontouchend" in document)),
        ud =
          !(typeof window > "u") &&
          window.navigator.userAgent.toLowerCase().indexOf("firefox") > -1,
        uu =
          !(typeof window > "u") &&
          ("ontouchstart" in window || navigator.maxTouchPoints > 0),
        up = (() => {
          if (typeof window > "u") return !1;
          let _ = navigator.userAgent,
            I = navigator.vendor;
          return /Safari/i.test(_) && /Apple Computer/.test(I);
        })(),
        uf = Number(
          (() => {
            if (typeof window > "u") return null;
            let _ = navigator.userAgent.match(/Version\/(\d+\.\d)/);
            return _ && _[1];
          })()
        );
      function vv(_) {
        return Array.isArray(_) ? _ : [_];
      }
      function xv(_, I) {
        let R = 0;
        for (; R < _.length && R < I.length; ) {
          if (_[R] < I[R]) return -1;
          if (_[R] > I[R]) return 1;
          R += 1;
        }
        return R !== I.length ? -1 : R !== _.length ? 1 : 0;
      }
      function Qp(_) {
        return ul ? _.metaKey : _.ctrlKey;
      }
      var um = [],
        ug = {},
        uv = {},
        uy = {};
      function V2(_) {
        um.includes(_) || um.push(_);
      }
      function Uh(_) {
        delete ug[_.pointerId];
        for (let I = 0; I < um.length; I++)
          if (um[I].pointerId === _.pointerId) {
            um.splice(I, 1);
            break;
          }
      }
      function wv(_) {
        if ("touch" !== _.pointerType) return;
        let I = ug[_.pointerId];
        void 0 === I && ((I = { x: 0, y: 0 }), (ug[_.pointerId] = I)),
          (I.x = _.pageX),
          (I.y = _.pageY);
      }
      function Av(_) {
        return ug[(_.pointerId === um[0].pointerId ? um[1] : um[0]).pointerId];
      }
      function U2(_) {
        (uv[_.key] = !0),
          (uy[_.key] = void 0 === uy[_.key] ? 1 : uy[_.key] + 1);
      }
      function G2(_) {
        if (ul && uv.Meta) for (let _ in uv) uv[_] = !1;
        else uv[_.key] = !1;
        uy = {};
      }
      var ux,
        u_,
        uS,
        uA,
        uC,
        uT,
        uP,
        uO,
        uI = new Promise((_) => {
          uT = _;
        }),
        uR = new Promise((_) => {
          uO = _;
        }),
        uL = class {
          modifyById(_, I) {
            if (void 0 === this[_]) throw Error("not expected");
            {
              let R = { ...this, [_]: I };
              return Object.setPrototypeOf(R, uL.prototype), R;
            }
          }
          add(_, I) {
            return this.runOp({ type: 1, id: _, data: I })?.data ?? this;
          }
          runOp(_) {
            if (1 === _.type) {
              let I = this[_.id],
                R;
              R =
                void 0 === I
                  ? { type: 2, id: _.id }
                  : { type: 1, id: _.id, data: I };
              let { id: B, data: z } = _,
                k = { ...this, [B]: z };
              return (
                Object.setPrototypeOf(k, uL.prototype),
                { data: k, actual: _, reverse: R }
              );
            }
            if (2 === _.type) {
              let { id: I } = _,
                R = this[I];
              if (void 0 === R) return null;
              {
                let B = { ...this };
                return (
                  Object.setPrototypeOf(B, uL.prototype),
                  delete B[I],
                  { data: B, actual: _, reverse: { type: 1, id: I, data: R } }
                );
              }
            }
            return null;
          }
        };
      function Zp(_) {
        if (void 0 !== _.deepFreeze) {
          _.deepFreeze(_);
          return;
        }
        for (let I of Object.getOwnPropertyNames(_)) {
          let R = _[I];
          R && "object" == typeof R && Zp(R);
        }
        return Object.freeze(_);
      }
      var uz = class extends Error {};
      function Tv(_) {
        let I = { ..._ };
        return Object.setPrototypeOf(I, Object.getPrototypeOf(_)), I;
      }
      function Co(_, I, R) {
        if (
          (void 0 === _
            ? void 0 === I
              ? ((_ = 0), (I = 10))
              : (_ = I - 10)
            : void 0 === I && (I = _ + 10),
          _ > I)
        ) {
          let R = _;
          (_ = I), (I = R);
        }
        let B = [],
          z = 1 / (R + 1);
        for (let k = 0; k < R; k++) {
          let R = _ + (I - _) * (k + 0.75 + 0.5 * Math.random()) * z;
          B.push(R);
        }
        return B;
      }
      function jh(_) {
        return (
          _ instanceof Uint8Array ||
          _ instanceof Uint16Array ||
          _ instanceof Uint32Array ||
          _ instanceof Int8Array ||
          _ instanceof Int16Array ||
          _ instanceof Int32Array ||
          _ instanceof Float32Array ||
          _ instanceof Float64Array
        );
      }
      var uF = class extends Array {
        constructor(..._) {
          super(..._), Object.setPrototypeOf(this, uF.prototype);
        }
        deepFreeze() {
          let _ = 0;
          for (; _ < this.length; ) Zp(this[_]), _++;
        }
        fillCaches0(_, I) {
          for (let R of (this.objCaches.set(_.id, _),
          this.parentCaches.set(_.id, I),
          _.children))
            this.fillCaches0(R, _.id);
        }
        fillCaches() {
          if (void 0 === this.objCaches)
            for (let _ of ((this.objCaches = new Map()),
            (this.parentCaches = new Map()),
            this))
              this.fillCaches0(_, null);
        }
        randomId() {
          this.fillCaches();
          let _ = Array.from(this.objCaches.keys());
          if (0 !== _.length)
            return _[Math.max(0, Math.floor(Math.random() * _.length) - 1)];
        }
        nonExistOrDescendantOf(_, I) {
          if (!this.has(_)) return !0;
          for (; _; ) {
            let R = this.parent(_);
            if (R === I) return !0;
            _ = R;
          }
          return !1;
        }
        rootAcestor(_) {
          for (; _; ) {
            let I = this.parent(_);
            if (I) _ = I;
            else break;
          }
          return _;
        }
        isDescendantOf(_, I) {
          for (; _; ) {
            let R = this.parent(_);
            if (R === I) return !0;
            _ = R;
          }
          return !1;
        }
        data(_) {
          return this.get(_)?.data;
        }
        has(_) {
          return void 0 !== this.childrenOf(_);
        }
        get(_) {
          return this.fillCaches(), this.objCaches.get(_);
        }
        childrenOf(_) {
          return null === _ ? this : this.get(_)?.children;
        }
        traverseFrom(_, I) {
          if (null === _) this.traverse(I);
          else {
            let R = this.get(_);
            R &&
              (function eD(_, I) {
                if (!0 !== I(_.id, _.data)) for (let R of _.children) eD(R, I);
              })(R, I);
          }
        }
        traverse(_) {
          !(function $2(_, I) {
            for (let R of _) !0 !== I(R.id, R.data) && $2(R.children, I);
          })(this, _);
        }
        totalSize() {
          return this.fillCaches(), this.objCaches.size;
        }
        parent(_) {
          return this.fillCaches(), this.parentCaches.get(_);
        }
        childrenArray(_) {
          return null === _ ? this : this.get(_).children;
        }
        modifyById(_, I) {
          if (void 0 === this.get(_)) throw Error("not expected");
          {
            let R = this.parent(_),
              B = this.childrenArray(R),
              z = B.findIndex((I) => I.id === _);
            if (z < 0) throw Error("not expected");
            let k = B[z];
            return (
              ((B = [...B])[z] = { ...k, data: I }), this.modifyArrayBy(R, B)
            );
          }
        }
        modifyArrayBy(_, I) {
          let R = _,
            B = I;
          for (; null !== R; ) {
            let _ = B,
              I = R;
            if (void 0 === (R = this.parent(R))) throw Error();
            let z = (B = this.childrenArray(R)).findIndex((_) => _.id === I);
            if (z < 0) throw Error();
            (B = [...B])[z] = { ...B[z], children: _ };
          }
          Object.setPrototypeOf(B, uF.prototype);
          let z = B;
          return z.fillCaches(), z;
        }
        runOp(_) {
          switch (_.type) {
            case 7:
              return this.addOp(_);
            case 8:
              return this.deleteOp(_);
            case 9:
              return this.moveOp(_);
          }
          return null;
        }
        checkDuplicatedIdRec({ id: _, children: I }) {
          if (void 0 !== this.get(_)) return !0;
          for (let _ of I) if (this.checkDuplicatedIdRec(_)) return !0;
          return !1;
        }
        addOp(_) {
          let { parent: I, fi: R, id: B, data: z, children: k } = _;
          if (
            (null !== I && void 0 === this.get(I)) ||
            this.checkDuplicatedIdRec(_)
          )
            return null;
          {
            let V = this.childrenArray(I),
              j = { fi: R, id: B, data: z, children: k };
            return (
              (V = [...V, j]).sort((_, I) => _.fi - I.fi),
              (_.localIndex = V.indexOf(j)),
              {
                data: this.modifyArrayBy(I, V),
                actual: _,
                reverse: { type: 8, id: B },
              }
            );
          }
        }
        deleteOp(_) {
          let { id: I } = _;
          if (null === this.get(I)) return null;
          {
            let R = this.parent(I);
            if (void 0 === R) return null;
            let B = this.childrenArray(R),
              z = B.findIndex((_) => _.id === I);
            _.localIndex = z;
            let k = (B = [...B]).splice(z, 1)[0];
            return {
              data: this.modifyArrayBy(R, B),
              actual: _,
              reverse: { type: 7, ...k, parent: R },
            };
          }
        }
        moveOp(_) {
          let { parent: I, fi: R, id: B } = _;
          if (null !== I && void 0 === this.get(I))
            return this.deleteOp({ type: 8, id: B });
          if (null !== I) {
            let _ = I;
            for (; null !== _; ) {
              if (void 0 === _) throw Error();
              if (_ === B) throw new uz("cyclic tree");
              _ = this.parent(_);
            }
          }
          let z = this.parent(B);
          if (void 0 === z) return null;
          let k = z,
            V = this.childrenArray(z),
            j = V.findIndex((_) => _.id === B),
            G = (V = [...V]).splice(j, 1)[0],
            q = this.modifyArrayBy(z, V);
          (z = I), (V = q.childrenArray(z));
          let X = G.fi;
          return (
            (V = [...V, (G = { ...G, fi: R })]).sort((_, I) => _.fi - I.fi),
            (_.localIndex = V.indexOf(G)),
            {
              data: (q = q.modifyArrayBy(z, V)),
              actual: _,
              reverse: { type: 9, parent: k, fi: X, id: B },
            }
          );
        }
        previous(_, I) {
          if (null === I) {
            let I = this.childrenArray(_);
            return 0 === I.length ? null : I[I.length - 1].id;
          }
          let R = null;
          for (let B of this.childrenArray(_)) {
            if (B.id === I) return R;
            R = B.id;
          }
          return null;
        }
        traverseSortNext(_) {
          let I = this.parent(_);
          if (void 0 !== I) {
            let R = this.childrenArray(I),
              B = R.findIndex((I) => I.id === _) + 1;
            if (B < R.length) return R[B].id;
            if (I) return this.traverseSortNext(I);
          }
        }
        sortNext(_) {
          let I = this.childrenArray(_);
          return I.length > 0 ? I[0].id : this.traverseSortNext(_);
        }
        traverseSortPrevious(_) {
          let I = this.childrenArray(_);
          return I.length > 0
            ? this.traverseSortPrevious(I[I.length - 1].id)
            : _;
        }
        sortPrevious(_) {
          let I = this.parent(_);
          if (void 0 !== I) {
            let R = this.childrenArray(I),
              B = R.findIndex((I) => I.id === _) - 1;
            return B >= 0 ? this.traverseSortPrevious(R[B].id) : I;
          }
        }
        getAllSorted(_) {
          let I = [];
          for (let R of _) {
            let _ = this.getWithSortKey(R.id);
            void 0 !== _ && I.push({ ...R, ..._ });
          }
          for (let _ of (I.sort((_, I) =>
            (function (_, I) {
              let R = 0;
              for (; R < _.length && R < I.length; ) {
                if (_[R] < I[R]) return -1;
                if (_[R] > I[R]) return 1;
                R += 1;
              }
              return R !== I.length ? -1 : R !== _.length ? 1 : 0;
            })(_.sortKey, I.sortKey)
          ),
          I))
            delete _.sortKey;
          return I;
        }
        getWithSortKey(_) {
          var I = _;
          let R = [],
            B = this.get(I),
            z = B;
          if (void 0 !== B) {
            for (; I; )
              R.splice(0, 0, B.fi),
                null !== (I = this.parent(I)) && (B = this.get(I));
            return { ...z, sortKey: R };
          }
        }
        insertBeforeHelper(_, I, R) {
          return this.insertAfterHelper(_, this.previous(_, I), R);
        }
        insertAfterHelper(_, I, R) {
          let B = this.childrenArray(_);
          if (null === I) {
            if (0 === B.length) return Co(0, R, R);
            {
              let _ = B[0].fi;
              return Co(_ - R, _, R);
            }
          }
          {
            let z = this.get(I);
            if (void 0 === z || this.parent(I) !== _)
              throw Error("illegal args");
            let k = B.find((_) => _.fi > z.fi);
            if (void 0 !== k) return Co(z.fi, k.fi, R);
            {
              let _ = B[B.length - 1].fi;
              return Co(_, _ + R, R);
            }
          }
        }
      };
      (uV || (uV = {})).runOp = function (_, I) {
        if (0 !== I.type) return null;
        if (Array.isArray(_)) {
          let R = I.props,
            B = {},
            z = [..._],
            k = !1;
          if (R)
            for (let _ of Object.keys(R)) {
              let I = parseInt(_);
              if (isNaN(I)) throw Error("wrong index");
              (B[_] = z[I]), (z[I] = R[_]), (k = !0);
            }
          return k
            ? { data: z, actual: I, reverse: { type: 0, props: B } }
            : null;
        }
        {
          let R = I.props,
            B = {},
            z = { ..._ },
            k = !1;
          if (R)
            for (let _ of Object.keys(R)) {
              B[_] = z[_];
              let I = R[_];
              void 0 === I ? delete z[_] : (z[_] = I), (k = !0);
            }
          return k
            ? { data: z, actual: I, reverse: { type: 0, props: B } }
            : null;
        }
      };
      var uN = class extends Array {
        constructor(..._) {
          super(..._), Object.setPrototypeOf(this, uN.prototype);
        }
        deepFreeze() {
          let _ = 0;
          for (; _ < this.length; ) Zp(this[_]), _++;
        }
        fillCaches0(_) {
          this.objCaches.set(_.id, _);
        }
        fillCaches() {
          if (void 0 === this.objCaches)
            for (let _ of ((this.objCaches = new Map()),
            (Object.getOwnPropertyDescriptor(this, "objCaches").enumerable =
              !1),
            this))
              this.fillCaches0(_);
        }
        randomId() {
          this.fillCaches();
          let _ = Array.from(this.objCaches.keys());
          if (0 !== _.length)
            return _[Math.max(0, Math.floor(Math.random() * _.length) - 1)];
        }
        data(_) {
          return this.get(_)?.data;
        }
        get(_) {
          return this.fillCaches(), this.objCaches.get(_);
        }
        modifyById(_, I) {
          if (void 0 === this.get(_)) throw Error("not expected");
          {
            let R = this,
              B = R.findIndex((I) => I.id === _);
            if (B < 0) throw Error("not expected");
            let z = R[B];
            return ((R = [...R])[B] = { ...z, data: I }), this.modifyArrayBy(R);
          }
        }
        modifyArrayBy(_) {
          return (
            Object.setPrototypeOf(_, uN.prototype),
            "u" > typeof iS || _.fillCaches(),
            _
          );
        }
        runOp(_) {
          switch (_.type) {
            case 4:
              return this.addOp(_);
            case 5:
              return this.deleteOp(_);
            case 6:
              return this.moveOp(_);
          }
          return null;
        }
        addOp(_) {
          let { fi: I, id: R, data: B } = _,
            z = this,
            k = { fi: I, id: R, data: B };
          return (
            (z = [...z, k]).sort((_, I) => _.fi - I.fi),
            (_.localIndex = z.indexOf(k)),
            {
              data: this.modifyArrayBy(z),
              actual: _,
              reverse: { type: 5, id: R },
            }
          );
        }
        deleteOp(_) {
          let { id: I } = _,
            R = this,
            B = R.findIndex((_) => _.id === I);
          if (-1 === B) return null;
          _.localIndex = B;
          let z = (R = [...R]).splice(B, 1)[0];
          return {
            data: this.modifyArrayBy(R),
            actual: _,
            reverse: { type: 4, ...z },
          };
        }
        moveOp(_) {
          let { fi: I, id: R } = _,
            B = this,
            z = (B = [...B]).findIndex((_) => _.id === R);
          if (-1 === z) return null;
          let k = B[z].fi,
            V = { ...B[z], fi: I };
          return (
            (B[z] = V),
            B.sort((_, I) => _.fi - I.fi),
            (_.localIndex = B.indexOf(V)),
            {
              data: this.modifyArrayBy(B),
              actual: _,
              reverse: { type: 6, fi: k, id: R },
            }
          );
        }
        previous(_) {
          if (null === _)
            return 0 === this.length ? null : this[this.length - 1].id;
          let I = null;
          for (let R of this) {
            if (R.id === _) return I;
            I = R.id;
          }
          return null;
        }
        insertBeforeHelper(_, I) {
          return this.insertAfterHelper(this.previous(_), I);
        }
        insertAfterHelper(_, I) {
          if (null === _) {
            if (0 === this.length) return Co(0, I, I);
            {
              let _ = this[0].fi;
              return Co(_ - I, _, I);
            }
          }
          {
            let R = this.get(_);
            if (void 0 === R) throw Error("illegal args");
            let B = this.find((_) => _.fi > R.fi);
            if (void 0 !== B) return Co(R.fi, B.fi, I);
            {
              let _ = this[this.length - 1].fi;
              return Co(_, _ + I, I);
            }
          }
        }
      };
      function Wh(_) {
        return _ && "object" == typeof _ && _ instanceof uG;
      }
      var uk,
        uV,
        uj,
        uG = class {
          unusedFunOverridesTable(_) {}
          runOp(_) {
            let I = [],
              R = this,
              B = 0,
              z = {};
            for (; B < _.path.length; ) {
              if (
                (I.push(R),
                void 0 !== (R = void 0 === R ? void 0 : R[_.path[B]]) && !Wh(R))
              )
                return null;
              B += 1;
            }
            for (let [I, B] of ((R = R ? Tv(R) : new uG()),
            Object.entries(_.props))) {
              let _ = R[I];
              (z[I] = _), void 0 === B ? delete R[I] : (R[I] = B);
            }
            for (; B > 0; ) {
              if (0 === Object.keys(R).length) {
                let z = I[B - 1];
                z && ((R = Tv(z)), delete R[_.path[B - 1]]);
              } else {
                let z = I[B - 1];
                if (z) {
                  let I = Tv(z);
                  (I[_.path[B - 1]] = R), (R = I);
                } else {
                  let I = new uG();
                  (I[_.path[B - 1]] = R), (R = I);
                }
              }
              B -= 1;
            }
            let k = Object.setPrototypeOf(R, uG.prototype),
              V = { ..._, props: z };
            return { data: k, actual: _, reverse: V };
          }
        };
      function $w(_, I) {
        if (void 0 === I) return;
        let R = !1,
          B = _.map((_) => {
            let B = _.id,
              z = Jp(_.data, I[B]);
            if (
              ((R = R || void 0 !== z),
              void 0 === z && (z = _.data),
              !_.children)
            )
              return { ..._, id: B, data: z };
            {
              let k = $w(_.children, I);
              return (
                void 0 !== k ? (R = !0) : (k = _.children),
                { ..._, id: B, data: z, children: k }
              );
            }
          });
        if (R) return B;
      }
      function Jp(_, I) {
        if (!Wh(I)) return I;
        if (_ instanceof uF) {
          let R = $w(_, I);
          return (
            void 0 !== R && Object.setPrototypeOf(R, Object.getPrototypeOf(_)),
            R
          );
        }
        if (_ instanceof uN)
          return (function (_, I) {
            if (void 0 === I) return;
            let R = !1,
              B = _.map((_) => {
                let B = _.id,
                  z = Jp(_.data, I[B]);
                return (
                  (R = R || void 0 !== z),
                  void 0 === z && (z = _.data),
                  { ..._, id: B, data: z }
                );
              });
            if (R) return Object.setPrototypeOf(B, Object.getPrototypeOf(_)), B;
          })(_, I);
        if (Array.isArray(_)) {
          let R = !1,
            B = _.map((_, B) => {
              let z = Jp(_, I[B]);
              return (R = R || void 0 !== z), void 0 === z && (z = _), z;
            });
          return R
            ? (Object.setPrototypeOf(B, Object.getPrototypeOf(_)), B)
            : void 0;
        }
        if (_ instanceof uG) return e1(_, I);
        if (_ && "object" == typeof _) {
          let R = {},
            B = !1;
          for (let [z, k] of Object.entries(_)) {
            let _ = Jp(k, I[z]);
            (B = B || void 0 !== _), void 0 === _ && (_ = k), (R[z] = _);
          }
          return B
            ? (Object.setPrototypeOf(R, Object.getPrototypeOf(_)), R)
            : void 0;
        }
      }
      function e1(_, I) {
        if (void 0 === _) return I;
        if (void 0 === I) return _;
        if (!Wh(I)) return I;
        if (!Wh(_)) return uj.apply(_, I);
        let R = new Set();
        for (let I of Object.keys(_)) R.add(I);
        for (let _ of Object.keys(I)) R.add(_);
        let B = new uG();
        for (let z of R) {
          let R = e1(
            void 0 === _ ? void 0 : _[z],
            void 0 === I ? void 0 : I[z]
          );
          B[z] = R;
        }
        return B;
      }
      function Mv(_, I) {
        return null === _ ? null : ((_.cur[_.len] = I), (_.len += 1), _);
      }
      function Cv(_) {
        _ && (_.len -= 1);
      }
      ((u6 = uj || (uj = {})).apply = function (_, I) {
        return Jp(_, I) ?? _;
      }),
        (u6.merge = function (_, I) {
          return e1(_, I);
        }),
        (u6.filterOp = function (_, I) {
          let R = 0,
            B = I.path,
            z = _;
          for (; R < B.length && void 0 !== z; ) {
            if (void 0 === (z = pe.zoomOnce(z, B[R]))) return I;
            if (!Wh(z)) return;
            R += 1;
          }
          if (void 0 === z) return I;
          if (Wh(z)) {
            if (0 === I.type) {
              let _ = { ...I.props };
              for (let I of Object.keys(z)) delete _[I];
              return { ...I, props: _ };
            }
            {
              if (1 !== I.type && 4 !== I.type && 7 !== I.type) return I;
              let _ = $w([I], z);
              return _ ? (console.log(_), _) : I;
            }
          }
        }),
        ((u8 || (u8 = {})).replaceProps = function (_, I) {
          let R = pe.zoom(I, _.path);
          if ("object" != typeof R) return { ..._, props: {} };
          {
            let I = {};
            for (let B of Object.keys(_.props)) I[B] = R[B];
            return { ..._, props: I };
          }
        }),
        ((_) => {
          function e(_, I) {
            let R = I.path;
            for (var B = []; ; ) {
              let z;
              if (
                (_ instanceof uG &&
                  0 === I.type &&
                  null === (z = _.runOp({ ...I, path: R.slice(B.length) })) &&
                  (z = void 0),
                void 0 === z &&
                  B.length === R.length &&
                  (z =
                    _ instanceof uF || _ instanceof uN || _ instanceof uL
                      ? _.runOp(I)
                      : uV.runOp(_, I)),
                void 0 !== z)
              ) {
                if (null === z) return null;
                {
                  let _ = z.data;
                  for (let I = B.length - 1; I >= 0; I--) {
                    let z = R[I],
                      k = B[I];
                    if (k instanceof uF) {
                      if ("number" == typeof z) throw Error("illegal arg");
                      _ = k.modifyById(z, _);
                    } else if (k instanceof uN) {
                      if ("number" == typeof z) throw Error("illegal arg");
                      _ = k.modifyById(z, _);
                    } else if (k instanceof uL) {
                      if ("number" == typeof z) throw Error("illegal arg");
                      _ = k.modifyById(z, _);
                    } else if (k instanceof uG)
                      _ = Object.setPrototypeOf({ ...k, [z]: _ }, uG.prototype);
                    else if ("object" != typeof k) return null;
                    else if (Array.isArray(k)) {
                      if ("string" == typeof z && isNaN((z = parseInt(z))))
                        throw Error("Invalid path");
                      let I = _;
                      (_ = [...k])[z] = I;
                    } else _ = { ...k, [z]: _ };
                  }
                  return {
                    data: _,
                    actual: { ...z.actual, path: R },
                    reverse: { ...z.reverse, path: R },
                  };
                }
              }
              let k = R[B.length],
                V;
              if (_ instanceof uF) {
                if ("number" == typeof k) throw Error("");
                V = _.get(k)?.data;
              } else if (_ instanceof uN) {
                if ("number" == typeof k) throw Error("");
                V = _.get(k)?.data;
              } else null !== _ && (V = _[k]);
              if (void 0 === V) return null;
              B.push(_), (_ = V);
            }
          }
          function r(_, I) {
            for (let R = 0; R < _.length && R < I.length; R++)
              if (_[R] !== I[R]) return !0;
            return !1;
          }
          function i(_, I) {
            if (_.length !== I.length) return !1;
            for (let R = 0; R < _.length; R++) if (_[R] !== I[R]) return !1;
            return !0;
          }
          (_.drop = function (_, I) {
            return { ..._, path: _.path.slice(I) };
          }),
            (_.applySimple = function (_, I) {
              return e(_, I)?.data ?? _;
            }),
            (_.apply = e),
            (_.pathDisjoint = r),
            (_.pathEq = i),
            (_.commutative = function (_, I) {
              return r(_.path, I.path);
            }),
            (_.subsumed = function (_, I) {
              return (
                !!(0 === _.type && 0 === I.type && i(_.path, I.path)) &&
                Object.keys(_.props).every((_) => void 0 !== I.props[_])
              );
            });
        })(u9 || (u9 = {})),
        ((_) => {
          function a(_, I) {
            var R = _;
            let B = [],
              z = [];
            for (let _ of I)
              try {
                if (
                  3 === _.type ||
                  (5 === _.type && "variables" === _.path[_.path.length - 1])
                ) {
                  let I, k, V;
                  if (
                    (3 === _.type
                      ? ((I = pe.zoom(R, [..._.path, _.id])),
                        (V = u9.apply(R, { ..._, type: 2 })))
                      : ((I = pe.zoom(R, [..._.path, _.id, "value"])),
                        (V = u9.apply(R, _))),
                    null !== V)
                  ) {
                    R = V.data;
                    let [j, G] = (function (_, I) {
                      let R = { cur: [], result: [], len: 0 };
                      return [
                        (_ =
                          (function $p(_, I, R) {
                            if (_ instanceof uF) {
                              let B = (function rD(_, I, R) {
                                let B = !1,
                                  z = _.map((_) => {
                                    let z = _.id,
                                      k = I[z];
                                    if (
                                      void 0 !== k &&
                                      "string" == typeof k &&
                                      ((B = !0), (z = k), null !== R)
                                    )
                                      throw Error("not supported");
                                    let V = $p(_.data, I, Mv(R, z));
                                    Cv(R),
                                      (B = B || void 0 !== V),
                                      void 0 === V && (V = _.data);
                                    let j = rD(_.children, I, R);
                                    return (
                                      void 0 !== j
                                        ? (B = !0)
                                        : (j = _.children),
                                      { ..._, id: z, data: V, children: j }
                                    );
                                  });
                                if (B) return z;
                              })(_, I, R);
                              return (
                                void 0 !== B &&
                                  Object.setPrototypeOf(
                                    B,
                                    Object.getPrototypeOf(_)
                                  ),
                                B
                              );
                            }
                            if (_ instanceof uN)
                              return (function (_, I, R) {
                                let B = !1,
                                  z = _.map((_) => {
                                    let z = _.id,
                                      k = I[z];
                                    if (
                                      void 0 !== k &&
                                      "string" == typeof k &&
                                      ((B = !0), (z = k), null !== R)
                                    )
                                      throw Error("not supported");
                                    let V = $p(_.data, I, Mv(R, z));
                                    return (
                                      Cv(R),
                                      (B = B || void 0 !== V),
                                      void 0 === V && (V = _.data),
                                      { ..._, id: z, data: V }
                                    );
                                  });
                                if (B)
                                  return (
                                    Object.setPrototypeOf(
                                      z,
                                      Object.getPrototypeOf(_)
                                    ),
                                    z
                                  );
                              })(_, I, R);
                            if (Array.isArray(_)) {
                              let B = !1,
                                z = _.map((_, z) => {
                                  let k = $p(_, I, Mv(R, z));
                                  return (
                                    Cv(R),
                                    (B = B || void 0 !== k),
                                    void 0 === k && (k = _),
                                    k
                                  );
                                });
                              return B
                                ? (Object.setPrototypeOf(
                                    z,
                                    Object.getPrototypeOf(_)
                                  ),
                                  z)
                                : void 0;
                            }
                            if (_ && "object" == typeof _ && !jh(_)) {
                              let B = {},
                                z = !1;
                              for (let [k, V] of Object.entries(_))
                                if ("name" !== k) {
                                  let _ = I[k];
                                  if ("string" == typeof _) {
                                    if (null !== R)
                                      throw Error("not supported");
                                    (z = !0), (k = _);
                                  }
                                  let j = $p(V, I, Mv(R, k));
                                  Cv(R),
                                    (z = z || void 0 !== j),
                                    void 0 === j && (j = V),
                                    (B[k] = j);
                                } else B[k] = V;
                              return z
                                ? (Object.setPrototypeOf(
                                    B,
                                    Object.getPrototypeOf(_)
                                  ),
                                  B)
                                : void 0;
                            }
                            {
                              var B;
                              if ("string" != typeof _) return;
                              let z = I[_];
                              return (
                                void 0 !== z &&
                                  ((B = R),
                                  null !== B &&
                                    B.result.push(B.cur.slice(0, B.len))),
                                z
                              );
                            }
                          })(_, I, R) ?? _),
                        R.result,
                      ];
                    })(R, { [_.id]: I });
                    R = j;
                    for (let V = 0; V < G.length; V++) {
                      let j = G[V],
                        q = j.pop();
                      if ("number" == typeof q) {
                        let B = [q];
                        for (let _ = V + 1; _ < G.length; _++) {
                          let I = G[_],
                            R = I[I.length - 1];
                          if (
                            "number" == typeof R &&
                            pe.equal(j, I.slice(0, I.length - 1))
                          )
                            B.push(R), G.splice(_, 1);
                          else break;
                        }
                        let z = pe.zoom(R, j);
                        (k = z.map((I, R) => (B.includes(R) ? _.id : I))),
                          (I = z),
                          (q = j.pop());
                      } else {
                        if ("alphaOverride" === q || "alpha" === q) {
                          let _ = (I /= 100),
                            B = pe.zoom(R, j.slice(0, j.length - 2)),
                            z = B.layers.map((I) =>
                              I.id === j[j.length - 1]
                                ? { ...I, data: { ...I.data, [q]: _ } }
                                : I
                            );
                          Object.setPrototypeOf(
                            z,
                            Object.getPrototypeOf(B.layers)
                          ),
                            (B.layers = z);
                        }
                        k = _.id;
                      }
                      B.push({ type: 0, path: j, props: { [q]: I } }),
                        z.push({ type: 0, path: j, props: { [q]: k } });
                    }
                    z.push(V.reverse), B.push(V.actual);
                  }
                } else {
                  let I = u9.apply(R, _);
                  null !== I &&
                    (B.push(I.actual), (R = I.data), z.push(I.reverse));
                }
              } catch (_) {
                if (_ instanceof uz) return null;
                throw _;
              }
            return { data: R, actual: B, reverse: z.reverse() };
          }
          (_.empty = function () {
            return [];
          }),
            (_.removePrefix = function (_, I) {
              let R = [];
              for (let B of _) {
                let [_, ...z] = B.path;
                _ === I && R.push({ ...B, path: z });
              }
              return R;
            }),
            (_.addPrefix = function (_, I) {
              return _.map((_) => ({ ..._, path: [I, ..._.path] }));
            }),
            (_.concat = function (_, I) {
              return [..._, ...I];
            }),
            (_.compress = function (_, I) {
              return [
                ..._.filter((_) => !I.some((I) => u9.subsumed(_, I))),
                ...I,
              ];
            }),
            (_.commutative = function (_, I) {
              return _.every((_) => I.every((I) => u9.commutative(_, I)));
            }),
            (_.applyAll = function (_, I) {
              for (let R of I) {
                let I = a(_, R);
                null !== I && (_ = I.data);
              }
              return _;
            }),
            (_.apply = a);
        })(u7 || (u7 = {}));
      var uH = Symbol(),
        uW = Symbol(),
        uq = Symbol(),
        uY = class {
          reportOp(_, I, R = []) {
            let B = this;
            if (null !== I) {
              for (B._current = I.data; !(B instanceof u2); ) {
                let _ = B._path,
                  I = B._current;
                if (("" !== _ && R.splice(0, 0, _), null === (B = B._parent)))
                  return;
                B.update(_, I);
              }
              B.push(R, _, I.actual, I.reverse);
            }
          }
          deleteChildren(_) {
            if (this._children) {
              let I = this._children[_];
              if (I) {
                let R = I[uq];
                R && R(), delete this._children[_];
              }
            }
          }
        },
        uX = class extends uY {
          constructor(_, I, R) {
            super(), (this._parent = _), (this._path = I), (this._current = R);
          }
          update(_, I) {
            if (Array.isArray(this._current)) {
              if ("string" == typeof _ && isNaN((_ = parseInt(_))))
                throw Error("Invalid path");
              (this._current = [...this._current]), (this._current[_] = I);
            } else this._current = { ...this._current, [_]: I };
          }
          runOp(_) {
            this.reportOp(_, uV.runOp(this._current, _), _.path);
          }
        },
        uQ = class extends uY {
          constructor(_, I, R) {
            super(), (this._parent = _), (this._path = I), (this._current = R);
          }
          update(_, I) {
            (this._current = { ...this._current, [_]: I }),
              Object.setPrototypeOf(this._current, uL.prototype);
          }
          runOp(_) {
            this.reportOp(_, this._current.runOp(_));
          }
        },
        uZ = {
          get(_, I) {
            if (I === uq)
              return () => {
                _._parent = null;
              };
            if (I === uH) return _._current;
            if (I === uW) return _;
            let { _current: R, _children: B } = _;
            if ("push" === I && Array.isArray(R))
              throw Error("not supported to expand array");
            let z = void 0 === B ? void 0 : B[I];
            if (void 0 !== z) return z;
            let k = R[I],
              V = Ov(_, I, k);
            return V !== k
              ? (void 0 === B && ((B = {}), (_._children = B)), (B[I] = V), V)
              : k;
          },
          has: (_, I) => I in _._current,
          ownKeys: (_) => Reflect.ownKeys(_._current),
          defineProperty() {
            throw Error("not supported");
          },
          getPrototypeOf: (_) => Object.getPrototypeOf(_._current),
          setPrototypeOf() {
            throw Error("not supported");
          },
          getOwnPropertyDescriptor(_, I) {
            let R = _._current,
              B = Reflect.getOwnPropertyDescriptor(R, I);
            return (
              B && {
                writable: !0,
                configurable: !0,
                enumerable: B.enumerable,
                value: R[I],
              }
            );
          },
        },
        uK = {
          ...uZ,
          set(_, I, R) {
            let B = { type: 0, props: { [I]: kr(R) ?? R } };
            return _.deleteChildren(I), _.runOp(B), !0;
          },
          deleteProperty: (_, I) => (
            _.deleteChildren(I),
            _.runOp({ type: 0, props: { [I]: void 0 } }),
            !0
          ),
        },
        u$ = {
          ...uZ,
          set(_, I, R) {
            return (
              void 0 === R
                ? this.deleteProperty(_, I)
                : (_.deleteChildren(I), _.runOp({ type: 1, id: I, data: R })),
              !0
            );
          },
          deleteProperty: (_, I) => (_.runOp({ type: 2, id: I }), !0),
        },
        u0 = class extends uY {
          constructor(_, I, R) {
            super(),
              (this._children = {}),
              (this._parent = _),
              (this._path = I),
              (this._current = R),
              (this[uq] = () => {
                this._parent = null;
              });
          }
          unproxy() {
            return this._current;
          }
          update(_, I) {
            this._current = this._current.modifyById(_, I);
          }
          runOp(_) {
            this.reportOp(_, this._current.runOp(_));
          }
          randomId() {
            return this._current.randomId();
          }
          isDescendantOf(_, I) {
            return this._current.isDescendantOf(_, I);
          }
          childrenOf(_) {
            return this._current.childrenOf(_);
          }
          traverse(_) {
            return this._current.traverse(_);
          }
          get(_) {
            return this._current.get(_);
          }
          parent(_) {
            return this._current.parent(_);
          }
          traverse(_) {
            this._current.traverse((I, R) => {
              _(I, this.data(I));
            });
          }
          data(_) {
            let { _current: I, _children: R } = this,
              B = void 0 === R ? void 0 : R[_];
            if (void 0 !== B) return B;
            let z = I.get(_)?.data,
              k = Ov(this, _, z);
            return k !== z
              ? (void 0 === R && ((R = {}), (this._children = R)),
                (R[_] = k),
                k)
              : z;
          }
          add(_, I, R, B, z) {
            this.runOp({
              type: 7,
              parent: _,
              fi: I,
              id: R,
              data: B,
              children: z,
            });
          }
          move(_, I, R) {
            this.runOp({ type: 9, parent: _, fi: I, id: R });
          }
          insertAfter(_, I, R) {
            let B = this._current.insertAfterHelper(_, I, R.length);
            for (let I = 0; I < R.length; I++) {
              let z = R[I];
              this.add(_, B[I], z.id, z.data, z.children);
            }
          }
          insertBefore(_, I, R) {
            let B = this._current.insertBeforeHelper(_, I, R.length);
            for (let I = 0; I < R.length; I++) {
              let z = R[I];
              this.add(_, B[I], z.id, z.data, z.children);
            }
          }
          moveAfter(_, I, R) {
            let B = this._current.insertAfterHelper(_, I, R.length);
            for (let I = 0; I < R.length; I++) {
              let z = R[I];
              this.move(_, B[I], z);
            }
          }
          moveBefore(_, I, R) {
            let B = this._current.insertBeforeHelper(_, I, R.length);
            for (let I = 0; I < R.length; I++) {
              let z = R[I];
              this.move(_, B[I], z);
            }
          }
          delete(_) {
            this.deleteChildren(_), this.runOp({ type: 8, id: _ });
          }
          sortNext(_) {
            return this._current.sortNext(_);
          }
          sortPrevious(_) {
            return this._current.sortPrevious(_);
          }
          getAllSorted(_) {
            return this._current.getAllSorted(_);
          }
        },
        u1 = class extends uY {
          constructor(_, I, R) {
            super(),
              (this._children = {}),
              (this._parent = _),
              (this._path = I),
              (this._current = R),
              (this[uq] = () => {
                this._parent = null;
              });
          }
          unproxy() {
            return this._current;
          }
          get length() {
            return this._current.length;
          }
          forEach(_) {
            let I = this.length;
            for (let R = 0; R < I; R++) {
              let I = this._current[R].id,
                B = this._current[R].fi;
              _(this.data(this._current[R].id), I, B);
            }
          }
          find(_) {
            let I = this.length;
            for (let R = 0; R < I; R++) {
              let I = this._current[R].id;
              if (_(this.data(I), I)) return this.get(I);
            }
          }
          update(_, I) {
            this._current = this._current.modifyById(_, I);
          }
          randomId() {
            return this._current.randomId();
          }
          get(_) {
            return { ...this._current.get(_), data: this.data(_) };
          }
          data(_) {
            let { _current: I, _children: R } = this,
              B = void 0 === R ? void 0 : R[_];
            if (void 0 !== B) return B;
            let z = I.get(_)?.data,
              k = Ov(this, _, z);
            return k !== z
              ? (void 0 === R && ((R = {}), (this._children = R)),
                (R[_] = k),
                k)
              : z;
          }
          runOp(_) {
            this.reportOp(_, this._current.runOp(_));
          }
          add(_, I, R) {
            this.runOp({ type: 4, fi: _, id: I, data: R });
          }
          move(_, I) {
            this.runOp({ type: 6, fi: _, id: I });
          }
          insertAfter(_, I) {
            let R = this._current.insertAfterHelper(_, I.length);
            for (let _ = 0; _ < I.length; _++) {
              let B = I[_];
              this.add(R[_], B.id, B.data);
            }
          }
          insertBefore(_, I) {
            let R = this._current.insertBeforeHelper(_, I.length);
            for (let _ = 0; _ < I.length; _++) {
              let B = I[_];
              this.add(R[_], B.id, B.data);
            }
          }
          moveAfter(_, I) {
            let R = this._current.insertAfterHelper(_, I.length);
            for (let _ = 0; _ < I.length; _++) {
              let B = I[_];
              this.move(R[_], B);
            }
          }
          moveBefore(_, I) {
            let R = this._current.insertBeforeHelper(_, I.length);
            for (let _ = 0; _ < I.length; _++) {
              let B = I[_];
              this.move(R[_], B);
            }
          }
          delete(_) {
            this.deleteChildren(_), this.runOp({ type: 5, id: _ });
          }
        };
      function t1(_, I, R) {
        if (_.length > 0) {
          let B = _[_.length - 1];
          if (0 === B.type && 0 === I.type && pe.equal(B.path, R)) {
            Object.assign(B.props, I.props);
            return;
          }
        }
        _.push({ ...I, path: R });
      }
      var u2 = class extends uY {
        constructor(_) {
          super(),
            (this.ts = []),
            (this.actual = []),
            (this.reverse = []),
            (this._current = _);
        }
        update(_, I) {
          if ("" !== _) throw Error("");
          this._current = I;
        }
        push(_, I, R, B) {
          t1(this.ts, I, _), t1(this.actual, R, _), t1(this.reverse, B, _);
        }
        result() {
          return {
            data: this._current,
            ts: this.ts,
            actual: this.actual,
            reverse: this.reverse.reverse(),
          };
        }
      };
      function Ov(_, I, R) {
        return R instanceof uF
          ? new u0(_, I, R)
          : R instanceof uN
          ? new u1(_, I, R)
          : R instanceof uL
          ? new Proxy(new uQ(_, I, R), u$)
          : null !== R && "object" == typeof R
          ? jh(R)
            ? R
            : new Proxy(new uX(_, I, R), uK)
          : R;
      }
      function n1(_) {
        let I = new u2(_);
        return [Ov(I, "", _), I];
      }
      function Tl(_, I) {
        let [R, B] = n1(_);
        return I(R), B.result();
      }
      function kr(_) {
        return _ instanceof u0 || _ instanceof u1
          ? _._current
          : null !== _ && "object" == typeof _
          ? _[uH]
          : _;
      }
      function Rt(_, I) {
        let R = [];
        if (!(I.length <= _.length)) return null;
        for (var B = 0; B < I.length; ) {
          if ("*" === I[B]) R.push(_[B]);
          else if (_[B] !== I[B]) return null;
          B += 1;
        }
        return R;
      }
      ((_) => {
        function e(_, I) {
          return ((_ instanceof uF || _ instanceof u0) &&
            "string" == typeof I) ||
            ((_ instanceof uN || _ instanceof u1) && "string" == typeof I)
            ? _.data(I)
            : ("number" == typeof I && Array.isArray(_)) ||
              ("string" == typeof I && "object" == typeof _ && null !== _)
            ? _[I]
            : void 0;
        }
        function r(_, I, R = 0) {
          for (; R < I.length && void 0 !== _; ) (_ = e(_, I[R])), (R += 1);
          return _;
        }
        (_.equal = function (_, I) {
          if (I.length !== _.length) return !1;
          for (var R = 0; R < _.length; ) {
            if (_[R] !== I[R]) return !1;
            R += 1;
          }
          return !0;
        }),
          (_.removeOverridden = function (_, I, R) {
            let B = r(R, _);
            if (void 0 === B || "object" != typeof B || null === B) return I;
            {
              let _ = { ...I };
              return (
                Object.keys(B).forEach((I) => {
                  delete _[I];
                }),
                _
              );
            }
          }),
          (_.zoomOnce = e),
          (_.zoom = r);
      })(pe || (pe = {}));
      var u3 = class {},
        u4 = class extends u3 {
          constructor(_) {
            super(), (this.id = _);
          }
        },
        u5 = class extends u3 {
          constructor(_) {
            super(), (this.data = _);
          }
        };
      try {
        pt = new TextDecoder();
      } catch {}
      var u6,
        u8,
        u9,
        u7,
        pe,
        pt,
        pr,
        ps,
        pa,
        pn,
        pl,
        pc,
        pd,
        pu = 0,
        pp = [],
        pm = pp,
        py = 0,
        px = {},
        pb = 0,
        pw = 0,
        p_ = [],
        pC = { useRecords: !1, mapsAsObjects: !0 },
        pT = class {},
        pP = new pT();
      pP.name = "MessagePack 0xC1";
      var pO = !1,
        pI = class {
          constructor(_) {
            _ &&
              (!1 === _.useRecords &&
                void 0 === _.mapsAsObjects &&
                (_.mapsAsObjects = !0),
              _.structures
                ? (_.structures.sharedLength = _.structures.length)
                : _.getStructures &&
                  (((_.structures = []).uninitialized = !0),
                  (_.structures.sharedLength = 0))),
              Object.assign(this, _);
          }
          unpack(_, I) {
            if (pr)
              return vD(
                () => (
                  Lv(),
                  this ? this.unpack(_, I) : pI.prototype.unpack.call(pC, _, I)
                )
              );
            (ps = I > -1 ? I : _.length),
              (pu = 0),
              (py = 0),
              (pw = 0),
              (pn = null),
              (pm = pp),
              (pl = null),
              (pr = _);
            try {
              pd =
                _.dataView ||
                (_.dataView = new DataView(
                  _.buffer,
                  _.byteOffset,
                  _.byteLength
                ));
            } catch (I) {
              throw (
                ((pr = null),
                _ instanceof Uint8Array
                  ? I
                  : Error(
                      "Source must be a Uint8Array or Buffer but was a " +
                        (_ && "object" == typeof _
                          ? _.constructor.name
                          : typeof _)
                    ))
              );
            }
            if (this instanceof pI) {
              if (((px = this), this.structures))
                return (pa = this.structures), Rv();
              (!pa || pa.length > 0) && (pa = []);
            } else (px = pC), (!pa || pa.length > 0) && (pa = []);
            return Rv();
          }
          unpackMultiple(_, I) {
            let R,
              B = 0;
            try {
              pO = !0;
              let z = _.length,
                k = this ? this.unpack(_, z) : pH.unpack(_, z);
              if (I) {
                for (I(k); pu < z; ) if (((B = pu), !1 === I(Rv()))) return;
              } else {
                for (R = [k]; pu < z; ) (B = pu), R.push(Rv());
                return R;
              }
            } catch (_) {
              throw ((_.lastPosition = B), (_.values = R), _);
            } finally {
              (pO = !1), Lv();
            }
          }
          _mergeStructures(_, I) {
            _ = _ || [];
            for (let I = 0, R = _.length; I < R; I++) {
              let R = _[I];
              R && ((R.isShared = !0), I >= 32 && (R.highByte = (I - 32) >> 5));
            }
            for (let R in ((_.sharedLength = _.length), I || []))
              if (R >= 0) {
                let B = _[R],
                  z = I[R];
                z &&
                  (B &&
                    ((_.restoreStructures || (_.restoreStructures = []))[R] =
                      B),
                  (_[R] = z));
              }
            return (this.structures = _);
          }
          decode(_, I) {
            return this.unpack(_, I);
          }
        };
      function Rv() {
        try {
          if (!px.trusted && !pO) {
            let _ = pa.sharedLength || 0;
            _ < pa.length && (pa.length = _);
          }
          let _ = Zr();
          if (pu == ps)
            pa.restoreStructures && aD(),
              (pa = null),
              (pr = null),
              pc && (pc = null);
          else if (pu > ps) {
            let _ = Error("Unexpected end of MessagePack data");
            throw ((_.incomplete = !0), _);
          } else if (!pO)
            throw Error("Data read, but end of buffer not reached");
          return _;
        } catch (_) {
          throw (
            (pa.restoreStructures && aD(),
            Lv(),
            (_ instanceof RangeError ||
              _.message.startsWith("Unexpected end of buffer")) &&
              (_.incomplete = !0),
            _)
          );
        }
      }
      function aD() {
        for (let _ in pa.restoreStructures) pa[_] = pa.restoreStructures[_];
        pa.restoreStructures = null;
      }
      function Zr() {
        let _ = pr[pu++];
        if (_ < 160) {
          if (_ < 128) {
            if (_ < 64) return _;
            {
              let I = pa[63 & _] || (px.getStructures && pD()[63 & _]);
              return I ? (I.read || (I.read = h1(I, 63 & _)), I.read()) : _;
            }
          }
          if (_ < 144) {
            if (((_ -= 128), px.mapsAsObjects)) {
              let I = {};
              for (let R = 0; R < _; R++) I[gD()] = Zr();
              return I;
            }
            {
              let I = new Map();
              for (let R = 0; R < _; R++) I.set(Zr(), Zr());
              return I;
            }
          }
          {
            let I = Array((_ -= 144));
            for (let R = 0; R < _; R++) I[R] = Zr();
            return I;
          }
        }
        if (_ < 192) {
          let I = _ - 160;
          if (pw >= pu) return pn.slice(pu - pb, (pu += I) - pb);
          if (0 == pw && ps < 140) {
            let _ = I < 16 ? d1(I) : mD(I);
            if (null != _) return _;
          }
          return pB(I);
        }
        {
          let I;
          switch (_) {
            case 192:
              return null;
            case 193:
              return pl
                ? (I = Zr()) > 0
                  ? pl[1].slice(pl.position1, (pl.position1 += I))
                  : pl[0].slice(pl.position0, (pl.position0 -= I))
                : pP;
            case 194:
              return !1;
            case 195:
              return !0;
            case 196:
              return s1(pr[pu++]);
            case 197:
              return (I = pd.getUint16(pu)), (pu += 2), s1(I);
            case 198:
              return (I = pd.getUint32(pu)), (pu += 4), s1(I);
            case 199:
              return kc(pr[pu++]);
            case 200:
              return (I = pd.getUint16(pu)), (pu += 2), kc(I);
            case 201:
              return (I = pd.getUint32(pu)), (pu += 4), kc(I);
            case 202:
              if (((I = pd.getFloat32(pu)), px.useFloat32 > 2)) {
                let _ = pG[((127 & pr[pu]) << 1) | (pr[pu + 1] >> 7)];
                return (pu += 4), ((_ * I + (I > 0 ? 0.5 : -0.5)) >> 0) / _;
              }
              return (pu += 4), I;
            case 203:
              return (I = pd.getFloat64(pu)), (pu += 8), I;
            case 204:
              return pr[pu++];
            case 205:
              return (I = pd.getUint16(pu)), (pu += 2), I;
            case 206:
              return (I = pd.getUint32(pu)), (pu += 4), I;
            case 207:
              return (
                (I = px.int64AsNumber
                  ? 4294967296 * pd.getUint32(pu) + pd.getUint32(pu + 4)
                  : pd.getBigUint64(pu)),
                (pu += 8),
                I
              );
            case 208:
              return pd.getInt8(pu++);
            case 209:
              return (I = pd.getInt16(pu)), (pu += 2), I;
            case 210:
              return (I = pd.getInt32(pu)), (pu += 4), I;
            case 211:
              return (
                (I = px.int64AsNumber
                  ? 4294967296 * pd.getInt32(pu) + pd.getUint32(pu + 4)
                  : pd.getBigInt64(pu)),
                (pu += 8),
                I
              );
            case 212:
              if (114 == (I = pr[pu++])) return dD(63 & pr[pu++]);
              {
                let _ = p_[I];
                if (_)
                  return _.read
                    ? (pu++, _.read(Zr()))
                    : _.noBuffer
                    ? (pu++, _())
                    : _(pr.subarray(pu, ++pu));
                throw Error("Unknown extension " + I);
              }
            case 213:
              return 114 == (I = pr[pu])
                ? (pu++, dD(63 & pr[pu++], pr[pu++]))
                : kc(2);
            case 214:
              return kc(4);
            case 215:
              return kc(8);
            case 216:
              return kc(16);
            case 217:
              return (
                (I = pr[pu++]),
                pw >= pu ? pn.slice(pu - pb, (pu += I) - pb) : pL(I)
              );
            case 218:
              return (
                (I = pd.getUint16(pu)),
                (pu += 2),
                pw >= pu ? pn.slice(pu - pb, (pu += I) - pb) : pz(I)
              );
            case 219:
              return (
                (I = pd.getUint32(pu)),
                (pu += 4),
                pw >= pu ? pn.slice(pu - pb, (pu += I) - pb) : pF(I)
              );
            case 220:
              return (I = pd.getUint16(pu)), (pu += 2), cD(I);
            case 221:
              return (I = pd.getUint32(pu)), (pu += 4), cD(I);
            case 222:
              return (I = pd.getUint16(pu)), (pu += 2), uD(I);
            case 223:
              return (I = pd.getUint32(pu)), (pu += 4), uD(I);
            default:
              if (_ >= 224) return _ - 256;
              if (void 0 === _) {
                let _ = Error("Unexpected end of MessagePack data");
                throw ((_.incomplete = !0), _);
              }
              throw Error("Unknown MessagePack token " + _);
          }
        }
      }
      var pR = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
      function h1(_, I) {
        function e() {
          if (e.count++ > 2) {
            let R = (_.read = Function(
              "r",
              "return function(){return {" +
                _.map((_) =>
                  pR.test(_) ? _ + ":r()" : "[" + JSON.stringify(_) + "]:r()"
                ).join(",") +
                "}}"
            )(Zr));
            return 0 === _.highByte && (_.read = lD(I, _.read)), R();
          }
          let R = {};
          for (let I = 0, B = _.length; I < B; I++) R[_[I]] = Zr();
          return R;
        }
        return (e.count = 0), 0 === _.highByte ? lD(I, e) : e;
      }
      var lD = (_, I) =>
        function () {
          let R = pr[pu++];
          if (0 === R) return I();
          let B = _ < 32 ? -(_ + (R << 5)) : _ + (R << 5),
            z = pa[B] || pD()[B];
          if (!z) throw Error("Record id is not defined for " + B);
          return z.read || (z.read = h1(z, _)), z.read();
        };
      function pD() {
        let _ = vD(() => ((pr = null), px.getStructures()));
        return (pa = px._mergeStructures(_, pa));
      }
      var pB = Bv,
        pL = Bv,
        pz = Bv,
        pF = Bv;
      function Bv(_) {
        let I;
        if (_ < 16 && (I = d1(_))) return I;
        if (_ > 64 && pt) return pt.decode(pr.subarray(pu, (pu += _)));
        let R = pu + _,
          B = [];
        for (I = ""; pu < R; ) {
          let _ = pr[pu++];
          if ((128 & _) == 0) B.push(_);
          else if ((224 & _) == 192) {
            let I = 63 & pr[pu++];
            B.push(((31 & _) << 6) | I);
          } else if ((240 & _) == 224) {
            let I = 63 & pr[pu++],
              R = 63 & pr[pu++];
            B.push(((31 & _) << 12) | (I << 6) | R);
          } else if ((248 & _) == 240) {
            let I =
              ((7 & _) << 18) |
              ((63 & pr[pu++]) << 12) |
              ((63 & pr[pu++]) << 6) |
              (63 & pr[pu++]);
            I > 65535 &&
              ((I -= 65536),
              B.push(((I >>> 10) & 1023) | 55296),
              (I = 56320 | (1023 & I))),
              B.push(I);
          } else B.push(_);
          B.length >= 4096 && ((I += pk.apply(String, B)), (B.length = 0));
        }
        return B.length > 0 && (I += pk.apply(String, B)), I;
      }
      function cD(_) {
        let I = Array(_);
        for (let R = 0; R < _; R++) I[R] = Zr();
        return I;
      }
      function uD(_) {
        if (px.mapsAsObjects) {
          let I = {};
          for (let R = 0; R < _; R++) I[gD()] = Zr();
          return I;
        }
        {
          let I = new Map();
          for (let R = 0; R < _; R++) I.set(Zr(), Zr());
          return I;
        }
      }
      var pk = String.fromCharCode;
      function mD(_) {
        let I = pu,
          R = Array(_);
        for (let B = 0; B < _; B++) {
          let _ = pr[pu++];
          if ((128 & _) > 0) {
            pu = I;
            return;
          }
          R[B] = _;
        }
        return pk.apply(String, R);
      }
      function d1(_) {
        if (_ < 4) {
          if (_ < 2) {
            if (0 === _) return "";
            {
              let _ = pr[pu++];
              if ((128 & _) > 1) {
                pu -= 1;
                return;
              }
              return pk(_);
            }
          }
          {
            let I = pr[pu++],
              R = pr[pu++];
            if ((128 & I) > 0 || (128 & R) > 0) {
              pu -= 2;
              return;
            }
            if (_ < 3) return pk(I, R);
            let B = pr[pu++];
            if ((128 & B) > 0) {
              pu -= 3;
              return;
            }
            return pk(I, R, B);
          }
        }
        {
          let I = pr[pu++],
            R = pr[pu++],
            B = pr[pu++],
            z = pr[pu++];
          if (
            (128 & I) > 0 ||
            (128 & R) > 0 ||
            (128 & B) > 0 ||
            (128 & z) > 0
          ) {
            pu -= 4;
            return;
          }
          if (_ < 6) {
            if (4 === _) return pk(I, R, B, z);
            {
              let _ = pr[pu++];
              if ((128 & _) > 0) {
                pu -= 5;
                return;
              }
              return pk(I, R, B, z, _);
            }
          }
          if (_ < 8) {
            let k = pr[pu++],
              V = pr[pu++];
            if ((128 & k) > 0 || (128 & V) > 0) {
              pu -= 6;
              return;
            }
            if (_ < 7) return pk(I, R, B, z, k, V);
            let j = pr[pu++];
            if ((128 & j) > 0) {
              pu -= 7;
              return;
            }
            return pk(I, R, B, z, k, V, j);
          }
          {
            let k = pr[pu++],
              V = pr[pu++],
              j = pr[pu++],
              G = pr[pu++];
            if (
              (128 & k) > 0 ||
              (128 & V) > 0 ||
              (128 & j) > 0 ||
              (128 & G) > 0
            ) {
              pu -= 8;
              return;
            }
            if (_ < 10) {
              if (8 === _) return pk(I, R, B, z, k, V, j, G);
              {
                let _ = pr[pu++];
                if ((128 & _) > 0) {
                  pu -= 9;
                  return;
                }
                return pk(I, R, B, z, k, V, j, G, _);
              }
            }
            if (_ < 12) {
              let q = pr[pu++],
                X = pr[pu++];
              if ((128 & q) > 0 || (128 & X) > 0) {
                pu -= 10;
                return;
              }
              if (_ < 11) return pk(I, R, B, z, k, V, j, G, q, X);
              let Q = pr[pu++];
              if ((128 & Q) > 0) {
                pu -= 11;
                return;
              }
              return pk(I, R, B, z, k, V, j, G, q, X, Q);
            }
            {
              let q = pr[pu++],
                X = pr[pu++],
                Q = pr[pu++],
                $ = pr[pu++];
              if (
                (128 & q) > 0 ||
                (128 & X) > 0 ||
                (128 & Q) > 0 ||
                (128 & $) > 0
              ) {
                pu -= 12;
                return;
              }
              if (_ < 14) {
                if (12 === _) return pk(I, R, B, z, k, V, j, G, q, X, Q, $);
                {
                  let _ = pr[pu++];
                  if ((128 & _) > 0) {
                    pu -= 13;
                    return;
                  }
                  return pk(I, R, B, z, k, V, j, G, q, X, Q, $, _);
                }
              }
              {
                let et = pr[pu++],
                  er = pr[pu++];
                if ((128 & et) > 0 || (128 & er) > 0) {
                  pu -= 14;
                  return;
                }
                if (_ < 15)
                  return pk(I, R, B, z, k, V, j, G, q, X, Q, $, et, er);
                let es = pr[pu++];
                if ((128 & es) > 0) {
                  pu -= 15;
                  return;
                }
                return pk(I, R, B, z, k, V, j, G, q, X, Q, $, et, er, es);
              }
            }
          }
        }
      }
      function s1(_) {
        return px.copyBuffers
          ? Uint8Array.prototype.slice.call(pr, pu, (pu += _))
          : pr.subarray(pu, (pu += _));
      }
      function kc(_) {
        let I = pr[pu++];
        if (p_[I]) return p_[I](pr.subarray(pu, (pu += _)));
        throw Error("Unknown extension type " + I);
      }
      var pU = Array(4096);
      function gD() {
        let _ = pr[pu++];
        if (!(_ >= 160) || !(_ < 192)) return pu--, Zr();
        if (((_ -= 160), pw >= pu)) return pn.slice(pu - pb, (pu += _) - pb);
        if (!(0 == pw && ps < 180)) return pB(_);
        let I =
            ((_ << 5) ^ (_ > 1 ? pd.getUint16(pu) : _ > 0 ? pr[pu] : 0)) & 4095,
          R = pU[I],
          B = pu,
          z = pu + _ - 3,
          k,
          V = 0;
        if (R && R.bytes == _) {
          for (; B < z; ) {
            if ((k = pd.getUint32(B)) != R[V++]) {
              B = 1879048192;
              break;
            }
            B += 4;
          }
          for (z += 3; B < z; )
            if ((k = pr[B++]) != R[V++]) {
              B = 1879048192;
              break;
            }
          if (B === z) return (pu = B), R.string;
          (z -= 3), (B = pu);
        }
        for (R = [], pU[I] = R, R.bytes = _; B < z; )
          (k = pd.getUint32(B)), R.push(k), (B += 4);
        for (z += 3; B < z; ) (k = pr[B++]), R.push(k);
        let j = _ < 16 ? d1(_) : mD(_);
        return null != j ? (R.string = j) : (R.string = pB(_));
      }
      var dD = (_, I) => {
          var R = Zr();
          let B = _;
          void 0 !== I &&
            ((_ = _ < 32 ? -((I << 5) + _) : (I << 5) + _), (R.highByte = I));
          let z = pa[_];
          return (
            z &&
              z.isShared &&
              ((pa.restoreStructures || (pa.restoreStructures = []))[_] = z),
            (pa[_] = R),
            (R.read = h1(R, B)),
            R.read()
          );
        },
        pV = "object" == typeof self ? self : global;
      (p_[0] = () => {}),
        (p_[0].noBuffer = !0),
        (p_[101] = () => {
          let _ = Zr();
          return (pV[_[0]] || Error)(_[1]);
        }),
        (p_[105] = (_) => {
          let I = pd.getUint32(pu - 4);
          pc || (pc = new Map());
          let R = pr[pu],
            B,
            z = {
              target: (B =
                (R >= 144 && R < 160) || 220 == R || 221 == R ? [] : {}),
            };
          pc.set(I, z);
          let k = Zr();
          return z.used ? Object.assign(B, k) : ((z.target = k), k);
        }),
        (p_[112] = (_) => {
          let I = pd.getUint32(pu - 4),
            R = pc.get(I);
          return (R.used = !0), R.target;
        }),
        (p_[115] = () => new Set(Zr()));
      var pj = [
        "Int8",
        "Uint8",
        "Uint8Clamped",
        "Int16",
        "Uint16",
        "Int32",
        "Uint32",
        "Float32",
        "Float64",
        "BigInt64",
        "BigUint64",
      ].map((_) => _ + "Array");
      function vD(_) {
        let I = ps,
          R = pu,
          B = py,
          z = pb,
          k = pw,
          V = pn,
          j = pm,
          G = pc,
          q = pl,
          X = new Uint8Array(pr.slice(0, ps)),
          Q = pa,
          $ = pa.slice(0, pa.length),
          et = px,
          er = pO,
          es = _();
        return (
          (ps = I),
          (pu = R),
          (py = B),
          (pb = z),
          (pw = k),
          (pn = V),
          (pm = j),
          (pc = G),
          (pl = q),
          (pr = X),
          (pO = er),
          (pa = Q).splice(0, pa.length, ...$),
          (px = et),
          (pd = new DataView(pr.buffer, pr.byteOffset, pr.byteLength)),
          es
        );
      }
      function Lv() {
        (pr = null), (pc = null), (pa = null);
      }
      (p_[116] = (_) => {
        let I = _[0],
          R = pj[I];
        if (!R) throw Error("Could not find typed array for code " + I);
        return new pV[R](Uint8Array.prototype.slice.call(_, 1).buffer);
      }),
        (p_[120] = () => {
          let _ = Zr();
          return new RegExp(_[0], _[1]);
        }),
        (p_[98] = (_) => {
          let I = (_[0] << 24) + (_[1] << 16) + (_[2] << 8) + _[3],
            R = pu;
          (pu += I - 4),
            ((pl = [Zr(), Zr()]).position0 = 0),
            (pl.position1 = 0);
          let B = pu;
          pu = R;
          try {
            return Zr();
          } finally {
            pu = B;
          }
        }),
        (p_[255] = (_) =>
          new Date(
            4 == _.length
              ? (16777216 * _[0] + (_[1] << 16) + (_[2] << 8) + _[3]) * 1e3
              : 8 == _.length
              ? ((_[0] << 22) + (_[1] << 14) + (_[2] << 6) + (_[3] >> 2)) /
                  1e6 +
                ((3 & _[3]) * 4294967296 +
                  16777216 * _[4] +
                  (_[5] << 16) +
                  (_[6] << 8) +
                  _[7]) *
                  1e3
              : 12 == _.length
              ? ((_[0] << 24) + (_[1] << 16) + (_[2] << 8) + _[3]) / 1e6 +
                ((128 & _[4] ? -281474976710656 : 0) +
                  1099511627776 * _[6] +
                  4294967296 * _[7] +
                  16777216 * _[8] +
                  (_[9] << 16) +
                  (_[10] << 8) +
                  _[11]) *
                  1e3
              : "invalid"
          ));
      var pG = Array(147);
      for (let _ = 0; _ < 256; _++)
        pG[_] = +("1e" + Math.floor(45.15 - 0.30103 * _));
      var pH = new pI({ useRecords: !1 }),
        pW = (pH.unpack, pH.unpackMultiple, pH.unpack, new Float32Array(1));
      new Uint8Array(pW.buffer, 0, 4);
      try {
        pq = new TextEncoder();
      } catch {}
      var pq,
        pY,
        pX,
        pQ,
        pZ,
        pK,
        pJ = "u" > typeof iA,
        p$ = pJ ? iA.allocUnsafeSlow : Uint8Array,
        p0 = pJ ? iA : Uint8Array,
        p1 = pJ ? 4294967296 : 2144337920,
        p3 = 0,
        p4 = null,
        p5 = /[\u0080-\uFFFF]/,
        p6 = Symbol("record-id"),
        p8 = class extends pI {
          constructor(_) {
            super(_), (this.offset = 0);
            let I,
              R,
              B,
              z,
              k,
              V = 0,
              j = p0.prototype.utf8Write
                ? function (_, I, R) {
                    return pQ.utf8Write(_, I, R);
                  }
                : !!pq &&
                  !!pq.encodeInto &&
                  function (_, I) {
                    return pq.encodeInto(_, pQ.subarray(I)).written;
                  },
              G = this;
            _ || (_ = {});
            let q = _ && _.sequential,
              X = _.structures || _.saveStructures,
              Q = _.maxSharedStructures;
            if ((null == Q && (Q = X ? 32 : 0), Q > 8160))
              throw Error("Maximum maxSharedStructure is 8160");
            let $ = _.maxOwnStructures;
            null == $ && ($ = X ? 32 : 64),
              q && !_.saveStructures && (this.structures = []);
            let et = Q > 32 || $ + Q > 64,
              er = Q + 64,
              es = Q + $ + 64;
            if (es > 8256)
              throw Error(
                "Maximum maxSharedStructure + maxOwnStructure is 8192"
              );
            let ea = [],
              en = 0,
              eo = 0;
            this.pack = this.encode = function (_, j) {
              if (
                (pQ ||
                  ((pQ = new p$(8192)),
                  (pZ = new DataView(pQ.buffer, 0, 8192)),
                  (p3 = 0)),
                (pK = pQ.length - 10) - p3 < 2048
                  ? ((pQ = new p$(pQ.length)),
                    (pZ = new DataView(pQ.buffer, 0, pQ.length)),
                    (pK = pQ.length - 10),
                    (p3 = 0))
                  : (p3 = (p3 + 7) & 2147483640),
                (I = p3),
                (k = G.structuredClone ? new Map() : null),
                G.bundleStrings
                  ? ((p4 = ["", ""]),
                    (pQ[p3++] = 214),
                    (pQ[p3++] = 98),
                    (p4.position = p3 - I),
                    (p3 += 4))
                  : (p4 = null),
                (R = G.structures))
              ) {
                R.uninitialized && (R = G._mergeStructures(G.getStructures()));
                let _ = R.sharedLength || 0;
                if (_ > Q)
                  throw Error(
                    "Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to " +
                      R.sharedLength
                  );
                if (!R.transitions) {
                  R.transitions = Object.create(null);
                  for (let I = 0; I < _; I++) {
                    let _ = R[I];
                    if (!_) continue;
                    let B,
                      z = R.transitions;
                    for (let I = 0, R = _.length; I < R; I++) {
                      let R = _[I];
                      (B = z[R]) || (B = z[R] = Object.create(null)), (z = B);
                    }
                    z[p6] = I + 64;
                  }
                  V = _;
                }
                q || (R.nextId = _ + 64);
              }
              B && (B = !1), (z = R || []);
              try {
                if ((w(_), p4)) {
                  pZ.setUint32(p4.position + I, p3 - p4.position - I);
                  let _ = p4;
                  (p4 = null), w(_[0]), w(_[1]);
                }
                if (((G.offset = p3), k && k.idsToInsert)) {
                  (p3 += 6 * k.idsToInsert.length) > pK && E(p3),
                    (G.offset = p3);
                  let _ = (function (_, I) {
                    let R,
                      B = 6 * I.length,
                      z = _.length - B;
                    for (
                      I.sort((_, I) => (_.offset > I.offset ? 1 : -1));
                      (R = I.pop());

                    ) {
                      let I = R.offset,
                        k = R.id;
                      _.copyWithin(I + B, I, z);
                      let V = I + (B -= 6);
                      (_[V++] = 214),
                        (_[V++] = 105),
                        (_[V++] = k >> 24),
                        (_[V++] = (k >> 16) & 255),
                        (_[V++] = (k >> 8) & 255),
                        (_[V++] = 255 & k),
                        (z = I);
                    }
                    return _;
                  })(pQ.subarray(I, p3), k.idsToInsert);
                  return (k = null), _;
                }
                return j & fa
                  ? ((pQ.start = I), (pQ.end = p3), pQ)
                  : pQ.subarray(I, p3);
              } finally {
                if (R) {
                  if ((eo < 10 && eo++, en > 1e4))
                    (R.transitions = null),
                      (eo = 0),
                      (en = 0),
                      ea.length > 0 && (ea = []);
                  else if (ea.length > 0 && !q) {
                    for (let _ = 0, I = ea.length; _ < I; _++) ea[_][p6] = 0;
                    ea = [];
                  }
                  if (B && G.saveStructures) {
                    let B = R.sharedLength || Q;
                    R.length > B && (R = R.slice(0, B));
                    let z = pQ.subarray(I, p3);
                    return !1 === G.saveStructures(R, V)
                      ? (G._mergeStructures(G.getStructures()), G.pack(_))
                      : ((V = B), z);
                  }
                }
                j & fn && (p3 = I);
              }
            };
            let w = (_) => {
                p3 > pK && (pQ = E(p3));
                var R,
                  B = typeof _;
                if ("string" === B) {
                  let I,
                    B = _.length;
                  if (p4 && B >= 8 && B < 4096) {
                    let I = p5.test(_);
                    (p4[I ? 0 : 1] += _), (pQ[p3++] = 193), w(I ? -B : B);
                    return;
                  }
                  I = B < 32 ? 1 : B < 256 ? 2 : B < 65536 ? 3 : 5;
                  let z = 3 * B;
                  if ((p3 + z > pK && (pQ = E(p3 + z)), B < 64 || !j)) {
                    let z,
                      k,
                      V,
                      j = p3 + I;
                    for (z = 0; z < B; z++)
                      (k = _.charCodeAt(z)) < 128
                        ? (pQ[j++] = k)
                        : (k < 2048
                            ? (pQ[j++] = (k >> 6) | 192)
                            : ((64512 & k) == 55296 &&
                              (64512 & (V = _.charCodeAt(z + 1))) == 56320
                                ? ((k =
                                    65536 + ((1023 & k) << 10) + (1023 & V)),
                                  z++,
                                  (pQ[j++] = (k >> 18) | 240),
                                  (pQ[j++] = ((k >> 12) & 63) | 128))
                                : (pQ[j++] = (k >> 12) | 224),
                              (pQ[j++] = ((k >> 6) & 63) | 128)),
                          (pQ[j++] = (63 & k) | 128));
                    R = j - p3 - I;
                  } else R = j(_, p3 + I, z);
                  R < 32
                    ? (pQ[p3++] = 160 | R)
                    : R < 256
                    ? (I < 2 && pQ.copyWithin(p3 + 2, p3 + 1, p3 + 1 + R),
                      (pQ[p3++] = 217),
                      (pQ[p3++] = R))
                    : R < 65536
                    ? (I < 3 && pQ.copyWithin(p3 + 3, p3 + 2, p3 + 2 + R),
                      (pQ[p3++] = 218),
                      (pQ[p3++] = R >> 8),
                      (pQ[p3++] = 255 & R))
                    : (I < 5 && pQ.copyWithin(p3 + 5, p3 + 3, p3 + 3 + R),
                      (pQ[p3++] = 219),
                      pZ.setUint32(p3, R),
                      (p3 += 4)),
                    (p3 += R);
                } else if ("number" === B) {
                  if (_ >>> 0 === _)
                    _ < 64
                      ? (pQ[p3++] = _)
                      : _ < 256
                      ? ((pQ[p3++] = 204), (pQ[p3++] = _))
                      : _ < 65536
                      ? ((pQ[p3++] = 205),
                        (pQ[p3++] = _ >> 8),
                        (pQ[p3++] = 255 & _))
                      : ((pQ[p3++] = 206), pZ.setUint32(p3, _), (p3 += 4));
                  else if (_ >> 0 === _)
                    _ >= -32
                      ? (pQ[p3++] = 256 + _)
                      : _ >= -128
                      ? ((pQ[p3++] = 208), (pQ[p3++] = _ + 256))
                      : _ >= -32768
                      ? ((pQ[p3++] = 209), pZ.setInt16(p3, _), (p3 += 2))
                      : ((pQ[p3++] = 210), pZ.setInt32(p3, _), (p3 += 4));
                  else {
                    let I;
                    if (
                      (I = this.useFloat32) > 0 &&
                      _ < 4294967296 &&
                      _ >= -2147483648
                    ) {
                      let R;
                      if (
                        ((pQ[p3++] = 202),
                        pZ.setFloat32(p3, _),
                        I < 4 ||
                          (R =
                            _ *
                            pG[((127 & pQ[p3]) << 1) | (pQ[p3 + 1] >> 7)]) >>
                            0 ===
                            R)
                      ) {
                        p3 += 4;
                        return;
                      }
                      p3--;
                    }
                    (pQ[p3++] = 203), pZ.setFloat64(p3, _), (p3 += 8);
                  }
                } else if ("object" === B) {
                  if (_) {
                    if (k) {
                      let R = k.get(_);
                      if (R) {
                        if (!R.id) {
                          let _ = k.idsToInsert || (k.idsToInsert = []);
                          R.id = _.push(R);
                        }
                        (pQ[p3++] = 214),
                          (pQ[p3++] = 112),
                          pZ.setUint32(p3, R.id),
                          (p3 += 4);
                        return;
                      }
                      k.set(_, { offset: p3 - I });
                    }
                    let B = _.constructor;
                    if (B === Object) el(_, !0);
                    else if (B === Array) {
                      (R = _.length) < 16
                        ? (pQ[p3++] = 144 | R)
                        : R < 65536
                        ? ((pQ[p3++] = 220),
                          (pQ[p3++] = R >> 8),
                          (pQ[p3++] = 255 & R))
                        : ((pQ[p3++] = 221), pZ.setUint32(p3, R), (p3 += 4));
                      for (let I = 0; I < R; I++) w(_[I]);
                    } else if (B === Map)
                      for (let [I, B] of ((R = _.size) < 16
                        ? (pQ[p3++] = 128 | R)
                        : R < 65536
                        ? ((pQ[p3++] = 222),
                          (pQ[p3++] = R >> 8),
                          (pQ[p3++] = 255 & R))
                        : ((pQ[p3++] = 223), pZ.setUint32(p3, R), (p3 += 4)),
                      _))
                        w(I), w(B);
                    else {
                      for (let I = 0, R = pY.length; I < R; I++)
                        if (_ instanceof pX[I]) {
                          let R,
                            B = pY[I];
                          if (B.write) {
                            B.type &&
                              ((pQ[p3++] = 212),
                              (pQ[p3++] = B.type),
                              (pQ[p3++] = 0)),
                              w(B.write.call(this, _));
                            return;
                          }
                          let z = pQ,
                            k = pZ,
                            V = p3;
                          pQ = null;
                          try {
                            R = B.pack.call(
                              this,
                              _,
                              (_) => (
                                (pQ = z),
                                (z = null),
                                (p3 += _) > pK && E(p3),
                                { target: pQ, targetView: pZ, position: p3 - _ }
                              ),
                              w
                            );
                          } finally {
                            z &&
                              ((pQ = z),
                              (pZ = k),
                              (p3 = V),
                              (pK = pQ.length - 10));
                          }
                          R &&
                            (R.length + p3 > pK && E(R.length + p3),
                            (p3 = (function (_, I, R, B) {
                              let z = _.length;
                              switch (z) {
                                case 1:
                                  I[R++] = 212;
                                  break;
                                case 2:
                                  I[R++] = 213;
                                  break;
                                case 4:
                                  I[R++] = 214;
                                  break;
                                case 8:
                                  I[R++] = 215;
                                  break;
                                case 16:
                                  I[R++] = 216;
                                  break;
                                default:
                                  z < 256
                                    ? ((I[R++] = 199), (I[R++] = z))
                                    : (z < 65536
                                        ? ((I[R++] = 200), (I[R++] = z >> 8))
                                        : ((I[R++] = 201),
                                          (I[R++] = z >> 24),
                                          (I[R++] = (z >> 16) & 255),
                                          (I[R++] = (z >> 8) & 255)),
                                      (I[R++] = 255 & z));
                              }
                              return (I[R++] = B), I.set(_, R), (R += z);
                            })(R, pQ, p3, B.type)));
                          return;
                        }
                      el(_, !_.hasOwnProperty);
                    }
                  } else pQ[p3++] = 192;
                } else if ("boolean" === B) pQ[p3++] = _ ? 195 : 194;
                else if ("bigint" === B) {
                  if (
                    _ < BigInt(1) << BigInt(63) &&
                    _ >= -(BigInt(1) << BigInt(63))
                  )
                    (pQ[p3++] = 211), pZ.setBigInt64(p3, _);
                  else if (_ < BigInt(1) << BigInt(64) && _ > 0)
                    (pQ[p3++] = 207), pZ.setBigUint64(p3, _);
                  else if (this.largeBigIntToFloat)
                    (pQ[p3++] = 203), pZ.setFloat64(p3, Number(_));
                  else
                    throw RangeError(
                      _ +
                        " was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64"
                    );
                  p3 += 8;
                } else if ("undefined" === B)
                  this.encodeUndefinedAsNil
                    ? (pQ[p3++] = 192)
                    : ((pQ[p3++] = 212), (pQ[p3++] = 0), (pQ[p3++] = 0));
                else if ("function" === B)
                  w(this.writeFunction && this.writeFunction());
                else throw Error("Unknown type: " + B);
              },
              el =
                !1 === this.useRecords
                  ? this.variableMapSize
                    ? (_) => {
                        let I,
                          R = Object.keys(_),
                          B = R.length;
                        B < 16
                          ? (pQ[p3++] = 128 | B)
                          : B < 65536
                          ? ((pQ[p3++] = 222),
                            (pQ[p3++] = B >> 8),
                            (pQ[p3++] = 255 & B))
                          : ((pQ[p3++] = 223), pZ.setUint32(p3, B), (p3 += 4));
                        for (let z = 0; z < B; z++) w((I = R[z])), w(_[I]);
                      }
                    : (_, R) => {
                        pQ[p3++] = 222;
                        let B = p3 - I;
                        p3 += 2;
                        let z = 0;
                        for (let I in _)
                          (R || _.hasOwnProperty(I)) && (w(I), w(_[I]), z++);
                        (pQ[B++ + I] = z >> 8), (pQ[B + I] = 255 & z);
                      }
                  : (_) => {
                      let I = Object.keys(_),
                        R,
                        k =
                          z.transitions ||
                          (z.transitions = Object.create(null)),
                        V = 0;
                      for (let _ = 0, B = I.length; _ < B; _++) {
                        let B = I[_];
                        (R = k[B]) || ((R = k[B] = Object.create(null)), V++),
                          (k = R);
                      }
                      let j = k[p6];
                      if (j)
                        j >= 96 && et
                          ? ((pQ[p3++] = (31 & (j -= 96)) + 96),
                            (pQ[p3++] = j >> 5))
                          : (pQ[p3++] = j);
                      else {
                        (j = z.nextId) || (j = 64),
                          j < er &&
                          this.shouldShareStructure &&
                          !this.shouldShareStructure(I)
                            ? ((j = z.nextOwnId) < es || (j = er),
                              (z.nextOwnId = j + 1))
                            : (j >= es && (j = er), (z.nextId = j + 1));
                        let _ = (I.highByte =
                          j >= 96 && et ? (j - 96) >> 5 : -1);
                        (k[p6] = j),
                          (z[j - 64] = I),
                          j < er
                            ? ((I.isShared = !0),
                              (z.sharedLength = j - 63),
                              (B = !0),
                              _ >= 0
                                ? ((pQ[p3++] = (31 & j) + 96), (pQ[p3++] = _))
                                : (pQ[p3++] = j))
                            : (_ >= 0
                                ? ((pQ[p3++] = 213),
                                  (pQ[p3++] = 114),
                                  (pQ[p3++] = (31 & j) + 96),
                                  (pQ[p3++] = _))
                                : ((pQ[p3++] = 212),
                                  (pQ[p3++] = 114),
                                  (pQ[p3++] = j)),
                              V && (en += eo * V),
                              ea.length >= $ && (ea.shift()[p6] = 0),
                              ea.push(k),
                              w(I));
                      }
                      for (let R = 0, B = I.length; R < B; R++) w(_[I[R]]);
                    },
              E = (_) => {
                let R;
                if (_ > 16777216) {
                  if (_ - I > p1)
                    throw Error(
                      "Packed buffer would be larger than maximum buffer size"
                    );
                  R = Math.min(
                    p1,
                    4096 *
                      Math.round(
                        Math.max((_ - I) * (_ > 67108864 ? 1.25 : 2), 4194304) /
                          4096
                      )
                  );
                } else
                  R = ((Math.max((_ - I) << 2, pQ.length - 1) >> 12) + 1) << 12;
                let B = new p$(R);
                return (
                  (pZ = new DataView(B.buffer, 0, R)),
                  pQ.copy ? pQ.copy(B, 0, I, _) : B.set(pQ.slice(I, _)),
                  (p3 -= I),
                  (I = 0),
                  (pK = B.length - 10),
                  (pQ = B)
                );
              };
          }
          useBuffer(_) {
            (pQ = _),
              (pZ = new DataView(pQ.buffer, pQ.byteOffset, pQ.byteLength)),
              (p3 = 0);
          }
        };
      function SD(_, I, R, B) {
        let z = _.byteLength;
        if (z + 1 < 256) {
          var { target: k, position: V } = R(4 + z);
          (k[V++] = 199), (k[V++] = z + 1);
        } else if (z + 1 < 65536) {
          var { target: k, position: V } = R(5 + z);
          (k[V++] = 200), (k[V++] = (z + 1) >> 8), (k[V++] = (z + 1) & 255);
        } else {
          var { target: k, position: V, targetView: j } = R(7 + z);
          (k[V++] = 201), j.setUint32(V, z + 1), (V += 4);
        }
        (k[V++] = 116),
          (k[V++] = I),
          k.set(new Uint8Array(_.buffer, _.byteOffset, _.byteLength), V);
      }
      function wD(_, I) {
        let R = _.byteLength;
        if (R < 256) {
          var B,
            z,
            { target: B, position: z } = I(R + 2);
          (B[z++] = 196), (B[z++] = R);
        } else if (R < 65536) {
          var { target: B, position: z } = I(R + 3);
          (B[z++] = 197), (B[z++] = R >> 8), (B[z++] = 255 & R);
        } else {
          var { target: B, position: z, targetView: k } = I(R + 5);
          (B[z++] = 198), k.setUint32(z, R), (z += 4);
        }
        B.set(_, z);
      }
      function Pl(_) {
        if (_.Class) {
          if (!_.pack && !_.write)
            throw Error("Extension has no pack or write function");
          if (_.pack && !_.type)
            throw Error(
              "Extension has no type (numeric code to identify the extension)"
            );
          pX.unshift(_.Class), pY.unshift(_);
        }
        _.unpack ? (p_[_.type] = _.unpack) : (p_[_.type] = _);
      }
      (pX = [
        Date,
        Set,
        Error,
        RegExp,
        ArrayBuffer,
        Object.getPrototypeOf(Uint8Array.prototype).constructor,
        pT,
      ]),
        (pY = [
          {
            pack(_, I, R) {
              let B = _.getTime() / 1e3;
              if (
                (this.useTimestamp32 || 0 === _.getMilliseconds()) &&
                B >= 0 &&
                B < 4294967296
              ) {
                let { target: _, targetView: R, position: z } = I(6);
                (_[z++] = 214), (_[z++] = 255), R.setUint32(z, B);
              } else if (B > 0 && B < 17179869184) {
                let { target: R, targetView: z, position: k } = I(10);
                (R[k++] = 215),
                  (R[k++] = 255),
                  z.setUint32(
                    k,
                    4e6 * _.getMilliseconds() + ((B / 1e3 / 4294967296) >> 0)
                  ),
                  z.setUint32(k + 4, B);
              } else if (isNaN(B)) {
                if (this.onInvalidDate) return I(0), R(this.onInvalidDate());
                let { target: _, targetView: B, position: z } = I(3);
                (_[z++] = 212), (_[z++] = 255), (_[z++] = 255);
              } else {
                let { target: R, targetView: z, position: k } = I(15);
                (R[k++] = 199),
                  (R[k++] = 12),
                  (R[k++] = 255),
                  z.setUint32(k, 1e6 * _.getMilliseconds()),
                  z.setBigInt64(k + 4, BigInt(Math.floor(B)));
              }
            },
          },
          {
            pack(_, I, R) {
              let B = Array.from(_),
                { target: z, position: k } = I(this.structuredClone ? 3 : 0);
              this.structuredClone &&
                ((z[k++] = 212), (z[k++] = 115), (z[k++] = 0)),
                R(B);
            },
          },
          {
            pack(_, I, R) {
              let { target: B, position: z } = I(this.structuredClone ? 3 : 0);
              this.structuredClone &&
                ((B[z++] = 212), (B[z++] = 101), (B[z++] = 0)),
                R([_.name, _.message]);
            },
          },
          {
            pack(_, I, R) {
              let { target: B, position: z } = I(this.structuredClone ? 3 : 0);
              this.structuredClone &&
                ((B[z++] = 212), (B[z++] = 120), (B[z++] = 0)),
                R([_.source, _.flags]);
            },
          },
          {
            pack(_, I) {
              this.structuredClone
                ? SD(_, 16, I)
                : wD(pJ ? iA.from(_) : new Uint8Array(_), I);
            },
          },
          {
            pack(_, I) {
              let R = _.constructor;
              R !== p0 && this.structuredClone
                ? SD(_, pj.indexOf(R.name), I)
                : wD(_, I);
            },
          },
          {
            pack(_, I) {
              let { target: R, position: B } = I(1);
              R[B] = 193;
            },
          },
        ]);
      var p9 = new p8({ useRecords: !1 });
      p9.pack, p9.pack;
      var {
          NEVER: p7,
          ALWAYS: fe,
          DECIMAL_ROUND: ft,
          DECIMAL_FIT: fs,
        } = { NEVER: 0, ALWAYS: 1, DECIMAL_ROUND: 3, DECIMAL_FIT: 4 },
        fa = 512,
        fn = 1024,
        fo = new p8({ structuredClone: !0 });
      Pl({
        Class: uL.prototype.constructor,
        type: 1,
        write: (_) => ({ ..._ }),
        read: (_) => (Object.setPrototypeOf(_, uL.prototype), _),
      }),
        Pl({
          Class: uN.prototype.constructor,
          type: 2,
          write: (_) => [..._],
          read: (_) => (Object.setPrototypeOf(_, uN.prototype), _),
        }),
        Pl({
          Class: uF.prototype.constructor,
          type: 3,
          write: (_) => [..._],
          read: (_) => (Object.setPrototypeOf(_, uF.prototype), _),
        }),
        Pl({
          Class: u4.prototype.constructor,
          type: 4,
          write: (_) => _.id,
          read: (_) => new u4(_),
        }),
        Pl({
          Class: u5.prototype.constructor,
          type: 5,
          write: (_) => _.data,
          read: (_) => new u5(_),
        }),
        Pl({
          Class: uG.prototype.constructor,
          type: 6,
          write: (_) => ({ ..._ }),
          read: (_) => (Object.setPrototypeOf(_, uG.prototype), _),
        }),
        ((_) => {
          function n(_) {
            return fo.pack(_);
          }
          (_.serialize = n),
            (_.deserialize = function (_) {
              return fo.unpack(_);
            }),
            (_.checksum = function (_) {
              return (function (_) {
                var I = 0;
                if (0 === _.length) return I;
                for (let R = 0; R < _.length; R++)
                  (I = (I << 5) - I + _[R]), (I &= I);
                return I;
              })(
                n(
                  (function g1(_) {
                    if (jh(_)) return _;
                    if (Array.isArray(_)) return _.map(g1);
                    if ("object" != typeof _ || null === _) return _;
                    {
                      let I = {};
                      for (let R of Object.keys(_).sort()) I[R] = g1(_[R]);
                      return (
                        Object.setPrototypeOf(I, Object.getPrototypeOf(_)), I
                      );
                    }
                  })(_)
                )
              ).toString();
            });
        })(fc || (fc = {})),
        ((fl = fp || (fp = {})).toEventUIType = function (_) {
          return "Conditional" === _.type
            ? "Distance" === _.condition.type
              ? "Distance"
              : "StateChange"
            : _.type;
        }),
        (fl.fromEventUIType = function (_) {
          return "Distance" === _ || "StateChange" === _ ? "Conditional" : _;
        });
      var fl,
        fc,
        fp,
        fm,
        fy = {
          LookAt: [],
          Follow: ["Create"],
          DragDrop: [
            "Transition",
            "Animation",
            "Audio",
            "Particles",
            "Create",
            "SetVariable",
            "DynamicVariablePlay",
            "Conditional",
          ],
          MouseHover: [
            "Transition",
            "Animation",
            "Particles",
            "Create",
            "Destroy",
            "SwitchCamera",
            "SceneTransition",
            "SetVariable",
            "DynamicVariablePlay",
            "Conditional",
          ],
          Scroll: [
            "Transition",
            "Animation",
            "Create",
            "SetVariable",
            "DynamicVariablePlay",
            "Conditional",
          ],
          Start: [
            "Transition",
            "Animation",
            "Audio",
            "Particles",
            "Video",
            "Create",
            "Destroy",
            "SwitchCamera",
            "SceneTransition",
            "Reset",
            "SetVariable",
            "DynamicVariablePlay",
            "Conditional",
          ],
          Conditional: [
            "Transition",
            "Animation",
            "Audio",
            "Particles",
            "Video",
            "Link",
            "Create",
            "Destroy",
            "SwitchCamera",
            "SceneTransition",
            "Reset",
            "SetVariable",
            "DynamicVariablePlay",
            "Conditional",
          ],
          MouseDown: [
            "Transition",
            "Animation",
            "Audio",
            "Particles",
            "Video",
            "Link",
            "Create",
            "Destroy",
            "SwitchCamera",
            "SceneTransition",
            "Reset",
            "SetVariable",
            "DynamicVariablePlay",
            "Conditional",
          ],
          MouseUp: [
            "Transition",
            "Animation",
            "Audio",
            "Particles",
            "Video",
            "Link",
            "Create",
            "Destroy",
            "SwitchCamera",
            "SceneTransition",
            "Reset",
            "SetVariable",
            "DynamicVariablePlay",
            "Conditional",
          ],
          MousePress: [
            "Transition",
            "Animation",
            "Audio",
            "Particles",
            "Video",
            "Link",
            "Create",
            "SwitchCamera",
            "SceneTransition",
            "Reset",
            "SetVariable",
            "DynamicVariablePlay",
            "Conditional",
          ],
          KeyDown: [
            "Transition",
            "Animation",
            "Audio",
            "Particles",
            "Video",
            "Link",
            "Create",
            "Destroy",
            "SwitchCamera",
            "SceneTransition",
            "Reset",
            "SetVariable",
            "DynamicVariablePlay",
            "Conditional",
          ],
          KeyUp: [
            "Transition",
            "Animation",
            "Audio",
            "Particles",
            "Video",
            "Link",
            "Create",
            "Destroy",
            "SwitchCamera",
            "SceneTransition",
            "Reset",
            "SetVariable",
            "DynamicVariablePlay",
            "Conditional",
          ],
          KeyPress: [
            "Transition",
            "Animation",
            "Audio",
            "Particles",
            "Video",
            "Link",
            "Create",
            "SwitchCamera",
            "Reset",
            "SetVariable",
            "DynamicVariablePlay",
            "Conditional",
          ],
          GameControl: [
            "Transition",
            "Animation",
            "Audio",
            "Particles",
            "Create",
            "Conditional",
          ],
          Collision: [
            "Transition",
            "Animation",
            "Audio",
            "Particles",
            "Video",
            "Create",
            "Destroy",
            "Reset",
            "SetVariable",
            "DynamicVariablePlay",
            "Conditional",
          ],
          Trigger: [
            "Transition",
            "Audio",
            "Particles",
            "Video",
            "Link",
            "Create",
            "Destroy",
            "SwitchCamera",
            "SceneTransition",
            "Reset",
            "SetVariable",
            "DynamicVariablePlay",
            "Conditional",
          ],
          Resize: [
            "Transition",
            "Animation",
            "Audio",
            "Particles",
            "Video",
            "Create",
            "Destroy",
            "SwitchCamera",
            "SceneTransition",
            "Reset",
            "SetVariable",
            "DynamicVariablePlay",
            "Conditional",
          ],
          VariableChange: [
            "Transition",
            "Animation",
            "Audio",
            "Particles",
            "Video",
            "Link",
            "Create",
            "Destroy",
            "SwitchCamera",
            "SceneTransition",
            "Reset",
            "SetVariable",
            "DynamicVariablePlay",
            "Conditional",
          ],
        };
      ((fD = fm || (fm = {})).is = function (_) {
        return (
          "MouseDown" === _.type ||
          "MouseUp" === _.type ||
          "MousePress" === _.type ||
          "KeyDown" === _.type ||
          "KeyUp" === _.type ||
          "KeyPress" === _.type
        );
      }),
        (fD.defaultData = function (_) {
          return "MouseDown" === _ || "MouseUp" === _ || "MousePress" === _
            ? {
                type: _,
                mode: "Object",
                disabled: !1,
                runMode: "Once",
                actions: new uN(),
              }
            : {
                type: _,
                disabled: !1,
                key: void 0,
                runMode: "Once",
                actions: new uN(),
              };
        }),
        ((fO = f6 || (f6 = {})).propertyDefaultData = function (_) {
          return { type: "Property", value: [_ ?? null, "position", "x"] };
        }),
        (fO.valueDefaultData = { type: "Literal", value: 0 }),
        ((fB = f8 || (f8 = {})).comparisonDefaultData = function (_) {
          return {
            type: "Comparison",
            operator: "==",
            lOperand: f6.propertyDefaultData(_),
            rOperand: { ...f6.valueDefaultData },
          };
        }),
        (fB.distanceDefaultData = function (_) {
          return {
            type: "Distance",
            toObject: _ ?? null,
            fromObject: _ ?? null,
            distance: 200,
          };
        }),
        (fB.stateDefaultData = function (_, I) {
          return { type: "State", object: _ ?? null, state: I ?? null };
        }),
        ((fL = f9 || (f9 = {})).is = function (_) {
          return "Conditional" === _.type;
        }),
        (fL.defaultData = function (_) {
          return {
            type: "Conditional",
            disabled: !1,
            inActions: new uN(),
            outActions: new uN(),
            condition: f8.distanceDefaultData(_),
          };
        }),
        ((f7 || (f7 = {})).defaultData = {
          type: "DragDrop",
          cursor: "hand",
          disabled: !1,
          dampingFactor: 1,
          objects: [],
          snapTo: "center",
          snapSurfaceMode: "bbox",
          snapSurfaceOffset: 0,
          dropOn: "all",
          autoOrient: !0,
          dropDestinations: [],
          plane: "adaptive",
          planeMode: "locked",
          referenceFrame: "global",
          limits: [-1 / 0, 1 / 0, -1 / 0, 1 / 0, -1 / 0, 1 / 0],
          drop: !1,
          resetOnSnapFail: !1,
          snapSpeed: 20,
          resetSpeed: 20,
          dragDropActions: { drag: new uN(), drop: new uN() },
        }),
        ((me || (me = {})).defaultData = {
          type: "Follow",
          disabled: !1,
          maxDelta: 0,
          dampingFactor: 1,
          target: "cursor",
          plane: "custom",
          resetOnPointerLeave: !0,
          resetAfterDistanceLimit: !0,
          enabledTranslation: [!0, !0, !0],
          limitDistanceEnabled: !1,
          limitDistance: 1e3,
          snapDelay: 0,
          resetSpeed: 5,
          actions: new uN(),
        }),
        ((mt || (mt = {})).defaultData = {
          type: "LookAt",
          disabled: !1,
          distance: 1e3,
          dampingFactor: 1,
          target: "cursor",
          tilt: "up",
          axis: "z",
          plane: "custom",
          resetOnPointerLeave: !0,
          resetAfterDistanceLimit: !0,
          enabledRotation: [!0, !0, !0],
          limitDistanceEnabled: !1,
          limitDistance: 1e3,
          snapDelay: 0,
          resetSpeed: 5,
        }),
        ((fz = mi || (mi = {})).is = function (_) {
          return "MouseHover" === _.type;
        }),
        (fz.defaultData = function () {
          return { type: "MouseHover", disabled: !1, actions: new uN() };
        }),
        ((fF = mr || (mr = {})).is = function (_) {
          return "Scroll" === _.type;
        }),
        (fF.defaultData = function () {
          return {
            type: "Scroll",
            disabled: !1,
            steps: 100,
            trigger: "load",
            startFrom: "enter",
            enterAnchor: "top",
            startOffset: 0,
            endAfter: 400,
            actions: new uN(),
          };
        }),
        ((fN = ma || (ma = {})).is = function (_) {
          return "Start" === _.type;
        }),
        (fN.defaultData = function () {
          return { type: "Start", disabled: !1, actions: new uN() };
        }),
        ((fk = mo || (mo = {})).is = function (_) {
          return "Collision" === _.type;
        }),
        (fk.defaultData = function () {
          return {
            type: "Collision",
            disabled: !1,
            runMode: "Once",
            target: "character",
            actions: new uN(),
          };
        }),
        ((fV = ml || (ml = {})).is = function (_) {
          return "Trigger" === _.type;
        }),
        (fV.defaultData = function (_, I) {
          return {
            type: "Trigger",
            disabled: !1,
            runMode: "Once",
            target: "all",
            triggeringObjects: [],
            actions: new uN(),
            triggerZone: "box",
            position: I.toArray(),
            rotation: [0, 0, 0],
            size: _.toArray(),
            radius: _.length() / 2,
            helperVisible: !0,
          };
        }),
        ((fj = mc || (mc = {})).defaultSizes = {
          mobile: [480, 480],
          tablet: [768, 768],
          desktop: [1200, 1200],
          custom: [769, 1200],
        }),
        (fj.is = function (_) {
          return "Resize" === _.type;
        }),
        (fj.sizeToDevice = function (_) {
          return "string" == typeof _ ? _ : "custom";
        }),
        (fj.deviceToSize = function (_) {
          return "string" == typeof _ ? [...fj.defaultSizes[_]] : [..._];
        }),
        (fj.defaultData = function () {
          let _ = { size: "mobile", operator: "<", actions: new uN() },
            I = { size: "tablet", operator: "<", actions: new uN() },
            R = {
              size: [...fj.defaultSizes.custom],
              operator: "<>",
              actions: new uN(),
            },
            B = new uN();
          return (
            B.push(
              { id: rr.generateUUID(), fi: 0, data: _ },
              { id: rr.generateUUID(), fi: 1, data: I },
              { id: rr.generateUUID(), fi: 2, data: R }
            ),
            {
              type: "Resize",
              disabled: !1,
              orientation: "horizontal",
              breakpoints: B,
            }
          );
        }),
        (fj.defaultBreakpointData = function () {
          return {
            size: [...fj.defaultSizes.custom],
            operator: "<>",
            actions: new uN(),
          };
        }),
        ((fG = md || (md = {})).propertyPaths = {
          Position: ["position"],
          "Position X": ["position", "x"],
          "Position Y": ["position", "y"],
          "Position Z": ["position", "z"],
          Rotation: ["rotation"],
          "Rotation X": ["rotation", "x"],
          "Rotation Y": ["rotation", "y"],
          "Rotation Z": ["rotation", "z"],
          Scale: ["scale"],
          "Scale X": ["scale", "x"],
          "Scale Y": ["scale", "y"],
          "Scale Z": ["scale", "z"],
          Width: ["width"],
          Height: ["height"],
          Depth: ["depth"],
          "Mouse Position X": ["mouse", "x"],
          "Mouse Position Y": ["mouse", "y"],
          "Mouse Pressed": ["mouse", "pressed"],
          "Screen Width": ["mouse", "width"],
          "Screen Height": ["mouse", "height"],
          "Hit Position X": ["raycast", "x"],
          "Hit Position Y": ["raycast", "y"],
          "Hit Position Z": ["raycast", "z"],
          "Hit Object Position X": ["raycast", "objX"],
          "Hit Object Position Y": ["raycast", "objY"],
          "Hit Object Position Z": ["raycast", "objZ"],
        }),
        (fG.is = function (_) {
          return "VariableChange" === _.type;
        }),
        (fG.defaultData = function () {
          return {
            disabled: !1,
            type: "VariableChange",
            actions: new uN(),
            variableId: "",
            objectId: null,
            property: "Position X",
          };
        });
      var fx = "personal camera",
        fb = "a218fcc3-276b-49b9-b485-49037fd14f5f";
      function v1(_) {
        return (
          "string" == typeof _ &&
          36 === _.length &&
          /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(
            _
          )
        );
      }
      ((_) => {
        function o(_, I) {
          return Math.pow(I[0] - _[0], 2) + Math.pow(I[1] - _[1], 2);
        }
        function a(_, I) {
          return Math.sqrt(o(_, I));
        }
        function c(I, R, B) {
          let z = _.sub(R, I),
            k = _.sub(B, I),
            V = _.dot(z, k) / _.dot(z, z),
            j = _.scalarMultiply(z, V);
          return _.add(I, j);
        }
        (_.isEqual = function (_, I) {
          return _[0] === I[0] && _[1] === I[1];
        }),
          (_.lerp = function (_, I, R) {
            return [_[0] + (I[0] - _[0]) * R, _[1] + (I[1] - _[1]) * R];
          }),
          (_.add = function (_, I) {
            return [_[0] + I[0], _[1] + I[1]];
          }),
          (_.sub = function (_, I) {
            return [_[0] - I[0], _[1] - I[1]];
          }),
          (_.multiply = function (_, I) {
            return [_[0] * I[0], _[1] * I[1]];
          }),
          (_.divide = function (_, I) {
            return [_[0] / I[0], _[1] / I[1]];
          }),
          (_.distanceSquared = o),
          (_.distance = a),
          (_.dot = function (_, I) {
            return _[0] * I[0] + _[1] * I[1];
          }),
          (_.scalarMultiply = function (_, I) {
            return [_[0] * I, _[1] * I];
          }),
          (_.projectionOnto = c),
          (_.projectionOntoDistance = function (_, I, R) {
            return a(_, c(_, I, R));
          }),
          (_.center = function (_, I) {
            return [(_[0] + I[0]) * 0.5, (_[1] + I[1]) * 0.5];
          });
      })(mu || (mu = {})),
        ((fH = mp || (mp = {})).isEqual = function (_, I) {
          return _[0] === I[0] && _[1] === I[1] && _[2] === I[2];
        }),
        (fH.add = function (_, I) {
          return [_[0] + I[0], _[1] + I[1], _[2] + I[2]];
        }),
        (fH.sub = function (_, I) {
          return [_[0] - I[0], _[1] - I[1], _[2] - I[2]];
        }),
        (fH.div = function (_, I) {
          return [_[0] / I[0], _[1] / I[1], _[2] / I[2]];
        }),
        (fH.mul = function (_, I) {
          return [_[0] * I[0], _[1] * I[1], _[2] * I[2]];
        }),
        (fH.dist = function (_, I) {
          return Math.hypot(_[0] - I[0], _[1] - I[1], _[2] - I[2]);
        }),
        (fH.lerp = function (_, I, R) {
          return [
            _[0] + (I[0] - _[0]) * R,
            _[1] + (I[1] - _[1]) * R,
            _[2] + (I[2] - _[2]) * R,
          ];
        }),
        ((fW = mg || (mg = {})).isEqual = function (_, I) {
          return (
            _[0] === I[0] && _[1] === I[1] && _[2] === I[2] && _[3] === I[3]
          );
        }),
        (fW.lerp = function (_, I, R) {
          return [
            _[0] + (I[0] - _[0]) * R,
            _[1] + (I[1] - _[1]) * R,
            _[2] + (I[2] - _[2]) * R,
            _[3] + (I[3] - _[3]) * R,
          ];
        }),
        ((fq = mv || (mv = {})).identity = [
          1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
        ]),
        (fq.isEqual = function (_, I) {
          for (let R = 0; R < 16; R++) if (_[R] !== I[R]) return !1;
          return !0;
        }),
        (fq.simplify = function (_) {
          return _ ?? fq.identity;
        }),
        (fq.applyMatrix4 = function (_, I) {
          let R = I.slice(0);
          for (var B = 0, z = I.length; B < z; B += 3) {
            let z = _[3] * I[B] + _[7] * I[B + 1] + _[11] * I[B + 2] + _[15];
            (R[B] =
              (_[0] * I[B] + _[4] * I[B + 1] + _[8] * I[B + 2] + _[12]) / z),
              (R[B + 1] =
                (_[1] * I[B] + _[5] * I[B + 1] + _[9] * I[B + 2] + _[13]) / z),
              (R[B + 2] =
                (_[2] * I[B] + _[6] * I[B + 1] + _[10] * I[B + 2] + _[14]) / z);
          }
          return R;
        }),
        ((fY = mx || (mx = {})).isRGB = function (_) {
          return (
            "object" == typeof _ &&
            "number" == typeof _.r &&
            "number" == typeof _.g &&
            "number" == typeof _.b
          );
        }),
        (fY.white = { r: 1, g: 1, b: 1 }),
        (fY.red = { r: 1, g: 0, b: 0 }),
        (fY.black = { r: 0, g: 0, b: 0 }),
        (fY.toRgb255a1 = function (_) {
          return {
            r: Math.round(255 * _.r),
            g: Math.round(255 * _.g),
            b: Math.round(255 * _.b),
            a: 1,
          };
        }),
        (fY.clone = function (_) {
          return { r: _.r, g: _.g, b: _.b };
        }),
        (fY.fromHex = function (_) {
          return {
            r: (((_ = Math.floor(_)) >> 16) & 255) / 255,
            g: ((_ >> 8) & 255) / 255,
            b: (255 & _) / 255,
          };
        }),
        (fY.toHex = function (_) {
          return (
            65536 * Math.round(255 * _.r) +
            256 * Math.round(255 * _.g) +
            Math.round(255 * _.b)
          );
        }),
        (fY.equals = function (_, I) {
          return _.r === I.r && _.g === I.g && _.b === I.b;
        }),
        (fY.equalsFixed = function (_, I) {
          return (
            _.r.toFixed(2) === I.r.toFixed(2) &&
            _.g.toFixed(2) === I.g.toFixed(2) &&
            _.b.toFixed(2) === I.b.toFixed(2)
          );
        }),
        (fY.lerp = function (_, I, R) {
          return {
            r: _.r + (I.r - _.r) * R,
            g: _.g + (I.g - _.g) * R,
            b: _.b + (I.b - _.b) * R,
          };
        }),
        ((fX = mb || (mb = {})).white = { ...mx.white, a: 1 }),
        (fX.transparent = { ...mx.white, a: 0 }),
        (fX.from0to1 = function (_) {
          return { r: _[0], g: _[1], b: _[2], a: _[3] };
        }),
        (fX.fromHexAndA = function (_, I) {
          return { ...mx.fromHex(_), a: I };
        }),
        (fX.toRgb255a1 = function (_) {
          return {
            r: Math.round(255 * _.r),
            g: Math.round(255 * _.g),
            b: Math.round(255 * _.b),
            a: _.a,
          };
        }),
        (fX.equals = function (_, I) {
          return mx.equals(_, I) && _.a === I.a;
        }),
        (fX.equalsFixed = function (_, I) {
          return mx.equalsFixed(_, I) && _.a.toFixed(2) === I.a.toFixed(2);
        }),
        (fX.lerp = function (_, I, R) {
          return {
            r: _.r + (I.r - _.r) * R,
            g: _.g + (I.g - _.g) * R,
            b: _.b + (I.b - _.b) * R,
            a: _.a + (I.a - _.a) * R,
          };
        }),
        (fX.toStyle = function ({ r: _, g: I, b: R, a: B } = fX.white) {
          return `rgba(${255 * _}, ${255 * I}, ${255 * R}, ${B})`;
        }),
        ((mw || (mw = {})).identity = {
          position: [0, 0, 0],
          rotation: [0, 0, 0],
          scale: [1, 1, 1],
        }),
        ((mE || (mE = {})).defaultData = {
          mass: 1,
          stiffness: 80,
          damping: 10,
          velocity: 0,
        }),
        ((mC || (mC = {})).defaultData = {
          control1: [0.5, 0],
          control2: [0.5, 1],
        }),
        ((fQ = mT || (mT = {})).linear = [0, 0, 1, 1]),
        (fQ.ease = [0.25, 0.1, 0.25, 1]),
        (fQ.easeIn = [0.42, 0, 1, 1]),
        (fQ.easeOut = [0, 0, 0.58, 1]),
        (fQ.easeInOut = [0.42, 0, 0.58, 1]),
        ((fZ = mP || (mP = {})).all = [
          "PerspectiveCamera",
          "OrthographicCamera",
        ]),
        (fZ.is = function (_) {
          return fZ.all.includes(_);
        }),
        ((fK = mO || (mO = {})).DefaultUp = [0, 1, 0]),
        (fK.DefaultTargetOffset = 1e3),
        (fK.defaultData = {
          far: 1e5,
          type: "OrthographicCamera",
          perspective: { near: 70, fov: 45, zoom: 1 },
          orthographic: { near: -1e5, zoom: 1 },
          up: fK.DefaultUp,
          isUpVectorFlipped: !1,
          targetOffset: fK.DefaultTargetOffset,
        }),
        (fK.getZoom = function (_) {
          return "PerspectiveCamera" === _.type
            ? _.perspective.zoom
            : _.orthographic.zoom;
        }),
        ((fJ = mI || (mI = {})).defaultData = function (_, I = 0.1) {
          return {
            disabled: !1,
            type: "linear",
            hideBase: !1,
            count: 3,
            radial: {
              radius: 2 * Math.max(_[0], _[1]),
              start: 0,
              end: 360,
              alignment: !1,
              axis: "y",
              scale: [1, 1, 1],
              rotation: [0, 0, 0],
              position: [0, 0, 0],
            },
            toObject: {
              object: "",
              spreadType: "random",
              scale: [0, 0, 0],
              rotation: [0, 0, 0],
              position: [0, 0, 0],
              axis: "x",
              seed: 0,
              count: 99,
              align: "normal",
            },
            linear: {
              scale: [1, 1, 1],
              rotation: [0, 0, 0],
              position: [_[0] + _[0] * I, 0, 0],
            },
            grid: {
              count: [2, 2, 2],
              size: _.map((_) => _ * (1 + I)),
              useCenter: !0,
            },
            randomness: !1,
            randomnessObject: {
              strength: 100,
              scale: [0, 0, 0],
              rotation: [0, 0, 0],
              position: [0, 0, 0],
              movement: 1,
              seed: 0,
              freqScale: 10,
              noiseType: "perlin",
            },
          };
        }),
        (fJ.merge = function (_, I) {
          let R = { ..._ };
          if (
            (fw.forEach((B) => {
              Object.assign(R, { [B]: I[B] ?? _[B] });
            }),
            (R.radial = { ..._.radial }),
            I.radial)
          ) {
            let B = _.radial,
              z = I.radial;
            f_.forEach((_) => {
              Object.assign(R.radial, { [_]: z[_] ?? B[_] });
            });
          }
          if (((R.linear = { ..._.linear }), I.linear)) {
            let B = _.linear,
              z = I.linear;
            fS.forEach((_) => {
              Object.assign(R.linear, { [_]: z[_] ?? B[_] });
            });
          }
          if (((R.grid = { ..._.grid }), I.grid)) {
            let B = _.grid,
              z = I.grid;
            fC.forEach((_) => {
              Object.assign(R.grid, { [_]: z[_] ?? B[_] });
            });
          }
          if (((R.toObject = { ..._.toObject }), I.toObject)) {
            let B = _.toObject,
              z = I.toObject;
            fT.forEach((_) => {
              Object.assign(R.toObject, { [_]: z[_] ?? B[_] });
            });
          }
          if (
            ((R.randomnessObject = { ..._.randomnessObject }),
            I.randomnessObject)
          ) {
            let B = _.randomnessObject,
              z = I.randomnessObject;
            fP.forEach((_) => {
              Object.assign(R.randomnessObject, { [_]: z[_] ?? B[_] });
            });
          }
          return R;
        }),
        ((f$ = mB || (mB = {})).defaultData = {
          radial: {},
          linear: {},
          grid: {},
          toObject: {},
          randomnessObject: {},
        }),
        (B = ["radial", "linear", "grid", "toObject", "randomnessObject"]),
        (f$.toOps = function (_, I) {
          let R = [];
          for (let z of (void 0 !== _.count &&
            R.push({ type: 0, path: I, props: { count: _.count } }),
          B)) {
            let B = _[z];
            B &&
              Object.keys(B).length > 0 &&
              R.push({ type: 0, path: [...I, z], props: B });
          }
          return R;
        });
      var fw = ["count"],
        f_ = ["radius", "start", "end", "position", "scale", "rotation"],
        fS = ["position", "scale", "rotation"],
        fC = ["count", "size"],
        fT = ["count", "position", "scale", "rotation"],
        fP = [
          "strength",
          "scale",
          "rotation",
          "position",
          "movement",
          "seed",
          "freqScale",
        ];
      ((f0 = mL || (mL = {})).all = [
        "PointLight",
        "SpotLight",
        "DirectionalLight",
        "HemisphereLight",
      ]),
        (f0.is = function (_) {
          return f0.all.includes(_);
        }),
        ((mz || (mz = {})).defaultData = function (_) {
          return (function (_) {
            if ("PointLight" === _)
              return {
                type: _,
                color: mb.white,
                intensity: 1,
                distance: 2e3,
                decay: 1,
                shadows: !0,
                shadowResolution: 1024,
                shadowRadius: 1,
                penumbraSize: 0.5,
                depth: 1e5,
              };
            if ("SpotLight" === _)
              return {
                type: _,
                color: mb.white,
                intensity: 1,
                distance: 2e3,
                decay: 1,
                shadows: !0,
                penumbra: 0,
                angle: (30 / 180) * Math.PI,
                depth: 1e5,
                penumbraSize: 0.5,
                shadowResolution: 1024,
                shadowRadius: 1,
              };
            if ("DirectionalLight" === _)
              return {
                type: _,
                color: mb.white,
                intensity: 1,
                shadows: !0,
                size: 2e3,
                depth: 1e5,
                penumbraSize: 0.5,
                shadowResolution: 1024,
                shadowRadius: 1,
              };
            throw Error("not implemented");
          })(_);
        }),
        ((f1 = mF || (mF = {})).defaultShapeData = {
          type: "PlaneEmitterShape",
          size: [100, 100, 100],
        }),
        (f1.defaultCollisionData = {
          colliderEntityId: null,
          collisionBounce: 0.75,
        }),
        (f1.defaultData = {
          renderMaterial: {
            type: "particleMaterial",
            color: { r: 1, g: 0.2, b: 0.545, a: 1 },
            color2: { r: 0.945, g: 0.714, b: 0.184, a: 1 },
            coloring: "gradient",
            ease: "linearFadeOut",
            easeSize: "linearFadeOut",
            transparent: !0,
            size: [40, 40],
            texture: "pt_default_particle",
            spriteRotation: [0, 0],
          },
          birthRatePerSec: 50,
          gravity: 1,
          noiseStrength: 0,
          noiseScale: 0,
          noiseSeed: 1,
          noiseType: "curl",
          randomRotation: 0,
          randomScale: 0.2,
          randomMass: 0.5,
          rootObjectType: "instancedMesh",
          life: 1,
          direction: [0, 0, 0],
          directionMode: "axis",
          speed: 10,
          shape: f1.defaultShapeData,
          autoPlay: !0,
          emitTimeDelay: 0,
          emitTimeCycle: "infinity",
          emitTimeLoopDelayStart: "end",
          emitTimeDuration: 1,
          ...f1.defaultCollisionData,
        }),
        ((mN || (mN = {})).defaultData = {
          enabled: "visibility",
          fusedBody: !0,
          rigidBody: "positioned",
          density: 1,
          pointMass: 0,
          gravityScale: 1,
          friction: 0.5,
          damping: 0,
          restitution: 0.2,
          colliderType: "convex",
          enabledRotation: [!0, !0, !0],
          enabledTranslation: [!0, !0, !0],
        }),
        ((f2 = mk || (mk = {})).defaultData = {
          castShadow: !0,
          receiveShadow: !0,
        }),
        (f2.equals = function (_, I) {
          return (
            _.castShadow === I.castShadow && _.receiveShadow === I.receiveShadow
          );
        }),
        ((f3 = mU || (mU = {})).defaultData = {
          flatShading: !1,
          wireframe: !1,
          side: 0,
        }),
        (f3.equals = function (_, I) {
          return (
            _.flatShading === I.flatShading &&
            _.side === I.side &&
            _.wireframe === I.wireframe
          );
        }),
        ((mV || (mV = {})).defaultData = {
          ...mU.defaultData,
          ...mk.defaultData,
        }),
        ((mj || (mj = {})).getMaterialData = function (_, I) {
          let R = [];
          if ("material" in _) {
            let B =
              "string" == typeof _.material
                ? I.materials[_.material] ?? I.lib.materials[_.material]?.asset
                : _.material;
            B && R.push(B);
          } else if ("materials" in _)
            for (let B of _.materials) {
              let _ =
                "string" == typeof B
                  ? I.materials[B] ?? I.lib.materials[B]?.asset
                  : B;
              _ && R.push(_);
            }
          return R;
        }),
        ((f5 = mG || (mG = {})).defaultVideo = {
          data: "",
          thumb: "https://egotv.github.io/ego-demos/assets/videos/catThumb.png",
          type: "video",
          name: "Cat video",
        }),
        (f5.maxSize = 3e7),
        ((mH || (mH = {})).is = function (_) {
          return (
            "texture" === _ ||
            "video" === _ ||
            "color" === _ ||
            "depth" === _ ||
            "normal" === _ ||
            "gradient" === _ ||
            "noise" === _ ||
            "fresnel" === _ ||
            "rainbow" === _ ||
            "toon" === _ ||
            "outline" === _ ||
            "particle" === _ ||
            "transmission" === _ ||
            "matcap" === _ ||
            "displace" === _ ||
            "pattern" === _ ||
            "light" === _
          );
        }),
        ((mW || (mW = {})).is = function (_) {
          return (
            "phong" === _ || "toon" === _ || "lambert" === _ || "physical" === _
          );
        });
      var fD,
        fO,
        fB,
        fL,
        fz,
        fF,
        fN,
        fk,
        fV,
        fj,
        fG,
        fH,
        fW,
        fq,
        fY,
        fX,
        fQ,
        fZ,
        fK,
        fJ,
        f$,
        f0,
        f1,
        f2,
        f3,
        f5,
        f6,
        f8,
        f9,
        f7,
        me,
        mt,
        mi,
        mr,
        ma,
        mo,
        ml,
        mc,
        md,
        mu,
        mp,
        mg,
        mv,
        mx,
        mb,
        mw,
        mE,
        mC,
        mT,
        mP,
        mO,
        mI,
        mB,
        mL,
        mz,
        mF,
        mN,
        mk,
        mU,
        mV,
        mj,
        mG,
        mH,
        mW,
        mq,
        mY = [
          "mode",
          "gradientType",
          "noiseType",
          "displacementType",
          "projection",
          "cnormal",
          "crop",
          "axis",
          "side",
        ],
        mX = ["wrapping", "image", "video", "name", "minFilter"];
      ((gb = mq || (mq = {})).patch = function (_, I) {
        let { texture: R, ...B } = I;
        if ((Object.assign(_, B), R)) {
          let I = _.texture;
          I && Object.assign(I, R);
        }
      }),
        (gb.defaultData = function (_, I) {
          return "light" === _ && I
            ? (function (_) {
                let I = {
                  mode: 0,
                  isMask: !1,
                  visible: !0,
                  bumpMap: void 0,
                  bumpMapIntensity: 5,
                  roughnessMap: void 0,
                  alphaOverride: 1,
                };
                switch (_) {
                  case "phong":
                    return {
                      ...I,
                      category: "phong",
                      specular: { r: 0.2, g: 0.2, b: 0.2 },
                      shininess: 5,
                      type: "light",
                      visible: !0,
                      mode: 0,
                      occlusion: !0,
                      alpha: 0.6,
                    };
                  case "toon":
                    return {
                      ...I,
                      category: "toon",
                      specular: { r: 0.2, g: 0.2, b: 0.2 },
                      shininess: 10,
                      type: "light",
                      alpha: 1,
                    };
                  case "lambert":
                    return {
                      ...I,
                      category: "lambert",
                      emissive: { r: 0, g: 0, b: 0 },
                      type: "light",
                      alpha: 1,
                      visible: !0,
                      mode: 0,
                      occlusion: !0,
                    };
                  case "physical":
                    return {
                      ...I,
                      category: "physical",
                      roughness: 0.2,
                      metalness: 0.2,
                      reflectivity: 0.2,
                      type: "light",
                      alpha: 1,
                      visible: !0,
                      mode: 0,
                      occlusion: !0,
                    };
                }
              })(I)
            : (function (_) {
                let I = { alpha: 1, mode: 0, isMask: !1, visible: !0 };
                switch (_) {
                  case "texture":
                    return {
                      ...I,
                      type: "texture",
                      size: [128, 128],
                      blending: 0,
                      axis: "x",
                      side: 2,
                      projection: 0,
                      texture: {
                        image: "image_0",
                        wrapping: 1e3,
                        repeat: [1, 1],
                        offset: [0, 0],
                        minFilter: 1008,
                      },
                      crop: !1,
                    };
                  case "video":
                    return {
                      ...I,
                      type: "video",
                      size: [128, 128],
                      blending: 0,
                      axis: "x",
                      side: 2,
                      projection: 0,
                      texture: {
                        video: mG.defaultVideo,
                        wrapping: 1001,
                        repeat: [1, 1],
                        offset: [0, 0],
                        minFilter: 1008,
                      },
                      crop: !1,
                    };
                  case "color":
                    return { ...I, type: "color", color: mx.fromHex(5526619) };
                  case "depth":
                    return {
                      ...I,
                      type: "depth",
                      gradientType: 1,
                      smooth: !1,
                      isVector: !0,
                      isWorldSpace: !1,
                      origin: [0, 0, 0],
                      direction: [1, 0, 0],
                      colors: [
                        [1, 1, 1, 1],
                        [0, 0, 0, 1],
                      ],
                      steps: [0, 1],
                      near: 50,
                      far: 200,
                    };
                  case "normal":
                    return { ...I, type: "normal", cnormal: [1, 1, 1] };
                  case "gradient":
                    return {
                      ...I,
                      type: "gradient",
                      gradientType: 0,
                      smooth: !1,
                      colors: [
                        [0, 0, 0, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                      ],
                      steps: [0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                      num: 2,
                      angle: 0,
                      offset: [0, 0],
                      morph: [0, 0],
                    };
                  case "noise":
                    return {
                      ...I,
                      type: "noise",
                      size: [100, 100, 100],
                      noiseType: 0,
                      scale: 1,
                      move: 1,
                      colorA: { ...mx.fromHex(6710886), a: 1 },
                      colorB: { ...mx.fromHex(6710886), a: 1 },
                      colorC: { ...mx.fromHex(16777215), a: 1 },
                      colorD: { ...mx.fromHex(16777215), a: 1 },
                      distortion: [1, 1],
                      fA: [1.7, 9.2],
                      fB: [8.3, 2.8],
                      voronoiStyle: 0,
                      highCut: 1,
                      lowCut: 0,
                      smoothness: 0.3,
                      seed: 0,
                      quality: 1,
                    };
                  case "fresnel":
                    return {
                      ...I,
                      type: "fresnel",
                      color: mb.fromHexAndA(16777215, 1),
                      bias: 0.1,
                      scale: 1,
                      intensity: 2,
                      factor: 1,
                    };
                  case "rainbow":
                    return {
                      ...I,
                      type: "rainbow",
                      filmThickness: 30,
                      movement: 0,
                      wavelengths: [0, 0, 0],
                      noiseStrength: 0,
                      noiseScale: 1,
                      offset: [0, 0, 0],
                    };
                  case "toon":
                    return {
                      ...I,
                      type: "toon",
                      positioning: 2,
                      colors: [
                        [0, 0, 0, 1],
                        [0.5, 0.5, 0.5, 1],
                        [0.5, 0.5, 0.5, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                      ],
                      steps: [0, 0.475, 0.525, 1, 1, 1, 1, 1, 1, 1],
                      num: 4,
                      source: [0, 1e3, 0],
                      isWorldSpace: !0,
                      noiseStrength: 0,
                      noiseScale: 1,
                      shadowColor: mb.fromHexAndA(0, 0),
                      offset: [0, 0, 0],
                    };
                  case "outline":
                    return {
                      ...I,
                      type: "outline",
                      outlineColor: mb.fromHexAndA(0, 1),
                      contourColor: mb.fromHexAndA(0, 1),
                      outlineWidth: 2,
                      contourWidth: 5,
                      outlineThreshold: 0.4,
                      contourThreshold: 0,
                      outlineSmoothing: 0,
                      contourFrequency: 10,
                      contourDirection: [0, 1, 0],
                      positionalLines: !1,
                      compensation: !0,
                    };
                  case "matcap":
                    return {
                      ...I,
                      type: "matcap",
                      texture: {
                        image: "matcap_0",
                        wrapping: 1001,
                        repeat: [1, 1],
                        offset: [0, 0],
                        minFilter: 1008,
                      },
                    };
                  case "transmission":
                    return {
                      ...I,
                      type: "transmission",
                      thickness: 10,
                      ior: 1.5,
                      roughness: 1,
                    };
                  case "displace":
                    return {
                      visible: !0,
                      type: "displace",
                      displacementType: "noise",
                      noiseType: 0,
                      scale: 10,
                      movement: 1,
                      offset: [0, 0, 0],
                      intensity: 8,
                      voronoiStyle: 0,
                      smoothness: 0.3,
                      seed: 0,
                      highCut: 1,
                      lowCut: 0,
                      quality: 1,
                    };
                  case "pattern":
                    return {
                      ...I,
                      type: "pattern",
                      style: 0,
                      projection: 0,
                      axis: "y",
                      blending: 0,
                      offset: [0, 0],
                      colorA: { ...mx.fromHex(0), a: 1 },
                      colorB: { ...mx.fromHex(16777215), a: 1 },
                      frequency: [10, 10],
                      size: 0.5,
                      variation: 0,
                      smoothness: 0.5,
                      zigzag: 0,
                      rotation: 0,
                      vertical: [0, 1],
                      horizontal: [0, 1],
                      sides: 6,
                    };
                }
              })(_);
        }),
        ((_) => {
          function s(_, I = "layer1", R = "layer2") {
            let B = new uN();
            return (
              B.push({ fi: 0, data: mq.defaultData("light", _), id: I }),
              B.push({ fi: 1, data: mq.defaultData("color"), id: R }),
              { layers: B }
            );
          }
          (_.isMergable = function (_) {
            return !_.layers.some(
              (_) =>
                ("texture" === _.data.type && 0 !== _.data.projection) ||
                ("depth" === _.data.type && !_.data.isWorldSpace) ||
                "noise" === _.data.type ||
                "displace" === _.data.type
            );
          }),
            (_.getHash = function (_) {
              let I = "";
              return (
                _.layers.forEach((_) => {
                  Object.entries(_.data).forEach(([_, R]) => {
                    (I += `${_}${R}`),
                      Array.isArray(R)
                        ? R.forEach((_) => (I += `${_}`))
                        : "object" == typeof R
                        ? Object.values(R).forEach((_) => {
                            "number" == typeof _
                              ? (I += `${_.toFixed(4)}`)
                              : (I += `${_}`);
                          })
                        : (I += `${R}`);
                  });
                }),
                I
              );
            }),
            (_.defaultEmptyData = function () {
              return { layers: new uN() };
            }),
            (_.defaultData = function (_ = "layer1", I = "layer2") {
              return s("phong", _, I);
            }),
            (_.withName = function (_, I) {
              return { ..._, name: I };
            }),
            (_.defaultTwoLayerData = s),
            (_.defaultUIObjectMaterial = function (_) {
              let I = mq.defaultData("texture");
              _ && Object.assign(I.texture, { image: _ });
              let R = new uN();
              return (
                R.push({ fi: 0, data: I, id: "layer1" }),
                R.push({
                  fi: 1,
                  data: { ...mq.defaultData("transmission"), alpha: 1 },
                  id: "layer2",
                }),
                R.push({
                  fi: 2,
                  data: { ...mq.defaultData("light", "lambert"), alpha: 0 },
                  id: "layer3",
                }),
                { layers: R }
              );
            }),
            (_.defaultTwoLayerTextureData = function (
              _,
              I = "phong",
              R = "layer1",
              B = "layer2"
            ) {
              let z = mq.defaultData("texture");
              Object.assign(z.texture, { image: _ });
              let k = new uN();
              return (
                k.push({ fi: 0, data: z, id: R }),
                k.push({ fi: 1, data: mq.defaultData("light", I), id: B }),
                { layers: k }
              );
            }),
            (_.defaultTwoLayerVideoTextureData = function (
              _,
              I = "phong",
              R = "layer1",
              B = "layer2"
            ) {
              let z = mq.defaultData("video");
              Object.assign(z.texture, { video: _ });
              let k = new uN();
              return (
                k.push({ fi: 0, data: z, id: R }),
                k.push({ fi: 1, data: mq.defaultData("light", I), id: B }),
                { layers: k }
              );
            });
        })(gG || (gG = {})),
        ((gH || (gH = {})).defaultData = function () {
          return {
            points: new uN(),
            roundness: 0,
            shapeHoles: [],
            isClosed: !1,
          };
        }),
        ((gW || (gW = {})).defaultData = function () {
          return {
            points: new uN(),
            lastInsertionPlane: null,
            subdivisions: 12,
            isClosed: !1,
          };
        });
      var mQ = {
        type: "Ellipse",
        width: 50,
        height: 50,
        spikes: 16,
        angle: 360,
        innerRadius: 0,
      };
      (gq || (gq = {})).merge = function (_, I) {
        let R = { ..._ };
        return (
          mK.forEach((B) => {
            Object.assign(R, { [B]: I[B] ?? _[B] });
          }),
          R
        );
      };
      var mZ = {
          shape: mQ,
          depth: 1,
          offset: 0,
          bevel: 50,
          bevelSides: 6,
          angle: 0,
          twist: 0,
          startScale: 1,
          endScale: 1,
          capType: "flat",
        },
        mK = ["depth", "offset", "angle", "twist", "startScale", "endScale"];
      ((gw = gY || (gY = {})).is2DParametricMesh = function (_) {
        return (
          "PolygonGeometry" === _ ||
          "RectangleGeometry" === _ ||
          "StarGeometry" === _ ||
          "TriangleGeometry" === _ ||
          "EllipseGeometry" === _ ||
          "UIGeometry" === _
        );
      }),
        (gw.isParametricMesh = function (_) {
          return (
            "PolygonGeometry" === _ ||
            "PolygonGeometry" === _ ||
            "RectangleGeometry" === _ ||
            "StarGeometry" === _ ||
            "TriangleGeometry" === _ ||
            "EllipseGeometry" === _ ||
            "PathGeometry" === _ ||
            "VectorGeometry" === _ ||
            "ConeGeometry" === _ ||
            "CubeGeometry" === _ ||
            "CylinderGeometry" === _ ||
            "DodecahedronGeometry" === _ ||
            "HelixGeometry" === _ ||
            "IcosahedronGeometry" === _ ||
            "LatheGeometry" === _ ||
            "PyramidGeometry" === _ ||
            "SphereGeometry" === _ ||
            "PlaneGeometry" === _ ||
            "BackdropGeometry" === _ ||
            "TorusGeometry" === _ ||
            "TorusKnotGeometry" === _ ||
            "BooleanGeometry" === _ ||
            "TextGeometry" === _
          );
        }),
        ((gX || (gX = {})).merge = function (_, I) {
          let R = { ..._ };
          return (
            Object.assign(R, I),
            "PathGeometry" === R.type &&
              "extrusion" in I &&
              I.extrusion &&
              ((R.extrusion = { ..._.extrusion }),
              Object.assign(R.extrusion, gq.merge(R.extrusion, I.extrusion))),
            R
          );
        }),
        ((gQ || (gQ = {})).defaultData = function (_) {
          if ("RectangleGeometry" === _)
            return {
              width: 320,
              height: 320,
              type: _,
              cornerRadius: [0, 0, 0, 0],
              cornerType: 0,
              depth: 0,
              extrudeBevelSize: 0,
              extrudeBevelSegments: 1,
            };
          if ("UIGeometry" === _)
            return {
              type: _,
              frame: "",
              cornerRadius: [0, 0, 0, 0],
              cornerType: 0,
              width: 1,
              height: 1,
            };
          if ("PathGeometry" === _)
            return {
              type: _,
              width: 1,
              height: 1,
              depth: 1,
              path: gW.defaultData(),
              extrusion: mZ,
            };
          if ("VectorGeometry" === _)
            return {
              width: 1,
              height: 1,
              type: _,
              subdivisions: 12,
              shape: gH.defaultData(),
              depth: 0,
              extrudeBevelSize: 0,
              extrudeBevelSegments: 1,
            };
          if ("BooleanGeometry" === _)
            return {
              type: _,
              operation: 2,
              width: 0,
              height: 0,
              depth: 0,
              phongAngle: 35,
            };
          if ("TextGeometry" === _)
            return {
              type: _,
              width: 100,
              height: 100,
              depth: 0,
              horizontalAlign: 1,
              verticalAlign: 1,
              fontSize: 16,
              lineHeight: 1.2,
              letterSpacing: 0,
              text: { textValue: "" },
              textTransform: 1,
              font: "Roboto_regular",
              extrudeBevelSize: 0,
              extrudeBevelSegments: 1,
            };
          if ("SphereGeometry" === _)
            return {
              type: "SphereGeometry",
              width: 100,
              height: 100,
              depth: 100,
              widthSegments: 64,
              heightSegments: 64,
              phiStart: 0,
              phiLength: 2 * Math.PI,
              thetaStart: 0,
              thetaLength: 180,
            };
          throw Error("not implemented");
        });
      var mJ = ["width", "height", "depth"];
      function KD(_) {
        _.layers.forEach((_) => {
          if ("depth" === _.type && void 0 !== _.colorA) {
            let I = _.colorA,
              R = _.colorB,
              B = [
                [I.r, I.g, I.b, I.a],
                [R.r, R.g, R.b, R.a],
              ],
              z = [0, 1];
            for (let _ = 2; _ < 10; _++) B.push(B[1]), z.push(1);
            let k = {
              ...uo(
                kr(_),
                "type",
                "visible",
                "isVector",
                "isWorldSpace",
                "origin",
                "alpha",
                "mode"
              ),
              near: Math.max(0, _.near),
              far: Math.max(0, _.far),
              colors: B,
              steps: z,
              num: 2,
              direction: [1, 0, 0],
              smooth: !1,
              gradientType: 1,
            };
            Object.assign(_, k);
          } else if (
            "depth" === _.type &&
            1 === _.gradientType &&
            (_.near < 0 || _.far < 0)
          ) {
            let I = {
              ...kr(_),
              near: Math.max(_.near, 0),
              far: Math.max(_.far, 0),
            };
            Object.assign(_, I);
          }
        });
      }
      function Ra(_, I) {
        Object.values(_.shared.materials).forEach((_) => I(_));
      }
      function La(_, I) {
        _.scene.objects.traverse((_, R) => {
          "materials" in R
            ? R.materials.forEach((_, B) => {
                void 0 === _ &&
                  ((R.materials[B] = gG.defaultData()), (_ = R.materials[B])),
                  "string" != typeof _ && I(_);
              })
            : "material" in R
            ? "string" != typeof R.material &&
              (void 0 === R.material && (R.material = gG.defaultData()),
              I(R.material))
            : "Mesh" === R.type &&
              (void 0 === R.material && (R.material = gG.defaultData()),
              I(R.material)),
            "overrides" in R &&
              Object.values(R.overrides).forEach((_) => {
                _.material &&
                  "string" != typeof _.material &&
                  Object.getPrototypeOf(_.material) !== uG.prototype &&
                  I(_.material);
              });
        });
      }
      function ZD(_) {
        void 0 === _.layers &&
          Object.assign(_, gG.defaultTwoLayerData("lambert"));
      }
      function F1(_) {
        _.layers &&
          _.layers.forEach((_) => {
            if ("depth" === _.type && 10 === _.colors.length) {
              let I = [..._.colors];
              I.push(_.colors[9]);
              let R = [..._.steps];
              R.push(_.steps[9]);
              let B = { ...kr(_), colors: I, steps: R };
              Object.assign(_, B);
            }
          });
      }
      function JD(_) {
        _.scene.objects.traverse((_, I) => {
          "materials" in I
            ? I.materials.forEach((_) => {
                "string" != typeof _ && F1(_);
              })
            : "material" in I &&
              "string" != typeof I.material &&
              F1(I.material);
        }),
          Object.values(_.shared.materials).forEach((_) => F1(_));
      }
      function $D(_) {
        _.layers &&
          _.layers.forEach((_) => {
            "depth" === _.type &&
              void 0 !== _.num &&
              ((_.colors = _.colors.slice(0, _.num)),
              (_.steps = _.steps.slice(0, _.num)),
              delete _.num);
          });
      }
      function eO(_) {
        _.layers &&
          _.layers.forEach((_) => {
            "displace" !== _.type && void 0 === _.isMask && (_.isMask = !1),
              ("texture" === _.type || "video" === _.type) &&
                void 0 === _.blending &&
                (_.blending = 0),
              ("noise" === _.type ||
                ("displace" === _.type && "noise" === _.displacementType)) &&
                (void 0 === _.voronoiStyle && (_.voronoiStyle = 0),
                void 0 === _.highCut && (_.highCut = 1),
                void 0 === _.lowCut && (_.lowCut = 0),
                void 0 === _.smoothness && (_.smoothness = 0.3),
                void 0 === _.seed && (_.seed = 0),
                void 0 === _.quality && (_.quality = 1));
          });
      }
      function tO(_) {
        let I = _.layers.find((_) => "light" === _.type)?.data;
        I?.category === "basic" &&
          (Object.assign(I, mq.defaultData("light", "phong")),
          (I.visible = !1));
      }
      function rO(_) {
        Ra(_, tO), La(_, tO);
      }
      function iO(_) {
        _.layers.forEach((_) => {
          "light" === _.type &&
            "toon" !== _.category &&
            void 0 === _.occlusion &&
            (_.occlusion = !0);
        });
      }
      function nO(_) {
        _.layers &&
          _.layers.forEach((_) => {
            "light" === _.type &&
              void 0 === _.bumpMapIntensity &&
              (_.bumpMapIntensity = 5);
          });
      }
      function oO(_) {
        _.layers &&
          _.layers.forEach((_) => {
            "light" === _.type &&
              void 0 === _.alphaOverride &&
              (_.alphaOverride = 1);
          });
      }
      ((gZ || (gZ = {})).defaultData = {
        enabled: !1,
        useBackgroundColor: !1,
        color: mx.white,
        near: 0.1,
        far: 2e3,
      }),
        (z = { opacity: 1, blendFunction: 13, enabled: !1 }),
        ((gK || (gK = {})).defaultData = {
          enabled: !1,
          pixelation: { ...z, blendFunction: 16, granularity: 15 },
          bloom: {
            ...z,
            blendFunction: 16,
            intensity: 1,
            blurScale: 1,
            luminanceThreshold: 0.25,
            luminanceSmoothing: 0.025,
            kernelSize: 3,
          },
          chromaticAberration: { ...z, offset: [2, 2] },
          vignette: { ...z, darkness: 1, offset: 0 },
          hueSaturation: { ...z, hue: 3, saturation: 0 },
          brightnessContrast: { ...z, brightness: 0.25, contrast: 0 },
          depthOfField: {
            ...z,
            focalLength: 2,
            focusDistance: 2,
            bokehScale: 2,
          },
          noise: { ...z, blendFunction: 16 },
        }),
        ((gJ || (gJ = {})).defaultData = { softShadowQuality: "low" }),
        ((g$ || (g$ = {})).defaultData = {
          enabled: !0,
          color: {
            r: 0.8274509803921568,
            g: 0.8274509803921568,
            b: 0.8274509803921568,
          },
          intensity: 0.75,
        }),
        ((g0 || (g0 = {})).defaultData = {
          occlusion: !1,
          aoFullRes: !1,
          radius: 256,
          bias: 0.5,
          aoColor: {
            r: 0.19607843137254902,
            g: 0.19607843137254902,
            b: 0.19607843137254902,
          },
        }),
        ((g3 || (g3 = {})).defaultData = { usePhysics: !1, gravity: -10 }),
        ((g4 || (g4 = {})).defaultData = {
          playCamera: fx,
          gameControlObject: null,
        }),
        ((g5 || (g5 = {})).defaultData = {
          backgroundColor: mb.fromHexAndA(2960946, 1),
          postprocessing: gK.defaultData,
          fog: gZ.defaultData,
          globalPhysics: g3.defaultData,
          ambient: g$.defaultData,
          ao: g0.defaultData,
          shadow: gJ.defaultData,
          publish: g4.defaultData,
        }),
        ((g6 || (g6 = {})).defaultData = {
          colliderType: "box",
          size: [100, 100, 100],
          colliderHelperVisible: !0,
          forceType: "collider",
          forceRange: "global",
          forceIntensity: 0.5,
          forceDambing: 0.95,
        }),
        ((gS = g8 || (g8 = {})).isComponentRelated = function (_) {
          return "Component" === _ || "Instance" === _;
        }),
        (gS.isEmptyOrComponent = function (_) {
          return "Empty" === _ || "Instance" === _;
        }),
        ((gC = g9 || (g9 = {})).identity = {
          ...mw.identity,
          hiddenMatrix: mv.identity,
        }),
        (gC.fromObject = function (_) {
          return {
            position: _.position,
            rotation: _.rotation,
            scale: _.scale,
            hiddenMatrix: _.hiddenMatrix,
          };
        }),
        (gC.merge = function (_, I) {
          return {
            position: I?.position || _.position,
            rotation: I?.rotation || _.rotation,
            scale: I?.scale || _.scale,
            hiddenMatrix: I?.hiddenMatrix || _.hiddenMatrix,
          };
        }),
        (gC.diff = function (_, I) {
          return yv({
            position: mp.isEqual(_.position, I.position) ? void 0 : I.position,
            rotation: mp.isEqual(_.rotation, I.rotation) ? void 0 : I.rotation,
            scale: mp.isEqual(_.scale, I.scale) ? null : I.scale,
            hiddenMatrix: mv.isEqual(_.hiddenMatrix, I.hiddenMatrix)
              ? void 0
              : I.hiddenMatrix,
          });
        }),
        ((g7 || (g7 = {})).defaultData = {
          states: new uN(),
          events: new uN(),
          visible: !0,
          raycastLock: !1,
          physics: mN.defaultData,
          pathSnapping: {
            pathId: null,
            slide: 0,
            offset: 0,
            orientation: "tangential",
          },
          ...g9.identity,
          cloner: null,
        }),
        ((vt || (vt = {})).defaultData = { type: "Empty", ...g7.defaultData }),
        ((vi || (vi = {})).defaultData = {
          type: "ParticleCollider",
          ...g6.defaultData,
          ...g7.defaultData,
        }),
        ((vr || (vr = {})).defaultData = {
          type: "Component",
          ...g7.defaultData,
        }),
        ((vs || (vs = {})).defaultData = {
          type: "Particle",
          ...g7.defaultData,
          ...mF.defaultData,
        }),
        ((va || (va = {})).defaultData = {
          type: "Mesh",
          ...g7.defaultData,
          ...mV.defaultData,
        }),
        ((vn || (vn = {})).defaultData = {
          ...g7.defaultData,
          ...g9.identity,
          position: [0, 0, mO.DefaultTargetOffset],
          ...mO.defaultData,
        }),
        ((gT = vl || (vl = {})).defaultData = function (_) {
          return { ...g7.defaultData, ...mz.defaultData(_) };
        }),
        (gT.defaultDirectionalLightData = {
          ...gT.defaultData("DirectionalLight"),
          position: [200, 300, 300],
          name: "Directional Light",
          intensity: 0.7,
        }),
        ((_) => {
          function n(_, I, R = 0) {
            for (; R < I.length; ) {
              let B = _ ? _[I[R]] : void 0;
              if (I.length === R + 1) return B;
              if (!B) return;
              (_ = B.descendants), (R += 1);
            }
          }
          (_.resolveWithDes = n),
            (_.resolve = function (_, I, R = 0) {
              let B = n(_, I, R);
              if (B) {
                let _ = Object.keys(B);
                if (1 === _.length && "descendants" === _[0]) return;
              }
              return B;
            });
        })(vh || (vh = {})),
        ((_) => {
          function r(_, I) {
            return {
              ...g7.defaultData,
              ...I,
              component: _,
              overrides: new uG(),
              physics: void 0,
              events: void 0,
              type: "Instance",
            };
          }
          (_.rootOverrideProps = ["physics", "events"]),
            (_.compositeNonOptionalOverrideProps = ["geometry"]),
            (_.compositeEntireOverrideOverrideProps = ["material"]),
            (_.ofComponent = r),
            (_.fromComponentData = function (_) {
              let I = g9.fromObject(_.data);
              return r(_.id, I);
            });
        })(vc || (vc = {})),
        ((gP = vd || (vd = {})).defaultData = {
          type: "Page",
          ...g7.defaultData,
          physics: { ...mN.defaultData, fusedBody: !1 },
          ...g5.defaultData,
          camera: vn.defaultData,
        }),
        (gP.isUIPage = function (_) {
          return void 0 !== _.uiScene;
        }),
        ((gO = vf || (vf = {})).defaultCamera = {
          position: [0, 0, 1e3],
          scale: [1, 1, 1],
          rotation: [0, 0, 0],
          hiddenMatrix: mv.identity,
          name: "Play Camera",
          visible: !0,
          raycastLock: !1,
          physics: mN.defaultData,
          states: new uN(),
          events: new uN(),
          cloner: null,
          pathSnapping: {
            pathId: null,
            orientation: "tangential",
            slide: 0,
            offset: 0,
          },
          ...mO.defaultData,
        }),
        (gO.KeysByResetCategory = {
          States: ["states"],
          Events: ["events"],
          Material: ["material", "materials"],
          Geometry: ["geometry"],
          Position: ["position"],
          Rotation: ["rotation"],
          Scale: ["scale"],
          Transform: ["position", "scale", "rotation", "hiddenMatrix"],
          Name: ["name"],
          Visibility: [
            "visible",
            "raycastLock",
            "flatShading",
            "wireframe",
            "side",
          ],
          Shadows: ["castShadow", "receiveShadow"],
          Cloner: ["cloner"],
          Physics: ["physics"],
        }),
        (gO.defaultMeshObject = {
          name: "Rectangle",
          ...g7.defaultData,
          ...va.defaultData,
          geometry: gQ.defaultData("RectangleGeometry"),
          material: gG.defaultTwoLayerData("phong", "layer1", "layer2"),
        }),
        (gO.defaultBooleanObject = {
          name: "Boolean",
          ...g7.defaultData,
          ...va.defaultData,
          geometry: gQ.defaultData("BooleanGeometry"),
          material: gG.defaultTwoLayerData("phong", "layer1", "layer2"),
        }),
        (gO.defaultTextObject = {
          name: "Text",
          ...g7.defaultData,
          ...va.defaultData,
          geometry: gQ.defaultData("TextGeometry"),
          material: gG.defaultTwoLayerData("phong", "layer1", "layer2"),
        }),
        ((gI = vm || (vm = {})).newEmpty = function (_, I) {
          let R = { name: I };
          return (
            "Mesh" === _.type
              ? ((R.geometry = {}),
                "material" in _ && (R.material = { layers: new uG() }),
                "materials" in _ &&
                  (R.materials = _.materials.map((_) => ({
                    layers: new uG(),
                  }))))
              : mP.is(_.type) && ((R.perspective = {}), (R.orthographic = {})),
            R
          );
        }),
        (gI.toOps = function (_, I) {
          let R,
            B = [],
            z = { orthographic: 0, perspective: 0, geometry: 0 };
          function c(_, I) {
            for (let [R, z] of Object.entries(I.layers)) {
              let { texture: I, ...k } = z;
              if (void 0 !== I && Object.keys(I).length > 0) {
                let z = {
                  path: [..._, "layers", R, "texture"],
                  props: I,
                  type: 0,
                };
                B.push(z);
              }
              if (Object.keys(k).length > 0) {
                let I = { path: [..._, "layers", R], props: k, type: 0 };
                B.push(I);
              }
            }
          }
          for (let [_, k] of Object.entries(I))
            if ("name" !== _) {
              if ("cloner" === _) B.push(...mB.toOps(k, ["cloner"]));
              else if ("pathSnapping" === _)
                B.push({
                  path: [_],
                  props: { slide: k.slide, offset: k.offset },
                  type: 0,
                });
              else if ("material" === _) c(["material"], k);
              else if ("materials" === _)
                for (let [_, I] of Object.entries(k)) c(["materials", _], I);
              else if (0 === z[_]) {
                if ("geometry" === _ && void 0 !== k.extrusion) {
                  let I = {
                    path: [_, "extrusion"],
                    props: k.extrusion,
                    type: 0,
                  };
                  B.push(I), (k = { ...k }), delete k.extrusion;
                }
                if (Object.keys(k).length > 0) {
                  let I = { path: [_], props: k, type: 0 };
                  B.push(I);
                }
              } else
                void 0 === R &&
                  ((R = { path: [], props: {}, type: 0 }), B.push(R)),
                  (R.props[_] = k);
            }
          return B;
        }),
        (gI.patch = function (_, I) {
          if (void 0 === I) return _;
          let R = { ..._ };
          return (
            (Object.assign(R, g9.merge(R, I)),
            Object.assign(R, {
              pathSnapping: Object.assign({}, R.pathSnapping, {
                slide: I.pathSnapping?.slide ?? R.pathSnapping?.slide ?? 0,
                offset: I.pathSnapping?.offset ?? R.pathSnapping?.offset ?? 0,
              }),
            }),
            mP.is(_.type))
              ? ((R.orthographic = { ...R.orthographic }),
                (R.perspective = { ...R.perspective }),
                I.orthographic?.zoom !== void 0 &&
                  (R.orthographic.zoom = I.orthographic.zoom),
                I.perspective?.zoom !== void 0 &&
                  (R.perspective.zoom = I.perspective.zoom),
                void 0 !== I.isUpVectorFlipped &&
                  (R.isUpVectorFlipped = I.isUpVectorFlipped),
                void 0 !== I.targetOffset && (R.targetOffset = I.targetOffset))
              : "Mesh" === _.type
              ? ("geometry" in I &&
                  Object.assign(R, {
                    geometry: gX.merge(R.geometry, I.geometry),
                  }),
                (I.material || I.materials) &&
                  (R = (function (_, I) {
                    if (void 0 === I) return _;
                    let R = { ..._ };
                    return (
                      "material" in R &&
                        "material" in I &&
                        I.material &&
                        (R.material = Tl(R.material, (_) => {
                          if ("string" != typeof _)
                            for (let [R, B] of Object.entries(
                              I.material.layers
                            )) {
                              let I = _.layers.data(R);
                              I && mq.patch(I, B);
                            }
                        }).data),
                      R.materials &&
                        I.materials &&
                        (R.materials = Tl(R.materials, (_) => {
                          for (let B = 0; B < R.materials.length; B++) {
                            let R = I.materials[B];
                            if ("string" != typeof R)
                              for (let [I, z] of Object.entries(R.layers)) {
                                let R = _[B]?.layers?.data(I);
                                R && mq.patch(R, z);
                              }
                          }
                        }).data),
                      R
                    );
                  })(R, I)),
                R.cloner &&
                  "cloner" in I &&
                  Object.assign(R, { cloner: mI.merge(R.cloner, I.cloner) }))
              : "Empty" === _.type
              ? R.cloner &&
                "cloner" in I &&
                Object.assign(R, { cloner: mI.merge(R.cloner, I.cloner) })
              : mL.is(_.type) &&
                (void 0 !== I.intensity && (R.intensity = I.intensity),
                void 0 !== I.color &&
                  ("string" == typeof I.color
                    ? (R.color = I.color)
                    : (R.color = mx.clone(I.color)))),
            R
          );
        }),
        ((vg || (vg = {})).defaultData = {
          enablePan: !0,
          enableZoom: !0,
          enableRotate: !0,
          enableDamping: !0,
          rotationLimitsMode: 0,
          rotationVerticalOffset: { min: Math.PI / 4, max: Math.PI / 4 },
          rotationHorizontalOffset: { min: Math.PI / 4, max: Math.PI / 4 },
          rotationSoftLimit: 2,
          panLimitsMode: 0,
          panVerticalOffset: { min: 250, max: 250 },
          panHorizontalOffset: { min: 250, max: 250 },
          panSoftLimit: 2,
          zoomLimitsEnabled: !1,
          zoomLimits: { min: 0.1, max: 2 },
          autoRotate: !1,
          autoRotateSpeed: 2,
          autoRotateClockwise: !0,
          hoverRotatePanMode: 0,
          hoverRotatePanStrength: 20,
          hoverRotateDamping: 0.125,
          isTouchZoom: !0,
          orbitTouches: 2,
          panTouches: 3,
          resetHoverEffectOnPointerLeave: !0,
        }),
        ((vy || (vy = {})).defaultData = {
          orbitControls: vg.defaultData,
          playPage: fb,
          withBackground: !0,
          preventScroll: !1,
          preventTouchScroll: !1,
          hideCursor: !1,
          mouseEventTarget: "canvas",
          joystickSizeAndXYOffset: Array(12)
            .fill(0)
            .map((_, I) => {
              let R = 0,
                B = 0;
              return (
                I < 5 ? (B = -30) : I < 10 && (B = 30),
                0 === I || 10 === I || 5 === I
                  ? (R = 30)
                  : (4 === I || 11 === I || 9 === I) && (R = -30),
                [120, [R, B], "show"]
              );
            }),
          settings: {
            image: { format: "jpg", ratio: 1 },
            video: {
              format: "mp4",
              imageFormat: "jpg",
              fps: 30,
              mbps: 80,
              ratio: Math.max(
                1,
                "u" > typeof window ? Math.floor(window.devicePixelRatio) : 1
              ),
              stopMode: "manual",
              duration: 5e3,
            },
            web: { logo: !0, compress: !0, preset: 1, preload: !0, hint: !1 },
          },
          stopRaycast: !0,
          hdTransmission: !1,
        }),
        ((vx || (vx = {})).defaultData = {
          id: "basic",
          label: "Basic",
          style: "None",
          prompt: "",
        }),
        ((vw || (vw = {})).defaultData = {
          weather: 0,
          shadows: 0,
          lightOrigin: 0,
          temperature: 0,
          sun: 0,
          camera: 0,
          environment: 0,
          particles: 0,
          nature: 0,
          floor: 0,
        }),
        ((gR = v_ || (v_ = {})).defaultData = () => ({
          mode: "line-art-both",
          prompt: "",
          negativePrompt: "",
          style: { ...vx.defaultData },
          isRandomSeed: !0,
          seed: gR.generateSeed(),
          guessMode: !1,
          advanced: !1,
          steps: 20,
          guidanceScale: 7.5,
          controlNetScale: 1,
          modifiers: vw.defaultData,
        })),
        (gR.generateSeed = () => Math.round(1e5 * Math.random())),
        ((gB = vM || (vM = {})).physicsEnabled = function (_) {
          return (
            void 0 !==
            _.find(
              (_) => "Page" === _.data.type && _.data.globalPhysics.usePhysics
            )
          );
        }),
        (gB.traverseModuleInstances = function (_, I, R) {
          _.scene.objects.traverseFrom(I, (I, B) => {
            if ("Instance" === B.type) {
              let z = vj.getComponentData(_, B.component)?.data;
              z && R(I, B, z.events);
            } else R(I, B, B.events);
          });
        }),
        ((_) => {
          function t(_ = { withLight: !0, withSquare: !0 }) {
            let I = [],
              R = vf.defaultMeshObject;
            !0 === _.withLight &&
              I.push({
                fi: -1,
                data: vl.defaultDirectionalLightData,
                id: "830a2708-8ed9-49cf-a68e-085299899103",
                children: [],
              }),
              !0 === _.withSquare &&
                I.push({
                  fi: 1,
                  id: "7ba78968-2a55-48f2-b14c-5191da3e075e",
                  data: R,
                  children: [],
                });
            let B = new uF();
            return (
              B.push({
                fi: 1,
                id: fb,
                data: { ...vd.defaultData, name: "Scene 1" },
                children: I,
              }),
              B
            );
          }
          function o(I) {
            return { ..._.defaultData, objects: _n(I, uF.prototype) };
          }
          (_.TRASH_CAN_ID = "830a2708-8ed9-49cf-a68e-085299892222"),
            (_.defaultData = {
              objects: t(),
              publish: vy.defaultData,
              styles: v_.defaultData(),
            }),
            (_.emptyDataWithoutPage = function () {
              return {
                objects: new uF(),
                publish: vy.defaultData,
                styles: v_.defaultData(),
              };
            }),
            (_.emptyDataWithPage = function (_) {
              return {
                objects: t(_),
                publish: vy.defaultData,
                styles: v_.defaultData(),
              };
            }),
            (_.emptyData = function () {
              return {
                objects: new uF(),
                publish: { ...vy.defaultData },
                styles: v_.defaultData(),
              };
            }),
            (_.withObjs = o),
            (_.withObj = function (_, I) {
              return o([{ id: _, data: I, children: [], fi: 0 }]);
            });
        })(vT || (vT = {})),
        ((vP || (vP = {})).defaultData = {
          preset: "fullscreen",
          allowResponsive: !1,
          size: [512, 512],
          coords: [0, 0],
          sceneScale: 1,
          color: { r: 0, g: 0, b: 0, a: 0.5 },
        }),
        ((vO || (vO = {})).emptyImage = {
          data: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQYV2NgYAAAAAMAAWgmWQ0AAAAASUVORK5CYII=",
          name: "empty",
        }),
        ((_) => {
          function n(_) {
            return void 0 !== _.textValue;
          }
          function e(_) {
            return "boolean" == typeof _;
          }
          (_.isTextValue = n),
            (_.isNumber = function (_) {
              return "number" == typeof _;
            }),
            (_.isBoolean = e),
            (_.typeOfVariable = function (_) {
              return n(_) ? "string" : e(_) ? "boolean" : "number";
            }),
            (_.getDisplayedValue = function (I) {
              return _.isTextValue(I)
                ? Array.isArray(I.textValue)
                  ? I.textValue
                      .map((_) => _.toString().padStart(I.padding ?? 2, "0"))
                      .join(I.deliminator ?? ":") +
                    (void 0 !== I.suffix ? " " + I.suffix : "")
                  : I.textValue.toString()
                : _.isBoolean(I)
                ? I
                  ? "True"
                  : "False"
                : _.isNumber(I)
                ? parseFloat(I.toFixed(3)).toString()
                : I.toString();
            });
        })(vR || (vR = {})),
        ((vB || (vB = {})).all = [
          "images",
          "videos",
          "colors",
          "audios",
          "particles",
          "fonts",
          "materials",
          "variables",
        ]),
        ((vL || (vL = {})).all = [...vB.all, "components"]),
        ((vz || (vz = {})).defaultData = function () {
          return {
            images: new uL(),
            videos: new uL(),
            colors: new uL(),
            audios: new uL(),
            particles: new uL(),
            fonts: new uL(),
            materials: new uL(),
            components: new uL(),
            variables: new uL(),
          };
        }),
        ((vF || (vF = {})).defaultData = function () {
          return {
            images: new uL(),
            videos: new uL(),
            colors: new uL(),
            audios: new uL(),
            particles: new uL(),
            fonts: new uL(),
            materials: new uL(),
            components: new uL(),
            variables: new uL(),
          };
        }),
        ((gL = vN || (vN = {})).defaultColors = function () {
          let _ = {};
          return (
            (_["89b10010-844c-11ec-a8a3-0242ac120002"] = {
              r: 0.5,
              g: 0.5,
              b: 0.5,
              a: 1,
              name: "Default Color",
            }),
            _n(_, uL.prototype)
          );
        }),
        (gL.defaultImages = function (_) {
          let I = {};
          return (
            _?.withAITexture &&
              (I["a1b10010-844c-a8a3-11ec-0242ac2011ec"] = {
                ...vO.emptyImage,
                name: "AI generated image",
              }),
            _n(I, uL.prototype)
          );
        }),
        (gL.emptyData = function () {
          return {
            catelogs: new uL(),
            materials: new uL(),
            images: new uL(),
            videos: new uL(),
            colors: new uL(),
            audios: new uL(),
            particles: new uL(),
            fonts: new uL(),
            variables: new uN(),
            lib: vF.defaultData(),
          };
        }),
        (gL.defaultVariables = function (_) {
          switch (_) {
            case "number":
              return { value: 0, name: "Number" };
            case "boolean":
              return { value: !1, name: "Boolean" };
            case "string":
              return { value: { textValue: "String value" }, name: "String" };
            case "time":
              let I = [0, 0, 0];
              return {
                name: "Time",
                value: {
                  textValue: I,
                  deliminator: ":",
                  padding: 2,
                  suffix: "AM",
                },
                dynamicVariableType: "time",
                format: "HH:mm:ss",
                format12h24h: "12ampm",
                timeZone: null,
                hasEnd: !1,
                endValue: {
                  textValue: I,
                  deliminator: ":",
                  padding: 2,
                  suffix: "AM",
                },
                autoStart: !0,
                repeat: !1,
              };
            case "counter":
              return {
                name: "Counter",
                value: 0,
                dynamicVariableType: "counter",
                updateInterval: 1e3,
                increment: 1,
                autoStart: !0,
                hasEnd: !0,
                endValue: 60,
                repeat: !0,
                randomStart: !1,
                range: [0, 100],
                decimals: 0,
              };
            case "random":
              return {
                name: "Random",
                value: 0,
                dynamicVariableType: "random",
                updateInterval: 1e3,
                increment: 1,
                autoStart: !0,
                isStatic: !1,
                hasEnd: !0,
                endValue: 60,
                repeat: !0,
                min: 0,
                max: 100,
                decimals: 0,
              };
            default:
              console.error("Unknown variable type", _);
          }
        }),
        (gL.getFormattedTimerTime = function (_, I) {
          if ("HH:mm:ss" === I.format) {
            let I = Math.floor(_ / 3600),
              R = Math.floor((_ - 3600 * I) / 60),
              B = Math.round(_ - 3600 * I - 60 * R);
            return { textValue: [I, R, B] };
          }
          if ("mm:ss" !== I.format)
            return (_ =
              "number" === I.format
                ? Math.round(_)
                : Math.round(1e3 * _) / 1e3);
          {
            let I = Math.floor(_ / 60),
              R = Math.round(_ - 60 * I);
            return { textValue: [I, R] };
          }
        }),
        ((vk || (vk = {})).list = ["idle", "move", "jump", "run"]),
        ((gz = vV || (vV = {})).defaultColliderData = {
          type: "capsule",
          height: 200,
          radius: 50,
          position: [0, 0, 0],
          rotation: [0, 0, 0],
        }),
        (gz.defaultDataThirdPerson = {
          moveMode: "walk",
          forwardDirection: "+z",
          speedTranslate: 1e3,
          speedRotate: 100,
          runMultiplier: 2,
          rotationMode: "normal",
          rotBy: "keys",
          rotByTouch: "drag",
          delayPos: [0.3, 0.3],
          delayRot: [0.3, 0.3],
          keyAssignments: [
            ["moveNegZ", "W"],
            ["moveNegX", "A"],
            ["movePosZ", "S"],
            ["movePosX", "D"],
            ["rotPosX", ""],
            ["rotPosY", ""],
            ["rotNegX", ""],
            ["rotNegY", ""],
            ["jump", "Space"],
            ["run", ""],
            ["none", "Ctrl"],
          ],
          touchControl: !0,
          joystickPosLoc: 5,
          joystickRotLoc: 11,
          jumpTouchButtonLoc: 9,
          collider: gz.defaultColliderData,
          colliderHelperVisible: !0,
          collisionEnabled: !0,
          jumpPower: 100,
          resetYPosition: 3e3,
          alignToGround: !1,
          autoOrientMove: !0,
          orientWith: "camera",
          orientMode: "radial",
          delayPosCamera: 0.3,
          delayRotCamera: 0.3,
          camera: "",
          cameraXAxis: "Limit",
          cameraYAxis: "Free",
          cameraRotXLimits: [0, Math.PI / 2],
          cameraRotYLimits: [-Math.PI / 2, Math.PI / 2],
          gameActions: {
            idle: new uN(),
            move: new uN(),
            jump: new uN(),
            run: new uN(),
          },
          navmesh: {
            enabled: !1,
            ch: 6,
            cs: 6,
            walkableClimb: 5,
            walkableHeight: 1,
            walkableRadius: 0,
            zones: "all",
            objects: [],
            helperVisible: !0,
            destinationHelperRadius: 0,
            destinationHelperColor: mb.fromHexAndA(3728051, 1),
          },
        });
      var m$ = 180 / Math.PI;
      function aO(_) {
        _.rotation = _.rotation.slice(0, 3).map((_) => _ * m$);
      }
      function lO(_) {
        aO(_),
          "Page" === _.type && aO(_.camera),
          _.states?.forEach((_) => {
            void 0 === _.rotation ||
              null === _.rotation ||
              (_.rotation = _.rotation.slice(0, 3).map((_) => _ * m$));
          });
        let I = _.geometry;
        I &&
          "SphereGeometry" === I.type &&
          (I.thetaLength = (I.thetaLength ?? 180) * m$),
          I && "TorusGeometry" === I.type && (I.arc = I.arc * m$),
          I &&
            "PathGeometry" === I.type &&
            ((I.extrusion.angle *= m$), (I.extrusion.twist *= m$)),
          "Mesh" === _.type &&
            "TextGeometry" === _.geometry.type &&
            (_.geometry.text = { textValue: _.geometry.text }),
          Array.isArray(kr(_.events)) &&
            _.events?.forEach((_) => {
              ("MouseDown" === _.type ||
                "MouseUp" === _.type ||
                "MousePress" === _.type ||
                "KeyDown" === _.type ||
                "KeyUp" === _.type ||
                "KeyPress" === _.type ||
                "Collision" === _.type ||
                "Trigger" === _.type) &&
                (_.runMode = _.toggle ? "Toggle" : "Repeat");
            });
      }
      function c0(_) {
        let I = _.schema ?? 0;
        if (111 !== I) {
          let R;
          for (let R of (console.warn("updating from ", I, "to ", 111),
          (function (_, I) {
            let R, B;
            if (
              (I < 1 && (La(_, KD), Ra(_, KD), (_.schema = 1)),
              I < 2 &&
                (Object.assign(_.scene.publish, {
                  orbitControls: {
                    ...vg.defaultData,
                    ...kr(_.scene.publish.orbitControls),
                  },
                }),
                (_.schema = 2)),
              I < 3 &&
                ((function (_) {
                  function t(_) {
                    if (_.layers) {
                      for (let I of Object.values(_.layers))
                        if (I) {
                          for (let [_, R] of Object.entries(I))
                            if (
                              ((mY.includes(_) || "boolean" == typeof R) &&
                                delete I[_],
                              "texture" === _)
                            )
                              for (let [_, I] of Object.entries(R))
                                (mX.includes(_) || "boolean" == typeof I) &&
                                  delete R[_];
                        }
                    }
                  }
                  _.scene.objects.traverse((_, I) => {
                    I.states.forEach((_) => {
                      _.material
                        ? t(_.material)
                        : _.materials &&
                          _.materials.forEach((_) => {
                            t(_);
                          });
                    });
                  });
                })(_),
                (_.schema = 3)),
              I < 4 && ((_.scene.publish.withBackground = !0), (_.schema = 4)),
              I < 5 &&
                ((_.scene.publish.settings.web = {
                  compress: !0,
                  preload: !0,
                  preset: 1,
                  logo: !0,
                  hint: !1,
                }),
                (_.schema = 5)),
              I < 6 &&
                ((function (_) {
                  _.scene.objects.traverse((_, I) => {
                    let R = I.cloner;
                    R &&
                      ((R.radial.scale = R.radial.scale.map((_) => _ + 1)),
                      (R.linear.scale = R.linear.scale.map((_) => _ + 1)));
                  });
                })(_),
                (_.schema = 6)),
              I < 7 &&
                ((function (_) {
                  _.scene.objects.traverse((_, I) => {
                    let R = I.geometry;
                    R &&
                      ("DodecahedronGeometry" === R.type ||
                        "IcosahedronGeometry" === R.type) &&
                      (R.detail = Math.round(R.detail));
                  });
                })(_),
                (_.schema = 7)),
              I < 8 && (_.schema = 8),
              I < 9 && (JD(_), (_.schema = 9)),
              I < 10 &&
                ((function (_) {
                  _.scene.objects.traverse((_, I) => {
                    "Mesh" === I.type &&
                      ("BooleanGeometry" === I.geometry.type ||
                        "SubdivGeometry" === I.geometry.type) &&
                      (I.geometry.phongAngle = 35);
                  });
                })(_),
                (_.schema = 10)),
              I < 11 &&
                ((_.scene.environment.ambientLight.softShadows = !1),
                (_.scene.environment.ambientLight.softShadowQuality = "low"),
                _.scene.objects.traverse((_, I) => {
                  ("DirectionalLight" === I.type || "SpotLight" === I.type) &&
                    ((I.shadowResolution = 1024),
                    (I.shadowRadius = 1),
                    (I.depth = 1e5));
                }),
                (_.shared.penumbraSize = [, , , , ,].fill(0.5)),
                (_.schema = 11)),
              I < 12 && (JD(_), (_.schema = 12)),
              I < 13 &&
                ((_.shared.audios = _n({}, uL.prototype)), (_.schema = 13)),
              I < 14 &&
                (Object.entries((R = _.shared.materials)).forEach(([_, I]) => {
                  I.layers ||
                    Object.assign(R, {
                      [_]: {
                        name: "Untitled Material",
                        layers: [
                          {
                            fi: 0,
                            data: {
                              type: "light",
                              category: "phong",
                              alpha: 0.6,
                              visible: !0,
                              mode: 0,
                              specular: { r: 0.2, g: 0.2, b: 0.2 },
                              shininess: 5,
                            },
                            id: "layer1",
                          },
                          {
                            fi: 1,
                            data: {
                              type: "color",
                              alpha: 1,
                              visible: !0,
                              mode: 0,
                              color: {
                                r: 0.2823529411764706,
                                g: 0.2823529411764706,
                                b: 0.30196078431372547,
                              },
                            },
                            id: "layer2",
                          },
                        ],
                      },
                    });
                }),
                (_.schema = 14)),
              I < 15 &&
                (Object.entries(kr(_.shared.images))
                  .filter((_) => !1 === _[1].asset)
                  .map((_) => _[0])
                  .forEach((I) => {
                    delete _.shared.images[I];
                  }),
                Object.entries(kr(_.shared.audios))
                  .filter((_) => !1 === _[1].asset)
                  .map((_) => _[0])
                  .forEach((I) => {
                    delete _.shared.audios[I];
                  }),
                (_.schema = 15)),
              I < 16 &&
                ((_.scene.publish.settings.web.preload = !1), (_.schema = 16)),
              I < 17 && (La(_, $D), Ra(_, $D), (_.schema = 17)),
              I < 18 && (La(_, ZD), Ra(_, ZD), (_.schema = 18)),
              I < 19 &&
                (Object.assign(_.scene.publish.settings, {
                  video: {
                    ...vy.defaultData.settings.video,
                    ...kr(_.scene.publish.settings.video),
                  },
                }),
                (_.schema = 19)),
              I < 20 &&
                ((_.shared.fonts = _n({}, uL.prototype)),
                (B = []),
                _.scene.objects.traverse((I, R) => {
                  if ("TextFrame" === R.type) {
                    let z = gG.defaultTwoLayerData("phong"),
                      k =
                        "string" == typeof R.color
                          ? _.shared.colors[R.color]
                          : R.color;
                    (z.layers[1].data.color = { r: k.r, g: k.g, b: k.b }),
                      (z.layers[1].data.alpha = R.alpha);
                    let V = R.font
                      .replace(".typeface", "")
                      .replace(/optimer/gi, "open sans")
                      .replace("space_mono", "space mono")
                      .replace(/alma_mono/gi, "varela round")
                      .replace(/droid_sans_mono/gi, "noto sans mono")
                      .replace(
                        /droid_sans|gentilis|gnomon_(simple|foreground)|helvetiker/gi,
                        "roboto"
                      )
                      .replace(/droid_serif/gi, "roboto slab")
                      .replace("_sans", " sans")
                      .replace("crimson_text", "crimson text")
                      .replace("medium_medium", "medium")
                      .replace("fatface_fatface", "fatface")
                      .replace("100hairline", "thin")
                      .replace("200thin", "extralight")
                      .replace("300light", "light")
                      .replace("500medium", "medium")
                      .replace("600semi", "semibold")
                      .replace("800heavy", "extrabold")
                      .replace("900black", "black")
                      .replace(
                        /bodoni_(11|16|24|36|48|72|96)([^_])/gi,
                        "bodoni_$1_$2"
                      )
                      .replace(/bodoni_(11|16|24|36|48|72|96)/gi, "bodoni moda")
                      .replace(/(thin|hairline)(_regular)?/gi, "100")
                      .replace(/(extra|ultra)light(_regular)?/gi, "200")
                      .replace(/light(_regular)?/gi, "300")
                      .replace(/_book|_normal|_roman/gi, "_regular")
                      .replace(/medium(_regular)?/gi, "500")
                      .replace(/(semi|demi)bold(_regular)?/gi, "600")
                      .replace(/(extra|ultra)bold(_regular)?/gi, "800")
                      .replace(/bold(_regular)?/gi, "700")
                      .replace(/(black|heavy|fatface)(_regular)?/gi, "900")
                      .replace(/([1-9]00)_italic/gi, "$1italic")
                      .replace(/regularitalic/gi, "italic")
                      .replace(/regularitalic/gi, "italic")
                      .split(" ")
                      .map((_) => _.charAt(0).toUpperCase() + _.slice(1))
                      .join(" ");
                    void 0 === _.shared.fonts[V] &&
                      (_.shared.fonts[V] = { name: V });
                    let j = {
                        name: R.name,
                        ...g7.defaultData,
                        ...va.defaultData,
                        flatShading: !1,
                        wireframe: !1,
                        geometry: {
                          ...gQ.defaultData("TextGeometry"),
                          width: R.width,
                          height: R.height,
                          font: V,
                          depth: 0,
                          horizontalAlign: R.horizontalAlign,
                          verticalAlign: R.verticalAlign,
                          fontSize: 1.40625 * R.fontSize,
                          lineHeight: R.lineHeight / 1.40625,
                          letterSpacing: R.letterSpacing - 1,
                          text: R.text,
                          textTransform: R.textTransform,
                          extrudeBevelSize: 0,
                          extrudeBevelSegments: 1,
                        },
                        material: z,
                        states: kr(R.states),
                        events: kr(R.events),
                        visible: R.visible,
                        raycastLock: R.raycastLock,
                        position: R.position,
                        rotation: R.rotation,
                        scale: R.scale,
                        hiddenMatrix: R.hiddenMatrix,
                      },
                      G = kr(_.scene.objects).parent(I);
                    _.scene.objects.insertAfter(G ?? null, I, [
                      { id: I + "new", data: j, children: [] },
                    ]),
                      B.push(I);
                  }
                }),
                B.forEach((I) => {
                  _.scene.objects.delete(I);
                }),
                (_.schema = 20)),
              I < 21 &&
                ((function (_) {
                  let I = {
                    0: "MouseDown",
                    1: "MouseUp",
                    2: "MouseHover",
                    5: "KeyDown",
                    6: "KeyUp",
                    7: "Start",
                    9: "LookAt",
                    10: "Follow",
                    11: "Scroll",
                    12: "Audio",
                    13: "GameControl",
                  };
                  _.scene.objects.traverse((_, R) => {
                    R.events.forEach((_) => {
                      if (I[Number(_.type)]) {
                        if (
                          (Object.assign(_, { type: I[Number(_.type)] }),
                          "Audio" === _.type &&
                            "audioEvent" in _ &&
                            (Object.assign(_, { playAudio: _.audioEvent }),
                            delete _.audioEvent),
                          "GameControl" === _.type)
                        )
                          Object.assign(_, {
                            gameActions: {
                              idle: new uN(),
                              move: new uN(),
                              jump: new uN(),
                            },
                          });
                        else {
                          let I = new uN();
                          Object.assign(_, { actions: I }),
                            ("MouseDown" === _.type ||
                              "MouseUp" === _.type ||
                              "KeyDown" === _.type ||
                              "KeyUp" === _.type) &&
                              "url" in _ &&
                              I.push({
                                fi: 0,
                                id: rr.generateUUID(),
                                data: { type: "Link", url: _.url, delay: 0 },
                              }),
                            "targets" in _ &&
                              (_.targets.forEach((_, R, B) => {
                                let z = {
                                  easing: _.easing,
                                  duration: _.duration,
                                };
                                6 === _.easing
                                  ? Object.assign(
                                      z,
                                      uo(
                                        _,
                                        "mass",
                                        "stiffness",
                                        "damping",
                                        "velocity"
                                      )
                                    )
                                  : 5 === _.easing &&
                                    Object.assign(z, {
                                      control1: { ..._.control1 },
                                      control2: { ..._.control2 },
                                    });
                                let k = {
                                    repeat: _.repeat ? -1 : 0,
                                    delay: _.delay,
                                    delayDirection: _.delayDirection,
                                    direction:
                                      _.cycle && _.rewind
                                        ? "pingpong-rewind"
                                        : _.cycle
                                        ? "pingpong"
                                        : "normal",
                                  },
                                  V = { state: _.state, ...k, ...z },
                                  j = {
                                    allowSlerp: !0,
                                    type: "Transition",
                                    object: _.object,
                                    repeat: 0,
                                    delay: 0,
                                    delayDirection: void 0,
                                    direction: "normal",
                                    tweens: new uN(
                                      {
                                        fi: 0,
                                        id: rr.generateUUID(),
                                        data: {
                                          state: void 0,
                                          repeat: 0,
                                          delay: 0,
                                          delayDirection: void 0,
                                          direction: "normal",
                                          duration: 0,
                                          easing: 4,
                                        },
                                      },
                                      { fi: 1, id: rr.generateUUID(), data: V }
                                    ),
                                  };
                                I.push({ fi: B, id: R, data: j });
                              }),
                              delete _.targets);
                        }
                      }
                    });
                  });
                })(_),
                (function (_) {
                  _.scene.objects.traverse((_, I) => {
                    function r(_, R) {
                      let B = new uN(),
                        z = [];
                      if (
                        (I.events.forEach((_, I, k) => {
                          if ("Audio" === _.type && _.trigger === R) {
                            let R;
                            z.push(I),
                              "play" === _.interaction
                                ? (R = {
                                    ...uo(
                                      _,
                                      "interaction",
                                      "audio",
                                      "delay",
                                      "volume",
                                      "loop"
                                    ),
                                    triggerAfter:
                                      "after" in _ ? _.after : void 0,
                                    toggle: "after" in _ ? _.toggle : void 0,
                                    type: "Audio",
                                  })
                                : ("pause" === _.interaction ||
                                    "stop" === _.interaction) &&
                                  (R = {
                                    ...uo(
                                      _,
                                      "interaction",
                                      "delay",
                                      "object",
                                      "playAudio"
                                    ),
                                    type: "Audio",
                                  }),
                              R && B.push({ fi: k, id: I, data: R });
                          }
                        }),
                        z.forEach((_) => I.events.delete(_)),
                        B.length)
                      ) {
                        let R = I.events.find((I) => I.type === _)?.data;
                        R
                          ? "actions" in R && R.actions.insertBefore(null, B)
                          : I.events.insertBefore(null, [
                              {
                                id: rr.generateUUID(),
                                data: { type: _, actions: B },
                              },
                            ]);
                      }
                    }
                    r("Start", "start"),
                      r("MouseDown", "mouseDown"),
                      r("MouseUp", "mouseUp"),
                      r("KeyDown", "keyDown"),
                      r("KeyUp", "keyUp");
                  });
                })(_),
                (_.schema = 21)),
              I < 22 && (rO(_), (_.schema = 22)),
              I < 23 &&
                ((function (_) {
                  _.scene.objects.traverse((_, I) => {
                    "Mesh" === I.type &&
                      "SubdivGeometry" === I.geometry.type &&
                      (I.geometry.scaleBaked ||
                        (I.geometry.scaleBaked = [1, 1, 1]));
                  });
                })(_),
                (_.schema = 23)),
              I < 24 &&
                ((function (_) {
                  _.scene.objects.traverse((_, I) => {
                    ("Empty" !== I.type && "Mesh" !== I.type) ||
                      !I.cloner ||
                      I.cloner.randomnessObject ||
                      I.cloner.toObject ||
                      I.cloner.randomness ||
                      (I.cloner = {
                        ...I.cloner,
                        toObject: {
                          object: "",
                          spreadType: "random",
                          scale: [0, 0, 0],
                          rotation: [0, 0, 0],
                          position: [0, 0, 0],
                          axis: "x",
                          seed: 0,
                          count: 99,
                          align: "normal",
                        },
                        randomness: !1,
                        randomnessObject: {
                          strength: 100,
                          scale: [0, 0, 0],
                          rotation: [0, 0, 0],
                          position: [0, 0, 0],
                          movement: 1,
                          seed: 0,
                          freqScale: 10,
                          noiseType: "perlin",
                        },
                      });
                  });
                })(_),
                (_.schema = 24)),
              (I < 25 || void 0 === _.shared.videos) &&
                ((_.shared.videos = _n({}, uL.prototype)),
                I < 25 && (_.schema = 25)),
              I < 26 &&
                ((function (_) {
                  _.scene.objects.traverse((I, R) => {
                    let B = _.scene.objects.unproxy().parent(I);
                    if (B) {
                      let I = kr(_.scene.objects.data(B));
                      I &&
                        "Mesh" === I.type &&
                        "BooleanGeometry" === I.geometry.type &&
                        "Mesh" === R.type &&
                        (R.visible = !0 !== kr(R).booleanExclude);
                    }
                  });
                })(_),
                (_.schema = 26)),
              I < 27 &&
                ((function (_) {
                  _.scene.objects.traverse((_, I) => {
                    "Mesh" === I.type &&
                      ("NonParametricGeometry" === I.geometry.type
                        ? void 0 !== I.material && delete I.material
                        : void 0 !== I.materials && delete I.materials);
                  });
                })(_),
                (_.schema = 27)),
              I < 28 && (rO(_), (_.schema = 28)),
              I < 29 &&
                ((function (_) {
                  function e(_) {
                    for (let R in (Object.setPrototypeOf(_, uG.prototype), _)) {
                      var I;
                      Object.setPrototypeOf((I = _[R]), uG.prototype),
                        I.texture &&
                          Object.setPrototypeOf(I.texture, uG.prototype);
                    }
                  }
                  _.scene.objects.traverse((_, I) => {
                    I.states.forEach((_) => {
                      if (_.material) {
                        let I = kr(_.material).layers;
                        e(I), (_.material.layers = I);
                      }
                      if (_.materials)
                        for (let I = 0; I < _.materials.length; I++) {
                          let R = _.materials[I],
                            B = kr(R).layers;
                          e(B), (R.layers = B);
                        }
                    });
                  });
                })(_),
                (_.schema = 29)),
              I < 30 &&
                ((function (_) {
                  _.scene.objects.traverse((_, I) => {
                    "Mesh" !== I.type ||
                      "NonParametricGeometry" !== I.geometry.type ||
                      "material" in I ||
                      "materials" in I ||
                      (I.material = gG.defaultTwoLayerData("phong"));
                  });
                })(_),
                (_.schema = 30)),
              I < 31 &&
                (void 0 === _.scene.publish.orbitControls.autoZoom &&
                  (_.scene.publish.orbitControls.autoZoom = !1),
                _.scene.objects.traverse((_, I) => {
                  ("OrthographicCamera" === I.type ||
                    "PerspectiveCamera" === I.type) &&
                    (void 0 === I.orthographic.autoZoom &&
                      (I.orthographic.autoZoom = !1),
                    void 0 === I.orthographic.autoZoomFrustumSize &&
                      (I.orthographic.autoZoomFrustumSize = 790));
                }),
                (_.schema = 31)),
              I < 33 &&
                ((function (_) {
                  _.scene.objects.traverse((_, I) => {
                    void 0 === I.pathSnapping &&
                      (I.pathSnapping = {
                        pathId: null,
                        slide: 0,
                        offset: 0,
                        orientation: "tangential",
                      }),
                      void 0 === I.pathSnapping.offset &&
                        (I.pathSnapping.offset = 0);
                  });
                })(_),
                (_.schema = 33)),
              I < 34 &&
                (void 0 === _.scene.publish.mouseEventTarget &&
                  (_.scene.publish.mouseEventTarget = "canvas"),
                void 0 === _.scene.publish.settings.web.hint &&
                  (_.scene.publish.settings.web.hint = !1),
                (_.schema = 34)),
              I < 35 &&
                ((function (_) {
                  let { video: I } = _.scene.publish.settings;
                  "gif" === I.format && I.fps > 48 && (I.fps = 15);
                })(_),
                (_.schema = 35)),
              I < 36 &&
                ((function (_) {
                  _.scene.objects.traverse((_, I) => {
                    I.events.forEach((_) => {
                      "GameControl" === _.type &&
                        (_.resetYPosition = Math.abs(
                          _.resetYPosition - I.position[1]
                        ));
                    });
                  });
                })(_),
                (_.schema = 36)),
              I < 37 &&
                ((function (_) {
                  let I = _.scene.environment.usePhysics;
                  _.scene.objects.traverse((_, R) => {
                    I && null === R.physics
                      ? (R.collision = !1)
                      : (R.collision = "visibility");
                  });
                })(_),
                (_.schema = 37)),
              I < 38 && (La(_, eO), Ra(_, eO), (_.schema = 38)),
              I < 39 &&
                ((function (_) {
                  _.scene.objects.traverse((_, I) => {
                    I.events.forEach((_) => {
                      "GameControl" === _.type &&
                        (_.navmesh = vV.defaultDataThirdPerson.navmesh);
                    });
                  });
                })(_),
                (_.schema = 39)),
              I < 40 &&
                (_.scene.styles || (_.scene.styles = v_.defaultData()),
                (_.schema = 40)),
              I < 41 &&
                (void 0 === _.scene.environment.ambientLight.occlusion &&
                  (_.scene.environment.ambientLight.occlusion = !1),
                void 0 === _.scene.environment.ambientLight.aoFullRes &&
                  (_.scene.environment.ambientLight.aoFullRes = !1),
                void 0 === _.scene.environment.ambientLight.radius &&
                  (_.scene.environment.ambientLight.radius = 256),
                void 0 === _.scene.environment.ambientLight.bias &&
                  (_.scene.environment.ambientLight.bias = 0.5),
                void 0 === _.scene.environment.ambientLight.aoColor &&
                  (_.scene.environment.ambientLight.aoColor = {
                    r: 0.19607843137254902,
                    g: 0.19607843137254902,
                    b: 0.19607843137254902,
                  }),
                La(_, iO),
                Ra(_, iO),
                (_.schema = 41)),
              I < 42 &&
                ((function (_) {
                  _.scene.objects.traverse((_, I) => {
                    I.events.forEach((_) => {
                      "GameControl" === _.type &&
                        Object.assign(_.gameActions, { run: new uN() });
                    });
                  });
                })(_),
                (_.schema = 42)),
              I < 43 &&
                ((function (_) {
                  _.scene.objects.traverse((_, I) => {
                    I.events.forEach((_) => {
                      "GameControl" === _.type &&
                        (_.keyAssignments = [
                          ..._.keyAssignments,
                          ["run", ""],
                          ["none", "Ctrl"],
                        ]);
                    });
                  });
                })(_),
                (_.schema = 43)),
              I < 99)
            ) {
              La(_, nO),
                Ra(_, nO),
                null === _.scene.publish.playCamera &&
                  (_.scene.publish.playCamera = fx);
              let I = kr(_.scene.objects),
                R = _.scene.objects;
              for (let B of ((_.scene.publish.playPage = fb),
              R.insertBefore(null, null, [
                {
                  id: fb,
                  data: {
                    ...vd.defaultData,
                    backgroundColor: _.scene.backgroundColor,
                    fog: _.scene.fog,
                    postprocessing: _.scene.postprocessing,
                    ao: uo(
                      _.scene.environment.ambientLight,
                      "occlusion",
                      "aoFullRes",
                      "radius",
                      "bias",
                      "aoColor"
                    ),
                    publish: {
                      playCamera: _.scene.publish.playCamera,
                      gameControlObject: _.scene.publish.gameControlObject,
                    },
                    shadow: uo(
                      _.scene.environment.ambientLight,
                      "softShadowQuality"
                    ),
                    globalPhysics: {
                      ...g3.defaultData,
                      ...uo(_.scene.environment, "usePhysics", "gravity"),
                    },
                    camera: kr(_.scene.ownerCamera) ?? vd.defaultData.camera,
                    name: "Scene",
                  },
                  children: [],
                },
              ]),
              I))
                B.id !== vT.TRASH_CAN_ID && R.move(fb, B.fi, B.id);
              let B = 0,
                z = 0;
              _.shared.penumbraSize &&
                _.scene.objects.traverse((I, R) => {
                  "DirectionalLight" === R.type
                    ? ((R.penumbraSize = _.shared.penumbraSize[Math.min(B, 2)]),
                      (B += 1))
                    : "SpotLight" === R.type &&
                      ((R.penumbraSize =
                        _.shared.penumbraSize[3 + Math.min(z, 1)]),
                      (z += 1)),
                    (void 0 === R.physics || null === R.physics) &&
                      "Instance" !== R.type &&
                      ((R.physics = {}),
                      Object.assign(R.physics, mN.defaultData)),
                    void 0 !== R.physics &&
                      null !== R.physics &&
                      ((R.physics.enabled = R.collision ?? "visibility"),
                      delete R.collision);
                }),
                (_.schema = 99);
            }
          })(_, I),
          I < 100 &&
            (void 0 === _.scene.publish.joystickSizeAndXYOffset &&
              (_.scene.publish.joystickSizeAndXYOffset =
                vy.defaultData.joystickSizeAndXYOffset),
            (_.schema = 100)),
          I < 101 && (La(_, oO), Ra(_, oO), (_.schema = 101)),
          I < 102 &&
            ((function (_) {
              _.scene.objects.traverse((_, I) => {
                let R = I.geometry;
                R &&
                  "PathGeometry" === R.type &&
                  ((R.extrusion.capType = "flat"),
                  (R.extrusion.bevel = 50),
                  (R.extrusion.bevelSides = 6),
                  "Custom" === R.extrusion.shape.type &&
                    (R.extrusion.shape.shapeQuality = "low"));
              });
            })(_),
            (_.schema = 102)),
          I < 104 &&
            ((_.shared.catelogs = new uL()),
            (_.shared.lib = vF.defaultData()),
            (_.schema = 104)),
          I < 105 &&
            ((_.shared.variables = _n({}, uL.prototype)),
            _.scene.objects.traverse((_, I) => {
              lO(I);
            }),
            (_.schema = 105)),
          Object.values(_.shared.lib.components)))
            !(function (_) {
              let I = _.schema ?? 104;
              111 !== I &&
                I < 105 &&
                ((function cO(_, I) {
                  for (let R of (I(_.data), _.children)) cO(R, I);
                })(_.asset, lO),
                (_.schema = 105));
            })(R);
          I < 106 &&
            ((R = kr(_.shared.variables)),
            (_.shared.variables = _n(
              Object.entries(R ?? {}).map(([_, I], R) => ({
                fi: R,
                id: _,
                data: I,
              })),
              uN.prototype
            )),
            (_.schema = 106)),
            I < 107 &&
              ((_.shared.lib.variables = vF.defaultData().variables),
              (_.schema = 107)),
            I < 109 &&
              ((_.shared.particles = _n({}, uL.prototype)),
              _.shared.lib &&
                (_.shared.lib.particles = vF.defaultData().particles),
              (_.schema = 109)),
            I < 110 &&
              ((function (_) {
                _.scene.objects.traverse((_, I) => {
                  "Particle" === I.type &&
                    "number" == typeof I.renderMaterial.size &&
                    Object.assign(I.renderMaterial, {
                      size: [I.renderMaterial.size, I.renderMaterial.size],
                    });
                });
              })(_),
              (_.schema = 110)),
            I < 111 &&
              (_.scene.objects.traverse((_, I) => {
                Array.isArray(kr(I.events)) &&
                  I.events?.forEach((_) => {
                    "disabled" in _ || (_.disabled = !1),
                      ("MouseDown" === _.type ||
                        "MouseUp" === _.type ||
                        "MousePress" === _.type) &&
                        (_.mode = _.mode || "Object");
                  });
              }),
              (_.schema = 111));
        }
      }
      function $s(_, I = !1) {
        let R = null !== _[0].index,
          B = new Set(Object.keys(_[0].attributes)),
          z = new Set(Object.keys(_[0].morphAttributes)),
          k = {},
          V = {},
          j = _[0].morphTargetsRelative,
          G = new ai(),
          q = 0;
        for (let X = 0; X < _.length; ++X) {
          let Q = _[X],
            $ = 0;
          if (R !== (null !== Q.index))
            return (
              console.error(
                "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                  X +
                  ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."
              ),
              null
            );
          for (let _ in Q.attributes) {
            if (!B.has(_))
              return (
                console.error(
                  "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                    X +
                    '. All geometries must have compatible attributes; make sure "' +
                    _ +
                    '" attribute exists among all geometries, or in none of them.'
                ),
                null
              );
            void 0 === k[_] && (k[_] = []), k[_].push(Q.attributes[_]), $++;
          }
          if ($ !== B.size)
            return (
              console.error(
                "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                  X +
                  ". Make sure all geometries have the same number of attributes."
              ),
              null
            );
          if (j !== Q.morphTargetsRelative)
            return (
              console.error(
                "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                  X +
                  ". .morphTargetsRelative must be consistent throughout all geometries."
              ),
              null
            );
          for (let _ in Q.morphAttributes) {
            if (!z.has(_))
              return (
                console.error(
                  "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                    X +
                    ".  .morphAttributes must be consistent throughout all geometries."
                ),
                null
              );
            void 0 === V[_] && (V[_] = []), V[_].push(Q.morphAttributes[_]);
          }
          if (I) {
            let _;
            if (R) _ = Q.index.count;
            else {
              if (void 0 === Q.attributes.position)
                return (
                  console.error(
                    "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                      X +
                      ". The geometry must have either an index or a position attribute"
                  ),
                  null
                );
              _ = Q.attributes.position.count;
            }
            G.addGroup(q, _, X), (q += _);
          }
        }
        if (R) {
          let I = 0,
            R = [];
          for (let B = 0; B < _.length; ++B) {
            let z = _[B].index;
            for (let _ = 0; _ < z.count; ++_) R.push(z.getX(_) + I);
            I += _[B].attributes.position.count;
          }
          G.setIndex(R);
        }
        for (let _ in k) {
          let I = dO(k[_]);
          if (!I)
            return (
              console.error(
                "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " +
                  _ +
                  " attribute."
              ),
              null
            );
          G.setAttribute(_, I);
        }
        for (let _ in V) {
          let I = V[_][0].length;
          if (0 === I) break;
          (G.morphAttributes = G.morphAttributes || {}),
            (G.morphAttributes[_] = []);
          for (let R = 0; R < I; ++R) {
            let I = [];
            for (let B = 0; B < V[_].length; ++B) I.push(V[_][B][R]);
            let B = dO(I);
            if (!B)
              return (
                console.error(
                  "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " +
                    _ +
                    " morphAttribute."
                ),
                null
              );
            G.morphAttributes[_].push(B);
          }
        }
        return G;
      }
      function dO(_) {
        let I,
          R,
          B,
          z = 0;
        for (let k = 0; k < _.length; ++k) {
          let V = _[k];
          if (V.isInterleavedBufferAttribute)
            return (
              console.error(
                "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."
              ),
              null
            );
          if (
            (void 0 === I && (I = V.array.constructor),
            I !== V.array.constructor)
          )
            return (
              console.error(
                "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."
              ),
              null
            );
          if ((void 0 === R && (R = V.itemSize), R !== V.itemSize))
            return (
              console.error(
                "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."
              ),
              null
            );
          if ((void 0 === B && (B = V.normalized), B !== V.normalized))
            return (
              console.error(
                "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."
              ),
              null
            );
          z += V.array.length;
        }
        let k = new I(z),
          V = 0;
        for (let I = 0; I < _.length; ++I)
          k.set(_[I].array, V), (V += _[I].array.length);
        return new s0(k, R, B);
      }
      ((gF = vj || (vj = {})).defaultData = {
        schema: 111,
        scene: vT.defaultData,
        frames: new uL().add(
          "72fc2993-2da3-4b6b-96ac-2879db3a28bd",
          vP.defaultData
        ),
        shared: { ...vN.emptyData(), colors: vN.defaultColors() },
      }),
        (gF.emptyDataForImports = function (_) {
          return {
            schema: 111,
            scene: vT.emptyDataWithPage(_),
            frames: new uL().add(
              "72fc2993-2da3-4b6b-96ac-2879db3a28bd",
              vP.defaultData
            ),
            shared: {
              ...vN.emptyData(),
              colors: vN.defaultColors(),
              images: vN.defaultImages(_),
            },
          };
        }),
        (gF.emptyData = function () {
          return {
            schema: 111,
            scene: vT.emptyDataWithPage(),
            frames: new uL().add(
              "72fc2993-2da3-4b6b-96ac-2879db3a28bd",
              vP.defaultData
            ),
            shared: vN.emptyData(),
          };
        }),
        (gF.clipboard2dData = function () {
          return {
            schema: 111,
            scene: vT.emptyData(),
            frames: new uL(),
            shared: vN.emptyData(),
          };
        }),
        (gF.collabHelper = {
          ...u7,
          updateSchema: (_) =>
            (_.schema ?? 0) < 111 ? Tl(_, c0) : (_.schema ?? 0) - 111,
        }),
        (gF.updateSchemaDirectly = function (_) {
          let I = gF.collabHelper.updateSchema(_);
          return "number" == typeof I ? (0 === I ? _ : null) : I.data;
        }),
        (gF.withoutLib = function (_) {
          return { ..._, shared: { ..._.shared, lib: vF.defaultData() } };
        }),
        (gF.getComponentData = function (_, I) {
          let R = _.scene.objects.get(I);
          if (R && "Component" === R.data.type) return R;
          {
            let R = _.shared.lib.components[I];
            if (R) return R.asset;
          }
        }),
        ((vG || (vG = {})).is = function (_) {
          return !0;
        }),
        ((gN = vH || (vH = {})).defaultData = {
          position: [0, 0],
          scale: [1, 1],
          rotation: 0,
          shear: [0, 0],
        }),
        (gN.merge = function (_, I) {
          return {
            position: I?.position ?? _.position,
            rotation: I?.rotation ?? _.rotation,
            scale: I?.scale ?? _.scale,
            shear: I?.shear ?? _.shear,
          };
        }),
        (gN.diff = function (_, I) {
          return yv({
            position: mu.isEqual(_.position, I.position) ? void 0 : I.position,
            rotation: _.rotation === I.rotation ? void 0 : I.rotation,
            scale: mu.isEqual(_.scale, I.scale) ? void 0 : I.scale,
            shear:
              _.shear && I.shear && mu.isEqual(_.shear, I.shear)
                ? void 0
                : I.shear,
          });
        }),
        ((vW || (vW = {})).defaultData = {
          horizontalConstraint: 0,
          verticalConstraint: 0,
        }),
        ((vq || (vq = {})).defaultData = {
          opacity: 1,
          fill: { color: mb.fromHexAndA(5526619, 1), enabled: !0 },
          stroke: {
            color: mb.from0to1([0, 0, 0, 1]),
            thickness: 1,
            enabled: !1,
            mode: "inside",
          },
          layerBlur: { radius: 2, enabled: !1 },
          backgroundBlur: { radius: 2, enabled: !1 },
          dropShadow: {
            offset: [10, 10],
            blurRadius: 10,
            color: mb.from0to1([0, 0, 0, 1]),
            enabled: !1,
            spread: 0,
          },
          innerShadow: {
            offset: [10, 10],
            blurRadius: 10,
            color: mb.from0to1([0, 0, 0, 1]),
            enabled: !1,
            spread: 0,
          },
        }),
        ((gk = vY || (vY = {})).newEmpty = function (_, I) {
          return { name: I };
        }),
        (gk.patch = function (_, I) {
          if (void 0 === I) return _;
          let R = { ..._ };
          return (
            Object.assign(R, vH.merge(R, I)),
            (R = (function (_, I) {
              if (void 0 === I) return _;
              let R = { ..._ };
              return (
                "fill" in R &&
                  "fill" in I &&
                  void 0 !== I.fill &&
                  Object.assign(R, { fill: { ...R.fill, ...I.fill } }),
                "stroke" in R &&
                  "stroke" in I &&
                  void 0 !== I.stroke &&
                  Object.assign(R, { stroke: { ...R.stroke, ...I.stroke } }),
                "layerBlur" in R &&
                  "layerBlur" in I &&
                  void 0 !== I.layerBlur &&
                  Object.assign(R, {
                    layerBlur: { ...R.layerBlur, ...I.layerBlur },
                  }),
                "backgroundBlur" in R &&
                  "backgroundBlur" in I &&
                  void 0 !== I.backgroundBlur &&
                  Object.assign(R, {
                    backgroundBlur: {
                      ...R.backgroundBlur,
                      ...I.backgroundBlur,
                    },
                  }),
                "dropShadow" in R &&
                  "dropShadow" in I &&
                  void 0 !== I.dropShadow &&
                  Object.assign(R, {
                    dropShadow: { ...R.dropShadow, ...I.dropShadow },
                  }),
                "innerShadow" in R &&
                  "innerShadow" in I &&
                  void 0 !== I.innerShadow &&
                  Object.assign(R, {
                    innerShadow: { ...R.innerShadow, ...I.innerShadow },
                  }),
                R
              );
            })(
              (R = (function (_, I) {
                if (void 0 === I) return _;
                let R = { ..._ };
                for (let _ of ["width", "height", "cornerRadius"])
                  _ in R &&
                    _ in I &&
                    void 0 !== I[_] &&
                    Object.assign(R, { [_]: I[_] });
                return R;
              })(R, I)),
              I
            ))
          );
        }),
        (gk.toOps = function (_, I) {
          let R,
            B = [];
          for (let [_, z] of Object.entries(I))
            "name" !== _ &&
              (void 0 === R &&
                ((R = { path: [], props: {}, type: 0 }), B.push(R)),
              (R.props[_] = z));
          return B;
        }),
        ((vX || (vX = {})).defaultData = {
          ...vH.defaultData,
          ...vW.defaultData,
          states: new uN(),
          events: new uN(),
          visible: !0,
          raycastLock: !1,
        }),
        ((vQ || (vQ = {})).defaultData = {
          ...vX.defaultData,
          ...vq.defaultData,
        }),
        ((vZ || (vZ = {})).defaultData = { cornerRadius: [0, 0, 0, 0] }),
        ((vJ || (vJ = {})).defaultData = {
          ...vQ.defaultData,
          type: "ellipse2d",
          width: 100,
          height: 100,
          name: "Ellipse",
        }),
        ((v$ || (v$ = {})).defaultData = {
          ...vQ.defaultData,
          ...vZ.defaultData,
          type: "rectangle2d",
          width: 100,
          height: 100,
          name: "Rectangle",
        }),
        ((v0 || (v0 = {})).defaultData = {
          ...vQ.defaultData,
          type: "text2d",
          width: 100,
          height: 100,
          fontSize: 12,
          lineHeight: 1.2,
          letterSpacing: 0,
          text: { textValue: "Hello world" },
          horizontalAlign: 1,
          verticalAlign: 1,
          textTransform: 1,
          font: "Roboto_regular",
          name: "Text",
        }),
        ((v2 || (v2 = {})).defaultData = {
          ...vQ.defaultData,
          type: "path2d",
          path: "",
          name: "Path",
        }),
        ((v3 || (v3 = {})).is = function (_) {
          return (
            "ellipse2d" === _.type ||
            "rectangle2d" === _.type ||
            "text2d" === _.type ||
            "vector2d" === _.type ||
            "path2d" === _.type
          );
        }),
        ((v4 || (v4 = {})).defaultData = {
          ...vX.defaultData,
          name: "Group",
          type: "group2d",
        }),
        ((v5 || (v5 = {})).defaultData = {
          ...vX.defaultData,
          ...vZ.defaultData,
          ...vq.defaultData,
          name: "Frame",
          type: "frame2d",
          clipped: !0,
          width: 200,
          height: 200,
          fill: { color: mb.fromHexAndA(4737101, 1), enabled: !0 },
          stroke: {
            color: mb.fromHexAndA(0, 1),
            thickness: 1,
            enabled: !1,
            mode: "inside",
          },
          backgroundBlur: { radius: 2, enabled: !1 },
          layerBlur: { radius: 2, enabled: !1 },
        }),
        ((gV = v6 || (v6 = {})).defaultData = function (_) {
          switch (_) {
            case "rectangle2d":
            case "vector2d":
              return { ...v$.defaultData };
            case "ellipse2d":
              return { ...vJ.defaultData };
            case "text2d":
              return { ...v0.defaultData };
            case "path2d":
              return { ...v2.defaultData };
            case "frame2d":
              return { ...v5.defaultData };
            case "group2d":
              return { ...v4.defaultData };
          }
        }),
        (gV.getPivot = function (_) {
          return "width" in _ && "height" in _
            ? [
                "number" == typeof _.width ? 0.5 * _.width : 0,
                "number" == typeof _.height ? 0.5 * _.height : 0,
              ]
            : [0, 0];
        }),
        (gV.isResizeable = function (_) {
          return (
            "rectangle2d" === _.type ||
            "ellipse2d" === _.type ||
            "text2d" === _.type ||
            "frame2d" === _.type
          );
        }),
        (gV.hasCorners = function (_) {
          return "rectangle2d" === _.type || "frame2d" === _.type;
        }),
        ((gj = v8 || (v8 = {})).defaultData = {
          name: "UI",
          type: "scene2d",
          objects: new uF(),
        }),
        (gj.emptyData = function () {
          return { type: "scene2d", objects: new uF() };
        });
      var m0 = class {
        constructor() {}
      };
      function Es(_, I, R) {
        return (
          (R.min.x = I[_]),
          (R.min.y = I[_ + 1]),
          (R.min.z = I[_ + 2]),
          (R.max.x = I[_ + 3]),
          (R.max.y = I[_ + 4]),
          (R.max.z = I[_ + 5]),
          R
        );
      }
      function j1(_) {
        let I = -1,
          R = -1 / 0;
        for (let B = 0; B < 3; B++) {
          let z = _[B + 3] - _[B];
          z > R && ((R = z), (I = B));
        }
        return I;
      }
      function W1(_, I, R) {
        let B, z;
        for (let k = 0; k < 3; k++) {
          let V = k + 3;
          (B = _[k]),
            (z = I[k]),
            (R[k] = B < z ? B : z),
            (B = _[V]),
            (z = I[V]),
            (R[V] = B > z ? B : z);
        }
      }
      function cm(_, I, R) {
        for (let B = 0; B < 3; B++) {
          let z = I[_ + 2 * B],
            k = I[_ + 2 * B + 1],
            V = z - k,
            j = z + k;
          V < R[B] && (R[B] = V), j > R[B + 3] && (R[B + 3] = j);
        }
      }
      function dd(_) {
        let I = _[3] - _[0],
          R = _[4] - _[1],
          B = _[5] - _[2];
        return 2 * (I * R + R * B + B * I);
      }
      function Y1(_, I, R, B, z = null) {
        let k = 1 / 0,
          V = 1 / 0,
          j = 1 / 0,
          G = -1 / 0,
          q = -1 / 0,
          X = -1 / 0,
          Q = 1 / 0,
          $ = 1 / 0,
          et = 1 / 0,
          er = -1 / 0,
          es = -1 / 0,
          ea = -1 / 0,
          en = null !== z;
        for (let B = 6 * I, z = (I + R) * 6; B < z; B += 6) {
          let I = _[B + 0],
            R = _[B + 1],
            z = I - R,
            eo = I + R;
          z < k && (k = z),
            eo > G && (G = eo),
            en && I < Q && (Q = I),
            en && I > er && (er = I);
          let el = _[B + 2],
            eh = _[B + 3],
            ec = el - eh,
            ed = el + eh;
          ec < V && (V = ec),
            ed > q && (q = ed),
            en && el < $ && ($ = el),
            en && el > es && (es = el);
          let ep = _[B + 4],
            ef = _[B + 5],
            em = ep - ef,
            ey = ep + ef;
          em < j && (j = em),
            ey > X && (X = ey),
            en && ep < et && (et = ep),
            en && ep > ea && (ea = ep);
        }
        (B[0] = k),
          (B[1] = V),
          (B[2] = j),
          (B[3] = G),
          (B[4] = q),
          (B[5] = X),
          en &&
            ((z[0] = Q),
            (z[1] = $),
            (z[2] = et),
            (z[3] = er),
            (z[4] = es),
            (z[5] = ea));
      }
      var I9 = (_, I) => _.candidate - I.candidate,
        m1 = Array(32)
          .fill()
          .map(() => ({
            count: 0,
            bounds: new Float32Array(6),
            rightCacheBounds: new Float32Array(6),
            leftCacheBounds: new Float32Array(6),
            candidate: 0,
          })),
        m2 = new Float32Array(6),
        m3 = class {
          constructor() {
            (this.min = 1 / 0), (this.max = -1 / 0);
          }
          setFromPointsField(_, I) {
            let R = 1 / 0,
              B = -1 / 0;
            for (let z = 0, k = _.length; z < k; z++) {
              let k = _[z][I];
              (R = k < R ? k : R), (B = k > B ? k : B);
            }
            (this.min = R), (this.max = B);
          }
          setFromPoints(_, I) {
            let R = 1 / 0,
              B = -1 / 0;
            for (let z = 0, k = I.length; z < k; z++) {
              let k = I[z],
                V = _.dot(k);
              (R = V < R ? V : R), (B = V > B ? V : B);
            }
            (this.min = R), (this.max = B);
          }
          isSeparated(_) {
            return this.min > _.max || _.min > this.max;
          }
        };
      (m3.prototype.setFromBox =
        ((k = new rF()),
        function (_, I) {
          let R = I.min,
            B = I.max,
            z = 1 / 0,
            V = -1 / 0;
          for (let I = 0; I <= 1; I++)
            for (let j = 0; j <= 1; j++)
              for (let G = 0; G <= 1; G++) {
                (k.x = R.x * I + B.x * (1 - I)),
                  (k.y = R.y * j + B.y * (1 - j)),
                  (k.z = R.z * G + B.z * (1 - G));
                let q = _.dot(k);
                (z = Math.min(q, z)), (V = Math.max(q, V));
              }
          (this.min = z), (this.max = V);
        })),
        new m3();
      var m4 =
          ((V = new rF()),
          (j = new rF()),
          (G = new rF()),
          function (_, I, R) {
            let B = _.start,
              z = I.start;
            G.subVectors(B, z),
              V.subVectors(_.end, _.start),
              j.subVectors(I.end, I.start);
            let k = G.dot(j),
              q = j.dot(V),
              X = j.dot(j),
              Q = G.dot(V),
              $ = V.dot(V) * X - q * q,
              et,
              er;
            (et = 0 !== $ ? (k * q - Q * X) / $ : 0),
              (er = (k + et * q) / X),
              (R.x = et),
              (R.y = er);
          }),
        m5 =
          ((q = new rs()),
          (X = new rF()),
          (Q = new rF()),
          function (_, I, R, B) {
            m4(_, I, q);
            let z = q.x,
              k = q.y;
            if (z >= 0 && z <= 1 && k >= 0 && k <= 1) {
              _.at(z, R), I.at(k, B);
              return;
            }
            if (z >= 0 && z <= 1) {
              k < 0 ? I.at(0, B) : I.at(1, B), _.closestPointToPoint(B, !0, R);
              return;
            }
            if (k >= 0 && k <= 1) {
              z < 0 ? _.at(0, R) : _.at(1, R), I.closestPointToPoint(R, !0, B);
              return;
            }
            {
              let V, j;
              if (
                ((V = z < 0 ? _.start : _.end),
                (j = k < 0 ? I.start : I.end),
                _.closestPointToPoint(j, !0, X),
                I.closestPointToPoint(V, !0, Q),
                X.distanceToSquared(j) <= Q.distanceToSquared(V))
              ) {
                R.copy(X), B.copy(j);
                return;
              }
              R.copy(V), B.copy(Q);
              return;
            }
          }),
        m6 =
          (($ = new rF()),
          (et = new rF()),
          (er = new aV()),
          (es = new lX()),
          function (_, I) {
            let { radius: R, center: B } = _,
              { a: z, b: k, c: V } = I;
            if (
              ((es.start = z),
              (es.end = k),
              es.closestPointToPoint(B, !0, $).distanceTo(B) <= R ||
                ((es.start = z),
                (es.end = V),
                es.closestPointToPoint(B, !0, $).distanceTo(B) <= R) ||
                ((es.start = k),
                (es.end = V),
                es.closestPointToPoint(B, !0, $).distanceTo(B) <= R))
            )
              return !0;
            let j = I.getPlane(er);
            if (Math.abs(j.distanceToPoint(B)) <= R) {
              let _ = j.projectPoint(B, et);
              if (I.containsPoint(_)) return !0;
            }
            return !1;
          });
      function fd(_) {
        return 1e-15 > Math.abs(_);
      }
      var m8 = class extends sX {
        constructor(..._) {
          super(..._),
            (this.isExtendedTriangle = !0),
            (this.satAxes = [, , , ,].fill().map(() => new rF())),
            (this.satBounds = [, , , ,].fill().map(() => new m3())),
            (this.points = [this.a, this.b, this.c]),
            (this.sphere = new r5()),
            (this.plane = new aV()),
            (this.needsUpdate = !0);
        }
        intersectsSphere(_) {
          return m6(_, this);
        }
        update() {
          let _ = this.a,
            I = this.b,
            R = this.c,
            B = this.points,
            z = this.satAxes,
            k = this.satBounds,
            V = z[0],
            j = k[0];
          this.getNormal(V), j.setFromPoints(V, B);
          let G = z[1],
            q = k[1];
          G.subVectors(_, I), q.setFromPoints(G, B);
          let X = z[2],
            Q = k[2];
          X.subVectors(I, R), Q.setFromPoints(X, B);
          let $ = z[3],
            et = k[3];
          $.subVectors(R, _),
            et.setFromPoints($, B),
            this.sphere.setFromPoints(this.points),
            this.plane.setFromNormalAndCoplanarPoint(V, _),
            (this.needsUpdate = !1);
        }
      };
      (m8.prototype.closestPointToSegment =
        ((ea = new rF()),
        (en = new rF()),
        (eo = new lX()),
        function (_, I = null, R = null) {
          let { start: B, end: z } = _,
            k = this.points,
            V,
            j = 1 / 0;
          for (let B = 0; B < 3; B++) {
            let z = (B + 1) % 3;
            eo.start.copy(k[B]),
              eo.end.copy(k[z]),
              m5(eo, _, ea, en),
              (V = ea.distanceToSquared(en)) < j &&
                ((j = V), I && I.copy(ea), R && R.copy(en));
          }
          return (
            this.closestPointToPoint(B, ea),
            (V = B.distanceToSquared(ea)) < j &&
              ((j = V), I && I.copy(ea), R && R.copy(B)),
            this.closestPointToPoint(z, ea),
            (V = z.distanceToSquared(ea)) < j &&
              ((j = V), I && I.copy(ea), R && R.copy(z)),
            Math.sqrt(j)
          );
        })),
        (m8.prototype.intersectsTriangle =
          ((el = new m8()),
          (eh = [, , ,]),
          (ec = [, , ,]),
          (ed = new m3()),
          (ep = new m3()),
          (ef = new rF()),
          (em = new rF()),
          (ey = new rF()),
          (ex = new rF()),
          (eb = new lX()),
          (ew = new lX()),
          (e_ = new lX()),
          function (_, I = null, R = !1) {
            this.needsUpdate && this.update(),
              _.isExtendedTriangle
                ? _.needsUpdate && _.update()
                : (el.copy(_), el.update(), (_ = el));
            let B = this.plane,
              z = _.plane;
            if (Math.abs(B.normal.dot(z.normal)) > 1 - 1e-10) {
              let B = this.satBounds,
                z = this.satAxes;
              (ec[0] = _.a), (ec[1] = _.b), (ec[2] = _.c);
              for (let _ = 0; _ < 4; _++) {
                let I = B[_],
                  R = z[_];
                if ((ed.setFromPoints(R, ec), I.isSeparated(ed))) return !1;
              }
              let k = _.satBounds,
                V = _.satAxes;
              (eh[0] = this.a), (eh[1] = this.b), (eh[2] = this.c);
              for (let _ = 0; _ < 4; _++) {
                let I = k[_],
                  R = V[_];
                if ((ed.setFromPoints(R, eh), I.isSeparated(ed))) return !1;
              }
              for (let _ = 0; _ < 4; _++) {
                let I = z[_];
                for (let _ = 0; _ < 4; _++) {
                  let R = V[_];
                  if (
                    (ef.crossVectors(I, R),
                    ed.setFromPoints(ef, eh),
                    ep.setFromPoints(ef, ec),
                    ed.isSeparated(ep))
                  )
                    return !1;
                }
              }
              return (
                I &&
                  (R ||
                    console.warn(
                      "ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."
                    ),
                  I.start.set(0, 0, 0),
                  I.end.set(0, 0, 0)),
                !0
              );
            }
            {
              let R = this.points,
                k = !1,
                V = 0;
              for (let _ = 0; _ < 3; _++) {
                let I = R[_],
                  B = R[(_ + 1) % 3];
                eb.start.copy(I), eb.end.copy(B), eb.delta(em);
                let j = k ? ew.start : ew.end,
                  G = fd(z.distanceToPoint(I));
                if (fd(z.normal.dot(em)) && G) {
                  ew.copy(eb), (V = 2);
                  break;
                }
                if ((z.intersectLine(eb, j) || G) && !fd(j.distanceTo(B))) {
                  if ((V++, k)) break;
                  k = !0;
                }
              }
              if (1 === V && _.containsPoint(ew.end))
                return I && (I.start.copy(ew.end), I.end.copy(ew.end)), !0;
              if (2 !== V) return !1;
              let j = _.points,
                G = !1,
                q = 0;
              for (let _ = 0; _ < 3; _++) {
                let I = j[_],
                  R = j[(_ + 1) % 3];
                eb.start.copy(I), eb.end.copy(R), eb.delta(ey);
                let z = G ? e_.start : e_.end,
                  k = fd(B.distanceToPoint(I));
                if (fd(B.normal.dot(ey)) && k) {
                  e_.copy(eb), (q = 2);
                  break;
                }
                if ((B.intersectLine(eb, z) || k) && !fd(z.distanceTo(R))) {
                  if ((q++, G)) break;
                  G = !0;
                }
              }
              if (1 === q && this.containsPoint(e_.end))
                return I && (I.start.copy(e_.end), I.end.copy(e_.end)), !0;
              if (2 !== q) return !1;
              if ((ew.delta(em), e_.delta(ey), 0 > em.dot(ey))) {
                let _ = e_.start;
                (e_.start = e_.end), (e_.end = _);
              }
              let X = ew.start.dot(em),
                Q = ew.end.dot(em),
                $ = e_.start.dot(em),
                et = e_.end.dot(em);
              return (
                (X === et || $ === Q || Q < $ != X < et) &&
                (I &&
                  (ex.subVectors(ew.start, e_.start),
                  ex.dot(em) > 0
                    ? I.start.copy(ew.start)
                    : I.start.copy(e_.start),
                  ex.subVectors(ew.end, e_.end),
                  0 > ex.dot(em) ? I.end.copy(ew.end) : I.end.copy(e_.end)),
                !0)
              );
            }
          })),
        (m8.prototype.distanceToPoint =
          ((eS = new rF()),
          function (_) {
            return this.closestPointToPoint(_, eS), _.distanceTo(eS);
          })),
        (m8.prototype.distanceToTriangle =
          ((eA = new rF()),
          (eC = new rF()),
          (eT = ["a", "b", "c"]),
          (eP = new lX()),
          (eI = new lX()),
          function (_, I = null, R = null) {
            let B = I || R ? eP : null;
            if (this.intersectsTriangle(_, B))
              return (I || R) && (I && B.getCenter(I), R && B.getCenter(R)), 0;
            let z = 1 / 0;
            for (let B = 0; B < 3; B++) {
              let k,
                V = eT[B],
                j = _[V];
              this.closestPointToPoint(j, eA),
                (k = j.distanceToSquared(eA)) < z &&
                  ((z = k), I && I.copy(eA), R && R.copy(j));
              let G = this[V];
              _.closestPointToPoint(G, eA),
                (k = G.distanceToSquared(eA)) < z &&
                  ((z = k), I && I.copy(G), R && R.copy(eA));
            }
            for (let B = 0; B < 3; B++) {
              let k = eT[B],
                V = eT[(B + 1) % 3];
              eP.set(this[k], this[V]);
              for (let B = 0; B < 3; B++) {
                let k = eT[B],
                  V = eT[(B + 1) % 3];
                eI.set(_[k], _[V]), m5(eP, eI, eA, eC);
                let j = eA.distanceToSquared(eC);
                j < z && ((z = j), I && I.copy(eA), R && R.copy(eC));
              }
            }
            return Math.sqrt(z);
          }));
      var m9 = class {
        constructor(_, I, R) {
          (this.isOrientedBox = !0),
            (this.min = new rF()),
            (this.max = new rF()),
            (this.matrix = new sa()),
            (this.invMatrix = new sa()),
            (this.points = Array(8)
              .fill()
              .map(() => new rF())),
            (this.satAxes = [, , ,].fill().map(() => new rF())),
            (this.satBounds = [, , ,].fill().map(() => new m3())),
            (this.alignedSatBounds = [, , ,].fill().map(() => new m3())),
            (this.needsUpdate = !1),
            _ && this.min.copy(_),
            I && this.max.copy(I),
            R && this.matrix.copy(R);
        }
        set(_, I, R) {
          this.min.copy(_),
            this.max.copy(I),
            this.matrix.copy(R),
            (this.needsUpdate = !0);
        }
        copy(_) {
          this.min.copy(_.min),
            this.max.copy(_.max),
            this.matrix.copy(_.matrix),
            (this.needsUpdate = !0);
        }
      };
      (m9.prototype.update = function () {
        let _ = this.matrix,
          I = this.min,
          R = this.max,
          B = this.points;
        for (let z = 0; z <= 1; z++)
          for (let k = 0; k <= 1; k++)
            for (let V = 0; V <= 1; V++) {
              let j = B[(1 * z) | (2 * k) | (4 * V)];
              (j.x = z ? R.x : I.x),
                (j.y = k ? R.y : I.y),
                (j.z = V ? R.z : I.z),
                j.applyMatrix4(_);
            }
        let z = this.satBounds,
          k = this.satAxes,
          V = B[0];
        for (let _ = 0; _ < 3; _++) {
          let I = k[_],
            R = z[_],
            j = B[1 << _];
          I.subVectors(V, j), R.setFromPoints(I, B);
        }
        let j = this.alignedSatBounds;
        j[0].setFromPointsField(B, "x"),
          j[1].setFromPointsField(B, "y"),
          j[2].setFromPointsField(B, "z"),
          this.invMatrix.copy(this.matrix).invert(),
          (this.needsUpdate = !1);
      }),
        (m9.prototype.intersectsBox =
          ((eR = new m3()),
          function (_) {
            this.needsUpdate && this.update();
            let I = _.min,
              R = _.max,
              B = this.satBounds,
              z = this.satAxes,
              k = this.alignedSatBounds;
            if (
              ((eR.min = I.x),
              (eR.max = R.x),
              k[0].isSeparated(eR) ||
                ((eR.min = I.y), (eR.max = R.y), k[1].isSeparated(eR)) ||
                ((eR.min = I.z), (eR.max = R.z), k[2].isSeparated(eR)))
            )
              return !1;
            for (let I = 0; I < 3; I++) {
              let R = z[I],
                k = B[I];
              if ((eR.setFromBox(R, _), k.isSeparated(eR))) return !1;
            }
            return !0;
          })),
        (m9.prototype.intersectsTriangle =
          ((eB = new m8()),
          (ez = [, , ,]),
          (eF = new m3()),
          (ek = new m3()),
          (eU = new rF()),
          function (_) {
            this.needsUpdate && this.update(),
              _.isExtendedTriangle
                ? _.needsUpdate && _.update()
                : (eB.copy(_), eB.update(), (_ = eB));
            let I = this.satBounds,
              R = this.satAxes;
            (ez[0] = _.a), (ez[1] = _.b), (ez[2] = _.c);
            for (let _ = 0; _ < 3; _++) {
              let B = I[_],
                z = R[_];
              if ((eF.setFromPoints(z, ez), B.isSeparated(eF))) return !1;
            }
            let B = _.satBounds,
              z = _.satAxes,
              k = this.points;
            for (let _ = 0; _ < 3; _++) {
              let I = B[_],
                R = z[_];
              if ((eF.setFromPoints(R, k), I.isSeparated(eF))) return !1;
            }
            for (let _ = 0; _ < 3; _++) {
              let I = R[_];
              for (let _ = 0; _ < 4; _++) {
                let R = z[_];
                if (
                  (eU.crossVectors(I, R),
                  eF.setFromPoints(eU, ez),
                  ek.setFromPoints(eU, k),
                  eF.isSeparated(ek))
                )
                  return !1;
              }
            }
            return !0;
          })),
        (m9.prototype.closestPointToPoint = function (_, I) {
          return (
            this.needsUpdate && this.update(),
            I.copy(_)
              .applyMatrix4(this.invMatrix)
              .clamp(this.min, this.max)
              .applyMatrix4(this.matrix),
            I
          );
        }),
        (m9.prototype.distanceToPoint =
          ((eV = new rF()),
          function (_) {
            return this.closestPointToPoint(_, eV), _.distanceTo(eV);
          })),
        (m9.prototype.distanceToBox =
          ((ej = ["x", "y", "z"]),
          (eH = Array(12)
            .fill()
            .map(() => new lX())),
          (eW = Array(12)
            .fill()
            .map(() => new lX())),
          (eq = new rF()),
          (eX = new rF()),
          function (_, I = 0, R = null, B = null) {
            if ((this.needsUpdate && this.update(), this.intersectsBox(_)))
              return (
                (R || B) &&
                  (_.getCenter(eX),
                  this.closestPointToPoint(eX, eq),
                  _.closestPointToPoint(eq, eX),
                  R && R.copy(eq),
                  B && B.copy(eX)),
                0
              );
            let z = I * I,
              k = _.min,
              V = _.max,
              j = this.points,
              G = 1 / 0;
            for (let _ = 0; _ < 8; _++) {
              let I = j[_];
              eX.copy(I).clamp(k, V);
              let q = I.distanceToSquared(eX);
              if (q < G && ((G = q), R && R.copy(I), B && B.copy(eX), q < z))
                return Math.sqrt(q);
            }
            let q = 0;
            for (let _ = 0; _ < 3; _++)
              for (let I = 0; I <= 1; I++)
                for (let R = 0; R <= 1; R++) {
                  let B = (_ + 1) % 3,
                    z = (_ + 2) % 3,
                    G = (I << B) | (R << z),
                    X = (1 << _) | (I << B) | (R << z),
                    Q = j[G],
                    $ = j[X];
                  eH[q].set(Q, $);
                  let et = ej[_],
                    er = ej[B],
                    es = ej[z],
                    ea = eW[q],
                    en = ea.start,
                    eo = ea.end;
                  (en[et] = k[et]),
                    (en[er] = I ? k[er] : V[er]),
                    (en[es] = R ? k[es] : V[er]),
                    (eo[et] = V[et]),
                    (eo[er] = I ? k[er] : V[er]),
                    (eo[es] = R ? k[es] : V[er]),
                    q++;
                }
            for (let _ = 0; _ <= 1; _++)
              for (let I = 0; I <= 1; I++)
                for (let j = 0; j <= 1; j++) {
                  (eX.x = _ ? V.x : k.x),
                    (eX.y = I ? V.y : k.y),
                    (eX.z = j ? V.z : k.z),
                    this.closestPointToPoint(eX, eq);
                  let q = eX.distanceToSquared(eq);
                  if (
                    q < G &&
                    ((G = q), R && R.copy(eq), B && B.copy(eX), q < z)
                  )
                    return Math.sqrt(q);
                }
            for (let _ = 0; _ < 12; _++) {
              let I = eH[_];
              for (let _ = 0; _ < 12; _++) {
                m5(I, eW[_], eq, eX);
                let k = eq.distanceToSquared(eX);
                if (k < G && ((G = k), R && R.copy(eq), B && B.copy(eX), k < z))
                  return Math.sqrt(k);
              }
            }
            return Math.sqrt(G);
          }));
      var m7 = new rF(),
        ge = new rF(),
        gr = new rF(),
        gs = new rs(),
        ga = new rs(),
        go = new rs(),
        gl = new rF(),
        gh = new rF(),
        gc = new rF(),
        gd = new rF();
      function Q1(_, I, R, B, z) {
        let k = 3 * B,
          V = _.index.getX(k),
          j = _.index.getX(k + 1),
          G = _.index.getX(k + 2),
          { position: q, normal: X, uv: Q, uv1: $ } = _.attributes,
          et = (function (_, I, R, B, z, k, V, j, G) {
            m7.fromBufferAttribute(I, k),
              ge.fromBufferAttribute(I, V),
              gr.fromBufferAttribute(I, j);
            let q =
              null ===
              (1 === G
                ? _.intersectTriangle(gr, ge, m7, !0, gd)
                : _.intersectTriangle(m7, ge, gr, 2 !== G, gd))
                ? null
                : { distance: _.origin.distanceTo(gd), point: gd.clone() };
            if (q) {
              B &&
                (gs.fromBufferAttribute(B, k),
                ga.fromBufferAttribute(B, V),
                go.fromBufferAttribute(B, j),
                (q.uv = sX.getInterpolation(
                  gd,
                  m7,
                  ge,
                  gr,
                  gs,
                  ga,
                  go,
                  new rs()
                ))),
                z &&
                  (gs.fromBufferAttribute(z, k),
                  ga.fromBufferAttribute(z, V),
                  go.fromBufferAttribute(z, j),
                  (q.uv1 = sX.getInterpolation(
                    gd,
                    m7,
                    ge,
                    gr,
                    gs,
                    ga,
                    go,
                    new rs()
                  ))),
                R &&
                  (gl.fromBufferAttribute(R, k),
                  gh.fromBufferAttribute(R, V),
                  gc.fromBufferAttribute(R, j),
                  (q.normal = sX.getInterpolation(
                    gd,
                    m7,
                    ge,
                    gr,
                    gl,
                    gh,
                    gc,
                    new rF()
                  )),
                  q.normal.dot(_.direction) > 0 && q.normal.multiplyScalar(-1));
              let I = { a: k, b: V, c: j, normal: new rF(), materialIndex: 0 };
              sX.getNormal(m7, ge, gr, I.normal),
                (q.face = I),
                (q.faceIndex = k);
            }
            return q;
          })(R, q, X, Q, $, V, j, G, I);
        return et ? ((et.faceIndex = B), z && z.push(et), et) : null;
      }
      function Ts(_, I, R, B) {
        let z = _.a,
          k = _.b,
          V = _.c,
          j = I,
          G = I + 1,
          q = I + 2;
        R && ((j = R.getX(I)), (G = R.getX(I + 1)), (q = R.getX(I + 2))),
          (z.x = B.getX(j)),
          (z.y = B.getY(j)),
          (z.z = B.getZ(j)),
          (k.x = B.getX(G)),
          (k.y = B.getY(G)),
          (k.z = B.getZ(G)),
          (V.x = B.getX(q)),
          (V.y = B.getY(q)),
          (V.z = B.getZ(q));
      }
      function K1(_, I, R, B, z, k, V) {
        let j = R.index,
          G = R.attributes.position;
        for (let R = _, q = I + _; R < q; R++)
          if ((Ts(V, 3 * R, j, G), (V.needsUpdate = !0), B(V, R, z, k)))
            return !0;
        return !1;
      }
      var gu = class {
        constructor(_) {
          (this._getNewPrimitive = _), (this._primitives = []);
        }
        getPrimitive() {
          let _ = this._primitives;
          return 0 === _.length ? this._getNewPrimitive() : _.pop();
        }
        releasePrimitive(_) {
          this._primitives.push(_);
        }
      };
      function ka(_, I) {
        return 65535 === I[_ + 15];
      }
      var gf = new rU(),
        gm = new rF(),
        gg = ["x", "y", "z"],
        gy =
          ((eK = []),
          (eJ = new gu(() => new rU())),
          function (..._) {
            (eQ = eJ.getPrimitive()), (eZ = eJ.getPrimitive()), eK.push(eQ, eZ);
            let I = (function i(_, I, R, B, z = null, k = 0, V = 0) {
              function d(_) {
                let I = 2 * _,
                  R = ye,
                  B = yi;
                for (; !ka(I, R); ) (_ += 8), (I = 2 * _);
                return B[_ + 6];
              }
              function f(_) {
                let I = 2 * _,
                  R = ye,
                  B = yi;
                for (; !ka(I, R); ) I = 2 * (_ = B[_ + 6]);
                return B[_ + 6] + R[I + 14];
              }
              let j = 2 * _,
                G = v7,
                q = ye,
                X = yi;
              if (ka(j, q)) {
                let I = X[_ + 6],
                  R = q[j + 14];
                return Es(_, G, eQ), B(I, R, !1, V, k + _, eQ);
              }
              {
                let j = _ + 8,
                  Q = X[_ + 6],
                  $ = j,
                  et = Q,
                  er,
                  es,
                  ea,
                  en;
                if (
                  z &&
                  ((ea = eQ),
                  (en = eZ),
                  Es($, G, ea),
                  Es(et, G, en),
                  (er = z(ea)),
                  (es = z(en)) < er)
                ) {
                  ($ = Q), (et = j);
                  let _ = er;
                  (er = es), (es = _), (ea = en);
                }
                ea || Es($, G, (ea = eQ));
                let eo = R(ea, ka(2 * $, q), er, V + 1, k + $),
                  el;
                if (2 === eo) {
                  let _ = d($),
                    I = f($) - _;
                  el = B(_, I, !0, V + 1, k + $, ea);
                } else el = eo && i($, I, R, B, z, k, V + 1);
                if (el) return !0;
                Es(et, G, (en = eZ));
                let eh = R(en, ka(2 * et, q), es, V + 1, k + et),
                  ec;
                if (2 === eh) {
                  let _ = d(et),
                    I = f(et) - _;
                  ec = B(_, I, !0, V + 1, k + et, en);
                } else ec = eh && i(et, I, R, B, z, k, V + 1);
                return !!ec;
              }
            })(..._);
            eJ.releasePrimitive(eQ),
              eJ.releasePrimitive(eZ),
              eK.pop(),
              eK.pop();
            let R = eK.length;
            return R > 0 && ((eZ = eK[R - 1]), (eQ = eK[R - 2])), I;
          }),
        gx =
          ((e$ = new m8()),
          (e0 = new m8()),
          (e3 = new sa()),
          (e4 = new m9()),
          (e5 = new m9()),
          function s(_, I, R, B, z = null) {
            let k = 2 * _,
              V = v7,
              j = ye,
              G = yi;
            if (
              (null === z &&
                (R.boundingBox || R.computeBoundingBox(),
                e4.set(R.boundingBox.min, R.boundingBox.max, B),
                (z = e4)),
              ka(k, j))
            ) {
              let z = I.index,
                q = I.attributes.position,
                X = R.index,
                Q = R.attributes.position,
                $ = G[_ + 6],
                et = j[k + 14];
              if ((e3.copy(B).invert(), R.boundsTree))
                return (
                  Es(_, V, e5),
                  e5.matrix.copy(e3),
                  (e5.needsUpdate = !0),
                  R.boundsTree.shapecast({
                    intersectsBounds: (_) => e5.intersectsBox(_),
                    intersectsTriangle: (_) => {
                      _.a.applyMatrix4(B),
                        _.b.applyMatrix4(B),
                        _.c.applyMatrix4(B),
                        (_.needsUpdate = !0);
                      for (let I = 3 * $, R = (et + $) * 3; I < R; I += 3)
                        if (
                          (Ts(e0, I, z, q),
                          (e0.needsUpdate = !0),
                          _.intersectsTriangle(e0))
                        )
                          return !0;
                      return !1;
                    },
                  })
                );
              for (let _ = 3 * $, I = et + 3 * $; _ < I; _ += 3) {
                Ts(e$, _, z, q),
                  e$.a.applyMatrix4(e3),
                  e$.b.applyMatrix4(e3),
                  e$.c.applyMatrix4(e3),
                  (e$.needsUpdate = !0);
                for (let _ = 0, I = X.count; _ < I; _ += 3)
                  if (
                    (Ts(e0, _, X, Q),
                    (e0.needsUpdate = !0),
                    e$.intersectsTriangle(e0))
                  )
                    return !0;
              }
            } else {
              let k = _ + 8,
                j = G[_ + 6];
              return (
                Es(k, V, gf),
                !!(
                  (z.intersectsBox(gf) && s(k, I, R, B, z)) ||
                  (Es(j, V, gf), z.intersectsBox(gf) && s(j, I, R, B, z))
                )
              );
            }
          });
      function _0(_, I, R, B) {
        return Es(_, I, gf), R.intersectBox(gf, B);
      }
      var gb,
        gw,
        gS,
        gC,
        gT,
        gP,
        gO,
        gI,
        gR,
        gB,
        gL,
        gz,
        gF,
        gN,
        gk,
        gV,
        gj,
        gG,
        gH,
        gW,
        gq,
        gY,
        gX,
        gQ,
        gZ,
        gK,
        gJ,
        g$,
        g0,
        g3,
        g4,
        g5,
        g6,
        g8,
        g9,
        g7,
        vt,
        vi,
        vr,
        vs,
        va,
        vn,
        vl,
        vh,
        vc,
        vd,
        vf,
        vm,
        vg,
        vy,
        vx,
        vw,
        v_,
        vM,
        vT,
        vP,
        vO,
        vR,
        vB,
        vL,
        vz,
        vF,
        vN,
        vk,
        vV,
        vj,
        vG,
        vH,
        vW,
        vq,
        vY,
        vX,
        vQ,
        vZ,
        vJ,
        v$,
        v0,
        v2,
        v3,
        v4,
        v5,
        v6,
        v8,
        v9,
        v7,
        ye,
        yi,
        yr = [];
      function Ad(_) {
        v9 && yr.push(v9),
          (v9 = _),
          (v7 = new Float32Array(_)),
          (ye = new Uint16Array(_)),
          (yi = new Uint32Array(_));
      }
      function hm() {
        (v9 = null),
          (v7 = null),
          (ye = null),
          (yi = null),
          yr.length && Ad(yr.pop());
      }
      var ys = Symbol("skip tree generation"),
        yn = new rU(),
        yl = new rU(),
        yh = new sa(),
        yc = new m9(),
        yd = new m9(),
        yu = new rF(),
        yp = new rF(),
        yf = new rF(),
        ym = new rF(),
        yg = new rF(),
        yy = new rU(),
        yx = new gu(() => new m8()),
        yw = class {
          static serialize(_, I = {}) {
            if (I.isBufferGeometry)
              return (
                console.warn(
                  "MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."
                ),
                yw.serialize(arguments[0], {
                  cloneBuffers: void 0 === arguments[2] || arguments[2],
                })
              );
            I = { cloneBuffers: !0, ...I };
            let R = _.geometry,
              B = _._roots,
              z = R.getIndex();
            return I.cloneBuffers
              ? { roots: B.map((_) => _.slice()), index: z.array.slice() }
              : { roots: B, index: z.array };
          }
          static deserialize(_, I, R = {}) {
            if ("boolean" == typeof R)
              return (
                console.warn(
                  "MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."
                ),
                yw.deserialize(arguments[0], arguments[1], {
                  setIndex: void 0 === arguments[2] || arguments[2],
                })
              );
            R = { setIndex: !0, ...R };
            let { index: B, roots: z } = _,
              k = new yw(I, { ...R, [ys]: !0 });
            if (((k._roots = z), R.setIndex)) {
              let R = I.getIndex();
              if (null === R) {
                let R = new s0(_.index, 1, !1);
                I.setIndex(R);
              } else R.array !== B && (R.array.set(B), (R.needsUpdate = !0));
            }
            return k;
          }
          constructor(_, I = {}) {
            if (_.isBufferGeometry) {
              if (_.index && _.index.isInterleavedBufferAttribute)
                throw Error(
                  "MeshBVH: InterleavedBufferAttribute is not supported for the index attribute."
                );
            } else throw Error("MeshBVH: Only BufferGeometries are supported.");
            if (
              (I = Object.assign(
                {
                  strategy: 0,
                  maxDepth: 40,
                  maxLeafTris: 10,
                  verbose: !0,
                  useSharedArrayBuffer: !1,
                  setBoundingBox: !0,
                  onProgress: null,
                  [ys]: !1,
                },
                I
              )).useSharedArrayBuffer &&
              typeof SharedArrayBuffer > "u"
            )
              throw Error("MeshBVH: SharedArrayBuffer is not available.");
            (this._roots = null),
              I[ys] ||
                ((this._roots = (function (_, I) {
                  let R = (function (_, I) {
                      function e(_) {
                        X && X(_ / Q);
                      }
                      function r(I, R, X, Q = null, et = 0) {
                        if (
                          (!$ &&
                            et >= V &&
                            (($ = !0),
                            j &&
                              (console.warn(
                                `MeshBVH: Max depth of ${V} reached when generating BVH. Consider increasing maxDepth.`
                              ),
                              console.warn(_))),
                          X <= G || et >= V)
                        )
                          return e(R + X), (I.offset = R), (I.count = X), I;
                        let er = (function (_, I, R, B, z, k) {
                          let V = -1,
                            j = 0;
                          if (0 === k)
                            -1 !== (V = j1(I)) && (j = (I[V] + I[V + 3]) / 2);
                          else if (1 === k)
                            -1 !== (V = j1(_)) &&
                              (j = (function (_, I, R, B) {
                                let z = 0;
                                for (let k = I, V = I + R; k < V; k++)
                                  z += _[6 * k + 2 * B];
                                return z / R;
                              })(R, B, z, V));
                          else if (2 === k) {
                            let k = dd(_),
                              G = 1.25 * z,
                              q = 6 * B,
                              X = (B + z) * 6;
                            for (let _ = 0; _ < 3; _++) {
                              let B = I[_],
                                Q = (I[_ + 3] - B) / 32;
                              if (z < 8) {
                                let I = [...m1];
                                I.length = z;
                                let B = 0;
                                for (let z = q; z < X; z += 6, B++) {
                                  let k = I[B];
                                  (k.candidate = R[z + 2 * _]), (k.count = 0);
                                  let {
                                    bounds: V,
                                    leftCacheBounds: j,
                                    rightCacheBounds: G,
                                  } = k;
                                  for (let _ = 0; _ < 3; _++)
                                    (G[_] = 1 / 0),
                                      (G[_ + 3] = -1 / 0),
                                      (j[_] = 1 / 0),
                                      (j[_ + 3] = -1 / 0),
                                      (V[_] = 1 / 0),
                                      (V[_ + 3] = -1 / 0);
                                  cm(z, R, V);
                                }
                                I.sort(I9);
                                let Q = z;
                                for (let _ = 0; _ < Q; _++) {
                                  let R = I[_];
                                  for (
                                    ;
                                    _ + 1 < Q &&
                                    I[_ + 1].candidate === R.candidate;

                                  )
                                    I.splice(_ + 1, 1), Q--;
                                }
                                for (let B = q; B < X; B += 6) {
                                  let z = R[B + 2 * _];
                                  for (let _ = 0; _ < Q; _++) {
                                    let k = I[_];
                                    z >= k.candidate
                                      ? cm(B, R, k.rightCacheBounds)
                                      : (cm(B, R, k.leftCacheBounds),
                                        k.count++);
                                  }
                                }
                                for (let R = 0; R < Q; R++) {
                                  let B = I[R],
                                    q = B.count,
                                    X = z - B.count,
                                    Q = B.leftCacheBounds,
                                    $ = B.rightCacheBounds,
                                    et = 0;
                                  0 !== q && (et = dd(Q) / k);
                                  let er = 0;
                                  0 !== X && (er = dd($) / k);
                                  let es = 1 + 1.25 * (et * q + er * X);
                                  es < G &&
                                    ((V = _), (G = es), (j = B.candidate));
                                }
                              } else {
                                for (let _ = 0; _ < 32; _++) {
                                  let I = m1[_];
                                  (I.count = 0), (I.candidate = B + Q + _ * Q);
                                  let R = I.bounds;
                                  for (let _ = 0; _ < 3; _++)
                                    (R[_] = 1 / 0), (R[_ + 3] = -1 / 0);
                                }
                                for (let I = q; I < X; I += 6) {
                                  let z = ~~((R[I + 2 * _] - B) / Q);
                                  z >= 32 && (z = 31);
                                  let k = m1[z];
                                  k.count++, cm(I, R, k.bounds);
                                }
                                let I = m1[31];
                                !(function (_, I) {
                                  I.set(_);
                                })(I.bounds, I.rightCacheBounds);
                                for (let _ = 30; _ >= 0; _--) {
                                  let I = m1[_],
                                    R = m1[_ + 1];
                                  W1(
                                    I.bounds,
                                    R.rightCacheBounds,
                                    I.rightCacheBounds
                                  );
                                }
                                let $ = 0;
                                for (let I = 0; I < 31; I++) {
                                  let R = m1[I],
                                    B = R.count,
                                    q = R.bounds,
                                    X = m1[I + 1].rightCacheBounds;
                                  0 !== B &&
                                    (0 === $
                                      ? (function (_, I) {
                                          I.set(_);
                                        })(q, m2)
                                      : W1(q, m2, m2));
                                  let Q = 0,
                                    et = 0;
                                  0 !== ($ += B) && (Q = dd(m2) / k);
                                  let er = z - $;
                                  0 !== er && (et = dd(X) / k);
                                  let es = 1 + 1.25 * (Q * $ + et * er);
                                  es < G &&
                                    ((V = _), (G = es), (j = R.candidate));
                                }
                              }
                            }
                          } else
                            console.warn(
                              `MeshBVH: Invalid build strategy value ${k} used.`
                            );
                          return { axis: V, pos: j };
                        })(I.boundingData, Q, z, R, X, q);
                        if (-1 === er.axis)
                          return e(R + X), (I.offset = R), (I.count = X), I;
                        let es = (function (_, I, R, B, z) {
                          let k = R,
                            V = R + B - 1,
                            j = z.pos,
                            G = 2 * z.axis;
                          for (;;) {
                            for (; k <= V && I[6 * k + G] < j; ) k++;
                            for (; k <= V && I[6 * V + G] >= j; ) V--;
                            if (!(k < V)) return k;
                            for (let R = 0; R < 3; R++) {
                              let B = _[3 * k + R];
                              (_[3 * k + R] = _[3 * V + R]), (_[3 * V + R] = B);
                              let z = I[6 * k + 2 * R + 0];
                              (I[6 * k + 2 * R + 0] = I[6 * V + 2 * R + 0]),
                                (I[6 * V + 2 * R + 0] = z);
                              let j = I[6 * k + 2 * R + 1];
                              (I[6 * k + 2 * R + 1] = I[6 * V + 2 * R + 1]),
                                (I[6 * V + 2 * R + 1] = j);
                            }
                            k++, V--;
                          }
                        })(k, z, R, X, er);
                        if (es === R || es === R + X)
                          e(R + X), (I.offset = R), (I.count = X);
                        else {
                          I.splitAxis = er.axis;
                          let _ = new m0(),
                            k = es - R;
                          (I.left = _),
                            (_.boundingData = new Float32Array(6)),
                            Y1(z, R, k, _.boundingData, B),
                            r(_, R, k, B, et + 1);
                          let V = new m0(),
                            j = X - k;
                          (I.right = V),
                            (V.boundingData = new Float32Array(6)),
                            Y1(z, es, j, V.boundingData, B),
                            r(V, es, j, B, et + 1);
                        }
                        return I;
                      }
                      !(function (_, I) {
                        if (!_.index) {
                          let R = _.attributes.position.count,
                            B = I.useSharedArrayBuffer
                              ? SharedArrayBuffer
                              : ArrayBuffer,
                            z;
                          (z =
                            R > 65535
                              ? new Uint32Array(new B(4 * R))
                              : new Uint16Array(new B(2 * R))),
                            _.setIndex(new s0(z, 1));
                          for (let _ = 0; _ < R; _++) z[_] = _;
                        }
                      })(_, I);
                      let R = new Float32Array(6),
                        B = new Float32Array(6),
                        z = (function (_, I) {
                          let R = _.attributes.position,
                            B = _.index.array,
                            z = B.length / 3,
                            k = new Float32Array(6 * z),
                            V = R.normalized,
                            j = R.array,
                            G = R.offset || 0,
                            q = 3;
                          R.isInterleavedBufferAttribute && (q = R.data.stride);
                          let X = ["getX", "getY", "getZ"];
                          for (let _ = 0; _ < z; _++) {
                            let z = 3 * _,
                              Q = 6 * _,
                              $,
                              et,
                              er;
                            V
                              ? (($ = B[z + 0]),
                                (et = B[z + 1]),
                                (er = B[z + 2]))
                              : (($ = B[z + 0] * q + G),
                                (et = B[z + 1] * q + G),
                                (er = B[z + 2] * q + G));
                            for (let _ = 0; _ < 3; _++) {
                              let B, z, G;
                              V
                                ? ((B = R[X[_]]($)),
                                  (z = R[X[_]](et)),
                                  (G = R[X[_]](er)))
                                : ((B = j[$ + _]),
                                  (z = j[et + _]),
                                  (G = j[er + _]));
                              let q = B;
                              z < q && (q = z), G < q && (q = G);
                              let es = B;
                              z > es && (es = z), G > es && (es = G);
                              let ea = (es - q) / 2,
                                en = 2 * _;
                              (k[Q + en + 0] = q + ea),
                                (k[Q + en + 1] =
                                  ea +
                                  (Math.abs(q) + ea) * 5960464477539063e-23),
                                q < I[_] && (I[_] = q),
                                es > I[_ + 3] && (I[_ + 3] = es);
                            }
                          }
                          return k;
                        })(_, R),
                        k = _.index.array,
                        V = I.maxDepth,
                        j = I.verbose,
                        G = I.maxLeafTris,
                        q = I.strategy,
                        X = I.onProgress,
                        Q = _.index.count / 3,
                        $ = !1,
                        et = [],
                        er = (function (_) {
                          if (!_.groups || !_.groups.length)
                            return [{ offset: 0, count: _.index.count / 3 }];
                          let I = [],
                            R = new Set();
                          for (let I of _.groups)
                            R.add(I.start), R.add(I.start + I.count);
                          let B = Array.from(R.values()).sort((_, I) => _ - I);
                          for (let _ = 0; _ < B.length - 1; _++) {
                            let R = B[_],
                              z = B[_ + 1];
                            I.push({ offset: R / 3, count: (z - R) / 3 });
                          }
                          return I;
                        })(_);
                      if (1 === er.length) {
                        let _ = er[0],
                          I = new m0();
                        (I.boundingData = R),
                          (function (_, I, R, B) {
                            let z = 1 / 0,
                              k = 1 / 0,
                              V = 1 / 0,
                              j = -1 / 0,
                              G = -1 / 0,
                              q = -1 / 0;
                            for (
                              let B = 6 * I, X = (I + R) * 6;
                              B < X;
                              B += 6
                            ) {
                              let I = _[B + 0];
                              I < z && (z = I), I > j && (j = I);
                              let R = _[B + 2];
                              R < k && (k = R), R > G && (G = R);
                              let X = _[B + 4];
                              X < V && (V = X), X > q && (q = X);
                            }
                            (B[0] = z),
                              (B[1] = k),
                              (B[2] = V),
                              (B[3] = j),
                              (B[4] = G),
                              (B[5] = q);
                          })(z, _.offset, _.count, B),
                          r(I, _.offset, _.count, B),
                          et.push(I);
                      } else
                        for (let _ of er) {
                          let I = new m0();
                          (I.boundingData = new Float32Array(6)),
                            Y1(z, _.offset, _.count, I.boundingData, B),
                            r(I, _.offset, _.count, B),
                            et.push(I);
                        }
                      return et;
                    })(_, I),
                    B,
                    z,
                    k,
                    V = [],
                    j = I.useSharedArrayBuffer
                      ? SharedArrayBuffer
                      : ArrayBuffer;
                  for (let _ = 0; _ < R.length; _++) {
                    let I = R[_],
                      G = (function l(_) {
                        return _.count ? 1 : 1 + l(_.left) + l(_.right);
                      })(I),
                      q = new j(32 * G);
                    (B = new Float32Array(q)),
                      (z = new Uint32Array(q)),
                      (k = new Uint16Array(q)),
                      (function u(_, I) {
                        let R = _ / 4,
                          V = _ / 2,
                          j = !!I.count,
                          G = I.boundingData;
                        for (let _ = 0; _ < 6; _++) B[R + _] = G[_];
                        if (j) {
                          let B = I.offset,
                            j = I.count;
                          return (
                            (z[R + 6] = B),
                            (k[V + 14] = j),
                            (k[V + 15] = 65535),
                            _ + 32
                          );
                        }
                        {
                          let B = I.left,
                            k = I.right,
                            V = I.splitAxis,
                            j;
                          if ((j = u(_ + 32, B)) / 4 > 4294967296)
                            throw Error(
                              "MeshBVH: Cannot store child pointer greater than 32 bits."
                            );
                          return (
                            (z[R + 6] = j / 4), (j = u(j, k)), (z[R + 7] = V), j
                          );
                        }
                      })(0, I),
                      V.push(q);
                  }
                  return V;
                })(_, I)),
                !_.boundingBox &&
                  I.setBoundingBox &&
                  (_.boundingBox = this.getBoundingBox(new rU()))),
              (this.geometry = _);
          }
          refit(_ = null) {
            _ && Array.isArray(_) && (_ = new Set(_));
            let I = this.geometry,
              R = I.index.array,
              B = I.attributes.position,
              z,
              k,
              V,
              j,
              G = 0,
              q = this._roots;
            for (let I = 0, X = q.length; I < X; I++)
              (z = q[I]),
                (k = new Uint32Array(z)),
                (V = new Uint16Array(z)),
                (j = new Float32Array(z)),
                (function h(I, z, G = !1) {
                  let q = 2 * I;
                  if (65535 === V[q + 15]) {
                    let _ = k[I + 6],
                      z = V[q + 14],
                      G = 1 / 0,
                      X = 1 / 0,
                      Q = 1 / 0,
                      $ = -1 / 0,
                      et = -1 / 0,
                      er = -1 / 0;
                    for (let I = 3 * _, k = 3 * (_ + z); I < k; I++) {
                      let _ = R[I],
                        z = B.getX(_),
                        k = B.getY(_),
                        V = B.getZ(_);
                      z < G && (G = z),
                        z > $ && ($ = z),
                        k < X && (X = k),
                        k > et && (et = k),
                        V < Q && (Q = V),
                        V > er && (er = V);
                    }
                    return (
                      (j[I + 0] !== G ||
                        j[I + 1] !== X ||
                        j[I + 2] !== Q ||
                        j[I + 3] !== $ ||
                        j[I + 4] !== et ||
                        j[I + 5] !== er) &&
                      ((j[I + 0] = G),
                      (j[I + 1] = X),
                      (j[I + 2] = Q),
                      (j[I + 3] = $),
                      (j[I + 4] = et),
                      (j[I + 5] = er),
                      !0)
                    );
                  }
                  {
                    let R = I + 8,
                      B = k[I + 6],
                      V = R + z,
                      q = B + z,
                      X = G,
                      Q = !1,
                      $ = !1;
                    _
                      ? X || ((Q = _.has(V)), ($ = _.has(q)), (X = !Q && !$))
                      : ((Q = !0), ($ = !0));
                    let et = X || Q,
                      er = X || $,
                      es = !1;
                    et && (es = h(R, z, X));
                    let ea = !1;
                    er && (ea = h(B, z, X));
                    let en = es || ea;
                    if (en)
                      for (let _ = 0; _ < 3; _++) {
                        let z = R + _,
                          k = B + _,
                          V = j[z],
                          G = j[z + 3],
                          q = j[k],
                          X = j[k + 3];
                        (j[I + _] = V < q ? V : q),
                          (j[I + _ + 3] = G > X ? G : X);
                      }
                    return en;
                  }
                })(0, G),
                (G += z.byteLength);
          }
          traverse(_, I = 0) {
            let R = this._roots[I],
              B = new Uint32Array(R),
              z = new Uint16Array(R);
            !(function o(I, k = 0) {
              let V = 2 * I,
                j = 65535 === z[V + 15];
              if (j) {
                let G = B[I + 6],
                  q = z[V + 14];
                _(k, j, new Float32Array(R, 4 * I, 6), G, q);
              } else {
                let z = I + 8,
                  V = B[I + 6],
                  G = B[I + 7];
                _(k, j, new Float32Array(R, 4 * I, 6), G) ||
                  (o(z, k + 1), o(V, k + 1));
              }
            })(0);
          }
          raycast(_, I = 0) {
            let R = this._roots,
              B = this.geometry,
              z = [],
              k = I.isMaterial,
              V = Array.isArray(I),
              j = B.groups,
              G = k ? I.side : I;
            for (let k = 0, q = R.length; k < q; k++) {
              let q = V ? I[j[k].materialIndex].side : G,
                X = z.length;
              if (
                (Ad(R[k]),
                (function w0(_, I, R, B, z) {
                  let k = 2 * _,
                    V = v7,
                    j = ye,
                    G = yi;
                  if (ka(k, j))
                    !(function (_, I, R, B, z, k) {
                      for (let V = B, j = B + z; V < j; V++) Q1(_, I, R, V, k);
                    })(I, R, B, G[_ + 6], j[k + 14], z);
                  else {
                    let k = _ + 8;
                    _0(k, V, B, gm) && w0(k, I, R, B, z);
                    let j = G[_ + 6];
                    _0(j, V, B, gm) && w0(j, I, R, B, z);
                  }
                })(0, B, q, _, z),
                hm(),
                V)
              ) {
                let _ = j[k].materialIndex;
                for (let I = X, R = z.length; I < R; I++)
                  z[I].face.materialIndex = _;
              }
            }
            return z;
          }
          raycastFirst(_, I = 0) {
            let R = this._roots,
              B = this.geometry,
              z = I.isMaterial,
              k = Array.isArray(I),
              V = null,
              j = B.groups,
              G = z ? I.side : I;
            for (let z = 0, q = R.length; z < q; z++) {
              let q = k ? I[j[z].materialIndex].side : G;
              Ad(R[z]);
              let X = (function A0(_, I, R, B) {
                let z = 2 * _,
                  k = v7,
                  V = ye,
                  j = yi;
                if (ka(z, V))
                  return (function (_, I, R, B, z) {
                    let k = 1 / 0,
                      V = null;
                    for (let j = B, G = B + z; j < G; j++) {
                      let B = Q1(_, I, R, j);
                      B && B.distance < k && ((V = B), (k = B.distance));
                    }
                    return V;
                  })(I, R, B, j[_ + 6], V[z + 14]);
                {
                  let z = j[_ + 7],
                    V = gg[z],
                    G = B.direction[V] >= 0,
                    q,
                    X;
                  G
                    ? ((q = _ + 8), (X = j[_ + 6]))
                    : ((q = j[_ + 6]), (X = _ + 8));
                  let Q = _0(q, k, B, gm) ? A0(q, I, R, B) : null;
                  if (Q) {
                    let _ = Q.point[V];
                    if (G ? _ <= k[X + z] : _ >= k[X + z + 3]) return Q;
                  }
                  let $ = _0(X, k, B, gm) ? A0(X, I, R, B) : null;
                  return Q && $
                    ? Q.distance <= $.distance
                      ? Q
                      : $
                    : Q || $ || null;
                }
              })(0, B, q, _);
              hm(),
                null != X &&
                  (null == V || X.distance < V.distance) &&
                  ((V = X), k && (X.face.materialIndex = j[z].materialIndex));
            }
            return V;
          }
          intersectsGeometry(_, I) {
            let R = this.geometry,
              B = !1;
            for (let z of this._roots)
              if ((Ad(z), (B = gx(0, R, _, I)), hm(), B)) break;
            return B;
          }
          shapecast(_, I, R) {
            let B = this.geometry;
            if (_ instanceof Function) {
              if (I) {
                let _ = I;
                I = (I, R, B, z) => {
                  let k = 3 * R;
                  return _(I, k, k + 1, k + 2, B, z);
                };
              }
              (_ = {
                boundsTraverseOrder: R,
                intersectsBounds: _,
                intersectsTriangle: I,
                intersectsRange: null,
              }),
                console.warn(
                  "MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature."
                );
            }
            let z = yx.getPrimitive(),
              {
                boundsTraverseOrder: k,
                intersectsBounds: V,
                intersectsRange: j,
                intersectsTriangle: G,
              } = _;
            if (j && G) {
              let _ = j;
              j = (I, R, k, V, j) =>
                !!_(I, R, k, V, j) || K1(I, R, B, G, k, V, z);
            } else
              j ||
                (j = G
                  ? (_, I, R, k) => K1(_, I, B, G, R, k, z)
                  : (_, I, R) => R);
            let q = !1,
              X = 0;
            for (let _ of this._roots) {
              if ((Ad(_), (q = gy(0, B, V, j, k, X)), hm(), q)) break;
              X += _.byteLength;
            }
            return yx.releasePrimitive(z), q;
          }
          bvhcast(_, I, R) {
            let { intersectsRanges: B, intersectsTriangles: z } = R,
              k = this.geometry.index,
              V = this.geometry.attributes.position,
              j = _.geometry.index,
              G = _.geometry.attributes.position;
            yh.copy(I).invert();
            let q = yx.getPrimitive(),
              X = yx.getPrimitive();
            if (z) {
              let f = function (_, R, B, Q, $, et, er, es) {
                for (let ea = B, en = B + Q; ea < en; ea++) {
                  Ts(X, 3 * ea, j, G),
                    X.a.applyMatrix4(I),
                    X.b.applyMatrix4(I),
                    X.c.applyMatrix4(I),
                    (X.needsUpdate = !0);
                  for (let I = _, B = _ + R; I < B; I++)
                    if (
                      (Ts(q, 3 * I, k, V),
                      (q.needsUpdate = !0),
                      z(q, X, I, ea, $, et, er, es))
                    )
                      return !0;
                }
                return !1;
              };
              if (B) {
                let _ = B;
                B = function (I, R, B, z, k, V, j, G) {
                  return (
                    !!_(I, R, B, z, k, V, j, G) || f(I, R, B, z, k, V, j, G)
                  );
                };
              } else B = f;
            }
            _.getBoundingBox(yl), yl.applyMatrix4(I);
            let Q = this.shapecast({
              intersectsBounds: (_) => yl.intersectsBox(_),
              intersectsRange: (I, R, z, k, V, j) => (
                yn.copy(j),
                yn.applyMatrix4(yh),
                _.shapecast({
                  intersectsBounds: (_) => yn.intersectsBox(_),
                  intersectsRange: (_, z, j, G, q) => B(I, R, _, z, k, V, G, q),
                })
              ),
            });
            return yx.releasePrimitive(q), yx.releasePrimitive(X), Q;
          }
          intersectsBox(_, I) {
            return (
              yc.set(_.min, _.max, I),
              (yc.needsUpdate = !0),
              this.shapecast({
                intersectsBounds: (_) => yc.intersectsBox(_),
                intersectsTriangle: (_) => yc.intersectsTriangle(_),
              })
            );
          }
          intersectsSphere(_) {
            return this.shapecast({
              intersectsBounds: (I) => _.intersectsBox(I),
              intersectsTriangle: (I) => I.intersectsSphere(_),
            });
          }
          closestPointToGeometry(_, I, R = {}, B = {}, z = 0, k = 1 / 0) {
            _.boundingBox || _.computeBoundingBox(),
              yc.set(_.boundingBox.min, _.boundingBox.max, I),
              (yc.needsUpdate = !0);
            let V = this.geometry,
              j = V.attributes.position,
              G = V.index,
              q = _.attributes.position,
              X = _.index,
              Q = yx.getPrimitive(),
              $ = yx.getPrimitive(),
              et = null,
              er = null;
            B && ((et = ym), (er = yg));
            let es = 1 / 0,
              ea = null,
              en = null;
            return (
              yh.copy(I).invert(),
              yd.matrix.copy(yh),
              this.shapecast({
                boundsTraverseOrder: (_) => yc.distanceToBox(_),
                intersectsBounds: (_, I, R) =>
                  R < es &&
                  R < k &&
                  (I &&
                    (yd.min.copy(_.min),
                    yd.max.copy(_.max),
                    (yd.needsUpdate = !0)),
                  !0),
                intersectsRange: (R, B) => {
                  if (_.boundsTree)
                    return _.boundsTree.shapecast({
                      boundsTraverseOrder: (_) => yd.distanceToBox(_),
                      intersectsBounds: (_, I, R) => R < es && R < k,
                      intersectsRange: (_, k) => {
                        for (let V = 3 * _, eo = (_ + k) * 3; V < eo; V += 3) {
                          Ts($, V, X, q),
                            $.a.applyMatrix4(I),
                            $.b.applyMatrix4(I),
                            $.c.applyMatrix4(I),
                            ($.needsUpdate = !0);
                          for (let _ = 3 * R, I = (R + B) * 3; _ < I; _ += 3) {
                            Ts(Q, _, G, j), (Q.needsUpdate = !0);
                            let I = Q.distanceToTriangle($, yp, et);
                            if (
                              (I < es &&
                                (yf.copy(yp),
                                er && er.copy(et),
                                (es = I),
                                (ea = _ / 3),
                                (en = V / 3)),
                              I < z)
                            )
                              return !0;
                          }
                        }
                      },
                    });
                  {
                    let _ = X ? X.count : q.count;
                    for (let k = 0; k < _; k += 3) {
                      Ts($, k, X, q),
                        $.a.applyMatrix4(I),
                        $.b.applyMatrix4(I),
                        $.c.applyMatrix4(I),
                        ($.needsUpdate = !0);
                      for (let _ = 3 * R, I = (R + B) * 3; _ < I; _ += 3) {
                        Ts(Q, _, G, j), (Q.needsUpdate = !0);
                        let I = Q.distanceToTriangle($, yp, et);
                        if (
                          (I < es &&
                            (yf.copy(yp),
                            er && er.copy(et),
                            (es = I),
                            (ea = _ / 3),
                            (en = k / 3)),
                          I < z)
                        )
                          return !0;
                      }
                    }
                  }
                },
              }),
              yx.releasePrimitive(Q),
              yx.releasePrimitive($),
              es === 1 / 0
                ? null
                : (R.point ? R.point.copy(yf) : (R.point = yf.clone()),
                  (R.distance = es),
                  (R.faceIndex = ea),
                  B &&
                    (B.point ? B.point.copy(er) : (B.point = er.clone()),
                    B.point.applyMatrix4(yh),
                    yf.applyMatrix4(yh),
                    (B.distance = yf.sub(B.point).length()),
                    (B.faceIndex = en)),
                  R)
            );
          }
          closestPointToPoint(_, I = {}, R = 0, B = 1 / 0) {
            let z = R * R,
              k = B * B,
              V = 1 / 0,
              j = null;
            if (
              (this.shapecast({
                boundsTraverseOrder: (I) => (
                  yu.copy(_).clamp(I.min, I.max), yu.distanceToSquared(_)
                ),
                intersectsBounds: (_, I, R) => R < V && R < k,
                intersectsTriangle: (I, R) => {
                  I.closestPointToPoint(_, yu);
                  let B = _.distanceToSquared(yu);
                  return B < V && (yp.copy(yu), (V = B), (j = R)), B < z;
                },
              }),
              V === 1 / 0)
            )
              return null;
            let G = Math.sqrt(V);
            return (
              I.point ? I.point.copy(yp) : (I.point = yp.clone()),
              (I.distance = G),
              (I.faceIndex = j),
              I
            );
          }
          getBoundingBox(_) {
            return (
              _.makeEmpty(),
              this._roots.forEach((I) => {
                Es(0, new Float32Array(I), yy), _.union(yy);
              }),
              _
            );
          }
        },
        y_ = pi(iz()),
        yS = 0.5 * (Math.sqrt(3) - 1),
        yA = (3 - Math.sqrt(3)) / 6,
        yM = 1 / 3,
        yT = 1 / 6,
        mm = (_) => 0 | Math.floor(_),
        yP = new Float64Array([
          1, 1, -1, 1, 1, -1, -1, -1, 1, 0, -1, 0, 1, 0, -1, 0, 0, 1, 0, -1, 0,
          1, 0, -1,
        ]),
        yD = new Float64Array([
          1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1,
          -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1,
        ]);
      function T0(_ = Math.random) {
        let I = OO(_),
          R = new Float64Array(I).map((_) => yP[(_ % 12) * 2]),
          B = new Float64Array(I).map((_) => yP[(_ % 12) * 2 + 1]);
        return function (_, z) {
          let k = 0,
            V = 0,
            j = 0,
            G = (_ + z) * yS,
            q = mm(_ + G),
            X = mm(z + G),
            Q = (q + X) * yA,
            $ = _ - (q - Q),
            et = z - (X - Q),
            er,
            es;
          $ > et ? ((er = 1), (es = 0)) : ((er = 0), (es = 1));
          let ea = $ - er + yA,
            en = et - es + yA,
            eo = $ - 1 + 2 * yA,
            el = et - 1 + 2 * yA,
            eh = 255 & q,
            ec = 255 & X,
            ed = 0.5 - $ * $ - et * et;
          if (ed >= 0) {
            let _ = eh + I[ec],
              z = R[_],
              V = B[_];
            (ed *= ed), (k = ed * ed * (z * $ + V * et));
          }
          let ep = 0.5 - ea * ea - en * en;
          if (ep >= 0) {
            let _ = eh + er + I[ec + es],
              z = R[_],
              k = B[_];
            (ep *= ep), (V = ep * ep * (z * ea + k * en));
          }
          let ef = 0.5 - eo * eo - el * el;
          if (ef >= 0) {
            let _ = eh + 1 + I[ec + 1],
              z = R[_],
              k = B[_];
            (ef *= ef), (j = ef * ef * (z * eo + k * el));
          }
          return 70 * (k + V + j);
        };
      }
      function OO(_) {
        let I = new Uint8Array(512);
        for (let _ = 0; _ < 256; _++) I[_] = _;
        for (let R = 0; R < 255; R++) {
          let B = R + ~~(_() * (256 - R)),
            z = I[R];
          (I[R] = I[B]), (I[B] = z);
        }
        for (let _ = 256; _ < 512; _++) I[_] = I[_ - 256];
        return I;
      }
      var yO,
        yR = new sX(),
        yB = class {
          constructor(_) {
            this.weightAttribute = null;
            let I = _.geometry;
            if (!I.isBufferGeometry || 3 !== I.attributes.position.itemSize)
              throw Error(
                "THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh."
              );
            I.index && (I = I.toNonIndexed()),
              (this.geometry = I),
              (this.randomFunction = Math.random),
              (this.positionAttribute = this.geometry.getAttribute("position")),
              (this.distribution = null);
          }
          build() {
            let _ = this.positionAttribute,
              I = new Float32Array(_.count / 3);
            for (let R = 0; R < _.count; R += 3) {
              let B = 1;
              yR.a.fromBufferAttribute(_, R),
                yR.b.fromBufferAttribute(_, R + 1),
                yR.c.fromBufferAttribute(_, R + 2),
                (B *= yR.getArea()),
                (I[R / 3] = B);
            }
            this.distribution = new Float32Array(_.count / 3);
            let R = 0;
            for (let _ = 0; _ < I.length; _++)
              (R += I[_]), (this.distribution[_] = R);
            return this;
          }
          setRandomGenerator(_) {
            return (this.randomFunction = _), this;
          }
          sample(_, I) {
            if (this.distribution) {
              let R = this.distribution[this.distribution.length - 1],
                B = this.binarySearch(this.randomFunction() * R);
              return this.sampleFace(B, _, I);
            }
          }
          binarySearch(_) {
            if (!this.distribution) return 0;
            let I = this.distribution,
              R = 0,
              B = I.length - 1,
              z = -1;
            for (; R <= B; ) {
              let k = Math.ceil((R + B) / 2);
              if (0 === k || (I[k - 1] <= _ && I[k] > _)) {
                z = k;
                break;
              }
              _ < I[k] ? (B = k - 1) : (R = k + 1);
            }
            return z;
          }
          sampleFace(_, I, R) {
            let B = this.randomFunction(),
              z = this.randomFunction();
            return (
              B + z > 1 && ((B = 1 - B), (z = 1 - z)),
              yR.a.fromBufferAttribute(this.positionAttribute, 3 * _),
              yR.b.fromBufferAttribute(this.positionAttribute, 3 * _ + 1),
              yR.c.fromBufferAttribute(this.positionAttribute, 3 * _ + 2),
              I.set(0, 0, 0)
                .addScaledVector(yR.a, B)
                .addScaledVector(yR.b, z)
                .addScaledVector(yR.c, 1 - (B + z)),
              yR.getNormal(R),
              this
            );
          }
        },
        yz = pi(iN()),
        yF = new sa(),
        yN = new sa(),
        yk = new sa();
      (yO || (yO = {})).is = function (_) {
        return _ && _.__isSPEObject;
      };
      var Td = (_) =>
          class extends _ {
            constructor() {
              super(...arguments),
                (this.previousModelViewMatrix = new sa()),
                (this.copyPreviousMatrix = !0),
                (this.hiddenMatrix = new sa()),
                (this.matrixWorldRigid = new sa()),
                (this.shearScale = new sa()),
                (this.shearScaleInv = new sa());
            }
            get __isSPEObject() {
              return !0;
            }
            isDescendantOf(_) {
              _ instanceof sL && (_ = _.uuid);
              let I = this;
              for (; I.parent; ) {
                if (I.parent.uuid === _) return !0;
                I = I.parent;
              }
              return !1;
            }
            updateMatrixWorld(_) {
              for (let I of (this.matrixAutoUpdate && this.updateMatrix(),
              (this.matrixWorldNeedsUpdate || _) &&
                (null === this.parent
                  ? this.matrixWorld.multiplyMatrices(
                      this.hiddenMatrix,
                      this.matrix
                    )
                  : (this.matrixWorld.multiplyMatrices(
                      this.parent.matrixWorld,
                      this.hiddenMatrix
                    ),
                    this.matrixWorld.multiplyMatrices(
                      this.matrixWorld,
                      this.matrix
                    )),
                (this.matrixWorldNeedsUpdate = !1),
                (_ = !0)),
              this.children))
                I.updateMatrixWorld(_);
            }
            updateWorldMatrix(_, I) {
              let R = this.parent;
              if (
                (_ && null !== R && R.updateWorldMatrix(!0, !1),
                this.matrixAutoUpdate && this.updateMatrix(),
                null === this.parent
                  ? this.matrixWorld.multiplyMatrices(
                      this.hiddenMatrix,
                      this.matrix
                    )
                  : (this.matrixWorld.multiplyMatrices(
                      this.parent.matrixWorld,
                      this.hiddenMatrix
                    ),
                    this.matrixWorld.multiplyMatrices(
                      this.matrixWorld,
                      this.matrix
                    )),
                I)
              )
                for (let _ of this.children) _.updateWorldMatrix(!1, !0);
            }
            traverseChildren(_, I = 0) {
              for (let R of this.children)
                yO.is(R) && R.traverseObject(_, I + 1);
            }
            traverseObject(_, I = 0) {
              if (!0 !== _(this, I))
                for (let R of this.children)
                  yO.is(R) && R.traverseObject(_, I + 1);
            }
            updateMatrixWorldSVD() {
              let _ = this.matrixWorld.elements,
                I = [
                  [_[0], _[4], _[8]],
                  [_[1], _[5], _[9]],
                  [_[2], _[6], _[10]],
                ],
                { u: R, v: B, q: z } = (0, yz.SVD)(I),
                k = yF.set(
                  R[0][0],
                  R[0][1],
                  R[0][2],
                  0,
                  R[1][0],
                  R[1][1],
                  R[1][2],
                  0,
                  R[2][0],
                  R[2][1],
                  R[2][2],
                  0,
                  0,
                  0,
                  0,
                  1
                ),
                V = yN.set(
                  B[0][0],
                  B[0][1],
                  B[0][2],
                  0,
                  B[1][0],
                  B[1][1],
                  B[1][2],
                  0,
                  B[2][0],
                  B[2][1],
                  B[2][2],
                  0,
                  0,
                  0,
                  0,
                  1
                ),
                j = yk.copy(V).transpose();
              this.shearScale
                .makeScale(z[0], z[1], z[2])
                .multiply(j)
                .premultiply(V),
                this.shearScaleInv.copy(this.shearScale).invert(),
                this.matrixWorldRigid
                  .multiplyMatrices(k, j)
                  .copyPosition(this.matrixWorld),
                z.every((_) => 0.01 > Math.abs(z[0] - _))
                  ? (this.hasNonUniformScale = !1)
                  : (this.hasNonUniformScale = !0);
            }
            attach(_, I) {
              this.updateWorldMatrix(!0, !1);
              let R = new sa().copy(this.matrixWorld).invert();
              return (
                null !== _.parent &&
                  (_.parent.updateWorldMatrix(!0, !1),
                  R.multiply(_.parent.matrixWorld)),
                "hiddenMatrix" in _ && _.hiddenMatrix instanceof sa
                  ? _.hiddenMatrix.premultiply(R)
                  : _.applyMatrix4(R),
                _.updateWorldMatrix(!1, !1),
                this.add(_),
                void 0 !== I &&
                  (this.children.pop(), this.children.splice(I, 0, _)),
                this
              );
            }
            copy(_, I = !1) {
              return (
                super.copy(_, I),
                (this.hasNonUniformScale = _.hasNonUniformScale),
                this
              );
            }
            onAfterRender(_, I, R, B, z, k) {
              this.copyPreviousMatrix &&
                this.previousModelViewMatrix.copy(this.modelViewMatrix);
            }
          },
        yV = class extends Td(sL) {},
        Z9 = (_) => "Mesh" === _.type,
        yj = class extends yV {
          constructor(_) {
            super(),
              (this.object = _),
              (this.matrixAutoUpdate = !1),
              (this.hasNonUniformScale = _.hasNonUniformScale);
          }
          raycast(_, I) {}
          expand() {
            let _ = 0,
              I = this.object.entityChildren(_);
            for (; I; ) {
              let R = this.children[_];
              R?.object !== I &&
                (R && this.remove(R),
                (R = new yj(I)),
                this.add(R),
                this.children.splice(_, 0, this.children.pop()),
                (R.matrixWorldNeedsUpdate = !0),
                (R.matrixAutoUpdate = !1),
                (R.matrix = I.matrix),
                (R.hiddenMatrix = I.hiddenMatrix)),
                R.expand(),
                (_ += 1),
                (I = this.object.entityChildren(_));
            }
            for (; this.children.length > _; ) this.remove(this.children[_]);
          }
          get visible() {
            return void 0 !== this.playModeVisible
              ? this.playModeVisible
              : this.object.visible ||
                  (this.object.dataPatched.visible &&
                    this.object.dataPatched.cloner?.hideBase === !0);
          }
          set visible(_) {}
          get castShadow() {
            return this.object.castShadow;
          }
          set castShadow(_) {}
          get receiveShadow() {
            return this.object.receiveShadow;
          }
          set receiveShadow(_) {}
          get isMesh() {
            return Z9(this.object);
          }
          get isLight() {
            return this.object.isLight;
          }
          get layers() {
            return this.object.layers;
          }
          set layers(_) {}
          get isCamera() {
            return !1;
          }
          get geometry() {
            if (this.object.geometry) return this.object.geometry;
          }
          get material() {
            if (this.object.material) return this.object.material;
          }
        },
        yG = new rF(),
        yH = new rF(),
        yW = new sa(),
        yq = [
          new rF(-1, 1, 1),
          new rF(-1, -1, 1),
          new rF(1, -1, 1),
          new rF(1, 1, 1),
          new rF(-1, 1, -1),
          new rF(-1, -1, -1),
          new rF(1, -1, -1),
          new rF(1, 1, -1),
        ],
        yY = [
          [0, 3],
          [1, 2],
          [5, 6],
          [4, 7],
          [0, 1],
          [3, 2],
          [7, 6],
          [4, 5],
          [0, 4],
          [1, 5],
          [2, 6],
          [3, 7],
        ],
        yX = [
          [0, 2],
          [7, 5],
          [4, 1],
          [3, 6],
          [4, 3],
          [1, 6],
        ],
        LO = (_, I, R) => {
          _.updateEntityBoxSize(yG, yH),
            yW.copy(I).multiply(_.matrixWorld),
            0 === yH.x && 0 === yH.y && 0 === yH.z
              ? R.push(new rF(yG.x, yG.y, yG.z).applyMatrix4(yW))
              : yq.forEach((_) => {
                  R.push(_.clone().multiply(yH).add(yG).applyMatrix4(yW));
                });
        },
        yQ = class extends rU {
          constructor() {
            super(...arguments),
              (this.matrix = new sa()),
              (this.vertices = []),
              (this.faces = []),
              (this.edges = []),
              (this.centerEdges = []);
          }
          copy(_) {
            return (
              super.copy(_),
              this.matrix.copy(_.matrix),
              (this.vertices = _.vertices.map((_) => _.clone())),
              (this.faces = _.faces.map((_) => _.clone())),
              (this.edges = _.edges.map((_) => _.clone())),
              (this.centerEdges = _.centerEdges.map((_) => _.clone())),
              this
            );
          }
          setFromObjectSize(_, I = !1) {
            _.updateWorldMatrix(!1, I),
              this.makeEmpty(),
              this.matrix.copy(_.matrixWorld);
            let R = new sa().copy(_.matrixWorld).invert();
            return this.expandByObjectSize(_, R, I);
          }
          expandByObjectSize(_, I, R = !1) {
            let B = [];
            return (
              !0 === R
                ? _.traverseEntity((_) => {
                    if (_.visible || (_.cloner && _.data.visible)) {
                      if (!("geometry" in _)) {
                        B.push(new rF());
                        return;
                      }
                      LO(_, I, B);
                    }
                  })
                : LO(_, I, B),
              this.setFromPoints(B)
            );
          }
          getCenter(_) {
            return (_ = super.getCenter(_)).applyMatrix4(this.matrix), _;
          }
          getPositionToCenter(_) {
            return (
              (_ = super.getCenter(_)).applyMatrix4(
                yW.copy(this.matrix).setPosition(0, 0, 0)
              ),
              _
            );
          }
          computeVertices() {
            this.getSize(yH).multiplyScalar(0.5),
              this.getCenter(yG),
              yW.copy(this.matrix).setPosition(yG),
              (this.vertices = yq.map((_) =>
                _.clone().multiply(yH).applyMatrix4(yW)
              ));
          }
          computeEdges() {
            this.vertices.length > 0 && this.computeVertices(),
              (this.edges = yY.map(
                ([_, I]) => new lX(this.vertices[_], this.vertices[I])
              )),
              (this.centerEdges = this.edges.map((_) => _.getCenter(new rF())));
          }
          computeFaces() {
            this.vertices.length > 0 && this.computeVertices(),
              (this.faces = yX.map(([_, I]) =>
                this.vertices[_].clone()
                  .add(this.vertices[I])
                  .multiplyScalar(0.5)
              ));
          }
        },
        yZ = {
          Cloner: () => {},
          changeEntityProptotype: () => {},
          createEntity: () => {},
        },
        yJ = class extends oA {
          constructor() {
            super();
          }
          getPoints(_ = 12) {
            let I = [],
              R,
              B = this.getCurveLengths(),
              z = B[B.length - 1] / B.length;
            for (let k = 0, V = this.curves; k < V.length; k++) {
              let j = V[k],
                G = Math.ceil((_ * (0 === k ? B[k] : B[k] - B[k - 1])) / z),
                q = j.getPoints(G);
              for (let _ = 0; _ < q.length; _++) {
                let B = q[_];
                (R && R.equals(B)) || (I.push(B), (R = B));
              }
            }
            return (
              this.autoClose &&
                I.length > 1 &&
                !I[I.length - 1].equals(I[0]) &&
                I.push(I[0]),
              I
            );
          }
        };
      function lA(_, I, R) {
        return 0.001 >= I.clone().sub(_).cross(I.clone().sub(R)).length();
      }
      function sA(_, I) {
        let R = new rF(..._.position),
          B = new rF(..._.controlNext.position),
          z = new rF(...I.controlPrevious.position),
          k = new rF(...I.position);
        return lA(R, B, k) && lA(R, z, k);
      }
      function P0(_) {
        let I = _.points.map((_) => new rF(..._.data.position)),
          R = [_.points[0]],
          B = new rF(...R[0].data.position);
        for (let z = 0; z < _.points.length - 1; z++)
          lA(B, I[z], I[z + 1]) || (R.push(_.points[z]), (B = I[z]));
        R.push(_.points[_.points.length - 1]);
        let z = _.isClosed,
          k = R.length - (z ? 0 : 1),
          V = R.length,
          j = [];
        for (let I = 0; I < V; I++) {
          let B = R[I].data,
            k = new rF(...B.position),
            G = new rF(...B.controlPrevious.position),
            q = new rF(...B.controlNext.position),
            X = {
              position: k,
              baseRoundness: B.roundness,
              controlPrevious: G,
              controlNext: q,
            };
          if (0 === B.roundness || (!_.isClosed && (0 === I || I === V - 1))) {
            j[I] = { ...X, removedLength: 0 };
            continue;
          }
          let Q = z && 0 == I ? V - 1 : I - 1,
            $ = z && I == V - 1 ? 0 : I + 1,
            et = R[Q].data,
            er = R[$].data,
            es = new rF(...et.position),
            ea = new rF(...er.position),
            en = es.clone().sub(k).normalize(),
            eo = ea.clone().sub(k).normalize();
          Object.assign(X, { prevDir: en, nextDir: eo });
          let el = sA(et, B),
            eh = sA(B, er);
          if (el && eh) {
            let _ = en.clone().add(eo).normalize(),
              R = _.clone().cross(en).length() / en.dot(_);
            j[I] = { ...X, tan: R, removedLength: B.roundness / R };
          } else j[I] = { ...X, removedLength: 0 };
        }
        for (let _ = 0; _ < k; _++) {
          let I = _,
            R = z && _ === V - 1 ? 0 : _ + 1,
            B = j[I],
            k = j[R];
          if (0 !== B.removedLength || 0 !== k.removedLength) {
            let _ = B.position.distanceTo(k.position);
            (B.removedLength = Math.min(B.removedLength, _ / 2)),
              (k.removedLength = Math.min(k.removedLength, _ / 2));
          }
        }
        let G = [];
        for (let _ = 0; _ < k; _++) {
          let I = _,
            B = z && _ === V - 1 ? 0 : _ + 1,
            k = j[I],
            q = j[B],
            X = null;
          if (sA(R[I].data, R[B].data)) {
            let _ = k.position.clone(),
              I = q.position.clone();
            (0 !== k.removedLength || 0 !== q.removedLength) &&
              (k.nextDir && _.add(k.nextDir.clone().setLength(k.removedLength)),
              q.prevDir && I.add(q.prevDir.clone().setLength(q.removedLength))),
              _.distanceTo(I) > 0.001 &&
                (X = new om(
                  _,
                  _.clone().lerp(I, 0.3),
                  I.clone().lerp(_, 0.3),
                  I
                ));
          } else
            k.position.distanceTo(q.position) > 0.001 &&
              (X = new om(
                k.position,
                k.controlNext,
                q.controlPrevious,
                q.position
              ));
          G[2 * _ + 1] = X;
        }
        for (let _ = 0; _ < V; _++) {
          let I = j[_];
          if (0 === I.removedLength) {
            G[2 * _] = null;
            continue;
          }
          let R = I.position,
            B = I.prevDir.clone().multiplyScalar(I.removedLength).add(R),
            z = I.nextDir.clone().multiplyScalar(I.removedLength).add(R),
            k = I.tan * I.removedLength,
            V = I.prevDir.clone().add(I.nextDir).normalize(),
            q = B.clone().lerp(z, 0.5),
            X = B.distanceTo(z) / 2,
            Q = V.clone()
              .multiplyScalar(Math.sqrt(Math.pow(k, 2) - Math.pow(X, 2)))
              .add(q),
            $ = V.clone().multiplyScalar(-k).add(Q),
            et = R.distanceTo($) / R.distanceTo(q),
            er = I.prevDir
              .clone()
              .multiplyScalar(et * R.distanceTo(B))
              .add(R),
            es = er.clone().lerp($, 2),
            ea = B.clone().lerp(er, 4 / 3),
            en = z.clone().lerp(es, 4 / 3);
          G[2 * _] = new om(B, ea, en, z);
        }
        let q = new yJ();
        return (
          G.forEach((_) => {
            _ && q.add(_);
          }),
          q
        );
      }
      (bG || (bG = {})).is = function (_) {
        return _ && _.__isEntity;
      };
      var Uo = (_) => bG.is(_),
        y$ = { type: "completeState", isfromEntity: !0 },
        y0 = ["x", "y", "z"],
        y1 = new rF(),
        y3 = new rF().set(0, 1, 0),
        Cd = (_) =>
          class extends Td(_) {
            constructor() {
              super(...arguments),
                (this.raycastLock = !1),
                (this.scaleLock = !1),
                (this.disposed = !1),
                (this.stateSelection = null),
                (this.destroyedInAction = !1),
                (this.instances = []),
                (this.prevState = null),
                (this.currentState = null),
                (this.reversibleToState = null),
                (this.currentTransitionEvent = null),
                (this.previousAction = null),
                (this._singleBBox = new yQ()),
                (this._recursiveBBox = new yQ()),
                (this.singleBBoxNeedsUpdate = !0),
                (this.recursiveBBoxNeedsUpdate = !0),
                (this._needApplyPathSnapping = !0),
                (this.attachedPaths = new Set());
            }
            get __isEntity() {
              return !0;
            }
            entityChildren(_) {
              let I = this.children[_];
              if (bG.is(I)) return I;
            }
            entityChildrenCount() {
              let _ = this.children.length;
              for (; _--; ) if (bG.is(this.children[_])) return _ + 1;
              return 0;
            }
            get isConcreteEntity() {
              return "string" == typeof this.identity;
            }
            get isVirtualEntity() {
              return "string" != typeof this.identity;
            }
            get isInstanceRoot() {
              return this.isConcreteEntity && "Instance" === this.data.type;
            }
            nearestInstanceSelfOrParent() {
              let _ = this;
              for (; "Instance" !== _.data.type; ) {
                let I = _.parent;
                if (!bG.is(I)) return;
                _ = I;
              }
              return _;
            }
            forInstancesRec(_) {
              this.instances.forEach((I) => {
                I.disposed || _(I), I.forInstancesRec(_);
              });
            }
            super_Entity(_, I) {
              "string" == typeof _ && (this.uuid = _),
                (this.identity = _),
                (this.data = I),
                (this.matrixAutoUpdate = !1),
                (this.dataPatched = this.data);
            }
            changeSelectedState(_, I, R = !1) {
              if (!(0 === this.data.states.length && !R)) {
                for (let _ of this.data.states)
                  vm.toOps(this.data, _.data).forEach((_) => {
                    let R = u8.replaceProps(_, this.data);
                    (this.dataPatched = this.data),
                      this.updateByPatchedOp(R, this.data, I);
                  });
                if (null !== _) {
                  let R = this.data.states.data(_);
                  R &&
                    ((this.dataPatched = vm.patch(this.data, R)),
                    vm.toOps(this.data, R).forEach((_) => {
                      this.updateByPatchedOp(_, this.dataPatched, I);
                    }));
                }
                R && this.updateTransformState(this.dataPatched, I),
                  (this.stateSelection = _),
                  this.updatePathSnapping(this.dataPatched.pathSnapping);
              }
            }
            get singleBBox() {
              return (
                this.singleBBoxNeedsUpdate &&
                  ((this.singleBBoxNeedsUpdate = !1),
                  this._singleBBox.setFromObjectSize(this, !1),
                  this._singleBBox.computeVertices(),
                  this._singleBBox.computeEdges(),
                  this._singleBBox.computeFaces()),
                this._singleBBox
              );
            }
            get recursiveBBox() {
              return (
                this.recursiveBBoxNeedsUpdate &&
                  ((this.recursiveBBoxNeedsUpdate = !1),
                  this._recursiveBBox.setFromObjectSize(this, !0),
                  this._recursiveBBox.computeVertices(),
                  this._recursiveBBox.computeEdges(),
                  this._recursiveBBox.computeFaces()),
                this._recursiveBBox
              );
            }
            updateEntityBoxSize(_, I) {
              _.setScalar(0), I.setScalar(0);
            }
            resetBBoxNeedsUpdateSelf() {
              (this.singleBBoxNeedsUpdate = !0),
                (this.recursiveBBoxNeedsUpdate = !0);
            }
            resetBBoxNeedsUpdate() {
              this.resetBBoxNeedsUpdateSelf(),
                this.traverseAncestors((_) => {
                  Uo(_) && _.resetBBoxNeedsUpdateSelf();
                }),
                this.traverseEntity((_) => {
                  _.resetBBoxNeedsUpdateSelf();
                });
            }
            find(_) {
              let I;
              return (
                this.traverseEntity((R) => {
                  R.uuid === _ && (I = R);
                }),
                I
              );
            }
            traverseSortNextHelper() {
              let _ = this.parent;
              if (_) {
                let I = _.children,
                  R = I.indexOf(this) + 1;
                if (bG.is(I[R])) return I[R];
                if (bG.is(_)) return _.traverseSortNextHelper();
              }
            }
            sortNext() {
              let _ = this.children;
              return this.children.length > 0 && bG.is(this.children[0])
                ? _[0]
                : this.traverseSortNextHelper();
            }
            goUp(_) {
              let I = this;
              for (; _ > 0 && null !== I; ) (I = I.parent), (_ -= 1);
              return I;
            }
            hasAnccestorOrSelf(_) {
              return this === _ || this.hasAnccestor(_);
            }
            hasAnccestor(_) {
              let I = this.parent;
              for (; I; ) {
                if (_ === I) return !0;
                I = I.parent;
              }
              return !1;
            }
            countToAccestor(_) {
              let I = 0,
                R = this;
              for (; R !== _; ) {
                if (null === R) return -1;
                (R = R.parent), (I += 1);
              }
              return I;
            }
            forEachEntity(_) {
              for (let I of this.children) Uo(I) && _(I);
            }
            traverseEntityAncestors(_) {
              this.traverseAncestors((I) => {
                bG.is(I) && _(I);
              });
            }
            traverseConcreteEntity(_, I = 0) {
              if (!0 !== _(this, I))
                for (let R of this.children)
                  Uo(R) && R.isConcreteEntity && R.traverseEntity(_, I + 1);
            }
            traverseEntity(_, I = 0) {
              if (!0 !== _(this, I))
                for (let R of this.children)
                  Uo(R) && R.traverseEntity(_, I + 1);
            }
            traverseVisibleEntity(_) {
              for (let I of (_(this), this.children))
                Uo(I) && I.visible && I.traverseVisibleEntity(_);
            }
            updateMatrix() {
              super.updateMatrix(),
                this.cloner && this.cloner.onObjUpdateMatrix(),
                this.dispatchEvent({ type: "updateMatrix" });
            }
            updateMatrixWorld(_) {
              super.updateMatrixWorld(_),
                this.dispatchEvent({ type: "updateMatrixWorld" });
            }
            copy(_, I = !1) {
              return (
                super.copy(_, I),
                (this.dataPatched = _.dataPatched),
                (this.raycastLock = _.raycastLock),
                (this.scaleLock = _.scaleLock),
                this.hiddenMatrix.copy(_.hiddenMatrix),
                this
              );
            }
            hasEntityChild() {
              return this.children.some((_) => Uo(_));
            }
            isAncestorOf(_) {
              if (this.uuid === _) return !1;
              let I = !1;
              return (
                this.traverseEntity((R) => {
                  R.uuid === _ && (I = !0);
                }),
                I
              );
            }
            toObjectTransformState(_ = []) {
              return (
                this.updateWorldMatrix(!0, !1),
                ua(
                  {
                    position: this.position.toArray(),
                    rotation: [
                      this.rotation.x * rr.RAD2DEG,
                      this.rotation.y * rr.RAD2DEG,
                      this.rotation.z * rr.RAD2DEG,
                    ],
                    scale: this.scale.toArray(),
                    hiddenMatrix: this.hiddenMatrix.toArray(),
                  },
                  _
                )
              );
            }
            getTransformValues(_, I, R) {
              return I[_].map(
                (I, B) => R?.shared.getVariable(I, [this.uuid, _, y0[B]]) ?? I
              );
            }
            updateTransformState(_, I) {
              let R = !1;
              return (
                _.position &&
                  (this.position.fromArray(
                    this.getTransformValues("position", _, I)
                  ),
                  (R = !0)),
                _.rotation &&
                  (y1
                    .fromArray(this.getTransformValues("rotation", _, I))
                    .multiplyScalar(rr.DEG2RAD),
                  this.rotation.setFromVector3(y1),
                  (R = !0)),
                _.scale &&
                  (this.scale.fromArray(this.getTransformValues("scale", _, I)),
                  (R = !0)),
                void 0 !== _.hiddenMatrix &&
                  ((R = !0),
                  this.hiddenMatrix.fromArray(_.hiddenMatrix ?? mv.identity)),
                R &&
                  (this.updateMatrix(),
                  this.resetBBoxNeedsUpdate(),
                  this.invalidateClonerTransform(this),
                  this.traverseEntityAncestors((_) => {
                    _.invalidateClonerTransform(this);
                  })),
                _.position &&
                  _.rotation &&
                  _.scale &&
                  void 0 !== _.hiddenMatrix &&
                  this.updateWorldMatrix(!1, !0),
                R
              );
            }
            onVariableUpdate(_ = !1) {
              if (_) {
                this.resetBBoxNeedsUpdate();
                return;
              }
              this.updateMatrix(),
                this.resetBBoxNeedsUpdate(),
                this.invalidateClonerTransform(this),
                this.traverseEntityAncestors((_) => {
                  _.invalidateClonerTransform(this);
                });
            }
            dispose() {
              (this.disposed = !0),
                this.cloner &&
                  (this.cloner.removeFromParent(), (this.cloner = void 0));
            }
            disposeChildrenRecursively() {
              for (let _ of this.children) bG.is(_) && _.disposeRecursively();
            }
            disposeRecursively() {
              this.dispose(),
                this.children.forEach((_) => {
                  bG.is(_) && _.disposeRecursively();
                });
            }
            toState(_ = []) {
              return ua(
                {
                  name: this.name,
                  visible: this.visible,
                  raycastLock: this.raycastLock,
                  ...this.toObjectTransformState(_),
                },
                _
              );
            }
            updateByObjUpdateOp(_, I) {
              void 0 !== _ &&
                this.updateByOp(
                  { type: 0, props: _, path: [] },
                  { ...this.data, ..._ },
                  I,
                  !1
                );
            }
            updateByOp(_, I, R, B) {
              let z = this.data;
              this.data = I;
              let k = _,
                V = Rt(_.path, ["states", "*"]);
              if (null !== V) {
                if (0 === _.type) {
                  let [I] = V;
                  if (this?.stateSelection === I) {
                    let I = { ..._.props };
                    if (
                      (delete I.name,
                      Object.values(_.props).some((_) => void 0 === _))
                    ) {
                      let R = this.data;
                      if (void 0 !== R) {
                        let B = pe.zoom(R, _.path.slice(2));
                        if (B)
                          for (let R in _.props)
                            void 0 === _.props[R] && R in B && (I[R] = B[R]);
                      }
                    }
                    k = { ..._, props: I, path: _.path.slice(2) };
                  }
                }
              } else if (0 === _.type) {
                let I = this.stateSelection
                  ? this.data.states.data(this.stateSelection)
                  : void 0;
                if (void 0 !== I) {
                  if (void 0 !== _.props.name && I.name) {
                    let { name: _, ...R } = I;
                    I = R;
                  }
                  if (void 0 !== _.props.material && "material" in I) {
                    let { material: _, ...R } = I;
                    I = R;
                  }
                  let R = pe.removeOverridden(_.path, _.props, I);
                  k = { ..._, props: R };
                }
              }
              if (
                (this.updateByPatchedOpBase(
                  k,
                  vm.patch(
                    this.data,
                    this.stateSelection
                      ? this.data.states.data(this.stateSelection)
                      : void 0
                  ),
                  R
                ),
                Rt(_.path, ["overrides"]))
              ) {
                let B = [],
                  z = [..._.path];
                for (
                  B.push(z[1]), z.splice(0, 2);
                  z.length > 0 && "descendants" === z[0];

                )
                  B.push(z[1]), z.splice(0, 2);
                if (void 0 === B[B.length - 1]) {
                  if (0 === _.type)
                    for (let I of Object.keys(_.props)) {
                      B[B.length - 1] = I;
                      let z = R.scene.findInstance([this.uuid, ...B]);
                      z &&
                        ((z.overrideData = _.props[I]),
                        z.updateState(
                          uj.apply(z.component.data, z.overrideData),
                          R
                        ));
                    }
                } else {
                  let k = R.scene.findInstance([this.uuid, ...B]);
                  if (k) {
                    let V = pe.zoom(k.component.data, z);
                    if (0 === (_ = { ..._, path: z }).type) {
                      let I = _.props;
                      if (V)
                        for (let [R, B] of Object.entries(_.props))
                          void 0 === B &&
                            (I === _.props && (I = { ..._.props }),
                            (I[R] = V[R]));
                      _ = { ..._, props: I };
                    }
                    (k.overrideData = vh.resolve(I.overrides, B)),
                      k.updateByOp(_, u9.applySimple(k.data, _), R, !1);
                  }
                }
              } else if (this.instances.length > 0) {
                let B;
                if (0 === _.path.length && 0 === _.type) {
                  let I;
                  for (let R of vc.rootOverrideProps)
                    R in _.props &&
                      (void 0 === I && (I = {}), (I[R] = _.props[R]));
                  I && (B = { ..._, props: I });
                } else
                  for (let I of vc.rootOverrideProps)
                    if (Rt(_.path, [I])) {
                      B = _;
                      break;
                    }
                void 0 !== B &&
                  this.instances.forEach((_) => {
                    if (_.isInstanceRoot) {
                      let I = uj.filterOp(_.overrideData, B);
                      I && _.updateByOp(I, u9.applySimple(_.data, I), R, !0);
                    }
                  }),
                  this.instances.forEach((B) => {
                    if (!B.isInstanceRoot) {
                      let k = uj.filterOp(B.overrideData, _);
                      if (k) {
                        let V;
                        (V =
                          z === B.data && _ === k
                            ? I
                            : u9.applySimple(B.data, k)),
                          B.updateByOp(k, V, R, !0);
                      }
                    }
                  });
              }
            }
            updateByPatchedOpBase(_, I, R) {
              if (((this.dataPatched = I), 0 === _.path.length && 0 === _.type))
                void 0 === _.props.type ||
                  mP.is(_.props.type) ||
                  yZ.changeEntityProptotype(this, I, R);
              else if (
                1 === _.path.length &&
                "geometry" === _.path[0] &&
                0 === _.type &&
                "type" in _.props
              )
                for (let _ of (yZ.changeEntityProptotype(this, I, R),
                this.children))
                  bG.is(_) && _.updateVisible(R.scene);
              this.updateByPatchedOp(_, I, R);
            }
            updateByPatchedOp(_, I, R) {
              if (
                (0 === _.path.length &&
                  0 === _.type &&
                  this.updateState(_.props, R),
                null !== Rt(_.path, ["pathSnapping"]) &&
                  this.updatePathSnapping(I.pathSnapping),
                null !== Rt(_.path, ["cloner"]))
              ) {
                let B = u9.drop(_, 1);
                0 === B.path.length && 0 === B.type && !0 === B.props.disabled
                  ? this.setFromClonerState(null, R)
                  : this.cloner
                  ? this.cloner.updateState(I.cloner, R.scene)
                  : (this.setFromClonerState(I.cloner, R),
                    this.expandCloner(R.scene)),
                  this.updateVisible(R.scene);
              }
            }
            updatePathSnapping(_ = this.dataPatched.pathSnapping) {
              (this._updatedPathSnapping = _),
                (this._needApplyPathSnapping = !0);
            }
            get updatedPathSnapping() {
              return this._updatedPathSnapping;
            }
            applyPathSnapping(_) {
              let I =
                  this._updatedPathSnapping?.pathId ??
                  this.dataPatched.pathSnapping.pathId,
                R =
                  this._updatedPathSnapping?.slide ??
                  this.dataPatched.pathSnapping.slide ??
                  0,
                B =
                  this._updatedPathSnapping?.offset ??
                  this.dataPatched.pathSnapping.offset ??
                  0,
                z =
                  this._updatedPathSnapping?.orientation ??
                  this.dataPatched.pathSnapping.orientation;
              if (null === I) return;
              let k = _.find(I);
              if (!k || !1 === this._needApplyPathSnapping) return;
              this._needApplyPathSnapping = !1;
              let V = k.data;
              if (V.geometry.path.points.length <= 1) return;
              let j = P0(V.geometry.path),
                G = (R + B) % 1;
              R + B === 1 && 0 === G && (G = 1);
              let q = j.getPointAt(G);
              if (null === q) return;
              let X = this.parent ? this.parent?.matrixWorld : new sa();
              k.updateMatrixWorld();
              let Q = new sa().multiplyMatrices(
                X.clone().invert(),
                k.matrixWorld
              );
              q.applyMatrix4(Q);
              let $ = { position: q.toArray(), rotation: V.rotation };
              if ("tangential" === z) {
                let _ = new sa().extractRotation(k.matrixWorld),
                  I = j.getTangentAt(G).applyMatrix4(_).add(q),
                  R = new sa().lookAt(q, I, y3),
                  B = y1
                    .setFromEuler(new sg().setFromRotationMatrix(R))
                    .multiplyScalar(rr.RAD2DEG);
                $ = { ...$, rotation: B.toArray() };
              }
              this.updateTransformState($),
                this.traverseEntity((_) => {
                  _._cameraType && _.dispatchEvent(y$);
                });
            }
            updateVisible(_) {
              if (
                ((this.visible =
                  this.dataPatched.visible &&
                  (!this.dataPatched.cloner ||
                    (this.dataPatched.cloner.disabled ?? !1) ||
                    this.dataPatched.cloner?.hideBase !== !0)),
                !_)
              )
                return;
              let I = !1;
              this.traverseEntity((_) => {
                if ("Splat" === _.data.type) return (I = !0), !0;
              }),
                I && _.reloadSplats();
            }
            updateState_Entity(_, I) {
              void 0 !== _.name && (this.name = _.name),
                void 0 !== _.raycastLock && (this.raycastLock = _.raycastLock),
                void 0 !== _.visible &&
                  (this.updateVisible(I?.scene), this.resetBBoxNeedsUpdate()),
                I &&
                  "cloner" in _ &&
                  void 0 !== _.cloner &&
                  (this.setFromClonerState(_.cloner, I),
                  this.updateVisible(I.scene)),
                this.updateTransformState(_, I);
            }
            get attachedSurfaceCloners() {
              return this.children.filter(
                (_) =>
                  _ instanceof yZ.Cloner && "toObject" === _.parameters.type
              );
            }
            setFromClonerState(_, I) {
              this.disposed ||
                (null === _ || _.disabled
                  ? (this.cloner && this.cloner.removeFromParent(),
                    (this.cloner = void 0))
                  : void 0 === this.cloner
                  ? ((this.cloner = new yZ.Cloner(this, _)),
                    I.scene.addPendingExpandCloner(this))
                  : this.cloner.updateState(_, I.scene));
            }
            expandCloner(_) {
              !this.disposed && this.cloner && this.cloner.expandClones(_);
            }
            invalidateClonerTransform(_) {
              this.cloner && this.cloner.invalidateTransform(_);
            }
            requestRender() {
              this.dispatchEvent({ type: "requestRender" });
            }
          },
        y4 = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R = Object.assign(
              {},
              I?.parameters ?? {
                width: 100,
                radialSegments: 64,
                heightSegments: 1,
                openEnded: !1,
                thetaStart: 0,
                thetaLength: 360,
                cornerRadius: 8,
                cornerSegments: 8,
                hollow: 0,
              },
              _.parameters
            );
            R.thetaLength = rr.clamp(R.thetaLength, 0, 360);
            let B = R.width / 2,
              z = R.radiusTop ?? B,
              k = R.radiusBottom ?? B;
            return (
              z === k
                ? ((z = B), (k = B))
                : z > k
                ? ((z = B), (k = (k * B) / z))
                : ((z = (z * B) / k), (k = B)),
              {
                parameters: Object.assign(R, {
                  width: Math.abs(R.width),
                  height: Math.abs(R.height ?? R.width),
                  depth: Math.abs(R.depth ?? R.width),
                  radiusTop: z,
                  radiusBottom: k,
                }),
              }
            );
          }
          static build(_) {
            let {
                width: I,
                depth: R,
                height: B,
                radialSegments: z,
                heightSegments: k,
                openEnded: V,
                thetaStart: j,
                thetaLength: G,
                radiusTop: q,
                radiusBottom: X,
                cornerRadius: Q,
                cornerSegments: $,
                hollow: et,
              } = _.parameters,
              er;
            return (
              0 === G
                ? (er = new ai()).setAttribute("position", new s4([], 3))
                : (er =
                    Q || et
                      ? new y5(
                          q,
                          X,
                          B,
                          z,
                          k,
                          V,
                          j,
                          (G * Math.PI) / 180,
                          Q,
                          Q,
                          $,
                          et
                        )
                      : new oC(q, X, B, z, k, V, j, (G * Math.PI) / 180)),
              er.scale(1, 1, R / I),
              Object.assign(er, {
                userData: { ..._, type: "CylinderGeometry" },
              })
            );
          }
        };
      function zl(_, I, R) {
        (R.x = _.x * I.x), (R.y = _.y), (R.z = _.x * I.y);
      }
      function NO(_) {
        return new rs(_.y, -_.x);
      }
      var y5 = class extends ai {
          constructor(_, I, R, B, z, k, V, j, G, q, X, Q, $ = !1) {
            super(),
              (this.type = "RoundedCylinderBufferGeometry"),
              (_ = void 0 !== _ ? _ : 1),
              (I = void 0 !== I ? I : 1),
              (R = R || 1),
              (B = Math.floor(B) || 8),
              (z = Math.floor(z) || 1),
              (k = void 0 !== k && k),
              (V = void 0 !== V ? V : 0),
              (j = void 0 !== j ? j : 2 * Math.PI),
              k && ((G = 0), (q = 0));
            let et = [],
              er = [],
              es = [],
              ea = [],
              en = 0,
              eo = R / 2,
              el = new rF(),
              eh = new rF();
            $ && 0 == _ && (_ = G), $ && 0 == I && (I = q);
            let ec = new rs(_, eo),
              ed = new rs(I, -eo),
              ep = null,
              ef = null,
              em = null,
              ey = null,
              ex = ec.clone().sub(ed),
              eb = 0,
              ew = 0,
              e_ = 0;
            Q > 0 &&
              ((eb = Math.min(_, I) * (1 - Q)), (ew = _ - eb), (e_ = I - eb));
            let eS = ec.clone();
            eS.x -= eb;
            let eA = Math.PI - ex.angle(),
              eC = ex.angle(),
              eT = Math.tan(eC / 2),
              eP = Math.tan(eA / 2),
              eI = eT + eP;
            if (
              ((G = Math.min(G, (_ - ew) / (Q ? eI : eP), ex.length() / eI)),
              (q = Math.min(q, (I - e_) / (Q ? eI : eT), ex.length() / eI)),
              G > 0)
            ) {
              let _ = G / eT;
              (ep = ec.clone().sub(new rs(_, G))),
                Q && ((em = ep.clone()), (em.x -= eb - eI * G)),
                ec.sub(ex.clone().setLength(_));
            }
            if (q > 0) {
              let _ = q / eP;
              (ef = ed.clone().sub(new rs(_, -q))),
                ed.add(ex.clone().setLength(_)),
                Q &&
                  ((ey = ef.clone()),
                  (ey.x -= eb - eI * q),
                  eS.sub(ex.clone().setLength(_)));
            }
            let eR = 0.5 > (ex = ec.clone().sub(ed)).length(),
              eB = [];
            for (let X = 0; X <= B; X++) {
              let $ = [],
                et = X / B,
                eo = et * j + V,
                ec = new rs(Math.sin(eo), Math.cos(eo));
              if (
                (ey && ef
                  ? (W($, et, ec, eA, q, ey, -1, !0),
                    W($, et, ec, eC, q, ef, -1, !1))
                  : ef
                  ? (ne($, ec, ef.x, 0, -1), W($, et, ec, eC, q, ef, -1, !1))
                  : k || ne($, ec, I, e_, -1),
                zl(NO(ex).normalize(), ec, el),
                !eR)
              )
                for (let _ = 0; _ <= z; _++) {
                  let I = _ / z;
                  zl(ex.clone().multiplyScalar(I).add(ed), ec, eh),
                    er.push(eh.x, eh.y, eh.z),
                    es.push(el.x, el.y, el.z),
                    ea.push(et, 0.5 + eh.y / R),
                    $.push(en++);
                }
              if (
                (em && ep
                  ? (W($, et, ec, eA, G, ep, 1, !1),
                    W($, et, ec, eC, G, em, 1, !0))
                  : ep
                  ? (W($, et, ec, eA, G, ep, 1, !1), ne($, ec, ep.x, 0, 1))
                  : k || ne($, ec, _, ew, 1),
                Q && !eR)
              ) {
                zl(NO(ex).multiplyScalar(-1).normalize(), ec, el);
                for (let _ = 0; _ <= z; _++) {
                  let I = _ / z;
                  zl(ex.clone().multiplyScalar(-I).add(eS), ec, eh),
                    er.push(eh.x, eh.y, eh.z),
                    es.push(el.x, el.y, el.z),
                    ea.push(et, 0.5 + eh.y / R),
                    $.push(en++);
                }
              }
              Q && !k && $.push($[0]), eB.push($);
            }
            for (let _ = 0; _ < eB.length - 1; _++)
              for (let I = 0; I < eB[0].length - 1; I++) {
                if (k && Q && I == z) continue;
                let R = eB[_][I],
                  B = eB[_ + 1][I],
                  V = eB[_ + 1][I + 1],
                  j = eB[_][I + 1],
                  G = er[3 * V + 0],
                  q = er[3 * V + 2];
                et.push(R, B, j), (0 != G || 0 != q) && et.push(B, V, j);
              }
            function W(_, I, B, z, k, V, j, G) {
              for (let q = 0; q < X + 1; q++) {
                let Q = q / X,
                  $ = j < 0 ? Q : 1 - Q;
                G && ($ -= 1), ($ *= z);
                let et = new rs(Math.sin($), Math.cos($) * j);
                zl(et.clone().multiplyScalar(k).add(V), B, eh),
                  er.push(eh.x, eh.y, eh.z),
                  zl(et, B, el),
                  es.push(el.x, el.y, el.z),
                  ea.push(I, 0.5 + eh.y / R),
                  _.push(en++);
              }
            }
            function ne(_, I, R, B, z) {
              let k = new rF(),
                V = new rs(),
                j = [R, B];
              for (let R of (z < 0 && j.reverse(), j))
                V.set(R, eo * z),
                  zl(V, I, k),
                  er.push(k.x, k.y, k.z),
                  es.push(0, z, 0),
                  ea.push(0.5, 0.5),
                  _.push(en++);
            }
            function ie(R, B, z) {
              let k = new rs(Math.sin(z), Math.cos(z)),
                V = new rs(-Math.cos(z), Math.sin(z)),
                j = new rF(),
                G =
                  R < 0
                    ? (_, I, R) => et.push(_, I, R)
                    : (_, I, R) => et.push(_, R, I);
              zl(new rs((_ + I + ew + e_) / 4, 0), k, j),
                er.push(j.x, j.y, j.z),
                es.push(V.x, 0, V.y),
                ea.push(0.5, 0.5);
              let q = en++;
              for (let _ of B) {
                let I = er.slice(3 * _, 3 * _ + 3);
                er.push(...I), es.push(V.x, 0, V.y);
                let R = ea.slice(2 * _, 2 * _ + 2);
                ea.push(...R), en++;
              }
              for (let _ = q + 1; _ < en - 1; _++) G(q, _, _ + 1);
              G(q, en - 1, q + 1);
            }
            j < 2 * Math.PI &&
              (ie(-1, eB[0], V), ie(1, eB[eB.length - 1], V + j)),
              this.setIndex(et),
              this.setAttribute("position", new s4(er, 3)),
              this.setAttribute("normal", new s4(es, 3)),
              this.setAttribute("uv", new s4(ea, 2));
          }
        },
        y6 = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R = Object.assign(
              {},
              I?.parameters ?? {
                width: 100,
                radialSegments: 32,
                heightSegments: 8,
                openEnded: !1,
                thetaStart: 0,
                thetaLength: 360,
                cornerRadiusTop: 8,
                cornerRadiusBottom: 8,
                cornerSegments: 8,
              },
              _.parameters
            );
            return (
              (R.thetaLength = rr.clamp(R.thetaLength, 0, 360)),
              {
                parameters: Object.assign(R, {
                  width: Math.abs(R.width),
                  height: Math.abs(R.height ?? R.width),
                  depth: Math.abs(R.depth ?? R.width),
                }),
              }
            );
          }
          static build(_) {
            let {
                width: I,
                depth: R,
                height: B,
                radialSegments: z,
                heightSegments: k,
                openEnded: V,
                thetaStart: j,
                thetaLength: G,
                cornerRadiusTop: q,
                cornerRadiusBottom: X,
                cornerSegments: Q,
              } = _.parameters,
              $;
            return (
              0 === G
                ? ($ = new ai()).setAttribute("position", new s4([], 3))
                : ($ =
                    q > 0 || X > 0 || G < 360
                      ? new y5(
                          0,
                          I / 2,
                          B,
                          z,
                          k,
                          V,
                          j,
                          (G * Math.PI) / 180,
                          q,
                          X,
                          Q,
                          0,
                          !0
                        )
                      : new oT(I / 2, B, z, k, V)),
              $.scale(1, 1, R / I),
              Object.assign($, { userData: { ..._, type: "ConeGeometry" } })
            );
          }
        },
        y8 = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R = Object.assign(
              {},
              I?.parameters ?? {
                width: 100,
                widthSegments: 1,
                heightSegments: 1,
                depthSegments: 1,
                cornerRadius: 8,
                cornerSegments: 8,
              },
              _.parameters
            );
            return {
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? R.width),
              }),
            };
          }
          static build(_) {
            let {
              width: I,
              height: R,
              depth: B,
              widthSegments: z,
              heightSegments: k,
              depthSegments: V,
              cornerRadius: j,
              cornerSegments: G,
            } = _.parameters;
            return Object.assign(
              0 == j
                ? new aS(I, R, B, z, k, V)
                : new y7(I, R, B, z, k, V, j, G),
              { userData: { ..._, type: "CubeGeometry" } }
            );
          }
        },
        y9 = Math.PI / 2,
        y7 = class extends ai {
          constructor(_ = 1, I = 1, R = 1, B = 1, z = 1, k = 1, V = 0, j = 4) {
            super(), (this.type = "BoxGeometry");
            let G = this;
            (B = Math.floor(B)),
              (z = Math.floor(z)),
              (k = Math.floor(k)),
              (j = Math.floor(j)),
              (V = Math.min(V, _ / 2, I / 2, R / 2));
            let q = [],
              X = [],
              Q = [],
              $ = [],
              et = 0,
              er = 0;
            function g(_, I, R, B, z, k, j, es, ea, en, eo) {
              let el = (k - 2 * V) / ea,
                eh = (j - 2 * V) / en,
                ec = k / 2 - V,
                ed = j / 2 - V,
                ep = es / 2,
                ef = ea + 1,
                em = en + 1,
                ey = 0,
                ex = 0,
                eb = new rF();
              for (let k = 0; k < em; k++) {
                let V = k * eh - ed;
                for (let j = 0; j < ef; j++) {
                  let G = j * el - ec;
                  (eb[_] = G * B),
                    (eb[I] = V * z),
                    (eb[R] = ep),
                    X.push(eb.x, eb.y, eb.z),
                    (eb[_] = 0),
                    (eb[I] = 0),
                    (eb[R] = es > 0 ? 1 : -1),
                    Q.push(eb.x, eb.y, eb.z),
                    $.push(j / ea),
                    $.push(1 - k / en),
                    (ey += 1);
                }
              }
              for (let _ = 0; _ < en; _++)
                for (let I = 0; I < ea; I++) {
                  let R = et + I + ef * _,
                    B = et + I + ef * (_ + 1),
                    z = et + (I + 1) + ef * (_ + 1),
                    k = et + (I + 1) + ef * _;
                  q.push(R, B, k), q.push(B, z, k), (ex += 6);
                }
              G.addGroup(er, ex, eo), (er += ex), (et += ey);
            }
            function y(_, I, R, B, z, k, es, ea, en, eo, el) {
              let eh = (es - 2 * V) / eo,
                ec = es / 2 - V,
                ed = ea / 2 - V,
                ep = en / 2,
                ef = eo + 1,
                em = 0,
                ey = 0,
                ex = new rF(),
                eb = new rF();
              for (let G = 0; G < j + 1; G++) {
                let q = (G / j) * y9,
                  et = Math.sin(q) * V,
                  er = (1 - Math.cos(q)) * V,
                  es = Math.sin(q),
                  ea = Math.cos(q);
                (ex[I] = (ed + et) * z),
                  (ex[R] = (ep - er) * k),
                  (eb[_] = 0),
                  (eb[I] = es * Math.sign(ex[I])),
                  (eb[R] = ea * Math.sign(ex[R]));
                for (let I = 0; I < ef; I++) {
                  let R = I * eh - ec;
                  (ex[_] = R * B),
                    X.push(ex.x, ex.y, ex.z),
                    Q.push(eb.x, eb.y, eb.z),
                    $.push(I / eo),
                    $.push(0),
                    (em += 1);
                }
              }
              for (let _ = 0; _ < j; _++)
                for (let I = 0; I < eo; I++) {
                  let R = et + I + ef * _,
                    B = et + I + ef * (_ + 1),
                    z = et + (I + 1) + ef * (_ + 1),
                    k = et + (I + 1) + ef * _;
                  q.push(R, B, k), q.push(B, z, k), (ey += 6);
                }
              G.addGroup(er, ey, el), (er += ey), (et += em);
            }
            function v(B, z, k) {
              let G = new rF(),
                er = new rF(_ / 2, I / 2, R / 2);
              er.subScalar(V);
              let es = [],
                ea =
                  B * z * k > 0
                    ? (_, I, R) => q.push(_, I, R)
                    : (_, I, R) => q.push(_, R, I);
              for (let _ = 0; _ <= j; _++) {
                let I = [],
                  R = y9 * (1 - _ / j),
                  q = Math.cos(R),
                  ea = Math.sin(R),
                  en = 0;
                for (let R = 0; R <= _; R++) {
                  let R = Math.cos(en),
                    j = Math.sin(en);
                  (G.x = q * R), (G.y = ea), (G.z = q * j);
                  let es = er.clone().addScaledVector(G, V);
                  X.push(B * es.x, z * es.y, k * es.z),
                    Q.push(B * G.x, z * G.y, k * G.z),
                    $.push(0, 0),
                    I.push(et++),
                    (en += y9 / _);
                }
                es.push(I);
              }
              let en = es.length - 1;
              for (let _ = 0; _ < en; _++) {
                let I = es[_],
                  R = es[_ + 1],
                  B = I.length - 1;
                ea(I[0], R[1], R[0]);
                for (let _ = 1; _ <= B; _++)
                  ea(I[_ - 1], I[_], R[_]), ea(I[_], R[_ + 1], R[_]);
              }
            }
            g("z", "y", "x", -1, -1, R, I, _, k, z, 0),
              g("z", "y", "x", 1, -1, R, I, -_, k, z, 1),
              g("x", "z", "y", 1, 1, _, R, I, B, k, 2),
              g("x", "z", "y", 1, -1, _, R, -I, B, k, 3),
              g("x", "y", "z", 1, -1, _, I, R, B, z, 4),
              g("x", "y", "z", -1, -1, _, I, -R, B, z, 5),
              V > 0 &&
                (y("z", "y", "x", -1, -1, 1, R, I, _, k, 0),
                y("z", "y", "x", 1, -1, -1, R, I, _, k, 1),
                y("z", "y", "x", -1, 1, -1, R, I, _, k, 1),
                y("z", "y", "x", 1, 1, 1, R, I, _, k, 0),
                y("x", "y", "z", -1, -1, -1, _, I, R, B, 0),
                y("x", "y", "z", 1, -1, 1, _, I, R, B, 1),
                y("x", "y", "z", -1, 1, 1, _, I, R, B, 0),
                y("x", "y", "z", 1, 1, -1, _, I, R, B, 1),
                y("y", "x", "z", -1, -1, 1, I, _, R, z, 0),
                y("y", "x", "z", 1, -1, -1, I, _, R, z, 1),
                y("y", "x", "z", 1, 1, 1, I, _, R, z, 1),
                y("y", "x", "z", -1, 1, -1, I, _, R, z, 0),
                v(1, 1, 1),
                v(-1, 1, 1),
                v(1, -1, 1),
                v(-1, -1, 1),
                v(1, 1, -1),
                v(-1, 1, -1),
                v(1, -1, -1),
                v(-1, -1, -1)),
              this.setIndex(q),
              this.setAttribute("position", new s4(X, 3)),
              this.setAttribute("normal", new s4(Q, 3)),
              this.setAttribute("uv", new s4($, 2));
          }
        },
        xe = class extends ai {
          constructor(_ = [], I = [], R = "", B = 1, z = 0.2, k = 4) {
            super(), (this.type = "PolyhedronGeometryRound");
            let V = [],
              j = [],
              G = [];
            (function () {
              0 == (z = Math.min(1 - 1e-5, z)) && (k = 0);
              let j = {
                  IcosahedronGeometry: 5,
                  DodecahedronGeometry: 3,
                  HexahedronGeometry: 3,
                  OctahedronGeometry: 4,
                  TetrahedronGeometry: 3,
                }[R],
                q = new rF(),
                X = q.clone(),
                Q = new sX(),
                $ = z * B,
                et = B - $,
                er = k + 1,
                es = new rF(),
                w = (_, I) => es.subVectors(_, I).normalize(),
                A = (_, I) =>
                  Array(_)
                    .fill(void 0)
                    .map(I),
                ea = A(_.length / 3, (I, R) =>
                  new rF().fromArray(_, 3 * R).setLength(B)
                ),
                en = [];
              for (let _ = 0; _ < ea.length; _++) {
                let R = ea[_],
                  B = [],
                  z,
                  k,
                  V,
                  j = 1e10,
                  G = -1;
                for (; -1 != (G = I.indexOf(_, G + 1)); ) {
                  let _ = G - (G % 3);
                  (z = I[_ + ((G + 1) % 3)]),
                    (k = I[_ + ((G + 2) % 3)]),
                    (j = Math.min(j, (V = R.distanceToSquared(ea[z])))),
                    B.push([z, k, V]);
                }
                j += 1e-6;
                let q = [],
                  X = 0,
                  Q = B.length;
                for (let I = 0; I < Q; I++) {
                  [z, k, V] = B[X];
                  let I = en[z]?.includes(_) == !0;
                  V <= j && q.push(z + 1e6 * +I),
                    (X = B.findIndex((_) => _[0] == k));
                }
                en.push(q);
              }
              let eo = [];
              {
                let _ = 0,
                  I = 0,
                  R,
                  B,
                  z = 3 == j;
                for (let V = 0; V <= k; V++) {
                  (R = (V * (V + 1)) / 2), (B = ((V + 1) * (V + 2)) / 2);
                  for (let j = 0; j < k - V; j++)
                    ([_, I] = [R + j + V + 2, B + j + V + 3]),
                      eo.push(R, B, ...(z ? [I, R] : [_, B]), I, _),
                      ([R, B] = [_, I]);
                  eo.push(R, B, R + k + 2);
                }
              }
              let el = q.clone(),
                eh = q.clone(),
                ec = q.clone(),
                ed = q.clone(),
                ep = q.clone(),
                ef = [],
                em = A(ea.length, () => A(j, () => q.clone()));
              for (let _ = 0; _ < ea.length; _++) {
                q.copy(ea[_]).normalize(), el.copy(q).multiplyScalar(et);
                let I = en[_];
                for (let R = 0; R < I.length; R++) {
                  let B = I[R],
                    z = I[(R + 1) % j];
                  Q.setFromPointsAndIndices(ea, _, B % 1e6, z % 1e6),
                    Q.b.sub(Q.a).setLength(1e10).add(Q.a),
                    Q.c.sub(Q.a).setLength(1e10).add(Q.a),
                    Q.closestPointToPoint(el, em[_][R]);
                }
                let R = [],
                  B = [],
                  z = [],
                  ey = new rF();
                0 == k &&
                  [...em[_]]
                    .reduce((_, I) => _.add(I), ey)
                    .multiplyScalar(1 / j);
                for (let I = 0; I < j; I++) {
                  let V = [],
                    G = (I - 1 + j) % j,
                    Q = em[_][G],
                    ea = em[_][I];
                  q.copy(Q).sub(el), X.copy(ea).sub(el);
                  let en = el.angleTo(q),
                    eo = q.angleTo(X),
                    ef = Math.cos(en) * $;
                  0 == k ? eh.copy(ey) : eh.copy(el).setLength(et + ef),
                    B.push(ef);
                  let ex = [eh, Q, ea];
                  for (let _ = 0; _ < 2; _++) {
                    let I = ex[_],
                      B = ex[_ + 1];
                    ed.subVectors(I, el),
                      ep.subVectors(B, el),
                      ec.crossVectors(ed, ep).normalize();
                    for (let B = 0; B < er; B++) {
                      let z = ([en, eo][_] * B) / er;
                      q.copy(ed).applyAxisAngle(ec, z).add(el),
                        R.push(q.clone()),
                        _ &&
                          (w(q, el),
                          V.push([0 == B ? I : q.clone(), es.clone()]));
                    }
                    _ && (w(B, el), V.push([B, es.clone()]));
                  }
                  z.push(V);
                }
                ef.push(z);
                let ex = 2 * er;
                for (let _ = 0; _ < j; _++) {
                  let I = ex * _,
                    z = ex * ((_ + 1) % j),
                    k = [R[I]];
                  for (let V = 1; V < er; V++) {
                    (ed = R[I + V]), (ep = R[z + V]), k.push(ed);
                    for (let I = 1, R = V - 2 + 1; I <= R; I++)
                      q.lerpVectors(ed, ep, I / (R + 1)),
                        q.sub(el).setLength(B[_]).add(el),
                        k.push(q.clone());
                    k.push(ep);
                  }
                  for (let _ = 0; _ < er; _++) k.push(R[_ + er + I]);
                  k.push(R[z + er]);
                  let X = eo.map((_) => k[_]);
                  V.push(...X.map((_) => [_.x, _.y, _.z]).flat()),
                    G.push(
                      ...X.map((_) => (w(_, el), [es.x, es.y, es.z])).flat()
                    );
                }
              }
              let ey = [];
              for (let _ = 0; _ < en.length; _++)
                for (let I = 0; I < j; I++) {
                  let R = en[_][I];
                  if (R < 1e6) {
                    let B = en[R].findIndex((I) => I % 1e6 == _),
                      z = ef[_][I],
                      k = ef[R][B];
                    for (let _ = 0; _ < er; _++) {
                      let I = z[_],
                        R = k[er - _],
                        B = z[_ + 1];
                      [I, R, B, B, R, k[er - (_ + 1)]].forEach((_) => {
                        V.push(_[0].x, _[0].y, _[0].z),
                          G.push(_[1].x, _[1].y, _[1].z);
                      });
                    }
                    ey.push(z[0][0], k[er][0], z[er][0], k[0][0]);
                  }
                }
              for (; ey.length; ) {
                let _, I, R, B;
                [_, I] = ey.splice(0, 2);
                let z = [_];
                for (; _ != I; )
                  z.push(I),
                    (B = (R = ey.indexOf(I)) % 2),
                    (I = ey.splice(R - B, 2)[1 - B]);
                es.subVectors(z[0], z[1])
                  .cross(q.subVectors(z[0], z[2]))
                  .normalize();
                let k = 0 > es.dot(z[0]);
                k && es.negate();
                for (let _ = 1; _ <= z.length - 2; _++)
                  [z[_ + +k], z[_ + 1 - +k], z[0]].forEach((_) => {
                    V.push(_.x, _.y, _.z), G.push(es.x, es.y, es.z);
                  });
              }
            })(),
              (function () {
                let _ = new rF();
                for (let I = 0; I < V.length; I += 3) {
                  (_.x = V[I + 0]), (_.y = V[I + 1]), (_.z = V[I + 2]);
                  let R = w(_) / 2 / Math.PI + 0.5,
                    B =
                      Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z)) /
                        Math.PI +
                      0.5;
                  j.push(R, 1 - B);
                }
                let I = new rF(),
                  R = new rF(),
                  B = new rF(),
                  z = new rF(),
                  k = new rs(),
                  G = new rs(),
                  q = new rs(),
                  S = (_, I, R, B) => {
                    B < 0 && 1 === _.x && (j[I] = _.x - 1),
                      0 === R.x && 0 === R.z && (j[I] = B / 2 / Math.PI + 0.5);
                  };
                for (let _ = 0, X = 0; _ < V.length; _ += 9, X += 6) {
                  I.set(V[_ + 0], V[_ + 1], V[_ + 2]),
                    R.set(V[_ + 3], V[_ + 4], V[_ + 5]),
                    B.set(V[_ + 6], V[_ + 7], V[_ + 8]),
                    k.set(j[X + 0], j[X + 1]),
                    G.set(j[X + 2], j[X + 3]),
                    q.set(j[X + 4], j[X + 5]),
                    z.copy(I).add(R).add(B).divideScalar(3);
                  let Q = w(z);
                  S(k, X + 0, I, Q), S(G, X + 2, R, Q), S(q, X + 4, B, Q);
                }
                for (let _ = 0; _ < j.length; _ += 6) {
                  let I = j[_ + 0],
                    R = j[_ + 2],
                    B = j[_ + 4],
                    z = Math.max(I, R, B),
                    k = Math.min(I, R, B);
                  z > 0.9 &&
                    k < 0.1 &&
                    (I < 0.2 && (j[_ + 0] += 1),
                    R < 0.2 && (j[_ + 2] += 1),
                    B < 0.2 && (j[_ + 4] += 1));
                }
                function w(_) {
                  return Math.atan2(_.z, -_.x);
                }
              })(),
              this.setAttribute("position", new s4(V, 3)),
              this.setAttribute("normal", new s4(G, 3)),
              this.setAttribute("uv", new s4(j, 2));
          }
          static fromJSON(_) {
            return new xe(
              _.vertices,
              _.indices,
              _.radius,
              _.corner,
              _.cornerSides
            );
          }
        },
        xi = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R = Object.assign(
              {},
              I?.parameters ?? {
                width: 100,
                detail: 0,
                corner: 0,
                cornerSides: 4,
              },
              _.parameters
            );
            return {
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? R.width),
              }),
            };
          }
          static build(_) {
            let {
                width: I,
                height: R,
                depth: B,
                detail: z,
                corner: k,
                cornerSides: V,
              } = _.parameters,
              j =
                0 === z && 0 !== k ? new xr(0.5 * I, k, V) : new oD(0.5 * I, z);
            return (
              j.scale(1, R / I, B / I),
              Object.assign(j, {
                userData: { ..._, type: "DodecahedronGeometry" },
              })
            );
          }
        },
        xr = class extends xe {
          constructor(_ = 1, I = 0.2, R = 4) {
            let B = (1 + Math.sqrt(5)) / 2,
              z = 1 / B,
              k = "DodecahedronGeometry";
            super(
              [
                -1,
                -1,
                -1,
                -1,
                -1,
                1,
                -1,
                1,
                -1,
                -1,
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                1,
                1,
                1,
                -1,
                1,
                1,
                1,
                0,
                -z,
                -B,
                0,
                -z,
                B,
                0,
                z,
                -B,
                0,
                z,
                B,
                -z,
                -B,
                0,
                -z,
                B,
                0,
                z,
                -B,
                0,
                z,
                B,
                0,
                -B,
                0,
                -z,
                B,
                0,
                -z,
                -B,
                0,
                z,
                B,
                0,
                z,
              ],
              [
                3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15,
                17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0,
                12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2,
                16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4,
                14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19,
                5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
              ],
              k,
              _,
              I,
              R
            ),
              (this.type = k);
          }
          static fromJSON(_) {
            return new xr(_.radius, _.corner, _.cornerSides);
          }
        },
        xs = class {
          constructor(_) {
            (this.position = new rs()),
              (this.startPosition = new rs()),
              (this.uuid = rr.generateUUID()),
              (this.position = _.clone());
          }
          start() {
            this.reset();
          }
          reset() {
            this.startPosition.copy(this.position);
          }
          applyOffset(_) {
            this.position.copy(this.startPosition).add(_);
          }
          copy(_) {
            return (
              this.position.copy(_.position),
              this.startPosition.copy(_.startPosition),
              this
            );
          }
          clone() {
            return new xs(this.position).copy(this);
          }
          toJSON() {
            return [this.position.x, this.position.y];
          }
        },
        xa = class extends xs {
          constructor(_) {
            super(_.position), (this.parent = _);
          }
          copy(_) {
            return super.copy(_), this;
          }
          clone() {
            return new xa(this.parent).copy(this);
          }
        },
        xn = class extends xs {
          constructor(_, I) {
            super(I),
              (this.controls = []),
              (this.roundness = 0),
              (this.areControlsDirectionsMirrored = !0),
              (this.uuid = _),
              this.controls.push(new xa(this), new xa(this));
          }
          static create(_, I) {
            let R = new xn(_, new rs(...I.position));
            return (
              R.controls[0].position.set(...I.controlPrevious.position),
              R.controls[1].position.set(...I.controlNext.position),
              (R.roundness = I.roundness),
              (R.areControlsDirectionsMirrored =
                I.areControlsDirectionsMirrored),
              R
            );
          }
          getOppositeControl(_) {
            let I = this.controls.indexOf(_);
            return 0 === I
              ? this.controls[1]
              : 1 === I
              ? this.controls[0]
              : null;
          }
          applyOffsetToControls(_, I = 1) {
            for (let R = 0, B = this.controls.length; R < B; R++) {
              let B = this.controls[R];
              this.position.distanceTo(B.position) <= I
                ? B.position.copy(this.position)
                : B.applyOffset(_);
            }
          }
          controlsMoved() {
            return !(
              this.position.equals(this.controls[0].position) &&
              this.position.equals(this.controls[1].position)
            );
          }
          copy(_) {
            return (
              super.copy(_),
              this.controls[0].copy(_.controls[0]),
              this.controls[1].copy(_.controls[1]),
              (this.roundness = _.roundness),
              (this.uuid = _.uuid),
              this
            );
          }
          clone() {
            return new xn(this.uuid, this.position).copy(this);
          }
          toJSON() {
            return super
              .toJSON()
              .concat(this.controls[0].toJSON(), this.controls[1].toJSON(), [
                this.roundness,
              ]);
          }
          computeTangents() {
            return [
              this.curveBefore?.getTangentAt(1),
              this.curveAfter?.getTangentAt(0),
            ];
          }
          computeNormals(_ = new rs(), I = new rs()) {
            let [R, B] = this.computeTangents();
            return R && B && (zO(R, _), zO(B, I)), [_, I];
          }
          computeTangent(_ = new rs()) {
            let [I, R] = this.computeTangents();
            return I && R && _.copy(I).add(R).normalize(), _;
          }
          computeNormal(_ = new rs()) {
            let [I, R] = this.computeNormals();
            return _.copy(I).add(R).normalize(), _;
          }
        };
      function zO(_, I = new rs()) {
        let R = _.length();
        return I.set(-_.y / R, _.x / R);
      }
      var fA = (_) => _,
        xo = new rs(),
        xh = new rs(),
        xc = new rs(),
        xd = new rs(),
        xp = new rs(),
        xf = new rs(),
        xm = new rF(),
        xg = new rF();
      function bm(_, I, R = Number.EPSILON) {
        return Math.abs(_ - I) < R;
      }
      function pA(_, I, R) {
        let B = Math.sqrt(Math.pow(I.x - _.x, 2) + Math.pow(I.y - _.y, 2)),
          z = Math.sqrt(Math.pow(I.x - R.x, 2) + Math.pow(I.y - R.y, 2)),
          k = Math.sqrt(Math.pow(R.x - _.x, 2) + Math.pow(R.y - _.y, 2));
        return Math.acos((z * z + B * B - k * k) / (2 * z * B));
      }
      function dA(_, I, R) {
        return 0 === xo.copy(I).sub(_).cross(xh.copy(R).sub(_));
      }
      function mA(_, I) {
        return (
          _.position.equals(_.controls[1].position) &&
          I.position.equals(I.controls[0].position)
        );
      }
      function UO(_, I) {
        return (
          dA(_.position, _.controls[1].position, I.position) &&
          dA(_.position, I.controls[0].position, I.position)
        );
      }
      function gA(_, I = 12, R = !1) {
        let B = [];
        for (let z = 0, k = _.length; z < k; z++) {
          let k = _[z],
            V = 0;
          if (R && void 0 !== k.roundedCurveCorner) {
            let _ = 0.5 * Gl(k.roundedCurveCorner, I);
            z > 0 && (B[z - 1] += _), (V += _);
          }
          void 0 !== k.curveAfter && (V += Gl(k.curveAfter, I)), B.push(V);
        }
        return (
          _.length > 0 &&
            R &&
            void 0 !== _[0].roundedCurveCorner &&
            (B[_.length - 1] += 0.5 * Gl(_[0].roundedCurveCorner, I)),
          B
        );
      }
      function Gl(_, I = 12) {
        return _ && _ instanceof oo
          ? 2 * I
          : _ && (_ instanceof og || _ instanceof ox)
          ? 1
          : _ && _ instanceof o_
          ? I * _.points.length
          : I;
      }
      var xy = new rs(),
        xx = new rs(),
        xw = new rs(),
        xS = new rs(),
        xA = new rs(),
        xM = new rs(),
        xT = class extends oR {
          constructor(_ = 100, I = 100) {
            super(),
              (this.points = []),
              (this.shapeHoles = []),
              (this.plane = new aV(new rF(0, 0, -1))),
              (this.subdivision = 0),
              (this.controlSnapDistance = 4),
              (this.pointIDs = 0),
              (this.isMesh2D = !1),
              (this.isText = !1),
              (this._roundness = 0),
              (this.isClosed = !1),
              (this.useCubicForRoundedCorners = !0),
              (this.uuid = rr.generateUUID()),
              (this.needsUpdate = !1),
              (this.roundedCurves = []),
              (this._width = _),
              (this._height = I);
          }
          static createFromState(_, I, R) {
            let B = new xT();
            return (
              (B.isClosed = _.isClosed),
              (B.points = _.points.map((_) => xn.create(_.id, _.data))),
              "number" == typeof _.roundness && (B.roundness = _.roundness),
              (B.shapeHoles = _.shapeHoles.map((_) => xT.createFromState(_))),
              void 0 !== I && void 0 !== R && B.applySize(I, R),
              B.update(),
              B
            );
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get roundness() {
            return this._roundness;
          }
          set roundness(_) {
            if (this._roundness !== _) {
              this._roundness = _;
              for (let I = 0, R = this.points.length; I < R; I++)
                this.points[I].roundness = _;
              this.needsUpdate = !0;
            }
          }
          getPointsIndexesByIds(_) {
            return _.map((_) => this.getPointIndexById(_)).filter(
              (_) => _ >= 0
            );
          }
          getPointIndexById(_) {
            let I = this.points.length,
              R = this.points.findIndex((I) => I.uuid === _);
            if (R < 0) {
              let R = I;
              for (let I = 0, B = this.shapeHoles.length; I < B; I++) {
                let B = this.shapeHoles[I],
                  z = B.points.length,
                  k = B.getPointIndexById(_);
                if (!(k < 0)) return k + R;
                R += z;
              }
            }
            return R;
          }
          getLineIndexById(_) {
            return this.getPointIndexById(_);
          }
          getBezierPoint(_) {
            if (_ <= this.points.length - 1) return this.points[_];
            if (this.shapeHoles.length > 0) {
              let I = this.points.length;
              for (let R = 0, B = this.shapeHoles.length; R < B; R++) {
                let B = this.shapeHoles[R],
                  z = _ - I;
                if (z <= B.points.length - 1) return B.points[z];
                I += B.points.length;
              }
            }
            throw Error(
              "This shape does not have a point for this index: " + _
            );
          }
          getBezierPointIndex(_) {
            let I = this.points.indexOf(_);
            if (I >= 0) return I;
            if (((I = this.points.length), this.shapeHoles.length > 0))
              for (let R = 0, B = this.shapeHoles.length; R < B; R++) {
                let B = this.shapeHoles[R],
                  z = B.points.indexOf(_);
                if (z >= 0) return I + z;
                I += B.points.length;
              }
            return -1;
          }
          getAllPoints() {
            let _ = [].concat(...this.shapeHoles.map((_) => _.points));
            return [...this.points, ..._];
          }
          applySize(_, I) {
            0 === _ && (_ = 0.001),
              0 === I && (I = 0.001),
              (this._width = _),
              (this._height = I);
          }
          applyScale(_, I) {
            let R = xy.set(_, I);
            for (let _ = 0, I = this.points.length; _ < I; _++) {
              let I = this.points[_];
              I.position.multiply(R),
                I.controls[0].position.multiply(R),
                I.controls[1].position.multiply(R);
            }
            for (let R = 0, B = this.shapeHoles.length; R < B; R++)
              this.shapeHoles[R].applyScale(_, I);
            this._update();
          }
          createPoint(_, I = 0, R = rr.generateUUID()) {
            let B;
            B = _ instanceof rs ? _ : new rs(_, I);
            let z = new xn(R, B);
            return (z.roundness = this.roundness), z;
          }
          addPoint(_) {
            this.points.push(_), (this.needsUpdate = !0);
          }
          addPointAt(_, I) {
            this.points.splice(I, 0, _), (this.needsUpdate = !0);
          }
          getPointByUuid(_) {
            for (let I = 0, R = this.points.length; I < R; I++) {
              let R = this.points[I];
              if (R.uuid === _) return R;
            }
            for (let I = 0, R = this.shapeHoles.length; I < R; I++) {
              let R = this.shapeHoles[I].getPointByUuid(_);
              if (R) return R;
            }
          }
          getFirstPoint() {
            return this.points[0];
          }
          getLastPoint() {
            return this.points[this.points.length - 1];
          }
          removePoint(_) {
            let I = this.points.indexOf(_);
            I >= 0 && this.points.splice(I, 1), (this.needsUpdate = !0);
          }
          removePointById(_) {
            let I = this.points.find((I) => I.uuid === _);
            I && this.removePoint(I);
          }
          update() {
            for (let _ = 0, I = this.shapeHoles.length; _ < I; _++)
              this.shapeHoles[_].update();
            this._update();
          }
          extractShapePointsToBuffer(_, I = 12, R = !1) {
            (this.subdivision = I),
              void 0 === this.curveDivisions && this.computeCurveDivisions(I);
            let B = R ? this.roundedCurveDivisions : this.curveDivisions;
            return (
              (function (_, I, R = 12, B = !0) {
                let z = xg.set(0, 0, 0),
                  k,
                  V = 0,
                  j = [];
                for (let B = 0; B < I.length; B++) {
                  let G = fA(I[B]),
                    q = Gl(G, R);
                  j.push(q);
                  for (let I = 0; I <= q; I++)
                    if (G instanceof of || G instanceof ob || G instanceof og) {
                      if (
                        (G.getPoint(I / q, xo),
                        z.set(xo.x, xo.y, 0),
                        void 0 !== k &&
                          (function (_, I, R = Number.EPSILON) {
                            return _.distanceTo(I) < R;
                          })(k, z))
                      )
                        continue;
                      void 0 === k && (k = xm),
                        k.copy(z),
                        _.setXYZ(V, z.x, z.y, z.z),
                        V++;
                    }
                }
                B &&
                  V > 1 &&
                  !(
                    _.getX(V - 1) === _.getX(0) &&
                    _.getY(V - 1) === _.getY(0) &&
                    _.getZ(V - 1) === _.getZ(0)
                  ) &&
                  (_.setXYZ(V, _.getX(0), _.getY(0), _.getZ(0)), V++);
              })(_, R ? this.roundedCurves : this.curves, I, this.autoClose),
              B.reduce((_, I) => _ + I, 0) + 1
            );
          }
          computeCurveDivisions(_ = 12) {
            return (
              (this.curveDivisions = gA(this.points, _, !1)),
              (this.roundedCurveDivisions = gA(this.points, _, !0)),
              this.curveDivisions
            );
          }
          extractFilteredShapePointsToBuffer(_, I, R = 12) {
            return (
              2 *
              (function (_, I, R, B = 12, z = !0) {
                let k = xg.set(0, 0, 0),
                  V = 0,
                  j = [];
                for (let z = 0; z < I.length; z++) {
                  if (!1 === R[z]) continue;
                  let G,
                    q = fA(I[z]),
                    X = Gl(q, B);
                  j.push(X);
                  for (let I = 0; I <= X; I++)
                    if (q instanceof of || q instanceof ob || q instanceof og) {
                      if (
                        (q.getPoint(I / X, xo),
                        k.set(xo.x, xo.y, 0),
                        G?.equals(k))
                      )
                        continue;
                      void 0 === G
                        ? (G = xm)
                        : (_.setXYZ(V, G.x, G.y, G.z),
                          V++,
                          _.setXYZ(V, k.x, k.y, k.z),
                          V++),
                        G.copy(k);
                    }
                }
                return (
                  z &&
                    V > 1 &&
                    !(
                      _.getX(V - 1) === _.getX(0) &&
                      _.getY(V - 1) === _.getY(0) &&
                      _.getZ(V - 1) === _.getZ(0)
                    ) &&
                    (_.setXYZ(V, _.getX(0), _.getY(0), _.getZ(0)), V++),
                  j
                );
              })(_, this.curves, I, R, this.autoClose).reduce(
                (_, I) => _ + I,
                0
              )
            );
          }
          extractShapePointsToFlatArray(_, I = 12) {
            return (
              (this.subdivision = I),
              void 0 === this.curveDivisions && this.computeCurveDivisions(I),
              (function (_, I, R = 12, B = !0) {
                let z,
                  k = 0;
                for (let B = 0; B < I.length; B++) {
                  let V = fA(I[B]),
                    j = Gl(V, R);
                  for (let I = 0; I <= j; I++)
                    if (V instanceof of || V instanceof ob || V instanceof og) {
                      if (
                        (V.getPoint(I / j, xo),
                        void 0 !== z &&
                          (function (_, I, R = Number.EPSILON) {
                            return _.distanceTo(I) < R;
                          })(z, xo, 1e-12))
                      )
                        continue;
                      void 0 === z && (z = xh),
                        z.copy(xo),
                        _.push(xo.x, xo.y),
                        k++;
                    }
                }
                return (
                  bm(_[0], _[_.length - 2], 1e-12) &&
                    bm(_[1], _[_.length - 1], 1e-12) &&
                    (_.pop(), _.pop()),
                  B &&
                    k > 1 &&
                    !(bm(_[k - 1], _[1], 1e-12) && bm(_[k - 2], _[0], 1e-12)) &&
                    (_.push(_[0], _[1]), k++),
                  _
                );
              })(_, this.roundedCurves, I, this.autoClose)
            );
          }
          getCurveIndexFromVertexId(_, I = !1) {
            let R = 0;
            void 0 === this.curveDivisions &&
              this.computeCurveDivisions(this.subdivision);
            let B = I ? this.roundedCurveDivisions : this.curveDivisions,
              z = 0;
            I &&
              void 0 !== this.points[0].roundedCurveCorner &&
              (z =
                0.5 * Gl(this.points[0].roundedCurveCorner, this.subdivision));
            let k = _ - z;
            k < 0 && (k += B.reduce((_, I) => _ + I, 0));
            for (let _ = 0, I = B.length; _ < I; _++) {
              let I = B[_];
              if (k < R + I) return [_, (k - R + 1) / I];
              R += I;
            }
            return [0, 1];
          }
          getCurveT(_, I, R) {
            let B = this.points[_],
              z = this.points[_ >= this.points.length - 1 ? 0 : _ + 1],
              k = this.curveDivisions,
              V = k[_];
            if (mA(B, z)) {
              let _ = B.position.distanceTo(z.position);
              return B.position.distanceTo(xy.set(R.x, R.y)) / _;
            }
            let j = 0;
            for (let I = 0; I < _; I++) j += k[I];
            return (I - j) / V;
          }
          dispose() {}
          _applyCurveForPoint(_, I) {
            mA(I, _)
              ? this.lineTo(_.position.x, _.position.y)
              : this.bezierCurveTo(
                  I.controls[1].position.x,
                  I.controls[1].position.y,
                  _.controls[0].position.x,
                  _.controls[0].position.y,
                  _.position.x,
                  _.position.y
                );
            let R = this.curves[this.curves.length - 1];
            (_.curveBefore = R), (I.curveAfter = R);
            let B = R.clone();
            (_.roundedCurveBefore = B),
              (I.roundedCurveAfter = B),
              (_.roundedCurveCorner = void 0),
              this.roundedCurves.push(B);
          }
          _update() {
            if (
              ((this.curves = []),
              (this.roundedCurves = []),
              !this.points.length)
            )
              return;
            for (let _ = 0, I = this.points.length; _ < I; _++) {
              let I = this.points[_];
              if (0 === _) this.moveTo(I.position.x, I.position.y);
              else {
                let R = this.points[_ - 1];
                this._applyCurveForPoint(I, R);
              }
            }
            let _ = this.getLastPoint();
            if ((_?.curveAfter && (_.curveAfter = void 0), this.isClosed)) {
              let _ = this.points[0],
                I = this.points[this.points.length - 1];
              this._applyCurveForPoint(_, I);
            }
            if (this.points.length > 2) {
              let _ = 0;
              for (let R = 0, B = this.points.length; R < B; R++) {
                var I;
                let B = this.points[R],
                  z = this.points[R - 1] ?? this.points[this.points.length - 1],
                  k = this.points[R + 1] ?? this.points[0],
                  V = B.roundness,
                  j =
                    z &&
                    k &&
                    UO(z, B) &&
                    UO(B, k) &&
                    dA(z.position, B.position, k.position);
                if (!B.controlsMoved() && V > 0 && !j) {
                  let z,
                    k = B.curveBefore,
                    j = B.curveAfter;
                  if (void 0 === k || void 0 === j) continue;
                  let G = B.roundedCurveBefore,
                    q = B.roundedCurveAfter,
                    X = k.getLength(),
                    Q = j.getLength(),
                    $ = Math.min(
                      Math.min(V, 0.499 * X),
                      Math.min(V, 0.499 * Q)
                    ),
                    et = 1 - $ / X,
                    er = $ / Q,
                    es = k.getPointAt(et, xy),
                    ea = j.getPointAt(er, xx);
                  if (
                    (this._subSplitCurve(k, G, et, es, void 0),
                    this._subSplitCurve(j, q, er, void 0, ea),
                    this.useCubicForRoundedCorners)
                  ) {
                    let _ =
                        Math.tan(pA(es, B.position, ea) / 2) *
                        es.distanceTo(B.position),
                      [R, k] = (function (_, I, R, B, z) {
                        let k = Math.sqrt(
                            Math.pow(I.x - _.x, 2) + Math.pow(I.y - _.y, 2)
                          ),
                          V = (_.y + I.y) / 2,
                          j = (_.x + I.x) / 2,
                          G =
                            (Math.sqrt(Math.pow(R, 2) - Math.pow(k / 2, 2)) *
                              (_.y - I.y)) /
                            k,
                          q =
                            (Math.sqrt(Math.pow(R, 2) - Math.pow(k / 2, 2)) *
                              (I.x - _.x)) /
                            k;
                        return B.set(j + G, V + q), z.set(j - G, V - q), [B, z];
                      })(es, ea, _, xw, xS),
                      [V, j] = (function (_, I, R, B, z, k) {
                        let V = I.x - _.x,
                          j = I.y - _.y,
                          G = R.x - _.x,
                          q = R.y - _.y,
                          X = Math.sqrt((V + G) * (V + G) + (j + q) * (j + q)),
                          Q;
                        return (
                          pA(I, _, R) > Math.PI && (X *= -1),
                          (Q = bm(q, j)
                            ? ((j + q) * (B / X - 0.5) * 8) / 3 / (V - G)
                            : ((V + G) * (B / X - 0.5) * 8) / 3 / (q - j)),
                          z.set(I.x - Q * j, I.y + Q * V),
                          k.set(R.x + Q * q, R.y - Q * G),
                          [z, k]
                        );
                      })(
                        ((I = B.position),
                        R.distanceTo(I) < k.distanceTo(I) ? k : R),
                        es,
                        ea,
                        _,
                        xA,
                        xM
                      );
                    z = new of(es.clone(), V.clone(), j.clone(), ea.clone());
                  } else z = new ob(es.clone(), B.position.clone(), ea.clone());
                  (B.roundedCurveCorner = z),
                    this.roundedCurves.splice(R + _, 0, z),
                    _++;
                }
              }
            }
          }
          _subSplitCurve(_, I, R, B, z) {
            if (_ instanceof og)
              void 0 !== B && I.v2.copy(B), void 0 !== z && I.v1.copy(z);
            else {
              let k = _.getUtoTmapping(R, 0),
                V = (function (_, I, R, B, z = 0.5) {
                  let k = xo.subVectors(I, _).multiplyScalar(z).add(_),
                    V = xh.subVectors(R, I).multiplyScalar(z).add(I),
                    j = xc.subVectors(B, R).multiplyScalar(z).add(R),
                    G = xd.subVectors(V, k).multiplyScalar(z).add(k),
                    q = xp.subVectors(j, V).multiplyScalar(z).add(V),
                    X = xf.subVectors(q, G).multiplyScalar(z).add(G);
                  return [
                    _.x,
                    _.y,
                    k.x,
                    k.y,
                    G.x,
                    G.y,
                    X.x,
                    X.y,
                    q.x,
                    q.y,
                    j.x,
                    j.y,
                    B.x,
                    B.y,
                  ];
                })(_.v0, _.v1, _.v2, _.v3, k);
              return (
                void 0 !== B &&
                  (I.v0.set(V[0], V[1]),
                  I.v1.set(V[2], V[3]),
                  I.v2.set(V[4], V[5]),
                  I.v3.set(V[6], V[7])),
                void 0 !== z &&
                  (I.v0.set(V[6], V[7]),
                  I.v1.set(V[8], V[9]),
                  I.v2.set(V[10], V[11]),
                  I.v3.set(V[12], V[13])),
                I
              );
            }
            return I;
          }
          clone() {
            let _ = new xT(this._width, this._height);
            return (
              (_.points = this.points.map((_) => _.clone())),
              (_.isClosed = this.isClosed),
              (_.roundness = this.roundness),
              (_.isMesh2D = this.isMesh2D),
              (_.shapeHoles = this.shapeHoles.map((_) => _.clone())),
              _
            );
          }
          toJSON() {
            return {
              points: this.points.reduce((_, I) => _.concat(I.toJSON()), []),
              shapeHoles: this.shapeHoles.map((_) => _.toJSON()),
              isClosed: this.isClosed,
              roundness: this.roundness,
            };
          }
          fromJSON(_) {
            (this.points = []), (this.pointIDs = 0);
            let I = _.points.length / 7;
            for (let R = 0; R < I; R++) {
              let I = 7 * R,
                B = _.points[I + 0],
                z = _.points[I + 1],
                k = _.points[I + 2],
                V = _.points[I + 3],
                j = _.points[I + 4],
                G = _.points[I + 5],
                q = _.points[I + 6],
                X = new xn(rr.generateUUID(), new rs(B, z));
              X.controls[0].position.set(k, V),
                X.controls[1].position.set(j, G),
                (X.roundness = q),
                this.points.push(X);
            }
            return (
              (this.shapeHoles = _.shapeHoles?.length
                ? _.shapeHoles.map((_) => {
                    let I = new xT();
                    return I.fromJSON(_), I;
                  })
                : []),
              (this.isClosed = _.isClosed),
              (this._roundness = _.roundness),
              this._update(),
              this
            );
          }
          fromShape(_, I = !1) {
            this.isText = I;
            let i = (_, I) => {
              I instanceof of &&
                I.v3.equals(_.position) &&
                _.controls[0].position.copy(I.v2);
            };
            return (
              (this.points = ((_) => {
                let I = [],
                  R,
                  B;
                for (R = 0, B = _.length; R < B; R++)
                  _[R] instanceof ob &&
                    (_[R] = (function (_) {
                      let I = new rs();
                      I.addVectors(
                        _.v0,
                        xo.subVectors(_.v1, _.v0).multiplyScalar(2 / 3)
                      );
                      let R = new rs();
                      return (
                        R.addVectors(
                          _.v2,
                          xh.subVectors(_.v1, _.v2).multiplyScalar(2 / 3)
                        ),
                        new of(_.v0, I, R, _.v2)
                      );
                    })(_[R]));
                for (R = 0, B = _.length; R < B; R++) {
                  let B = _[R],
                    z = R > 0 ? _[R - 1] : null,
                    k;
                  B instanceof of
                    ? (k = this.createPoint(B.v0)).controls[1].position.copy(
                        B.v1
                      )
                    : B instanceof og && (k = this.createPoint(B.v1)),
                    void 0 !== k && (null !== z && i(k, z), I.push(k));
                }
                let z = _[_.length - 1],
                  k = !1;
                return (
                  z instanceof of
                    ? z.v3.equals(I[0].position) &&
                      (I[0].controls[0].position.copy(z.v2), (k = !0))
                    : z instanceof og && z.v2.equals(I[0].position) && (k = !0),
                  (this.isClosed = k),
                  I
                );
              })(_.curves)),
              _ instanceof oR &&
                (this.shapeHoles = _.holes.map((_) => {
                  let I = new xT();
                  return I.fromShape(_), I;
                })),
              this.update(),
              this
            );
          }
          updatePoint(_, I) {
            let R = this.getPointByUuid(_);
            R &&
              (void 0 !== I.position && R.position.fromArray(I.position),
              void 0 !== I.roundness && (R.roundness = I.roundness),
              void 0 !== I.areControlsDirectionsMirrored &&
                (R.areControlsDirectionsMirrored =
                  I.areControlsDirectionsMirrored),
              (this.needsUpdate = !0));
          }
          updatePreviousControl(_, I) {
            let R = this.getPointByUuid(_)?.controls[0];
            R &&
              (I.position && R.position.fromArray(I.position),
              (this.needsUpdate = !0));
          }
          updateNextControl(_, I) {
            let R = this.getPointByUuid(_)?.controls[1];
            R &&
              (I.position && R.position.fromArray(I.position),
              (this.needsUpdate = !0));
          }
        },
        xD = 2 * Math.PI;
      function vA({ x: _, y: I }, R, B, z, k) {
        return { x: _ * R + z, y: I * B + k };
      }
      function $O(_, I, R, B) {
        let z = Math.min(1, Math.max(-1, _ * R + I * B));
        return (_ * B - I * R < 0 ? -1 : 1) * Math.acos(z);
      }
      function ht(_, I) {
        if (!_) throw I || "Assertion Failed!";
      }
      ((bV = bH || (bH = {}))[(bV.ODD = 0)] = "ODD"),
        (bV[(bV.NONZERO = 1)] = "NONZERO"),
        (bV[(bV.POSITIVE = 2)] = "POSITIVE"),
        (bV[(bV.NEGATIVE = 3)] = "NEGATIVE"),
        (bV[(bV.ABS_GEQ_TWO = 4)] = "ABS_GEQ_TWO"),
        ((bj = bW || (bW = {}))[(bj.POLYGONS = 0)] = "POLYGONS"),
        (bj[(bj.CONNECTED_POLYGONS = 1)] = "CONNECTED_POLYGONS"),
        (bj[(bj.BOUNDARY_CONTOURS = 2)] = "BOUNDARY_CONTOURS");
      var xO = (function () {
          function n() {}
          return (
            (n.vertEq = function (_, I) {
              return _.s === I.s && _.t === I.t;
            }),
            (n.vertLeq = function (_, I) {
              return _.s < I.s || (_.s === I.s && _.t <= I.t);
            }),
            (n.transLeq = function (_, I) {
              return _.t < I.t || (_.t === I.t && _.s <= I.s);
            }),
            (n.edgeGoesLeft = function (_) {
              return n.vertLeq(_.Dst, _.Org);
            }),
            (n.edgeGoesRight = function (_) {
              return n.vertLeq(_.Org, _.Dst);
            }),
            (n.vertL1dist = function (_, I) {
              return Math.abs(_.s - I.s) + Math.abs(_.t - I.t);
            }),
            (n.edgeEval = function (_, I, R) {
              ht(n.vertLeq(_, I) && n.vertLeq(I, R));
              var B = I.s - _.s,
                z = R.s - I.s;
              return B + z > 0
                ? B < z
                  ? I.t - _.t + (_.t - R.t) * (B / (B + z))
                  : I.t - R.t + (R.t - _.t) * (z / (B + z))
                : 0;
            }),
            (n.edgeSign = function (_, I, R) {
              ht(n.vertLeq(_, I) && n.vertLeq(I, R));
              var B = I.s - _.s,
                z = R.s - I.s;
              return B + z > 0 ? (I.t - R.t) * B + (I.t - _.t) * z : 0;
            }),
            (n.transEval = function (_, I, R) {
              ht(n.transLeq(_, I) && n.transLeq(I, R));
              var B = I.t - _.t,
                z = R.t - I.t;
              return B + z > 0
                ? B < z
                  ? I.s - _.s + (_.s - R.s) * (B / (B + z))
                  : I.s - R.s + (R.s - _.s) * (z / (B + z))
                : 0;
            }),
            (n.transSign = function (_, I, R) {
              ht(n.transLeq(_, I) && n.transLeq(I, R));
              var B = I.t - _.t,
                z = R.t - I.t;
              return B + z > 0 ? (I.s - R.s) * B + (I.s - _.s) * z : 0;
            }),
            (n.vertCCW = function (_, I, R) {
              return (
                _.s * (I.t - R.t) + I.s * (R.t - _.t) + R.s * (_.t - I.t) >= 0
              );
            }),
            (n.interpolate = function (_, I, R, B) {
              return (_ = _ < 0 ? 0 : _) <= (R = R < 0 ? 0 : R)
                ? 0 === R
                  ? (I + B) / 2
                  : I + (B - I) * (_ / (_ + R))
                : B + (I - B) * (R / (_ + R));
            }),
            (n.intersect = function (_, I, R, B, z) {
              var k, V, j;
              n.vertLeq(_, I) || ((j = _), (_ = I), (I = j)),
                n.vertLeq(R, B) || ((j = R), (R = B), (B = j)),
                n.vertLeq(_, R) ||
                  ((j = _), (_ = R), (R = j), (j = I), (I = B), (B = j)),
                n.vertLeq(R, I)
                  ? n.vertLeq(I, B)
                    ? ((k = n.edgeEval(_, R, I)) + (V = n.edgeEval(R, I, B)) <
                        0 && ((k = -k), (V = -V)),
                      (z.s = n.interpolate(k, R.s, V, I.s)))
                    : ((k = n.edgeSign(_, R, I)) + (V = -n.edgeSign(_, B, I)) <
                        0 && ((k = -k), (V = -V)),
                      (z.s = n.interpolate(k, R.s, V, B.s)))
                  : (z.s = (R.s + I.s) / 2),
                n.transLeq(_, I) || ((j = _), (_ = I), (I = j)),
                n.transLeq(R, B) || ((j = R), (R = B), (B = j)),
                n.transLeq(_, R) ||
                  ((j = _), (_ = R), (R = j), (j = I), (I = B), (B = j)),
                n.transLeq(R, I)
                  ? n.transLeq(I, B)
                    ? ((k = n.transEval(_, R, I)) + (V = n.transEval(R, I, B)) <
                        0 && ((k = -k), (V = -V)),
                      (z.t = n.interpolate(k, R.t, V, I.t)))
                    : ((k = n.transSign(_, R, I)) +
                        (V = -n.transSign(_, B, I)) <
                        0 && ((k = -k), (V = -V)),
                      (z.t = n.interpolate(k, R.t, V, B.t)))
                  : (z.t = (R.t + I.t) / 2);
            }),
            n
          );
        })(),
        Sm = function () {
          (this.next = null),
            (this.prev = null),
            (this.anEdge = null),
            (this.trail = null),
            (this.n = 0),
            (this.marked = !1),
            (this.inside = !1);
        },
        xR = (function () {
          function n(_) {
            (this.side = _),
              (this.next = null),
              (this.Org = null),
              (this.Sym = null),
              (this.Onext = null),
              (this.Lnext = null),
              (this.Lface = null),
              (this.activeRegion = null),
              (this.winding = 0);
          }
          return (
            Object.defineProperty(n.prototype, "Rface", {
              get: function () {
                return this.Sym.Lface;
              },
              set: function (_) {
                this.Sym.Lface = _;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(n.prototype, "Dst", {
              get: function () {
                return this.Sym.Org;
              },
              set: function (_) {
                this.Sym.Org = _;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(n.prototype, "Oprev", {
              get: function () {
                return this.Sym.Lnext;
              },
              set: function (_) {
                this.Sym.Lnext = _;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(n.prototype, "Lprev", {
              get: function () {
                return this.Onext.Sym;
              },
              set: function (_) {
                this.Onext.Sym = _;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(n.prototype, "Dprev", {
              get: function () {
                return this.Lnext.Sym;
              },
              set: function (_) {
                this.Lnext.Sym = _;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(n.prototype, "Rprev", {
              get: function () {
                return this.Sym.Onext;
              },
              set: function (_) {
                this.Sym.Onext = _;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(n.prototype, "Dnext", {
              get: function () {
                return this.Sym.Onext.Sym;
              },
              set: function (_) {
                this.Sym.Onext.Sym = _;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(n.prototype, "Rnext", {
              get: function () {
                return this.Sym.Lnext.Sym;
              },
              set: function (_) {
                this.Sym.Lnext.Sym = _;
              },
              enumerable: !0,
              configurable: !0,
            }),
            n
          );
        })(),
        Id = function () {
          (this.next = null),
            (this.prev = null),
            (this.anEdge = null),
            (this.coords = [0, 0, 0]),
            (this.s = 0),
            (this.t = 0),
            (this.pqHandle = 0),
            (this.n = 0),
            (this.idx = 0);
        },
        xB = (function () {
          function n() {
            var _ = new Id(),
              I = new Sm(),
              R = new xR(0),
              B = new xR(1);
            (_.next = _.prev = _),
              (_.anEdge = null),
              (I.next = I.prev = I),
              (R.next = R),
              (R.Sym = B),
              (B.next = B),
              (B.Sym = R),
              (this.vHead = _),
              (this.fHead = I),
              (this.eHead = R),
              (this.eHeadSym = B);
          }
          return (
            (n.prototype.makeEdge_ = function (_) {
              var I = new xR(0),
                R = new xR(1);
              _.Sym.side < _.side && (_ = _.Sym);
              var B = _.Sym.next;
              return (
                (R.next = B),
                (B.Sym.next = I),
                (I.next = _),
                (_.Sym.next = R),
                (I.Sym = R),
                (I.Onext = I),
                (I.Lnext = R),
                (I.Org = null),
                (I.Lface = null),
                (I.winding = 0),
                (I.activeRegion = null),
                (R.Sym = I),
                (R.Onext = R),
                (R.Lnext = I),
                (R.Org = null),
                (R.Lface = null),
                (R.winding = 0),
                (R.activeRegion = null),
                I
              );
            }),
            (n.prototype.splice_ = function (_, I) {
              var R = _.Onext,
                B = I.Onext;
              (R.Sym.Lnext = I),
                (B.Sym.Lnext = _),
                (_.Onext = B),
                (I.Onext = R);
            }),
            (n.prototype.makeVertex_ = function (_, I, R) {
              ht(_, "Vertex can't be null!");
              var B = R.prev;
              (_.prev = B),
                (B.next = _),
                (_.next = R),
                (R.prev = _),
                (_.anEdge = I);
              var z = I;
              do (z.Org = _), (z = z.Onext);
              while (z !== I);
            }),
            (n.prototype.makeFace_ = function (_, I, R) {
              ht(_, "Face can't be null");
              var B = R.prev;
              (_.prev = B),
                (B.next = _),
                (_.next = R),
                (R.prev = _),
                (_.anEdge = I),
                (_.trail = null),
                (_.marked = !1),
                (_.inside = R.inside);
              var z = I;
              do (z.Lface = _), (z = z.Lnext);
              while (z !== I);
            }),
            (n.prototype.killEdge_ = function (_) {
              _.Sym.side < _.side && (_ = _.Sym);
              var I = _.next,
                R = _.Sym.next;
              (I.Sym.next = R), (R.Sym.next = I);
            }),
            (n.prototype.killVertex_ = function (_, I) {
              var R = _.anEdge,
                B = R;
              do (B.Org = I), (B = B.Onext);
              while (B !== R);
              var z = _.prev,
                k = _.next;
              (k.prev = z), (z.next = k);
            }),
            (n.prototype.killFace_ = function (_, I) {
              var R = _.anEdge,
                B = R;
              do (B.Lface = I), (B = B.Lnext);
              while (B !== R);
              var z = _.prev,
                k = _.next;
              (k.prev = z), (z.next = k);
            }),
            (n.prototype.makeEdge = function () {
              var _ = new Id(),
                I = new Id(),
                R = new Sm(),
                B = this.makeEdge_(this.eHead);
              return (
                this.makeVertex_(_, B, this.vHead),
                this.makeVertex_(I, B.Sym, this.vHead),
                this.makeFace_(R, B, this.fHead),
                B
              );
            }),
            (n.prototype.splice = function (_, I) {
              var R = !1,
                B = !1;
              if (_ !== I) {
                if (
                  (I.Org !== _.Org &&
                    ((B = !0), this.killVertex_(I.Org, _.Org)),
                  I.Lface !== _.Lface &&
                    ((R = !0), this.killFace_(I.Lface, _.Lface)),
                  this.splice_(I, _),
                  !B)
                ) {
                  var z = new Id();
                  this.makeVertex_(z, I, _.Org), (_.Org.anEdge = _);
                }
                if (!R) {
                  var k = new Sm();
                  this.makeFace_(k, I, _.Lface), (_.Lface.anEdge = _);
                }
              }
            }),
            (n.prototype.delete = function (_) {
              var I = _.Sym,
                R = !1;
              if (
                (_.Lface !== _.Rface &&
                  ((R = !0), this.killFace_(_.Lface, _.Rface)),
                _.Onext === _)
              )
                this.killVertex_(_.Org, null);
              else if (
                ((_.Rface.anEdge = _.Oprev),
                (_.Org.anEdge = _.Onext),
                this.splice_(_, _.Oprev),
                !R)
              ) {
                var B = new Sm();
                this.makeFace_(B, _, _.Lface);
              }
              I.Onext === I
                ? (this.killVertex_(I.Org, null), this.killFace_(I.Lface, null))
                : ((_.Lface.anEdge = I.Oprev),
                  (I.Org.anEdge = I.Onext),
                  this.splice_(I, I.Oprev)),
                this.killEdge_(_);
            }),
            (n.prototype.addEdgeVertex = function (_) {
              var I = this.makeEdge_(_),
                R = I.Sym;
              this.splice_(I, _.Lnext), (I.Org = _.Dst);
              var B = new Id();
              return (
                this.makeVertex_(B, R, I.Org), (I.Lface = R.Lface = _.Lface), I
              );
            }),
            (n.prototype.splitEdge = function (_) {
              var I = this.addEdgeVertex(_).Sym;
              return (
                this.splice_(_.Sym, _.Sym.Oprev),
                this.splice_(_.Sym, I),
                (_.Dst = I.Org),
                (I.Dst.anEdge = I.Sym),
                (I.Rface = _.Rface),
                (I.winding = _.winding),
                (I.Sym.winding = _.Sym.winding),
                (I.idx = _.idx),
                (I.Sym.idx = _.Sym.idx),
                I
              );
            }),
            (n.prototype.connect = function (_, I) {
              var R = !1,
                B = this.makeEdge_(_),
                z = B.Sym;
              if (
                (I.Lface !== _.Lface &&
                  ((R = !0), this.killFace_(I.Lface, _.Lface)),
                this.splice_(B, _.Lnext),
                this.splice_(z, I),
                (B.Org = _.Dst),
                (z.Org = I.Org),
                (B.Lface = z.Lface = _.Lface),
                (_.Lface.anEdge = z),
                !R)
              ) {
                var k = new Sm();
                this.makeFace_(k, B, _.Lface);
              }
              return B;
            }),
            (n.prototype.zapFace = function (_) {
              var I,
                R,
                B,
                z,
                k,
                V = _.anEdge;
              R = V.Lnext;
              do
                (R = (I = R).Lnext),
                  (I.Lface = null),
                  null === I.Rface &&
                    (I.Onext === I
                      ? this.killVertex_(I.Org, null)
                      : ((I.Org.anEdge = I.Onext), this.splice_(I, I.Oprev)),
                    (B = I.Sym).Onext === B
                      ? this.killVertex_(B.Org, null)
                      : ((B.Org.anEdge = B.Onext), this.splice_(B, B.Oprev)),
                    this.killEdge_(I));
              while (I != V);
              (z = _.prev), ((k = _.next).prev = z), (z.next = k);
            }),
            (n.prototype.countFaceVerts_ = function (_) {
              var I = _.anEdge,
                R = 0;
              do R++, (I = I.Lnext);
              while (I !== _.anEdge);
              return R;
            }),
            (n.prototype.mergeConvexFaces = function (_) {
              var I, R, B, z, k;
              for (I = this.fHead.next; I !== this.fHead; I = I.next)
                if (I.inside)
                  for (
                    k = (R = I.anEdge).Org;
                    (B = R.Lnext),
                      (z = R.Sym) &&
                        z.Lface &&
                        z.Lface.inside &&
                        this.countFaceVerts_(I) +
                          this.countFaceVerts_(z.Lface) -
                          2 <=
                          _ &&
                        xO.vertCCW(R.Lprev.Org, R.Org, z.Lnext.Lnext.Org) &&
                        xO.vertCCW(z.Lprev.Org, z.Org, R.Lnext.Lnext.Org) &&
                        ((B = z.Lnext), this.delete(z), (R = null), (z = null)),
                      !(R && R.Lnext.Org === k);

                  )
                    R = B;
              return !0;
            }),
            (n.prototype.check = function () {
              var _,
                I,
                R,
                B,
                z,
                k,
                V = this.fHead,
                j = this.vHead,
                G = this.eHead;
              for (I = V, I = V; (_ = I.next) !== V; I = _) {
                ht(_.prev === I), (z = _.anEdge);
                do
                  ht(z.Sym !== z),
                    ht(z.Sym.Sym === z),
                    ht(z.Lnext.Onext.Sym === z),
                    ht(z.Onext.Sym.Lnext === z),
                    ht(z.Lface === _),
                    (z = z.Lnext);
                while (z !== _.anEdge);
              }
              for (
                ht(_.prev === I && null === _.anEdge), B = j, B = j;
                (R = B.next) !== j;
                B = R
              ) {
                ht(R.prev === B), (z = R.anEdge);
                do
                  ht(z.Sym !== z),
                    ht(z.Sym.Sym === z),
                    ht(z.Lnext.Onext.Sym === z),
                    ht(z.Onext.Sym.Lnext === z),
                    ht(z.Org === R),
                    (z = z.Onext);
                while (z !== R.anEdge);
              }
              for (
                ht(R.prev === B && null === R.anEdge), k = G, k = G;
                (z = k.next) !== G;
                k = z
              )
                ht(z.Sym.next === k.Sym),
                  ht(z.Sym !== z),
                  ht(z.Sym.Sym === z),
                  ht(null !== z.Org),
                  ht(null !== z.Dst),
                  ht(z.Lnext.Onext.Sym === z),
                  ht(z.Onext.Sym.Lnext === z);
              ht(
                z.Sym.next === k.Sym &&
                  z.Sym === this.eHeadSym &&
                  z.Sym.Sym === z &&
                  null === z.Org &&
                  null === z.Dst &&
                  null === z.Lface &&
                  null === z.Rface
              );
            }),
            n
          );
        })(),
        rI = function () {
          this.handle = null;
        },
        iI = function () {
          (this.key = null), (this.node = 0);
        },
        xz = (function () {
          function n(_, I) {
            (this.leq = I),
              (this.max = 0),
              (this.nodes = []),
              (this.handles = []),
              (this.initialized = !1),
              (this.freeList = 0),
              (this.size = 0),
              (this.max = _),
              (this.nodes = []),
              (this.handles = []);
            for (var R = 0; R < _ + 1; R++)
              (this.nodes[R] = new rI()), (this.handles[R] = new iI());
            (this.initialized = !1),
              (this.nodes[1].handle = 1),
              (this.handles[1].key = null);
          }
          return (
            (n.prototype.floatDown_ = function (_) {
              var I,
                R,
                B,
                z = this.nodes,
                k = this.handles;
              for (I = z[_].handle; ; ) {
                if (
                  ((B = _ << 1) < this.size &&
                    this.leq(k[z[B + 1].handle].key, k[z[B].handle].key) &&
                    ++B,
                  ht(B <= this.max),
                  (R = z[B].handle),
                  B > this.size || this.leq(k[I].key, k[R].key))
                ) {
                  (z[_].handle = I), (k[I].node = _);
                  break;
                }
                (z[_].handle = R), (k[R].node = _), (_ = B);
              }
            }),
            (n.prototype.floatUp_ = function (_) {
              var I,
                R,
                B,
                z = this.nodes,
                k = this.handles;
              for (I = z[_].handle; ; ) {
                if (
                  ((R = z[(B = _ >> 1)].handle),
                  0 === B || this.leq(k[R].key, k[I].key))
                ) {
                  (z[_].handle = I), (k[I].node = _);
                  break;
                }
                (z[_].handle = R), (k[R].node = _), (_ = B);
              }
            }),
            (n.prototype.init = function () {
              for (var _ = this.size; _ >= 1; --_) this.floatDown_(_);
              this.initialized = !0;
            }),
            (n.prototype.min = function () {
              return this.handles[this.nodes[1].handle].key;
            }),
            (n.prototype.insert = function (_) {
              var I, R, B, z;
              if (2 * (I = ++this.size) > this.max) {
                for (
                  this.max *= 2,
                    z = this.nodes.length,
                    this.nodes.length = this.max + 1,
                    B = z;
                  B < this.nodes.length;
                  B++
                )
                  this.nodes[B] = new rI();
                for (
                  z = this.handles.length,
                    this.handles.length = this.max + 1,
                    B = z;
                  B < this.handles.length;
                  B++
                )
                  this.handles[B] = new iI();
              }
              return (
                0 === this.freeList
                  ? (R = I)
                  : ((R = this.freeList),
                    (this.freeList = this.handles[R].node)),
                (this.nodes[I].handle = R),
                (this.handles[R].node = I),
                (this.handles[R].key = _),
                this.initialized && this.floatUp_(I),
                R
              );
            }),
            (n.prototype.extractMin = function () {
              var _ = this.nodes,
                I = this.handles,
                R = _[1].handle,
                B = I[R].key;
              return (
                this.size > 0 &&
                  ((_[1].handle = _[this.size].handle),
                  (I[_[1].handle].node = 1),
                  (I[R].key = null),
                  (I[R].node = this.freeList),
                  (this.freeList = R),
                  --this.size,
                  this.size > 0 && this.floatDown_(1)),
                B
              );
            }),
            (n.prototype.delete = function (_) {
              var I,
                R = this.nodes,
                B = this.handles;
              ht(_ >= 1 && _ <= this.max && null !== B[_].key),
                (R[(I = B[_].node)].handle = R[this.size].handle),
                (B[R[I].handle].node = I),
                --this.size,
                I <= this.size &&
                  (I <= 1 ||
                  this.leq(B[R[I >> 1].handle].key, B[R[I].handle].key)
                    ? this.floatDown_(I)
                    : this.floatUp_(I)),
                (B[_].key = null),
                (B[_].node = this.freeList),
                (this.freeList = _);
            }),
            n
          );
        })(),
        bA = function () {
          (this.eUp = null),
            (this.nodeUp = null),
            (this.windingNumber = 0),
            (this.inside = !1),
            (this.sentinel = !1),
            (this.dirty = !1),
            (this.fixUpperEdge = !1);
        },
        nI = function () {
          (this.key = null), (this.next = null), (this.prev = null);
        },
        xF = (function () {
          function n(_, I) {
            (this.frame = _),
              (this.leq = I),
              (this.head = new nI()),
              (this.head.next = this.head),
              (this.head.prev = this.head);
          }
          return (
            (n.prototype.min = function () {
              return this.head.next;
            }),
            (n.prototype.max = function () {
              return this.head.prev;
            }),
            (n.prototype.insert = function (_) {
              return this.insertBefore(this.head, _);
            }),
            (n.prototype.search = function (_) {
              var I = this.head;
              do I = I.next;
              while (null !== I.key && !this.leq(this.frame, _, I.key));
              return I;
            }),
            (n.prototype.insertBefore = function (_, I) {
              do _ = _.prev;
              while (null !== _.key && !this.leq(this.frame, _.key, I));
              var R = new nI();
              return (
                (R.key = I),
                (R.next = _.next),
                (_.next.prev = R),
                (R.prev = _),
                (_.next = R),
                R
              );
            }),
            (n.prototype.delete = function (_) {
              (_.next.prev = _.prev), (_.prev.next = _.next);
            }),
            n
          );
        })(),
        xN = (function () {
          function n() {}
          return (
            (n.regionBelow = function (_) {
              return _.nodeUp.prev.key;
            }),
            (n.regionAbove = function (_) {
              return _.nodeUp.next.key;
            }),
            (n.debugEvent = function (_) {}),
            (n.addWinding = function (_, I) {
              (_.winding += I.winding), (_.Sym.winding += I.Sym.winding);
            }),
            (n.edgeLeq = function (_, I, R) {
              var B = _.event,
                z = I.eUp,
                k = R.eUp;
              return z.Dst === B
                ? k.Dst === B
                  ? xO.vertLeq(z.Org, k.Org)
                    ? 0 >= xO.edgeSign(k.Dst, z.Org, k.Org)
                    : xO.edgeSign(z.Dst, k.Org, z.Org) >= 0
                  : 0 >= xO.edgeSign(k.Dst, B, k.Org)
                : k.Dst === B
                ? xO.edgeSign(z.Dst, B, z.Org) >= 0
                : xO.edgeEval(z.Dst, B, z.Org) >= xO.edgeEval(k.Dst, B, k.Org);
            }),
            (n.deleteRegion = function (_, I) {
              I.fixUpperEdge && ht(0 === I.eUp.winding),
                (I.eUp.activeRegion = null),
                _.dict.delete(I.nodeUp);
            }),
            (n.fixUpperEdge = function (_, I, R) {
              ht(I.fixUpperEdge),
                _.mesh.delete(I.eUp),
                (I.fixUpperEdge = !1),
                (I.eUp = R),
                (R.activeRegion = I);
            }),
            (n.topLeftRegion = function (_, I) {
              var R,
                B = I.eUp.Org;
              do I = n.regionAbove(I);
              while (I.eUp.Org === B);
              if (I.fixUpperEdge) {
                if (
                  null ===
                  (R = _.mesh.connect(n.regionBelow(I).eUp.Sym, I.eUp.Lnext))
                )
                  return null;
                n.fixUpperEdge(_, I, R), (I = n.regionAbove(I));
              }
              return I;
            }),
            (n.topRightRegion = function (_) {
              var I = _.eUp.Dst;
              do _ = n.regionAbove(_);
              while (_.eUp.Dst === I);
              return _;
            }),
            (n.addRegionBelow = function (_, I, R) {
              var B = new bA();
              return (
                (B.eUp = R),
                (B.nodeUp = _.dict.insertBefore(I.nodeUp, B)),
                (B.fixUpperEdge = !1),
                (B.sentinel = !1),
                (B.dirty = !1),
                (R.activeRegion = B),
                B
              );
            }),
            (n.isWindingInside = function (_, I) {
              switch (_.windingRule) {
                case bH.ODD:
                  return (1 & I) != 0;
                case bH.NONZERO:
                  return 0 !== I;
                case bH.POSITIVE:
                  return I > 0;
                case bH.NEGATIVE:
                  return I < 0;
                case bH.ABS_GEQ_TWO:
                  return I >= 2 || I <= -2;
              }
              throw Error("Invalid winding rulle");
            }),
            (n.computeWinding = function (_, I) {
              (I.windingNumber =
                n.regionAbove(I).windingNumber + I.eUp.winding),
                (I.inside = n.isWindingInside(_, I.windingNumber));
            }),
            (n.finishRegion = function (_, I) {
              var R = I.eUp,
                B = R.Lface;
              (B.inside = I.inside), (B.anEdge = R), n.deleteRegion(_, I);
            }),
            (n.finishLeftRegions = function (_, I, R) {
              for (var B, z = null, k = I, V = I.eUp; k !== R; ) {
                if (
                  ((k.fixUpperEdge = !1),
                  (B = (z = n.regionBelow(k)).eUp).Org != V.Org)
                ) {
                  if (!z.fixUpperEdge) {
                    n.finishRegion(_, k);
                    break;
                  }
                  (B = _.mesh.connect(V.Lprev, B.Sym)), n.fixUpperEdge(_, z, B);
                }
                V.Onext !== B &&
                  (_.mesh.splice(B.Oprev, B), _.mesh.splice(V, B)),
                  n.finishRegion(_, k),
                  (V = z.eUp),
                  (k = z);
              }
              return V;
            }),
            (n.addRightEdges = function (_, I, R, B, z, k) {
              var V,
                j,
                G,
                q,
                X = !0;
              G = R;
              do
                ht(xO.vertLeq(G.Org, G.Dst)),
                  n.addRegionBelow(_, I, G.Sym),
                  (G = G.Onext);
              while (G !== B);
              for (
                null === z && (z = n.regionBelow(I).eUp.Rprev), j = I, q = z;
                (G = (V = n.regionBelow(j)).eUp.Sym).Org === q.Org;

              )
                G.Onext !== q &&
                  (_.mesh.splice(G.Oprev, G), _.mesh.splice(q.Oprev, G)),
                  (V.windingNumber = j.windingNumber - G.winding),
                  (V.inside = n.isWindingInside(_, V.windingNumber)),
                  (j.dirty = !0),
                  !X &&
                    n.checkForRightSplice(_, j) &&
                    (n.addWinding(G, q),
                    n.deleteRegion(_, j),
                    _.mesh.delete(q)),
                  (X = !1),
                  (j = V),
                  (q = G);
              (j.dirty = !0),
                ht(j.windingNumber - G.winding === V.windingNumber),
                k && n.walkDirtyRegions(_, j);
            }),
            (n.spliceMergeVertices = function (_, I, R) {
              _.mesh.splice(I, R);
            }),
            (n.vertexWeights = function (_, I, R) {
              var B = xO.vertL1dist(I, _),
                z = xO.vertL1dist(R, _),
                k = (0.5 * z) / (B + z),
                V = (0.5 * B) / (B + z);
              (_.coords[0] += k * I.coords[0] + V * R.coords[0]),
                (_.coords[1] += k * I.coords[1] + V * R.coords[1]),
                (_.coords[2] += k * I.coords[2] + V * R.coords[2]);
            }),
            (n.getIntersectData = function (_, I, R, B, z, k) {
              (I.coords[0] = I.coords[1] = I.coords[2] = 0),
                (I.idx = -1),
                n.vertexWeights(I, R, B),
                n.vertexWeights(I, z, k);
            }),
            (n.checkForRightSplice = function (_, I) {
              var R = n.regionBelow(I),
                B = I.eUp,
                z = R.eUp;
              if (xO.vertLeq(B.Org, z.Org)) {
                if (xO.edgeSign(z.Dst, B.Org, z.Org) > 0) return !1;
                xO.vertEq(B.Org, z.Org)
                  ? B.Org !== z.Org &&
                    (_.pq.delete(B.Org.pqHandle),
                    n.spliceMergeVertices(_, z.Oprev, B))
                  : (_.mesh.splitEdge(z.Sym),
                    _.mesh.splice(B, z.Oprev),
                    (I.dirty = R.dirty = !0));
              } else {
                if (0 > xO.edgeSign(B.Dst, z.Org, B.Org)) return !1;
                (n.regionAbove(I).dirty = I.dirty = !0),
                  _.mesh.splitEdge(B.Sym),
                  _.mesh.splice(z.Oprev, B);
              }
              return !0;
            }),
            (n.checkForLeftSplice = function (_, I) {
              var R,
                B = n.regionBelow(I),
                z = I.eUp,
                k = B.eUp;
              if ((ht(!xO.vertEq(z.Dst, k.Dst)), xO.vertLeq(z.Dst, k.Dst))) {
                if (0 > xO.edgeSign(z.Dst, k.Dst, z.Org)) return !1;
                (n.regionAbove(I).dirty = I.dirty = !0),
                  (R = _.mesh.splitEdge(z)),
                  _.mesh.splice(k.Sym, R),
                  (R.Lface.inside = I.inside);
              } else {
                if (xO.edgeSign(k.Dst, z.Dst, k.Org) > 0) return !1;
                (I.dirty = B.dirty = !0),
                  (R = _.mesh.splitEdge(k)),
                  _.mesh.splice(z.Lnext, k.Sym),
                  (R.Rface.inside = I.inside);
              }
              return !0;
            }),
            (n.checkForIntersect = function (_, I) {
              var R,
                B,
                z = n.regionBelow(I),
                k = I.eUp,
                V = z.eUp,
                j = k.Org,
                G = V.Org,
                q = k.Dst,
                X = V.Dst,
                Q = new Id();
              if (
                (ht(!xO.vertEq(X, q)),
                ht(0 >= xO.edgeSign(q, _.event, j)),
                ht(xO.edgeSign(X, _.event, G) >= 0),
                ht(j !== _.event && G !== _.event),
                ht(!I.fixUpperEdge && !z.fixUpperEdge),
                j === G || Math.min(j.t, q.t) > Math.max(G.t, X.t))
              )
                return !1;
              if (xO.vertLeq(j, G)) {
                if (xO.edgeSign(X, j, G) > 0) return !1;
              } else if (0 > xO.edgeSign(q, G, j)) return !1;
              return (
                n.debugEvent(_),
                xO.intersect(q, j, X, G, Q),
                ht(Math.min(j.t, q.t) <= Q.t),
                ht(Q.t <= Math.max(G.t, X.t)),
                ht(Math.min(X.s, q.s) <= Q.s),
                ht(Q.s <= Math.max(G.s, j.s)),
                xO.vertLeq(Q, _.event) &&
                  ((Q.s = _.event.s), (Q.t = _.event.t)),
                (R = xO.vertLeq(j, G) ? j : G),
                xO.vertLeq(R, Q) && ((Q.s = R.s), (Q.t = R.t)),
                xO.vertEq(Q, j) || xO.vertEq(Q, G)
                  ? (n.checkForRightSplice(_, I), !1)
                  : (!xO.vertEq(q, _.event) &&
                      xO.edgeSign(q, _.event, Q) >= 0) ||
                    (!xO.vertEq(X, _.event) && 0 >= xO.edgeSign(X, _.event, Q))
                  ? X === _.event
                    ? (_.mesh.splitEdge(k.Sym),
                      _.mesh.splice(V.Sym, k),
                      (I = n.topLeftRegion(_, I)),
                      (k = n.regionBelow(I).eUp),
                      n.finishLeftRegions(_, n.regionBelow(I), z),
                      n.addRightEdges(_, I, k.Oprev, k, k, !0),
                      !0)
                    : q === _.event
                    ? (_.mesh.splitEdge(V.Sym),
                      _.mesh.splice(k.Lnext, V.Oprev),
                      (z = I),
                      (I = n.topRightRegion(I)),
                      (B = n.regionBelow(I).eUp.Rprev),
                      (z.eUp = V.Oprev),
                      (V = n.finishLeftRegions(_, z, null)),
                      n.addRightEdges(_, I, V.Onext, k.Rprev, B, !0),
                      !0)
                    : (xO.edgeSign(q, _.event, Q) >= 0 &&
                        ((n.regionAbove(I).dirty = I.dirty = !0),
                        _.mesh.splitEdge(k.Sym),
                        (k.Org.s = _.event.s),
                        (k.Org.t = _.event.t)),
                      0 >= xO.edgeSign(X, _.event, Q) &&
                        ((I.dirty = z.dirty = !0),
                        _.mesh.splitEdge(V.Sym),
                        (V.Org.s = _.event.s),
                        (V.Org.t = _.event.t)),
                      !1)
                  : (_.mesh.splitEdge(k.Sym),
                    _.mesh.splitEdge(V.Sym),
                    _.mesh.splice(V.Oprev, k),
                    (k.Org.s = Q.s),
                    (k.Org.t = Q.t),
                    (k.Org.pqHandle = _.pq.insert(k.Org)),
                    n.getIntersectData(_, k.Org, j, q, G, X),
                    (n.regionAbove(I).dirty = I.dirty = z.dirty = !0),
                    !1)
              );
            }),
            (n.walkDirtyRegions = function (_, I) {
              for (var R, B, z = n.regionBelow(I); ; ) {
                for (; z.dirty; ) (I = z), (z = n.regionBelow(z));
                if (
                  !I.dirty &&
                  ((z = I), null === (I = n.regionAbove(I)) || !I.dirty)
                )
                  return;
                if (
                  ((I.dirty = !1),
                  (R = I.eUp),
                  (B = z.eUp),
                  R.Dst !== B.Dst &&
                    n.checkForLeftSplice(_, I) &&
                    (z.fixUpperEdge
                      ? (n.deleteRegion(_, z),
                        _.mesh.delete(B),
                        (B = (z = n.regionBelow(I)).eUp))
                      : I.fixUpperEdge &&
                        (n.deleteRegion(_, I),
                        _.mesh.delete(R),
                        (R = (I = n.regionAbove(z)).eUp))),
                  R.Org !== B.Org)
                ) {
                  if (
                    R.Dst === B.Dst ||
                    I.fixUpperEdge ||
                    z.fixUpperEdge ||
                    (R.Dst !== _.event && B.Dst !== _.event)
                  )
                    n.checkForRightSplice(_, I);
                  else if (n.checkForIntersect(_, I)) return;
                }
                R.Org === B.Org &&
                  R.Dst === B.Dst &&
                  (n.addWinding(B, R),
                  n.deleteRegion(_, I),
                  _.mesh.delete(R),
                  (I = n.regionAbove(z)));
              }
            }),
            (n.connectRightVertex = function (_, I, R) {
              var B,
                z = R.Onext,
                k = n.regionBelow(I),
                V = I.eUp,
                j = k.eUp,
                G = !1;
              if (
                (V.Dst !== j.Dst && n.checkForIntersect(_, I),
                xO.vertEq(V.Org, _.event) &&
                  (_.mesh.splice(z.Oprev, V),
                  (I = n.topLeftRegion(_, I)),
                  (z = n.regionBelow(I).eUp),
                  n.finishLeftRegions(_, n.regionBelow(I), k),
                  (G = !0)),
                xO.vertEq(j.Org, _.event) &&
                  (_.mesh.splice(R, j.Oprev),
                  (R = n.finishLeftRegions(_, k, null)),
                  (G = !0)),
                G)
              ) {
                n.addRightEdges(_, I, R.Onext, z, z, !0);
                return;
              }
              (B = xO.vertLeq(j.Org, V.Org) ? j.Oprev : V),
                (B = _.mesh.connect(R.Lprev, B)),
                n.addRightEdges(_, I, B, B.Onext, B.Onext, !1),
                (B.Sym.activeRegion.fixUpperEdge = !0),
                n.walkDirtyRegions(_, I);
            }),
            (n.connectLeftDegenerate = function (_, I, R) {
              var B, z, k, V, j;
              if (((B = I.eUp), xO.vertEq(B.Org, R))) {
                ht(!1), n.spliceMergeVertices(_, B, R.anEdge);
                return;
              }
              if (!xO.vertEq(B.Dst, R)) {
                _.mesh.splitEdge(B.Sym),
                  I.fixUpperEdge &&
                    (_.mesh.delete(B.Onext), (I.fixUpperEdge = !1)),
                  _.mesh.splice(R.anEdge, B),
                  n.sweepEvent(_, R);
                return;
              }
              ht(!1),
                (I = n.topRightRegion(I)),
                (z = V = (k = (j = n.regionBelow(I)).eUp.Sym).Onext),
                j.fixUpperEdge &&
                  (ht(z !== k),
                  n.deleteRegion(_, j),
                  _.mesh.delete(k),
                  (k = z.Oprev)),
                _.mesh.splice(R.anEdge, k),
                xO.edgeGoesLeft(z) || (z = null),
                n.addRightEdges(_, I, k.Onext, V, z, !0);
            }),
            (n.connectLeftVertex = function (_, I) {
              var R,
                B,
                z,
                k,
                V,
                j,
                G = new bA();
              if (
                ((G.eUp = I.anEdge.Sym),
                (R = _.dict.search(G).key),
                (B = n.regionBelow(R)))
              ) {
                if (
                  ((k = R.eUp), (V = B.eUp), 0 === xO.edgeSign(k.Dst, I, k.Org))
                ) {
                  n.connectLeftDegenerate(_, R, I);
                  return;
                }
                ((z = xO.vertLeq(V.Dst, k.Dst) ? R : B),
                R.inside || z.fixUpperEdge)
                  ? ((j =
                      z === R
                        ? _.mesh.connect(I.anEdge.Sym, k.Lnext)
                        : _.mesh.connect(V.Dnext, I.anEdge).Sym),
                    z.fixUpperEdge
                      ? n.fixUpperEdge(_, z, j)
                      : n.computeWinding(_, n.addRegionBelow(_, R, j)),
                    n.sweepEvent(_, I))
                  : n.addRightEdges(_, R, I.anEdge, I.anEdge, null, !0);
              }
            }),
            (n.sweepEvent = function (_, I) {
              (_.event = I), n.debugEvent(_);
              for (var R = I.anEdge; null === R.activeRegion; )
                if ((R = R.Onext) === I.anEdge) {
                  n.connectLeftVertex(_, I);
                  return;
                }
              var B = n.topLeftRegion(_, R.activeRegion);
              ht(null !== B);
              var z = n.regionBelow(B),
                k = z.eUp,
                V = n.finishLeftRegions(_, z, null);
              V.Onext === k
                ? n.connectRightVertex(_, B, V)
                : n.addRightEdges(_, B, V.Onext, k, k, !0);
            }),
            (n.addSentinel = function (_, I, R, B) {
              var z = new bA(),
                k = _.mesh.makeEdge();
              (k.Org.s = R),
                (k.Org.t = B),
                (k.Dst.s = I),
                (k.Dst.t = B),
                (_.event = k.Dst),
                (z.eUp = k),
                (z.windingNumber = 0),
                (z.inside = !1),
                (z.fixUpperEdge = !1),
                (z.sentinel = !0),
                (z.dirty = !1),
                (z.nodeUp = _.dict.insert(z));
            }),
            (n.initEdgeDict = function (_) {
              _.dict = new xF(_, n.edgeLeq);
              var I = _.bmax[0] - _.bmin[0],
                R = _.bmax[1] - _.bmin[1],
                B = _.bmin[0] - I,
                z = _.bmax[0] + I,
                k = _.bmin[1] - R,
                V = _.bmax[1] + R;
              n.addSentinel(_, B, z, k), n.addSentinel(_, B, z, V);
            }),
            (n.doneEdgeDict = function (_) {
              for (var I, R = 0; null !== (I = _.dict.min().key); )
                I.sentinel || (ht(I.fixUpperEdge), ht(1 == ++R)),
                  ht(0 === I.windingNumber),
                  n.deleteRegion(_, I);
            }),
            (n.removeDegenerateEdges = function (_) {
              var I,
                R,
                B,
                z = _.mesh.eHead;
              for (I = z.next; I !== z; I = R)
                (R = I.next),
                  (B = I.Lnext),
                  xO.vertEq(I.Org, I.Dst) &&
                    I.Lnext.Lnext !== I &&
                    (n.spliceMergeVertices(_, B, I),
                    _.mesh.delete(I),
                    (B = (I = B).Lnext)),
                  B.Lnext === I &&
                    (B !== I &&
                      ((B === R || B === R.Sym) && (R = R.next),
                      _.mesh.delete(B)),
                    (I === R || I === R.Sym) && (R = R.next),
                    _.mesh.delete(I));
            }),
            (n.initPriorityQ = function (_) {
              var I,
                R,
                B,
                z = 0;
              for (R = (B = _.mesh.vHead).next; R !== B; R = R.next) z++;
              for (
                z += 8,
                  I = _.pq = new xz(z, xO.vertLeq),
                  R = (B = _.mesh.vHead).next;
                R !== B;
                R = R.next
              )
                R.pqHandle = I.insert(R);
              return R === B && (I.init(), !0);
            }),
            (n.donePriorityQ = function (_) {
              _.pq = null;
            }),
            (n.removeDegenerateFaces = function (_, I) {
              var R, B, z;
              for (R = I.fHead.next; R !== I.fHead; R = B)
                (B = R.next),
                  ht((z = R.anEdge).Lnext !== z),
                  z.Lnext.Lnext === z &&
                    (n.addWinding(z.Onext, z), _.mesh.delete(z));
              return !0;
            }),
            (n.computeInterior = function (_, I) {
              var R, B;
              if (
                (void 0 === I && (I = !0),
                n.removeDegenerateEdges(_),
                !n.initPriorityQ(_))
              )
                return !1;
              for (n.initEdgeDict(_); null !== (R = _.pq.extractMin()); ) {
                for (; !(null === (B = _.pq.min()) || !xO.vertEq(B, R)); )
                  (B = _.pq.extractMin()),
                    n.spliceMergeVertices(_, R.anEdge, B.anEdge);
                n.sweepEvent(_, R);
              }
              return (
                (_.event = _.dict.min().key.eUp.Org),
                n.debugEvent(_),
                n.doneEdgeDict(_),
                n.donePriorityQ(_),
                !!n.removeDegenerateFaces(_, _.mesh) &&
                  (I && _.mesh.check(), !0)
              );
            }),
            n
          );
        })(),
        xk = (function () {
          function n() {
            (this.mesh = new xB()),
              (this.normal = [0, 0, 0]),
              (this.sUnit = [0, 0, 0]),
              (this.tUnit = [0, 0, 0]),
              (this.bmin = [0, 0]),
              (this.bmax = [0, 0]),
              (this.windingRule = bH.ODD),
              (this.dict = null),
              (this.pq = null),
              (this.event = null),
              (this.vertexIndexCounter = 0),
              (this.vertices = []),
              (this.vertexIndices = []),
              (this.vertexCount = 0),
              (this.elements = []),
              (this.elementCount = 0);
          }
          return (
            (n.prototype.dot_ = function (_, I) {
              return _[0] * I[0] + _[1] * I[1] + _[2] * I[2];
            }),
            (n.prototype.normalize_ = function (_) {
              var I = _[0] * _[0] + _[1] * _[1] + _[2] * _[2];
              if (!I) throw "Zero-size vector!";
              (I = Math.sqrt(I)), (_[0] /= I), (_[1] /= I), (_[2] /= I);
            }),
            (n.prototype.longAxis_ = function (_) {
              var I = 0;
              return (
                Math.abs(_[1]) > Math.abs(_[0]) && (I = 1),
                Math.abs(_[2]) > Math.abs(_[I]) && (I = 2),
                I
              );
            }),
            (n.prototype.computeNormal_ = function (_) {
              var I,
                R,
                B,
                z,
                k,
                V,
                j = [0, 0, 0],
                G = [0, 0, 0],
                q = [0, 0, 0],
                X = [0, 0, 0],
                Q = [0, 0, 0],
                $ = [null, null, null],
                et = [null, null, null],
                er = this.mesh.vHead;
              I = er.next;
              for (var es = 0; es < 3; ++es)
                (z = I.coords[es]),
                  (G[es] = z),
                  (et[es] = I),
                  (j[es] = z),
                  ($[es] = I);
              for (I = er.next; I !== er; I = I.next)
                for (var ea = 0; ea < 3; ++ea)
                  (z = I.coords[ea]) < G[ea] && ((G[ea] = z), (et[ea] = I)),
                    z > j[ea] && ((j[ea] = z), ($[ea] = I));
              var en = 0;
              if (
                (j[1] - G[1] > j[0] - G[0] && (en = 1),
                j[2] - G[2] > j[en] - G[en] && (en = 2),
                G[en] >= j[en])
              ) {
                (_[0] = 0), (_[1] = 0), (_[2] = 1);
                return;
              }
              for (
                V = 0,
                  R = et[en],
                  B = $[en],
                  q[0] = R.coords[0] - B.coords[0],
                  q[1] = R.coords[1] - B.coords[1],
                  q[2] = R.coords[2] - B.coords[2],
                  I = er.next;
                I !== er;
                I = I.next
              )
                (X[0] = I.coords[0] - B.coords[0]),
                  (X[1] = I.coords[1] - B.coords[1]),
                  (X[2] = I.coords[2] - B.coords[2]),
                  (Q[0] = q[1] * X[2] - q[2] * X[1]),
                  (Q[1] = q[2] * X[0] - q[0] * X[2]),
                  (Q[2] = q[0] * X[1] - q[1] * X[0]),
                  (k = Q[0] * Q[0] + Q[1] * Q[1] + Q[2] * Q[2]) > V &&
                    ((V = k), (_[0] = Q[0]), (_[1] = Q[1]), (_[2] = Q[2]));
              V <= 0 && ((_[0] = _[1] = _[2] = 0), (_[this.longAxis_(q)] = 1));
            }),
            (n.prototype.checkOrientation_ = function () {
              for (
                var _,
                  I,
                  R = this.mesh.fHead,
                  B = this.mesh.vHead,
                  z = 0,
                  k = R.next;
                k !== R;
                k = k.next
              )
                if (!((I = k.anEdge).winding <= 0))
                  do
                    (z += (I.Org.s - I.Dst.s) * (I.Org.t + I.Dst.t)),
                      (I = I.Lnext);
                  while (I !== k.anEdge);
              if (z < 0) {
                for (_ = B.next; _ !== B; _ = _.next) _.t = -_.t;
                (this.tUnit[0] = -this.tUnit[0]),
                  (this.tUnit[1] = -this.tUnit[1]),
                  (this.tUnit[2] = -this.tUnit[2]);
              }
            }),
            (n.prototype.projectPolygon_ = function () {
              var _,
                I,
                R = this.mesh.vHead,
                B = [0, 0, 0],
                z = !1;
              (B[0] = this.normal[0]),
                (B[1] = this.normal[1]),
                (B[2] = this.normal[2]),
                B[0] || B[1] || B[2] || (this.computeNormal_(B), (z = !0)),
                (_ = this.sUnit),
                (I = this.tUnit);
              var k = this.longAxis_(B);
              (_[k] = 0),
                (_[(k + 1) % 3] = 1),
                (_[(k + 2) % 3] = 0),
                (I[k] = 0),
                (I[(k + 1) % 3] = 0),
                (I[(k + 2) % 3] = B[k] > 0 ? 1 : -1);
              for (var V = R.next; V !== R; V = V.next)
                (V.s = this.dot_(V.coords, _)), (V.t = this.dot_(V.coords, I));
              z && this.checkOrientation_();
              for (var j = !0, G = R.next; G !== R; G = G.next)
                j
                  ? ((this.bmin[0] = this.bmax[0] = G.s),
                    (this.bmin[1] = this.bmax[1] = G.t),
                    (j = !1))
                  : (G.s < this.bmin[0] && (this.bmin[0] = G.s),
                    G.s > this.bmax[0] && (this.bmax[0] = G.s),
                    G.t < this.bmin[1] && (this.bmin[1] = G.t),
                    G.t > this.bmax[1] && (this.bmax[1] = G.t));
            }),
            (n.prototype.addWinding_ = function (_, I) {
              (_.winding += I.winding), (_.Sym.winding += I.Sym.winding);
            }),
            (n.prototype.tessellateMonoRegion_ = function (_, I) {
              var R, B;
              if (!((R = I.anEdge).Lnext !== R && R.Lnext.Lnext !== R))
                throw "Mono region invalid";
              for (; xO.vertLeq(R.Dst, R.Org); R = R.Lprev);
              for (; xO.vertLeq(R.Org, R.Dst); R = R.Lnext);
              for (B = R.Lprev; R.Lnext !== B; )
                if (xO.vertLeq(R.Dst, B.Org)) {
                  for (
                    ;
                    B.Lnext !== R &&
                    (xO.edgeGoesLeft(B.Lnext) ||
                      0 >= xO.edgeSign(B.Org, B.Dst, B.Lnext.Dst));

                  )
                    B = _.connect(B.Lnext, B).Sym;
                  B = B.Lprev;
                } else {
                  for (
                    ;
                    B.Lnext !== R &&
                    (xO.edgeGoesRight(R.Lprev) ||
                      xO.edgeSign(R.Dst, R.Org, R.Lprev.Org) >= 0);

                  )
                    R = _.connect(R, R.Lprev).Sym;
                  R = R.Lnext;
                }
              if (B.Lnext === R) throw "Mono region invalid";
              for (; B.Lnext.Lnext !== R; ) B = _.connect(B.Lnext, B).Sym;
              return !0;
            }),
            (n.prototype.tessellateInterior_ = function (_) {
              for (var I, R = _.fHead.next; R !== _.fHead; R = I)
                if (
                  ((I = R.next), R.inside && !this.tessellateMonoRegion_(_, R))
                )
                  return !1;
              return !0;
            }),
            (n.prototype.discardExterior_ = function (_) {
              for (var I, R = _.fHead.next; R !== _.fHead; R = I)
                (I = R.next), R.inside || _.zapFace(R);
            }),
            (n.prototype.setWindingNumber_ = function (_, I, R) {
              for (var B, z = _.eHead.next; z !== _.eHead; z = B)
                (B = z.next),
                  z.Rface.inside !== z.Lface.inside
                    ? (z.winding = z.Lface.inside ? I : -I)
                    : R
                    ? _.delete(z)
                    : (z.winding = 0);
            }),
            (n.prototype.getNeighbourFace_ = function (_) {
              return _.Rface && _.Rface.inside ? _.Rface.n : -1;
            }),
            (n.prototype.outputPolymesh_ = function (_, I, R, B) {
              var z,
                k,
                V = 0,
                j = 0;
              R > 3 && _.mergeConvexFaces(R);
              for (var G = _.vHead.next; G !== _.vHead; G = G.next) G.n = -1;
              for (var q = _.fHead.next; q !== _.fHead; q = q.next)
                if (((q.n = -1), q.inside)) {
                  (z = q.anEdge), (k = 0);
                  do {
                    var G = z.Org;
                    -1 === G.n && ((G.n = j), j++), k++, (z = z.Lnext);
                  } while (z !== q.anEdge);
                  if (k > R) throw "Face vertex greater that support polygon";
                  (q.n = V), ++V;
                }
              (this.elementCount = V),
                I === bW.CONNECTED_POLYGONS && (V *= 2),
                (this.elements = []),
                (this.elements.length = V * R),
                (this.vertexCount = j),
                (this.vertices = []),
                (this.vertices.length = j * B),
                (this.vertexIndices = []),
                (this.vertexIndices.length = j);
              for (var G = _.vHead.next; G !== _.vHead; G = G.next)
                if (-1 !== G.n) {
                  var X = G.n * B;
                  (this.vertices[X + 0] = G.coords[0]),
                    (this.vertices[X + 1] = G.coords[1]),
                    B > 2 && (this.vertices[X + 2] = G.coords[2]),
                    (this.vertexIndices[G.n] = G.idx);
                }
              for (var Q = 0, q = _.fHead.next; q !== _.fHead; q = q.next)
                if (q.inside) {
                  (z = q.anEdge), (k = 0);
                  do {
                    var G = z.Org;
                    (this.elements[Q++] = G.n), k++, (z = z.Lnext);
                  } while (z !== q.anEdge);
                  for (var $ = k; $ < R; ++$) this.elements[Q++] = -1;
                  if (I === bW.CONNECTED_POLYGONS) {
                    z = q.anEdge;
                    do
                      (this.elements[Q++] = this.getNeighbourFace_(z)),
                        (z = z.Lnext);
                    while (z !== q.anEdge);
                    for (var et = k; et < R; ++et) this.elements[Q++] = -1;
                  }
                }
            }),
            (n.prototype.outputContours_ = function (_, I) {
              var R,
                B,
                z = 0,
                k = 0;
              (this.vertexCount = 0), (this.elementCount = 0);
              for (var V = _.fHead.next; V !== _.fHead; V = V.next)
                if (V.inside) {
                  B = R = V.anEdge;
                  do this.vertexCount++, (R = R.Lnext);
                  while (R !== B);
                  this.elementCount++;
                }
              (this.elements = []),
                (this.elements.length = 2 * this.elementCount),
                (this.vertices = []),
                (this.vertices.length = this.vertexCount * I),
                (this.vertexIndices = []),
                (this.vertexIndices.length = this.vertexCount);
              var j = 0,
                G = 0,
                q = 0;
              z = 0;
              for (var V = _.fHead.next; V !== _.fHead; V = V.next)
                if (V.inside) {
                  (k = 0), (B = R = V.anEdge);
                  do
                    (this.vertices[j++] = R.Org.coords[0]),
                      (this.vertices[j++] = R.Org.coords[1]),
                      I > 2 && (this.vertices[j++] = R.Org.coords[2]),
                      (this.vertexIndices[G++] = this.vertexIdCallback
                        ? this.vertexIdCallback(R)
                        : R.Org.idx),
                      k++,
                      (R = R.Lnext);
                  while (R !== B);
                  (this.elements[q++] = z), (this.elements[q++] = k), (z += k);
                }
            }),
            (n.prototype.addContour = function (_, I) {
              null === this.mesh && (this.mesh = new xB()),
                _ < 2 && (_ = 2),
                _ > 3 && (_ = 3);
              for (var R = null, B = 0; B < I.length; B += _)
                null === R
                  ? ((R = this.mesh.makeEdge()), this.mesh.splice(R, R.Sym))
                  : (this.mesh.splitEdge(R), (R = R.Lnext)),
                  (R.Org.coords[0] = I[B + 0]),
                  (R.Org.coords[1] = I[B + 1]),
                  _ > 2 ? (R.Org.coords[2] = I[B + 2]) : (R.Org.coords[2] = 0),
                  (R.Org.idx = this.vertexIndexCounter++),
                  this.edgeCreateCallback && this.edgeCreateCallback(R),
                  (R.winding = 1),
                  (R.Sym.winding = -1);
            }),
            (n.prototype.tesselate = function (_, I, R, B, z, k) {
              if (
                (void 0 === _ && (_ = bH.ODD),
                void 0 === I && (I = bW.POLYGONS),
                void 0 === k && (k = !0),
                (this.vertices = []),
                (this.elements = []),
                (this.vertexIndices = []),
                (this.vertexIndexCounter = 0),
                z &&
                  ((this.normal[0] = z[0]),
                  (this.normal[1] = z[1]),
                  (this.normal[2] = z[2])),
                (this.windingRule = _),
                B < 2 && (B = 2),
                B > 3 && (B = 3),
                !this.mesh)
              )
                return !1;
              this.projectPolygon_(), xN.computeInterior(this, k);
              var V = this.mesh;
              return (
                I === bW.BOUNDARY_CONTOURS
                  ? this.setWindingNumber_(V, 1, !0)
                  : this.tessellateInterior_(V),
                k && V.check(),
                I === bW.BOUNDARY_CONTOURS
                  ? this.outputContours_(V, B)
                  : this.outputPolymesh_(V, I, R, B),
                !0
              );
            }),
            n
          );
        })();
      function io(_) {
        var I = _.windingRule,
          R = void 0 === I ? bH.ODD : I,
          B = _.elementType,
          z = void 0 === B ? bW.POLYGONS : B,
          k = _.polySize,
          V = _.vertexSize,
          j = void 0 === V ? 2 : V,
          G = _.normal,
          q = _.contours,
          X = void 0 === q ? [] : q,
          Q = _.strict,
          $ = void 0 === Q || Q,
          et = _.debug;
        if (!X && $) throw Error("Contours can't be empty");
        if (X) {
          var er = new xk();
          _.edgeCreateCallback &&
            (er.edgeCreateCallback = _.edgeCreateCallback),
            _.vertexIdCallback && (er.vertexIdCallback = _.vertexIdCallback);
          for (var es = 0; es < X.length; es++) er.addContour(j || 2, X[es]);
          return (
            er.tesselate(
              R,
              z,
              void 0 === k ? 3 : k,
              j,
              void 0 === G ? [0, 0, 1] : G,
              $
            ),
            {
              vertices: er.vertices,
              vertexIndices: er.vertexIndices,
              vertexCount: er.vertexCount,
              elements: er.elements,
              elementCount: er.elementCount,
              mesh: void 0 !== et && et ? er.mesh : void 0,
            }
          );
        }
      }
      bH.ODD,
        bH.NONZERO,
        bH.POSITIVE,
        bH.NEGATIVE,
        bH.ABS_GEQ_TWO,
        bW.POLYGONS,
        bW.CONNECTED_POLYGONS,
        bW.BOUNDARY_CONTOURS;
      var xV = class {
        constructor(_ = 256, I = !1) {
          (this.capacity = _),
            (this.size = 0),
            (this.debug = I),
            this.debug && console.log(`allocating with cap ${_}`);
          let R = _ * xV.eSize;
          this.buffer = new ArrayBuffer(R);
          let B = Float32Array.BYTES_PER_ELEMENT,
            z = 0;
          (this.positions = new Float32Array(this.buffer, z * B, 3 * _)),
            (z += 3 * _),
            (this.normals = new Float32Array(this.buffer, z * B, 3 * _)),
            (z += 3 * _),
            (this.uvs = new Float32Array(this.buffer, z * B, 2 * _));
        }
        realloc(_, I = !1) {
          if (_ < this.size) throw Error("cannot shrink buffer");
          if (_ <= this.capacity && !I) return;
          this.debug &&
            console.log(`resizing from ${this.capacity} \u2192 ${_}`);
          let R = _ * xV.eSize,
            B = new ArrayBuffer(R),
            z = Float32Array.BYTES_PER_ELEMENT,
            k = 0,
            V = new Float32Array(B, k * z, 3 * _);
          k += 3 * _;
          let j = new Float32Array(B, k * z, 3 * _);
          k += 3 * _;
          let G = new Float32Array(B, k * z, 2 * _);
          I
            ? (V.set(this.positions.subarray(0, 3 * this.size)),
              j.set(this.normals.subarray(0, 3 * this.size)),
              G.set(this.uvs.subarray(0, 2 * this.size)))
            : (V.set(this.positions), j.set(this.normals), G.set(this.uvs)),
            (this.buffer = B),
            (this.positions = V),
            (this.normals = j),
            (this.uvs = G),
            (this.capacity = _);
        }
        get(_ = 1) {
          let I = this.size + _;
          if (I > this.capacity) {
            let _ = this.capacity;
            for (; I > _; ) _ *= 2;
            this.realloc(_);
          }
          let R = this.size;
          return (this.size = I), R;
        }
        reserve(_) {
          let I = this.size + _;
          I > this.capacity && this.realloc(I);
        }
        shrink() {
          this.debug &&
            console.log(`shrinking ${this.capacity} \u2192 ${this.size}`),
            this.realloc(this.size, !0);
        }
      };
      xV.eSize = 8 * Float32Array.BYTES_PER_ELEMENT;
      var xj = pi(iU()),
        xG = {
          vertices: [160, 160, -160, 160, -160, -160, 160, -160],
          vertexIndices: [1, 0, 3, 2],
          vertexCount: 4,
          elements: [0, 4],
          elementCount: 1,
          mesh: void 0,
        },
        xH = {
          vertices: [],
          vertexIndices: [],
          vertexCount: 0,
          elements: [],
          elementCount: 0,
          mesh: void 0,
        },
        xW = {
          vertices: [-160, 160, 160, -160, 160, 160, -160, -160],
          vertexIndices: [1, 3, 0, 2],
          vertexCount: 4,
          elements: [0, 1, 2, 1, 0, 3],
          elementCount: 2,
          mesh: void 0,
        },
        _A =
          (_, I) =>
          ([R, B]) => (B < R && (B += I), (_ >= R ? _ : _ + I) <= B),
        xq = class extends ai {
          constructor(_, I, R = 0, B = 12, z = 3, k = bH.ODD, V = !1) {
            let j, G, q;
            super(),
              (this.forPathBevel = V),
              (this.type = "ShapeGeometry"),
              (this.vertexCache = {}),
              (this._shape = _),
              (this._depth = I),
              (this._curveSegments = B),
              (this._bevelSegmentsInput = z);
            let X = this._shape.extractShapePointsToFlatArray([], B),
              Q = this._shape.shapeHoles.map((_) => {
                let I = _.extractShapePointsToFlatArray([], B),
                  R = [];
                for (let _ = I.length - 1; _ >= 1; _ -= 2) {
                  let B = I[_ - 1],
                    z = I[_ - 0];
                  R.push(B, z);
                }
                return R;
              }),
              $ = [],
              et = [];
            for (let _ = 0; _ < X.length; _ += 2) et.push([X[_], X[_ + 1]]);
            $.push(et);
            for (let _ = 0; _ < Q.length; _++) {
              let I = Q[_],
                R = [];
              for (let _ = 0; _ < I.length; _ += 2) R.push([I[_], I[_ + 1]]);
              $.push(R);
            }
            (j = _.isText
              ? 0.1 *
                new lW()
                  .setFromPoints(_.points.map((_) => _.position))
                  .getSize(new rs())
                  .length()
              : 0 === $[0].length
              ? R
              : (0, xj.default)($).distance),
              R <= 0
                ? ((this._bevel = 0), (this._bevelSegments = 0))
                : ((this._bevel = Math.min(R, j, I / 2)),
                  (this._bevelSegments = Math.floor(z)));
            try {
              G = io({
                windingRule: k,
                elementType: bW.BOUNDARY_CONTOURS,
                vertexSize: 2,
                strict: !0,
                contours: [X],
              });
            } catch {
              G = xG;
            }
            try {
              q = io({
                windingRule: bH.ODD,
                elementType: bW.BOUNDARY_CONTOURS,
                vertexSize: 2,
                strict: !0,
                contours: [...Q],
              });
            } catch {
              q = xH;
            }
            if (!G) throw Error("error generating geometry");
            let er = G.elementCount;
            if (q) {
              G.elementCount += q.elementCount;
              for (let _ = 0; _ < q.elements.length; _++) {
                let I = q.elements[_],
                  R = _ % 2 == 0 ? G.vertexCount : 0;
                G.elements.push(I + R);
              }
              for (let _ = 0; _ < q.vertexIndices.length; _++) {
                let I = q.vertexIndices[_],
                  R = G.vertexCount;
                G.vertexIndices.push(I + R);
              }
              for (let _ = 0; _ < q.vertices.length; _++) {
                let I = q.vertices[_];
                G.vertices.push(I);
              }
            }
            let es = 1 / 0,
              ea = -1 / 0,
              en = 1 / 0,
              eo = -1 / 0;
            for (let _ = 0, I = G.vertexCount; _ < I; _++) {
              let I = 2 * _,
                R = G.vertices[I + 0],
                B = G.vertices[I + 1];
              R < es && (es = R),
                R > ea && (ea = R),
                B < en && (en = B),
                B > eo && (eo = B);
            }
            (this._minX = es),
              (this._minY = en),
              (this._width = ea - es),
              (this._height = eo - en),
              (this._buffer = new xV(this._computeBufferEstimatedSize(G)));
            let el = [],
              eh = [];
            for (let _ = G.elementCount - 1; _ >= 0; _--) {
              let I = _ >= er,
                R = 2 * _,
                z = G.elements[R + 0],
                k = G.elements[R + 1],
                q = z + k,
                X = {
                  start: z,
                  count: k,
                  normals: [],
                  continuous: [],
                  concave: [],
                },
                $ = z,
                et = q - 1,
                es = z + 1,
                ea = this._shape.roundedCurves.length;
              do {
                let _ = $ - z,
                  R = G.vertices[2 * et + 0],
                  B = G.vertices[2 * et + 1],
                  V = G.vertices[2 * $ + 0],
                  j = G.vertices[2 * $ + 1],
                  Q = G.vertices[2 * es + 0],
                  er = G.vertices[2 * es + 1],
                  en = V - R,
                  eo = j - B,
                  el = Math.sqrt(en * en + eo * eo);
                (en /= el), (eo /= el);
                let eh = V - Q,
                  ec = j - er,
                  ed = Math.sqrt(eh * eh + ec * ec);
                (eh /= ed),
                  (ec /= ed),
                  (X.normals[2 * _ + 0] = -ec),
                  (X.normals[2 * _ + 1] = eh),
                  (X.concave[_] = en * ec - eo * eh > 0);
                let ep = G.vertexIndices[$];
                if (Array.isArray(ep)) X.continuous[_] = !1;
                else {
                  let [I, R] = this._shape.getCurveIndexFromVertexId(
                    ep - 1,
                    !0
                  );
                  if (R > 0 && R < 1) X.continuous[_] = !0;
                  else {
                    let B = 1 === R ? I + 1 : I - 1;
                    B = (B + ea) % ea;
                    let z = 1 === R ? 0 : 1,
                      k = this._shape.roundedCurves[I].getTangent(R),
                      V = this._shape.roundedCurves[B].getTangent(z);
                    X.continuous[_] = k.dot(V) > 0.95;
                  }
                }
                I &&
                  ((X.normals[2 * _ + 0] *= -1), (X.normals[2 * _ + 1] *= -1)),
                  ([et, $, es] = [$, es, es + 1]),
                  es >= q && (es -= k);
              } while (es !== z + 1);
              let en = [];
              en.push({
                bevelI: 0,
                angle: 0,
                size: 0,
                boundary: {
                  vertices: G.vertices.slice(2 * z, 2 * q),
                  vertexCount: k,
                  vertexIndices: Array(k)
                    .fill(!0)
                    .map((_, I) => [I, I]),
                  elements: [0, k],
                  elementCount: 1,
                  mesh: null,
                },
                reverseMap: [],
                insetPoints: G.vertices.slice(2 * z, 2 * q),
              });
              let eo = 0;
              for (let _ = 1; _ <= this._bevelSegments; _++) {
                let R = ((_ / this._bevelSegments) * Math.PI) / 2,
                  z = (1 - Math.cos(R)) * this._bevel,
                  V = [],
                  j = [],
                  q = [],
                  Q = [],
                  $ = 0;
                for (let _ = 0; _ < k; _++) {
                  let R = 2 * _,
                    et = ((_ - 1 + k) % k) * 2,
                    er = G.vertices[2 * X.start + R + 0],
                    es = G.vertices[2 * X.start + R + 1],
                    ea = -X.normals[et + 0] * z,
                    en = -X.normals[et + 1] * z,
                    eo = -X.normals[R + 0] * z,
                    el = -X.normals[R + 1] * z;
                  if (X.concave[_] || (!X.concave[_] && I)) {
                    let R = Math.atan2(en, ea),
                      k = Math.atan2(el, eo);
                    k > R && (k -= 2 * Math.PI);
                    let j = k - R;
                    if (X.continuous[_] || I) {
                      let B = R + j / 2,
                        k = Math.cos(B) * z,
                        G = Math.sin(B) * z;
                      (V[2 * $ + 0] = er + k * (I ? -1 : 1)),
                        (V[2 * $ + 1] = es + G * (I ? -1 : 1)),
                        (Q[$] = _),
                        $++;
                    } else {
                      let I = Math.max(
                        1,
                        Math.floor(((B / 4) * Math.abs(j)) / Math.PI)
                      );
                      for (let B = 0; B <= I; B++) {
                        let k = R + j * (B / I),
                          G = Math.cos(k) * z,
                          q = Math.sin(k) * z;
                        (V[2 * $ + 0] = er + G),
                          (V[2 * $ + 1] = es + q),
                          (Q[$] = _),
                          $++;
                      }
                    }
                  } else
                    (V[2 * $ + 0] = er + ea),
                      (V[2 * $ + 1] = es + en),
                      (Q[$] = _),
                      (j[_] = $),
                      (V[2 * ++$ + 0] = er),
                      (V[2 * $ + 1] = es),
                      (Q[$] = _),
                      (V[2 * ++$ + 0] = er + eo),
                      (V[2 * $ + 1] = es + el),
                      (Q[$] = _),
                      (q[_] = $),
                      $++;
                }
                let et = io({
                  windingRule: bH.POSITIVE,
                  elementType: bW.BOUNDARY_CONTOURS,
                  vertexSize: 2,
                  strict: !0,
                  contours: [V],
                  edgeCreateCallback: (_) => {
                    let I = _.Org.idx,
                      R = Q[I],
                      B = Q[(I + 1) % Q.length];
                    (_.idx = [R, B]), (_.Sym.idx = [B, R]);
                  },
                  vertexIdCallback: (_) => {
                    let I = _.Lprev.idx;
                    return [I ? I[1] : 0, _.idx ? _.idx[0] : 0];
                  },
                });
                if (!et)
                  throw (
                    (console.log("Error"),
                    Error(`error generating bevel geometry for ${_}'th loop`))
                  );
                if (!et.vertexCount) {
                  eo =
                    (1 -
                      Math.sin(
                        (((_ - 1) / this._bevelSegments) * Math.PI) / 2
                      )) *
                    this._bevel;
                  break;
                }
                for (let _ = 0; _ < et.vertexIndices.length; _++) {
                  let [I, R] = et.vertexIndices[_];
                  if (I === R) continue;
                  let B = R;
                  R < I && (B += k);
                  for (let z = I; z < B; z++) {
                    let B = z % k,
                      V = (z + 1) % k;
                    if (!X.continuous[B] || !X.continuous[V]) {
                      (et.vertexIndices[_] = [I, B]),
                        et.vertexIndices.splice(_ + 1, 0, [V, R]),
                        et.vertices.splice(
                          (_ + 1) * 2,
                          0,
                          et.vertices[2 * _],
                          et.vertices[2 * _ + 1]
                        );
                      break;
                    }
                  }
                }
                en.push({
                  bevelI: _,
                  angle: R,
                  size: z,
                  boundary: et,
                  reverseMap: Q,
                  insetPoints: V,
                });
              }
              let ee = (_, I, R) => {
                  let B = 0,
                    z = _.boundary.vertexIndices.length;
                  for (; B < z && R(_.boundary.vertexIndices[I]); )
                    (I = (I + 1) % z), B++;
                  return B;
                },
                ec = el.length;
              for (let _ = 1; _ < en.length; _++) {
                let I = en[_ - 1],
                  R = en[_],
                  B = I.boundary.vertexIndices.length,
                  z = R.boundary.vertexIndices.length;
                if (!B || !z) break;
                let j = X.concave.length,
                  G = 0,
                  q = _A(0, k);
                for (
                  ;
                  !I.boundary.vertexIndices.filter(q).length ||
                  !R.boundary.vertexIndices.filter(q).length;

                )
                  q = _A(++G, k);
                let Q = I.boundary.vertexIndices.findIndex(q),
                  $ = R.boundary.vertexIndices.findIndex(q);
                do Q = (Q + 1) % B;
                while (q(I.boundary.vertexIndices[Q]));
                do $ = ($ + 1) % z;
                while (q(R.boundary.vertexIndices[$]));
                let et = (G = (G + 1) % k),
                  er = 0,
                  es = this._buildBevelVert(X, I, (Q - 1 + B) % B, void 0, er),
                  ea = this._buildBevelVert(X, R, ($ - 1 + z) % z, void 0, er),
                  eo = es,
                  eh = ea,
                  ec,
                  ed,
                  ep = !1;
                do {
                  er = (G || j) / j;
                  let _ = ee(I, Q, (q = _A(G, k))),
                    et = ee(R, $, q),
                    es = ep;
                  if (((ep = !1), _ && !et)) {
                    for (let R = 0; R < _; R++)
                      (ec = this._buildBevelVert(
                        X,
                        I,
                        (Q + R) % B,
                        R / (_ - 1),
                        er
                      )),
                        el.push(eo.topN, ec.topP, eh.topN),
                        !1 === V && el.push(ec.bottomP, eo.bottomN, eh.bottomN),
                        (eo = ec);
                    ep = !0;
                  } else if (!_ && et)
                    for (let _ = 0; _ < et; _++)
                      (ed = this._buildBevelVert(
                        X,
                        R,
                        ($ + _) % z,
                        _ / (et - 1),
                        er
                      )),
                        el.push(eh.topN, eo.topP, ed.topP),
                        !1 === V && el.push(eo.bottomP, eh.bottomN, ed.bottomP),
                        (eh = ed);
                  else if (_ && et) {
                    if (
                      ((ec = this._buildBevelVert(X, I, Q, 0, er)),
                      (ed = this._buildBevelVert(X, R, $, 0, er)),
                      es
                        ? (el.push(eo.topN, ed.topP, eh.topN),
                          el.push(eo.topN, ec.topP, ed.topP),
                          !1 === V &&
                            (el.push(ed.bottomP, eo.bottomN, eh.bottomN),
                            el.push(ed.bottomP, ec.bottomP, eo.bottomN)))
                        : (el.push(eh.topN, eo.topN, ec.topP),
                          el.push(eh.topN, ec.topP, ed.topP),
                          !1 === V &&
                            (el.push(ec.bottomP, eo.bottomN, eh.bottomN),
                            el.push(ec.bottomP, eh.bottomN, ed.bottomP))),
                      (eo = ec),
                      (eh = ed),
                      _ === et)
                    )
                      for (let k = 1; k < _; k++)
                        (ec = this._buildBevelVert(
                          X,
                          I,
                          (Q + k) % B,
                          k / (_ - 1),
                          er
                        )),
                          (ed = this._buildBevelVert(
                            X,
                            R,
                            ($ + k) % z,
                            k / (et - 1),
                            er
                          )),
                          el.push(eo.topN, ec.topP, eh.topN),
                          el.push(eh.topN, ec.topP, ed.topP),
                          !1 === V &&
                            (el.push(ec.bottomP, eo.bottomN, eh.bottomN),
                            el.push(ec.bottomP, eh.bottomN, ed.bottomP)),
                          (eo = ec),
                          (eh = ed);
                    else if (_ > et) {
                      let k = _ / et,
                        j = 0;
                      for (let G = 1; G < _; G++)
                        (ec = this._buildBevelVert(
                          X,
                          I,
                          (Q + G) % B,
                          G / (_ - 1),
                          er
                        )),
                          el.push(eo.topN, ec.topP, eh.topN),
                          !1 === V &&
                            el.push(ec.bottomP, eo.bottomN, eh.bottomN),
                          (eo = ec),
                          G > (j + 1) * k &&
                            (j++,
                            (ed = this._buildBevelVert(
                              X,
                              R,
                              ($ + j) % z,
                              j / (et - 1),
                              er
                            )),
                            el.push(eh.topN, ec.topP, ed.topP),
                            !1 === V &&
                              el.push(ec.bottomP, eh.bottomN, ed.bottomP),
                            (eh = ed));
                    } else {
                      let k = et / _,
                        j = 0;
                      for (let G = 1; G < et; G++)
                        (ed = this._buildBevelVert(
                          X,
                          R,
                          ($ + G) % z,
                          G / (et - 1),
                          er
                        )),
                          el.push(eh.topN, ec.topP, ed.topP),
                          !1 === V &&
                            el.push(ec.bottomP, eh.bottomN, ed.bottomP),
                          (eh = ed),
                          G > (j + 1) * k &&
                            (j++,
                            (ec = this._buildBevelVert(
                              X,
                              I,
                              (Q + j) % B,
                              j / (_ - 1),
                              er
                            )),
                            el.push(eo.topN, ec.topP, eh.topN),
                            !1 === V &&
                              el.push(ec.bottomP, eo.bottomN, eh.bottomN),
                            (eo = ec));
                    }
                  }
                  (Q = (Q + _) % B), ($ = ($ + et) % z), (G = (G + 1) % j);
                } while (G !== et);
              }
              if (
                (!1 === V &&
                  this._depth > 2 * this._bevel &&
                  this._buildWall(en, X, el),
                I)
              ) {
                let _ = [];
                for (let I = el.length - 1; I >= ec + 2; I -= 3) {
                  let R = el[I - 2],
                    B = el[I - 1],
                    z = el[I - 0];
                  _.push(z, B, R);
                }
                el.splice(ec, el.length - ec, ..._);
              }
              if (I) {
                let _ = [];
                for (
                  let I = en[en.length - 1].boundary.vertices.length - 1;
                  I >= 1;
                  I -= 2
                ) {
                  let R = en[en.length - 1].boundary.vertices[I - 1],
                    B = en[en.length - 1].boundary.vertices[I - 0];
                  _.push(R, B);
                }
                eh.push(_);
              }
              if (!I) {
                let _ = en[en.length - 1],
                  I;
                try {
                  I = io({
                    windingRule: en.length > 1 ? bH.POSITIVE : bH.ODD,
                    elementType: bW.POLYGONS,
                    vertexSize: 2,
                    strict: !0,
                    contours: [_.insetPoints, ...eh],
                  });
                } catch {
                  I = xW;
                }
                if (!I) throw Error("Error generating geometry for surface");
                0 === Q.length &&
                  this._bevel < j &&
                  Object.assign(this, {
                    useNgonForTopBottomFaceDuringBake: !0,
                  });
                for (let _ = 0; _ < 3 * I.elementCount; _ += 3) {
                  let R = this._buildSurfaceVert(I, I.elements[_ + 0], eo),
                    B = this._buildSurfaceVert(I, I.elements[_ + 1], eo),
                    z = this._buildSurfaceVert(I, I.elements[_ + 2], eo);
                  el.push(R.top, B.top, z.top),
                    !1 === V && el.push(z.bottom, B.bottom, R.bottom);
                }
              }
              this.vertexCache = {};
            }
            this._buffer.shrink();
            let ec = new s0(Uint32Array.from(el), 1),
              ed = new s0(this._buffer.positions, 3),
              ep = new s0(this._buffer.normals, 3),
              ef = new s0(this._buffer.uvs, 2);
            (ed.needsUpdate = !0),
              (ep.needsUpdate = !0),
              (ef.needsUpdate = !0),
              (ec.needsUpdate = !0),
              this.setAttribute("position", ed),
              this.setAttribute("normal", ep),
              this.setAttribute("uv", ef),
              this.setIndex(ec);
          }
          _computeBufferEstimatedSize(_) {
            return 2 * _.vertexCount * (2 + this._bevelSegments);
          }
          _buildWall(_, I, R) {
            let B = _[0];
            for (let _ = 0, z = B.boundary.vertexCount; _ < z; _++) {
              let k = this._buildBevelVert(I, B, _),
                V = this._buildBevelVert(I, B, (_ + 1) % z);
              R.push(V.topP, k.topN, k.bottomN),
                R.push(V.topP, k.bottomN, V.bottomP);
            }
          }
          _buildSurfaceVert(_, I, R) {
            let B = I.toString();
            if (B in this.vertexCache) return this.vertexCache[B];
            let z = _.vertices[2 * I + 0],
              k = _.vertices[2 * I + 1],
              V = (z - this._minX) / this._width,
              j = (k - this._minY) / this._height;
            this.forPathBevel && (j = 1);
            let G = this._buffer.get(this.forPathBevel ? 1 : 2),
              q = 3 * G,
              X = 2 * G,
              Q = { top: G + 0, bottom: G + 1 };
            return (
              (this._buffer.positions[q + 0] = z),
              (this._buffer.positions[q + 1] = k),
              (this._buffer.positions[q + 2] = this.forPathBevel
                ? this._bevel
                : this._depth - R),
              (this._buffer.normals[q + 0] = 0),
              (this._buffer.normals[q + 1] = 0),
              (this._buffer.normals[q + 2] = 1),
              (this._buffer.uvs[X + 0] = V),
              (this._buffer.uvs[X + 1] = j),
              !1 === this.forPathBevel &&
                ((this._buffer.positions[q + 3] = z),
                (this._buffer.positions[q + 4] = k),
                (this._buffer.positions[q + 5] = R),
                (this._buffer.normals[q + 3] = 0),
                (this._buffer.normals[q + 4] = 0),
                (this._buffer.normals[q + 5] = -1),
                (this._buffer.uvs[X + 2] = V),
                (this._buffer.uvs[X + 3] = j)),
              (this.vertexCache[B] = Q),
              Q
            );
          }
          _buildBevelVert(_, I, R, B = 1, z) {
            let k = `${I.bevelI}:${R}`;
            if (
              k in this.vertexCache &&
              0 !== z &&
              1 !== z &&
              (!z || z === this.vertexCache[k].pathBevelUCoord)
            )
              return this.vertexCache[k];
            let [V, j] = I.boundary.vertexIndices[R],
              G,
              q,
              X,
              Q;
            V !== j
              ? ((q = V),
                (G = j),
                (Q = !1),
                (X = _.continuous[q] && _.continuous[G]))
              : ((q = ((G = V) - 1 + _.count) % _.count),
                (Q = _.concave[G] && I.bevelI > 0),
                (X = _.continuous[G] || Q));
            let $ = Math.cos(I.angle),
              et = Math.sin(I.angle),
              er = 2 * R,
              es = 2 * G,
              ea = 2 * q,
              en = I.boundary.vertices[er + 0],
              eo = I.boundary.vertices[er + 1],
              el = (1 - et) * this._bevel,
              eh = (en - this._minX) / this._width,
              ec = (eo - this._minY) / this._height;
            this.forPathBevel && (void 0 !== z && (eh = z), (ec = 1));
            let ed = _.normals[es + 0],
              ep = _.normals[es + 1],
              ef = _.normals[ea + 0],
              em = _.normals[ea + 1];
            if (Q) {
              let _ = ef - ed,
                I = em - ep,
                R = Math.sqrt(
                  (ed += _ * (1 - B)) * ed + (ep += I * (1 - B)) * ep
                );
              (ed /= R), (ep /= R);
            }
            let ey = this.forPathBevel
                ? this._buffer.get(X ? 1 : 2)
                : this._buffer.get(X ? 2 : 4),
              ex = 3 * ey,
              eb = 2 * ey,
              ew = {
                i: R,
                fi: G,
                topP: ey + 0,
                topN: ey + 0,
                bottomP: ey + 1,
                bottomN: ey + 1,
                pathBevelUCoord: z,
              };
            return (
              (this._buffer.positions[ex + 0] = en),
              (this._buffer.positions[ex + 1] = eo),
              (this._buffer.positions[ex + 2] =
                (this.forPathBevel ? this._bevel : this._depth) - el),
              (this._buffer.normals[ex + 0] = ed * $),
              (this._buffer.normals[ex + 1] = ep * $),
              (this._buffer.normals[ex + 2] = et),
              (this._buffer.uvs[eb + 0] = eh),
              (this._buffer.uvs[eb + 1] = ec),
              !1 === this.forPathBevel &&
                ((this._buffer.positions[ex + 3] = en),
                (this._buffer.positions[ex + 4] = eo),
                (this._buffer.positions[ex + 5] = el),
                (this._buffer.normals[ex + 3] = ed * $),
                (this._buffer.normals[ex + 4] = ep * $),
                (this._buffer.normals[ex + 5] = -et),
                (this._buffer.uvs[eb + 2] = ec),
                (this._buffer.uvs[eb + 3] = eh)),
              X ||
                (this.forPathBevel
                  ? ((ey += 1), (ex += 3), (eb += 2))
                  : ((ey += 2), (ex += 6), (eb += 4)),
                (ew.topP = ey + 0),
                (ew.bottomP = ey + 1),
                (this._buffer.positions[ex + 0] = en),
                (this._buffer.positions[ex + 1] = eo),
                (this._buffer.positions[ex + 2] =
                  (this.forPathBevel ? this._bevel : this._depth) - el),
                (this._buffer.normals[ex + 0] = ef * $),
                (this._buffer.normals[ex + 1] = em * $),
                (this._buffer.normals[ex + 2] = et),
                (this._buffer.uvs[eb + 0] = eh),
                (this._buffer.uvs[eb + 1] = ec),
                !1 === this.forPathBevel &&
                  ((this._buffer.positions[ex + 3] = en),
                  (this._buffer.positions[ex + 4] = eo),
                  (this._buffer.positions[ex + 5] = el),
                  (this._buffer.normals[ex + 3] = ef * $),
                  (this._buffer.normals[ex + 4] = em * $),
                  (this._buffer.normals[ex + 5] = -et),
                  (this._buffer.uvs[eb + 2] = ec),
                  (this._buffer.uvs[eb + 3] = eh))),
              (this.vertexCache[k] = ew),
              ew
            );
          }
          clone() {
            let _ = new xq(
              this._shape,
              this._depth,
              this._bevel,
              this._curveSegments,
              this._bevelSegmentsInput
            );
            return (_.userData = Ea(this.userData)), _;
          }
        },
        xY = class extends ai {
          constructor(_, I = 12, R = {}) {
            super(),
              (this.type = "ShapeGeometry"),
              (this.windingRule = bH.ODD),
              (this.elementType = bW.POLYGONS),
              (this.polySize = 3),
              (this.vertexSize = 2),
              (this.strict = !0),
              (this._shape = _),
              (this._curveSegments = I),
              (this._triangulationOptions = Object.assign(
                {
                  windingRule: bH.ODD,
                  elementType: bW.POLYGONS,
                  polySize: 3,
                  vertexSize: 2,
                  strict: !0,
                },
                R
              ));
            let B = this._shape.extractShapePointsToFlatArray(
                [],
                this._curveSegments
              ),
              z = this._shape.shapeHoles.map((_) =>
                _.extractShapePointsToFlatArray([], this._curveSegments)
              ),
              k,
              V = !0,
              j = !0,
              G,
              q;
            for (let _ = 0, I = B.length / 2; _ < I; _++) {
              let I = 2 * _,
                R = B[I + 0],
                z = B[I + 1];
              if (
                (void 0 !== G && R !== G && (V = !1),
                void 0 !== q && z !== q && (j = !1),
                (G = R),
                (q = z),
                !V && !j)
              )
                break;
            }
            if (!V && !j)
              try {
                k = io({
                  contours: [B, ...z],
                  windingRule: this._triangulationOptions.windingRule,
                  elementType: this._triangulationOptions.elementType,
                  polySize: this._triangulationOptions.polySize,
                  vertexSize: this._triangulationOptions.vertexSize,
                  strict: this._triangulationOptions.strict,
                });
              } catch {
                k = xG;
              }
            let X = k?.vertexCount ?? 1,
              Q = k?.elementCount ?? 1;
            if (
              ((this._positionAttribute = new s0(new Float32Array(3 * X), 3)),
              (this._normalAttribute = new s0(new Float32Array(3 * X), 3)),
              (this._uvAttribute = new s0(new Float32Array(2 * X), 2)),
              (this._indexAttribute = new s0(new Uint32Array(3 * Q), 1)),
              k)
            ) {
              let _ = 1 / 0,
                I = -1 / 0,
                R = 1 / 0,
                B = -1 / 0;
              for (let z = 0; z < X; z++) {
                let V = 2 * z,
                  j = k.vertices[V + 0],
                  G = k.vertices[V + 1];
                j < _ && (_ = j),
                  j > I && (I = j),
                  G < R && (R = G),
                  G > B && (B = G);
              }
              let z = I - _,
                V = B - R;
              for (let I = 0; I < X; I++) {
                let B = 2 * I,
                  j = k.vertices[B + 0],
                  G = k.vertices[B + 1],
                  q = (j - _) / z,
                  X = (G - R) / V;
                this._positionAttribute.setXYZ(I, j, G, 0),
                  this._normalAttribute.setXYZ(I, 0, 0, 1),
                  this._uvAttribute.setXY(I, q, X);
              }
              for (let _ = 0; _ < Q; _++) {
                let I = 3 * _,
                  R = k.elements[I + 0],
                  B = k.elements[I + 1],
                  z = k.elements[I + 2];
                this._indexAttribute.setX(I + 0, R),
                  this._indexAttribute.setX(I + 1, B),
                  this._indexAttribute.setX(I + 2, z);
              }
            }
            this.setAttribute("position", this._positionAttribute),
              this.setAttribute("normal", this._normalAttribute),
              this.setAttribute("uv", this._uvAttribute),
              this.setIndex(this._indexAttribute),
              this.setDrawRange(0, (k?.elementCount ?? 1) * 3);
          }
          clone() {
            let _ = new xY(this._shape, this._curveSegments);
            return (_.userData = Ea(this.userData)), _;
          }
        },
        xX = class extends xq {
          constructor(_, I, R = 0, B = 12, z = 3, k = bH.ODD) {
            super(_, I, R, B, z, k), (this.type = "ShapeGeometry");
          }
          _computeBufferEstimatedSize(_) {
            return 2 * _.vertexCount * (2 + this._bevelSegments);
          }
          _buildWall(_, I, R) {
            let B = _[0];
            for (let _ = 0, z = B.boundary.vertexCount; _ < z; _++) {
              let k = this._buildBevelVert(I, B, _),
                V = this._buildBevelVert(I, B, (_ + 1) % z);
              R.push(V.topP, k.topN, k.bottomN),
                R.push(V.topP, k.bottomN, V.bottomP);
            }
          }
          clone() {
            let _ = new xX(
              this._shape,
              this._depth,
              this._bevel,
              this._curveSegments,
              this._bevelSegmentsInput
            );
            return (_.userData = Ea(this.userData)), _;
          }
        },
        xQ = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R = Object.assign(
                {},
                I?.parameters ?? {
                  width: 100,
                  subdivisions: 40,
                  roundness: 0,
                  extrudeBevelSize: 0,
                  extrudeBevelSegments: 3,
                  windingRule: bH.ODD,
                },
                _.parameters
              ),
              B = Math.abs(R.width),
              z = Math.abs(R.height ?? R.width),
              k = Math.abs(R.depth ?? 0),
              V = _.shape ?? I?.shape,
              j = V?.roundness ?? R.roundness;
            void 0 !== V &&
              (V instanceof xT
                ? (V.width !== B || V.height !== z) && V.applySize(B, z)
                : (V = new xT(B, z).fromJSON(V)),
              _.parameters?.roundness !== void 0 &&
                _.parameters?.roundness > 0 &&
                V.update());
            let G = V ?? new xT(B, z);
            return {
              parameters: Object.assign(R, {
                width: B,
                height: z,
                depth: k,
                roundness: j,
              }),
              shape: G,
            };
          }
          static build(_) {
            let {
              depth: I,
              extrudeBevelSize: R,
              extrudeBevelSegments: B,
              subdivisions: z,
              roundness: k,
              windingRule: V,
            } = _.parameters;
            return (
              (_.shape.roundness = k),
              Object.assign(
                I <= 0
                  ? new xY(_.shape, z, { windingRule: V })
                  : new xX(_.shape, I, R, z, B, V),
                { userData: { ..._, type: "VectorGeometry" } }
              )
            );
          }
        },
        xZ = 2 * Math.PI,
        xK = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R = Object.assign(
              {},
              I?.parameters ?? {
                width: 100,
                depth: 0,
                spikes: 64,
                angle: 360,
                innerRadius: 0,
                extrudeBevelSize: 0,
                extrudeBevelSegments: 1,
              },
              _.parameters
            );
            return (
              (R.angle = rr.clamp(R.angle, 0, 360)),
              {
                shape: _.shape && _.shape instanceof xT ? _.shape : new xT(),
                parameters: Object.assign(R, {
                  width: Math.abs(R.width),
                  height: Math.abs(R.height ?? R.width),
                  depth: Math.abs(R.depth ?? 0),
                }),
              }
            );
          }
          static build(_) {
            let I,
              {
                width: R,
                height: B,
                spikes: z,
                angle: k,
                innerRadius: V,
                depth: j,
                extrudeBevelSize: G,
                extrudeBevelSegments: q,
              } = _.parameters,
              X = _.shape,
              Q = (function (_, I, R, B, z, k) {
                if (B >= xZ)
                  return z > 30 || z % 4 == 0
                    ? ((function (_, I, R, B = 0, z = 0, k = 0) {
                        let V = 0.5522847498 * I,
                          j = 0.5522847498 * R;
                        _.addPoint(B0(z - I, k, z - I, k - j, z - I, k + j)),
                          _.addPoint(B0(z, k + R, z - V, k + R, z + V, k + R)),
                          _.addPoint(B0(z + I, k, z + I, k + j, z + I, k - j)),
                          _.addPoint(B0(z, k - R, z + V, k - R, z - V, k - R)),
                          B > 0 && dI(_, I, R, B);
                      })(_, I, R, k),
                      Math.round(z / 4))
                    : cI(_, B, z, I, R, k);
                let V = { x: 0, y: R },
                  j = (B = Math.max(B, 0.001)) + 0.5 * Math.PI,
                  G = { x: Math.cos(j) * I, y: Math.sin(j) * R },
                  q = (function ({
                    px: _,
                    py: I,
                    cx: R,
                    cy: B,
                    rx: z,
                    ry: k,
                    largeArcFlag: V,
                    sweepFlag: j,
                  }) {
                    var G, q;
                    let X,
                      Q,
                      $,
                      et,
                      er,
                      es,
                      ea,
                      en,
                      eo,
                      el,
                      eh,
                      ec = [];
                    if (0 === z || 0 === k) return [];
                    let ed = (_ - R) / 2,
                      ep = (I - B) / 2;
                    if (0 === ed && 0 === ep) return [];
                    let ef =
                      Math.pow(ed, 2) / Math.pow((z = Math.abs(z)), 2) +
                      Math.pow(ep, 2) / Math.pow((k = Math.abs(k)), 2);
                    ef > 1 && ((z *= Math.sqrt(ef)), (k *= Math.sqrt(ef)));
                    let em =
                        ((G = z),
                        (q = k),
                        (X = Math.pow(G, 2)),
                        (Q = Math.pow(q, 2)),
                        ($ = Math.pow(ed, 2)),
                        (er = X * Q - X * (et = Math.pow(ep, 2)) - Q * $) < 0 &&
                          (er = 0),
                        (er /= X * et + Q * $),
                        (es =
                          (((er = Math.sqrt(er) * (V === j ? -1 : 1)) * G) /
                            q) *
                          ep),
                        (ea = (-(er * q) / G) * ed),
                        (el = $O(
                          1,
                          0,
                          (en = (ed - es) / G),
                          (eo = (ep - ea) / q)
                        )),
                        (eh = $O(en, eo, (-ed - es) / G, (-ep - ea) / q)),
                        !j && eh > 0 && (eh -= xD),
                        j && eh < 0 && (eh += xD),
                        {
                          centerx: es + (_ + R) / 2,
                          centery: ea + (I + B) / 2,
                          ang1: el,
                          ang2: eh,
                        }),
                      { ang1: ey, ang2: ex } = em,
                      { centerx: eb, centery: ew } = em,
                      e_ = Math.abs(ex) / (xD / 4);
                    1e-7 > Math.abs(1 - e_) && (e_ = 1);
                    let eS = Math.max(Math.ceil(e_), 1);
                    ex /= eS;
                    for (let _ = 0; _ < eS; _++)
                      ec.push(
                        (function (_, I) {
                          let R =
                              1.5707963267948966 === I
                                ? 0.551915024494
                                : -1.5707963267948966 === I
                                ? -0.551915024494
                                : 1.3333333333333333 * Math.tan(I / 4),
                            B = Math.cos(_),
                            z = Math.sin(_),
                            k = Math.cos(_ + I),
                            V = Math.sin(_ + I);
                          return [
                            { x: B - z * R, y: z + B * R },
                            { x: k + V * R, y: V - k * R },
                            { x: k, y: V },
                          ];
                        })(ey, ex)
                      ),
                        (ey += ex);
                    return ec.map((_) => {
                      let { x: I, y: R } = vA(_[0], z, k, eb, ew),
                        { x: B, y: V } = vA(_[1], z, k, eb, ew),
                        { x: j, y: G } = vA(_[2], z, k, eb, ew);
                      return { x1: I, y1: R, x2: B, y2: V, x: j, y: G };
                    });
                  })({
                    px: V.x,
                    py: V.y,
                    cx: G.x,
                    cy: G.y,
                    rx: I,
                    ry: R,
                    largeArcFlag: B > Math.PI,
                    sweepFlag: !0,
                  });
                return z > 30 || z % q.length == 0
                  ? (function (_, I, R, B, z, k, V, j) {
                      let G = Math.round(z / B.length);
                      _.addPoint(Bd(I, R));
                      for (let I = 0, R = B.length; I < R; I++) {
                        let R = B[I],
                          z = _.points[I],
                          k = Bd(R.x, R.y);
                        z.controls[1].position.set(R.x1, R.y1),
                          k.controls[0].position.set(R.x2, R.y2),
                          _.addPoint(k);
                      }
                      return j > 0 ? hI(_, k, V, j) : _.addPoint(Bd(0, 0)), G;
                    })(_, V.x, V.y, q, z, I, R, k)
                  : cI(_, B, z, I, R, k);
              })(X, 0.5 * R, 0.5 * B, (k * Math.PI) / 180, z, V);
            return (
              (X.isClosed = !0),
              X.update(),
              0 === k
                ? (I = new ai()).setAttribute("position", new s4([], 3))
                : (I = xQ.create({
                    shape: X,
                    parameters: {
                      subdivisions: Q,
                      depth: j,
                      extrudeBevelSize: G,
                      extrudeBevelSegments: q,
                    },
                  })),
              Object.assign(I, { userData: { ..._, type: "EllipseGeometry" } })
            );
          }
        };
      function cI(_, I, R, B, z, k) {
        let V = -I / R;
        for (let I = 0; I <= R; I++) {
          let R = V * I,
            k = Math.sin(R) * B,
            j = Math.cos(R) * z;
          _.addPoint(Bd(k, j));
        }
        return (
          I < xZ
            ? k > 0
              ? hI(_, B, z, k)
              : _.addPoint(Bd(0, 0))
            : (_.removePoint(_.points[_.points.length - 1]),
              k > 0 && dI(_, B, z, k)),
          1
        );
      }
      function Bd(_, I) {
        return new xn(rr.generateUUID(), new rs(_, I));
      }
      function B0(_, I, R, B, z, k) {
        let V = Bd(_, I);
        return (
          V.controls[0].position.set(R, B), V.controls[1].position.set(z, k), V
        );
      }
      function hI(_, I, R, B) {
        fI(_, I, R, B).forEach((I) => _.addPoint(I));
      }
      function dI(_, I, R, B) {
        let z = fI(_, I, R, B),
          k = new xT();
        z.forEach((_) => k.addPoint(_)),
          (k.isClosed = !0),
          _.shapeHoles.push(k);
      }
      function fI(_, I, R, B) {
        let z = (B * I) / 100,
          k = z * (Math.abs(R) / Math.abs(I)),
          V = new rs(z / I, k / R),
          j = _.points
            .map((_) => {
              let I = _.clone();
              return (I.uuid = rr.generateUUID()), I;
            })
            .reverse();
        return (
          j.forEach((_) => {
            _.position.multiply(V);
            let I = _.controls[0].position.clone().multiply(V),
              R = _.controls[1].position.clone().multiply(V);
            _.controls[0].position.copy(R), _.controls[1].position.copy(I);
          }),
          j
        );
      }
      var xJ = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R = Object.assign(
                {},
                I?.parameters ?? {
                  width: 100,
                  revolutions: 2,
                  segments: 40,
                  pathRadius: 10,
                  pathType: 0,
                  pathSegments: 30,
                  cornerRadius: 30,
                  cornerSegments: 4,
                },
                _.parameters
              ),
              B = Math.abs(R.width),
              z = Math.abs(R.height ?? B),
              k = Math.abs(R.depth ?? B),
              V = Math.abs(Math.min(B, k)) / 2;
            return {
              parameters: Object.assign(R, {
                width: B,
                height: z,
                depth: k,
                radius: V,
                segments: Math.round(R.segments),
                pathSegments: Math.round(R.pathSegments),
                cornerSegments: Math.round(R.cornerSegments),
              }),
            };
          }
          static build(_) {
            let {
              width: I,
              height: R,
              depth: B,
              radius: z,
              revolutions: k,
              segments: V,
              pathRadius: j,
              pathType: G,
              pathSegments: q,
              cornerRadius: X,
              cornerSegments: Q,
            } = _.parameters;
            return Object.assign(new x0(!1, I, R, B, z, k, V, j, G, q, X, Q), {
              userData: { ..._, type: "HelixGeometry" },
            });
          }
        },
        x$ = new s3([0, 0, 0], 1),
        x0 = class extends ai {
          constructor(
            _ = !0,
            I = 1,
            R = 1,
            B = 1,
            z = 1,
            k = 1,
            V = 1,
            j = 1,
            G = 1,
            q = 1,
            X = 1,
            Q = 1
          ) {
            if ((super(), 0 === k)) return;
            let $ = _ && 1 === k;
            $ && (Q = 0), X > 100 && (X = 100), 0 === X && (Q = 0);
            let p = () => new rF(),
              et = new rF(),
              er = p(),
              es = p(),
              ea = p(),
              en,
              eo,
              el,
              eh,
              ec,
              ed,
              ep,
              ef,
              em = p(),
              ey = p(),
              ex = p(),
              eb = p(),
              ew = p(),
              e_ = p(),
              eS = p(),
              eA = p(),
              eC = R - 2 * j + 0.001,
              eT = eC / k,
              eP = Math.ceil(V * k),
              eI = eP + 1,
              eR = eC / eP,
              eB = -eC / 2,
              ez = q + 1,
              eF = (2 * Math.PI) / q,
              ek = Math.PI / 2 / Q,
              eU = Math.min((1 - X / 100) * j, j - 0.01),
              eV = j - eU,
              ej = 0,
              eH = 2 * Q + 2,
              eW = (ez * eH) / 2,
              eq = eW + ez * eI,
              eX = Math.max(0, ez * (eI + eH)),
              [eQ, eZ, eK] = [3, 3, 2].map((_) => Array(eX * _).fill(0)),
              eJ = [],
              e$ = z - j;
            function N(I, R) {
              let B = Math.PI / 2;
              (ef = (2 * Math.PI * ((ed = R * eR) % eT)) / eT + B),
                (ed += eB),
                (ep = Math.sin(ef) * e$),
                (ec = Math.cos(ef) * e$),
                _ ? I.set(ec, ep, ed) : I.set(ec, ed, ep);
            }
            N(et, -0.0000000001), N(er, 0), em.copy(et), N(et, 1);
            let e0 = et.distanceTo(er),
              e3 = $ ? 0 : eV + eU,
              e4 = e0 * eP + 2 * e3,
              e5 = e4 - e3;
            for (let I = 0; I <= eP; I++) {
              N(es, I),
                eA.subVectors(es, em).normalize(),
                em.copy(es),
                e_
                  .copy(es)
                  .setComponent(+_ + 1, 0)
                  .normalize(),
                eS.crossVectors(eA, e_).normalize();
              let R = 0 === I,
                B = I === eP,
                z = R ? (3 * Math.PI) / 2 : ek,
                k = R ? eU : e5,
                V = R ? ez : eq,
                G = R ? 0 : eX - ez,
                X = eA
                  .clone()
                  .multiplyScalar(R ? -eV : eV)
                  .add(es),
                en = eA
                  .clone()
                  .multiplyScalar(R ? -1 : 1)
                  .normalize();
              for (let _ = 0; _ < ez; _++) {
                let eo = _ * eF;
                if (
                  (ey.addVectors(
                    et.copy(e_).multiplyScalar(j * Math.cos(eo)),
                    er.copy(eS).multiplyScalar(j * Math.sin(eo))
                  ),
                  ex.copy(ey).normalize(),
                  R || B)
                ) {
                  $ ||
                    ((ej = G + _),
                    [0, 1, 2].forEach((_) => {
                      (eQ[3 * ej + _] = X.getComponent(_)),
                        (eZ[3 * ej + _] = en.getComponent(_));
                    }),
                    (eK[2 * ej] = +B),
                    (eK[2 * ej + 1] = _ / q)),
                    er.copy(ex).multiplyScalar(eU),
                    ea.addVectors(es, er);
                  for (let I = 0; I < Q; I++) {
                    let B = I * ek + z;
                    eb.addVectors(
                      et.copy(eA).multiplyScalar(eV * Math.sin(B)),
                      er.copy(ex).multiplyScalar(eV * Math.cos(B))
                    ),
                      ew.copy(eb).normalize(),
                      er.addVectors(ea, eb),
                      eb.normalize(),
                      (ej = V + I * ez + _),
                      [0, 1, 2].forEach((_) => {
                        (eQ[3 * ej + _] = er.getComponent(_)),
                          (eZ[3 * ej + _] = ew.getComponent(_));
                      });
                    let j = +R + Math.sin(B);
                    (eK[2 * ej] = (k + eV * j) / e4), (eK[2 * ej + 1] = _ / q);
                  }
                }
                er.addVectors(es, ey),
                  (ej = eW + I * ez + _),
                  [0, 1, 2].forEach((_) => {
                    (eQ[3 * ej + _] = er.getComponent(_)),
                      (eZ[3 * ej + _] = ex.getComponent(_));
                  }),
                  (eK[2 * ej] = (e3 + I * e0) / e4),
                  (eK[2 * ej + 1] = _ / q);
              }
            }
            let e6 = eI + 2 * Q + 2,
              [e8, e9] = [+$, e6 - 1];
            for (let _ = e8; _ <= e9 - 1; _++) {
              let I = $ && _ === e9 - 1;
              for (let R = 0; R < ez - 1; R++)
                (eo = (en = _ * ez + R) + 1),
                  (el = (I ? R : en) + ez),
                  (eh = (I ? R + 1 : eo) + ez),
                  0 === _
                    ? eJ.push(eo, eh, el)
                    : _ === e6 - 2
                    ? eJ.push(en, eo, el)
                    : eJ.push(en, eo, el, eo, eh, el);
            }
            this.setIndex(eJ),
              this.setAttribute("position", new s4(eQ, 3)),
              this.setAttribute("normal", new s4(eZ, 3)),
              this.setAttribute("uv", new s4(eK, 2));
          }
          getClosedTorusIndicesForBooleanOrSubdiv() {
            let _ = this.userData.parameters,
              I = Math.ceil(_.tubularSegments),
              R = _.radialSegments + 1,
              B = Array.from(this.getIndex().array),
              z,
              k,
              V,
              j,
              G = 6 * (I - 1) * _.radialSegments,
              q = I == I;
            for (let X = 0; X < _.radialSegments; X++)
              (k = (z = I * R + X) + 1),
                (V = (q ? X : z) + R),
                (j = (q ? X + 1 : k) + R),
                (B[G++] = z),
                (B[G++] = k),
                (B[G++] = V),
                (B[G++] = k),
                (B[G++] = j),
                (B[G++] = V);
            return (B.length = G), (x$.array = B), (x$.count = B.length), x$;
          }
        },
        x1 = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R = Object.assign(
              {},
              I?.parameters ?? {
                width: 100,
                detail: 0,
                corner: 0,
                cornerSides: 4,
              },
              _.parameters
            );
            return {
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? R.width),
              }),
            };
          }
          static build(_) {
            let {
                width: I,
                height: R,
                depth: B,
                detail: z,
                corner: k,
                cornerSides: V,
              } = _.parameters,
              j =
                0 === z && 0 !== k ? new x3(0.5 * I, k, V) : new oF(0.5 * I, z);
            return (
              j.scale(1, R / I, B / I),
              Object.assign(j, {
                userData: { ..._, type: "IcosahedronGeometry" },
              })
            );
          }
        },
        x3 = class extends xe {
          constructor(_ = 1, I = 0.2, R = 4) {
            let B = (1 + Math.sqrt(5)) / 2,
              z = "IcosahedronGeometry";
            super(
              [
                -1,
                B,
                0,
                1,
                B,
                0,
                -1,
                -B,
                0,
                1,
                -B,
                0,
                0,
                -1,
                B,
                0,
                1,
                B,
                0,
                -1,
                -B,
                0,
                1,
                -B,
                B,
                0,
                -1,
                B,
                0,
                1,
                -B,
                0,
                -1,
                -B,
                0,
                1,
              ],
              [
                0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11,
                4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3,
                6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
              ],
              z,
              _,
              I,
              R
            ),
              (this.type = z);
          }
          static fromJSON(_) {
            return new x3(_.radius, _.corner, _.cornerSides);
          }
        },
        x4 = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            (_.parameters?.points ?? []).forEach((_) => {
              Array.isArray(_) && ((_.x = _[0]), (_.y = _[1]));
            });
            let R = Object.assign(
              {},
              I?.parameters ?? {
                width: 100,
                segments: 64,
                verticalSegments: 64,
                points: [
                  { x: 0, y: -50, id: 0 },
                  { x: 50, y: -50, id: 1 },
                  { x: 50, y: 50, id: 2 },
                  { x: 0, y: 50, id: 3 },
                ],
              },
              _.parameters
            );
            return {
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? R.width),
              }),
            };
          }
          static build(_) {
            let { points: I, segments: R, verticalSegments: B } = _.parameters,
              z = new oR();
            z.moveTo(I[0].x, I[0].y),
              z.bezierCurveTo(I[1].x, I[1].y, I[2].x, I[2].y, I[3].x, I[3].y);
            let k = new oE(z.extractPoints(B).shape, R);
            return (
              k.rotateZ(Math.PI),
              Object.assign(k, { userData: { ..._, type: "LatheGeometry" } })
            );
          }
        },
        x5 = new sa(),
        x6 = new sL(),
        x8 = new rF(),
        x9 = class extends i8 {
          constructor() {
            super(),
              (this.uuid = rr.generateUUID()),
              (this.name = ""),
              (this.type = "Geometry"),
              (this.vertices = []),
              (this.colors = []),
              (this.faces = []),
              (this.faceVertexUvs = [[]]),
              (this.morphTargets = []),
              (this.morphNormals = []),
              (this.skinWeights = []),
              (this.skinIndices = []),
              (this.lineDistances = []),
              (this.boundingBox = null),
              (this.boundingSphere = null),
              (this.elementsNeedUpdate = !1),
              (this.verticesNeedUpdate = !1),
              (this.uvsNeedUpdate = !1),
              (this.normalsNeedUpdate = !1),
              (this.colorsNeedUpdate = !1),
              (this.lineDistancesNeedUpdate = !1),
              (this.groupsNeedUpdate = !1);
          }
          applyMatrix4(_) {
            let I = new ro().getNormalMatrix(_);
            for (let I = 0, R = this.vertices.length; I < R; I++)
              this.vertices[I].applyMatrix4(_);
            for (let _ = 0, R = this.faces.length; _ < R; _++) {
              let R = this.faces[_];
              R.normal.applyMatrix3(I).normalize();
              for (let _ = 0, B = R.vertexNormals.length; _ < B; _++)
                R.vertexNormals[_].applyMatrix3(I).normalize();
            }
            return (
              null !== this.boundingBox && this.computeBoundingBox(),
              null !== this.boundingSphere && this.computeBoundingSphere(),
              (this.verticesNeedUpdate = !0),
              (this.normalsNeedUpdate = !0),
              this
            );
          }
          rotateX(_) {
            return x5.makeRotationX(_), this.applyMatrix4(x5), this;
          }
          rotateY(_) {
            return x5.makeRotationY(_), this.applyMatrix4(x5), this;
          }
          rotateZ(_) {
            return x5.makeRotationZ(_), this.applyMatrix4(x5), this;
          }
          translate(_, I, R) {
            return x5.makeTranslation(_, I, R), this.applyMatrix4(x5), this;
          }
          scale(_, I, R) {
            return x5.makeScale(_, I, R), this.applyMatrix4(x5), this;
          }
          lookAt(_) {
            return (
              x6.lookAt(_),
              x6.updateMatrix(),
              this.applyMatrix4(x6.matrix),
              this
            );
          }
          fromBufferGeometry(_) {
            let I = this,
              R = null !== _.index ? _.index : void 0,
              B = _.attributes;
            if (void 0 === B.position)
              return (
                console.error(
                  "THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."
                ),
                this
              );
            let z = B.position,
              k = B.normal,
              V = B.color,
              j = B.uv,
              G = B.uv2;
            void 0 !== G && (this.faceVertexUvs[1] = []);
            for (let _ = 0; _ < z.count; _++)
              I.vertices.push(new rF().fromBufferAttribute(z, _)),
                void 0 !== V &&
                  I.colors.push(new ry().fromBufferAttribute(V, _));
            function c(_, R, B, z) {
              let q =
                  void 0 === V
                    ? []
                    : [
                        I.colors[_].clone(),
                        I.colors[R].clone(),
                        I.colors[B].clone(),
                      ],
                X =
                  void 0 === k
                    ? []
                    : [
                        new rF().fromBufferAttribute(k, _),
                        new rF().fromBufferAttribute(k, R),
                        new rF().fromBufferAttribute(k, B),
                      ],
                Q = new be(_, R, B, X, q, z);
              I.faces.push(Q),
                void 0 !== j &&
                  I.faceVertexUvs[0].push([
                    new rs().fromBufferAttribute(j, _),
                    new rs().fromBufferAttribute(j, R),
                    new rs().fromBufferAttribute(j, B),
                  ]),
                void 0 !== G &&
                  I.faceVertexUvs[1].push([
                    new rs().fromBufferAttribute(G, _),
                    new rs().fromBufferAttribute(G, R),
                    new rs().fromBufferAttribute(G, B),
                  ]);
            }
            let q = _.groups;
            if (q.length > 0)
              for (let _ = 0; _ < q.length; _++) {
                let I = q[_],
                  B = I.start,
                  z = I.count;
                for (let _ = B, k = B + z; _ < k; _ += 3)
                  void 0 !== R
                    ? c(
                        R.getX(_),
                        R.getX(_ + 1),
                        R.getX(_ + 2),
                        I.materialIndex
                      )
                    : c(_, _ + 1, _ + 2, I.materialIndex);
              }
            else if (void 0 !== R)
              for (let _ = 0; _ < R.count; _ += 3)
                c(R.getX(_), R.getX(_ + 1), R.getX(_ + 2));
            else for (let _ = 0; _ < z.count; _ += 3) c(_, _ + 1, _ + 2);
            return (
              this.computeFaceNormals(),
              null !== _.boundingBox &&
                (this.boundingBox = _.boundingBox.clone()),
              null !== _.boundingSphere &&
                (this.boundingSphere = _.boundingSphere.clone()),
              this
            );
          }
          center() {
            return (
              this.computeBoundingBox(),
              this.boundingBox.getCenter(x8).negate(),
              this.translate(x8.x, x8.y, x8.z),
              this
            );
          }
          normalize() {
            this.computeBoundingSphere();
            let _ = this.boundingSphere.center,
              I = this.boundingSphere.radius,
              R = 0 === I ? 1 : 1 / I,
              B = new sa();
            return (
              B.set(
                R,
                0,
                0,
                -R * _.x,
                0,
                R,
                0,
                -R * _.y,
                0,
                0,
                R,
                -R * _.z,
                0,
                0,
                0,
                1
              ),
              this.applyMatrix4(B),
              this
            );
          }
          computeFaceNormals() {
            let _ = new rF(),
              I = new rF();
            for (let R = 0, B = this.faces.length; R < B; R++) {
              let B = this.faces[R],
                z = this.vertices[B.a],
                k = this.vertices[B.b],
                V = this.vertices[B.c];
              _.subVectors(V, k),
                I.subVectors(z, k),
                _.cross(I),
                _.normalize(),
                B.normal.copy(_);
            }
          }
          computeVertexNormals(_ = !0) {
            let I = Array(this.vertices.length);
            for (let _ = 0, R = this.vertices.length; _ < R; _++)
              I[_] = new rF();
            if (_) {
              let _ = new rF(),
                R = new rF();
              for (let B = 0, z = this.faces.length; B < z; B++) {
                let z = this.faces[B],
                  k = this.vertices[z.a],
                  V = this.vertices[z.b],
                  j = this.vertices[z.c];
                _.subVectors(j, V),
                  R.subVectors(k, V),
                  _.cross(R),
                  I[z.a].add(_),
                  I[z.b].add(_),
                  I[z.c].add(_);
              }
            } else {
              this.computeFaceNormals();
              for (let _ = 0, R = this.faces.length; _ < R; _++) {
                let R = this.faces[_];
                I[R.a].add(R.normal),
                  I[R.b].add(R.normal),
                  I[R.c].add(R.normal);
              }
            }
            for (let _ = 0, R = this.vertices.length; _ < R; _++)
              I[_].normalize();
            for (let _ = 0, R = this.faces.length; _ < R; _++) {
              let R = this.faces[_],
                B = R.vertexNormals;
              3 === B.length
                ? (B[0].copy(I[R.a]), B[1].copy(I[R.b]), B[2].copy(I[R.c]))
                : ((B[0] = I[R.a].clone()),
                  (B[1] = I[R.b].clone()),
                  (B[2] = I[R.c].clone()));
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0);
          }
          computeFlatVertexNormals() {
            this.computeFaceNormals();
            for (let _ = 0, I = this.faces.length; _ < I; _++) {
              let I = this.faces[_],
                R = I.vertexNormals;
              3 === R.length
                ? (R[0].copy(I.normal),
                  R[1].copy(I.normal),
                  R[2].copy(I.normal))
                : ((R[0] = I.normal.clone()),
                  (R[1] = I.normal.clone()),
                  (R[2] = I.normal.clone()));
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0);
          }
          computeMorphNormals() {
            for (let _ = 0, I = this.faces.length; _ < I; _++) {
              let I = this.faces[_];
              I.__originalFaceNormal
                ? I.__originalFaceNormal.copy(I.normal)
                : (I.__originalFaceNormal = I.normal.clone()),
                I.__originalVertexNormals || (I.__originalVertexNormals = []);
              for (let _ = 0, R = I.vertexNormals.length; _ < R; _++)
                I.__originalVertexNormals[_]
                  ? I.__originalVertexNormals[_].copy(I.vertexNormals[_])
                  : (I.__originalVertexNormals[_] = I.vertexNormals[_].clone());
            }
            let _ = new x9();
            _.faces = this.faces;
            for (let I = 0, R = this.morphTargets.length; I < R; I++) {
              if (!this.morphNormals[I]) {
                (this.morphNormals[I] = {}),
                  (this.morphNormals[I].faceNormals = []),
                  (this.morphNormals[I].vertexNormals = []);
                let _ = this.morphNormals[I].faceNormals,
                  R = this.morphNormals[I].vertexNormals;
                for (let I = 0, B = this.faces.length; I < B; I++) {
                  let I = new rF(),
                    B = { a: new rF(), b: new rF(), c: new rF() };
                  _.push(I), R.push(B);
                }
              }
              let R = this.morphNormals[I];
              (_.vertices = this.morphTargets[I].vertices),
                _.computeFaceNormals(),
                _.computeVertexNormals();
              for (let _ = 0, I = this.faces.length; _ < I; _++) {
                let I = this.faces[_],
                  B = R.faceNormals[_],
                  z = R.vertexNormals[_];
                B.copy(I.normal),
                  z.a.copy(I.vertexNormals[0]),
                  z.b.copy(I.vertexNormals[1]),
                  z.c.copy(I.vertexNormals[2]);
              }
            }
            for (let _ = 0, I = this.faces.length; _ < I; _++) {
              let I = this.faces[_];
              (I.normal = I.__originalFaceNormal),
                (I.vertexNormals = I.__originalVertexNormals);
            }
          }
          computeBoundingBox() {
            null === this.boundingBox && (this.boundingBox = new rU()),
              this.boundingBox.setFromPoints(this.vertices);
          }
          computeBoundingSphere() {
            null === this.boundingSphere && (this.boundingSphere = new r5()),
              this.boundingSphere.setFromPoints(this.vertices);
          }
          merge(_, I, R = 0) {
            if (!(_ && _.isGeometry)) {
              console.error(
                "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
                _
              );
              return;
            }
            let B,
              z = this.vertices.length,
              k = this.vertices,
              V = _.vertices,
              j = this.faces,
              G = _.faces,
              q = this.colors,
              X = _.colors;
            void 0 !== I && (B = new ro().getNormalMatrix(I));
            for (let _ = 0, R = V.length; _ < R; _++) {
              let R = V[_].clone();
              void 0 !== I && R.applyMatrix4(I), k.push(R);
            }
            for (let _ = 0, I = X.length; _ < I; _++) q.push(X[_].clone());
            for (let _ = 0, I = G.length; _ < I; _++) {
              let I = G[_],
                k,
                V,
                q = I.vertexNormals,
                X = I.vertexColors,
                Q = new be(I.a + z, I.b + z, I.c + z);
              Q.normal.copy(I.normal),
                void 0 !== B && Q.normal.applyMatrix3(B).normalize();
              for (let _ = 0, I = q.length; _ < I; _++)
                (k = q[_].clone()),
                  void 0 !== B && k.applyMatrix3(B).normalize(),
                  Q.vertexNormals.push(k);
              Q.color.copy(I.color);
              for (let _ = 0, I = X.length; _ < I; _++)
                (V = X[_]), Q.vertexColors.push(V.clone());
              (Q.materialIndex = I.materialIndex + R), j.push(Q);
            }
            for (let I = 0, R = _.faceVertexUvs.length; I < R; I++) {
              let R = _.faceVertexUvs[I];
              void 0 === this.faceVertexUvs[I] && (this.faceVertexUvs[I] = []);
              for (let _ = 0, B = R.length; _ < B; _++) {
                let B = R[_],
                  z = [];
                for (let _ = 0, I = B.length; _ < I; _++) z.push(B[_].clone());
                this.faceVertexUvs[I].push(z);
              }
            }
          }
          mergeMesh(_) {
            if (!(_ && _.isMesh)) {
              console.error(
                "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
                _
              );
              return;
            }
            _.matrixAutoUpdate && _.updateMatrix(),
              this.merge(_.geometry, _.matrix);
          }
          mergeVertices(_ = 4) {
            let I = {},
              R = [],
              B = [],
              z = Math.pow(10, _);
            for (let _ = 0, k = this.vertices.length; _ < k; _++) {
              let k = this.vertices[_],
                V =
                  Math.round(k.x * z) +
                  "_" +
                  Math.round(k.y * z) +
                  "_" +
                  Math.round(k.z * z);
              void 0 === I[V]
                ? ((I[V] = _), R.push(this.vertices[_]), (B[_] = R.length - 1))
                : (B[_] = B[I[V]]);
            }
            let k = [];
            for (let _ = 0, I = this.faces.length; _ < I; _++) {
              let I = this.faces[_];
              (I.a = B[I.a]), (I.b = B[I.b]), (I.c = B[I.c]);
              let R = [I.a, I.b, I.c];
              for (let I = 0; I < 3; I++)
                if (R[I] === R[(I + 1) % 3]) {
                  k.push(_);
                  break;
                }
            }
            for (let _ = k.length - 1; _ >= 0; _--) {
              let I = k[_];
              this.faces.splice(I, 1);
              for (let _ = 0, R = this.faceVertexUvs.length; _ < R; _++)
                this.faceVertexUvs[_].splice(I, 1);
            }
            let V = this.vertices.length - R.length;
            return (this.vertices = R), V;
          }
          setFromPoints(_) {
            this.vertices = [];
            for (let I = 0, R = _.length; I < R; I++) {
              let R = _[I];
              this.vertices.push(new rF(R.x, R.y, R.z || 0));
            }
            return this;
          }
          sortFacesByMaterialIndex() {
            let _ = this.faces,
              I = _.length;
            for (let R = 0; R < I; R++) _[R]._id = R;
            _.sort(function (_, I) {
              return _.materialIndex - I.materialIndex;
            });
            let R = this.faceVertexUvs[0],
              B = this.faceVertexUvs[1],
              z,
              k;
            R && R.length === I && (z = []), B && B.length === I && (k = []);
            for (let V = 0; V < I; V++) {
              let I = _[V]._id;
              z && z.push(R[I]), k && k.push(B[I]);
            }
            z && (this.faceVertexUvs[0] = z), k && (this.faceVertexUvs[1] = k);
          }
          toJSON() {
            let _ = {
              metadata: {
                version: 4.5,
                type: "Geometry",
                generator: "Geometry.toJSON",
              },
            };
            if (
              ((_.uuid = this.uuid),
              (_.type = this.type),
              "" !== this.name && (_.name = this.name),
              void 0 !== this.parameters)
            ) {
              let I = this.parameters;
              for (let R in I) void 0 !== I[R] && (_[R] = I[R]);
              return _;
            }
            let I = [];
            for (let _ = 0; _ < this.vertices.length; _++) {
              let R = this.vertices[_];
              I.push(R.x, R.y, R.z);
            }
            let R = [],
              B = [],
              z = {},
              k = [],
              V = {},
              j = [],
              G = {};
            for (let _ = 0; _ < this.faces.length; _++) {
              let I = this.faces[_],
                B = void 0 !== this.faceVertexUvs[0][_],
                z = I.normal.length() > 0,
                k = I.vertexNormals.length > 0,
                V = 1 !== I.color.r || 1 !== I.color.g || 1 !== I.color.b,
                j = I.vertexColors.length > 0,
                G = 0;
              if (
                ((G = c(0, 0, 0)),
                (G = c(G, 1, !0)),
                (G = c(G, 2, !1)),
                (G = c(G, 3, B)),
                (G = c(G, 4, z)),
                (G = c(G, 5, k)),
                (G = c(G, 6, V)),
                (G = c(G, 7, j)),
                R.push(G),
                R.push(I.a, I.b, I.c),
                R.push(I.materialIndex),
                B)
              ) {
                let I = this.faceVertexUvs[0][_];
                R.push(f(I[0]), f(I[1]), f(I[2]));
              }
              if ((z && R.push(h(I.normal)), k)) {
                let _ = I.vertexNormals;
                R.push(h(_[0]), h(_[1]), h(_[2]));
              }
              if ((V && R.push(d(I.color)), j)) {
                let _ = I.vertexColors;
                R.push(d(_[0]), d(_[1]), d(_[2]));
              }
            }
            function c(_, I, R) {
              return R ? _ | (1 << I) : _ & ~(1 << I);
            }
            function h(_) {
              let I = _.x.toString() + _.y.toString() + _.z.toString();
              return (
                void 0 !== z[I] ||
                  ((z[I] = B.length / 3), B.push(_.x, _.y, _.z)),
                z[I]
              );
            }
            function d(_) {
              let I = _.r.toString() + _.g.toString() + _.b.toString();
              return (
                void 0 !== V[I] || ((V[I] = k.length), k.push(_.getHex())), V[I]
              );
            }
            function f(_) {
              let I = _.x.toString() + _.y.toString();
              return (
                void 0 !== G[I] || ((G[I] = j.length / 2), j.push(_.x, _.y)),
                G[I]
              );
            }
            return (
              (_.data = {}),
              (_.data.vertices = I),
              (_.data.normals = B),
              k.length > 0 && (_.data.colors = k),
              j.length > 0 && (_.data.uvs = [j]),
              (_.data.faces = R),
              _
            );
          }
          clone() {
            return new x9().copy(this);
          }
          copy(_) {
            (this.vertices = []),
              (this.colors = []),
              (this.faces = []),
              (this.faceVertexUvs = [[]]),
              (this.morphTargets = []),
              (this.morphNormals = []),
              (this.skinWeights = []),
              (this.skinIndices = []),
              (this.lineDistances = []),
              (this.boundingBox = null),
              (this.boundingSphere = null),
              (this.name = _.name);
            let I = _.vertices;
            for (let _ = 0, R = I.length; _ < R; _++)
              this.vertices.push(I[_].clone());
            let R = _.colors;
            for (let _ = 0, I = R.length; _ < I; _++)
              this.colors.push(R[_].clone());
            let B = _.faces;
            for (let _ = 0, I = B.length; _ < I; _++)
              this.faces.push(B[_].clone());
            for (let I = 0, R = _.faceVertexUvs.length; I < R; I++) {
              let R = _.faceVertexUvs[I];
              void 0 === this.faceVertexUvs[I] && (this.faceVertexUvs[I] = []);
              for (let _ = 0, B = R.length; _ < B; _++) {
                let B = R[_],
                  z = [];
                for (let _ = 0, I = B.length; _ < I; _++) {
                  let I = B[_];
                  z.push(I.clone());
                }
                this.faceVertexUvs[I].push(z);
              }
            }
            let z = _.morphTargets;
            for (let _ = 0, I = z.length; _ < I; _++) {
              let I = {};
              if (((I.name = z[_].name), void 0 !== z[_].vertices)) {
                I.vertices = [];
                for (let R = 0, B = z[_].vertices.length; R < B; R++)
                  I.vertices.push(z[_].vertices[R].clone());
              }
              if (void 0 !== z[_].normals) {
                I.normals = [];
                for (let R = 0, B = z[_].normals.length; R < B; R++)
                  I.normals.push(z[_].normals[R].clone());
              }
              this.morphTargets.push(I);
            }
            let k = _.morphNormals;
            for (let _ = 0, I = k.length; _ < I; _++) {
              let I = {};
              if (void 0 !== k[_].vertexNormals) {
                I.vertexNormals = [];
                for (let R = 0, B = k[_].vertexNormals.length; R < B; R++) {
                  let B = k[_].vertexNormals[R],
                    z = {};
                  (z.a = B.a.clone()),
                    (z.b = B.b.clone()),
                    (z.c = B.c.clone()),
                    I.vertexNormals.push(z);
                }
              }
              if (void 0 !== k[_].faceNormals) {
                I.faceNormals = [];
                for (let R = 0, B = k[_].faceNormals.length; R < B; R++)
                  I.faceNormals.push(k[_].faceNormals[R].clone());
              }
              this.morphNormals.push(I);
            }
            let V = _.skinWeights;
            for (let _ = 0, I = V.length; _ < I; _++)
              this.skinWeights.push(V[_].clone());
            let j = _.skinIndices;
            for (let _ = 0, I = j.length; _ < I; _++)
              this.skinIndices.push(j[_].clone());
            let G = _.lineDistances;
            for (let _ = 0, I = G.length; _ < I; _++)
              this.lineDistances.push(G[_]);
            let q = _.boundingBox;
            null !== q && (this.boundingBox = q.clone());
            let X = _.boundingSphere;
            return (
              null !== X && (this.boundingSphere = X.clone()),
              (this.elementsNeedUpdate = _.elementsNeedUpdate),
              (this.verticesNeedUpdate = _.verticesNeedUpdate),
              (this.uvsNeedUpdate = _.uvsNeedUpdate),
              (this.normalsNeedUpdate = _.normalsNeedUpdate),
              (this.colorsNeedUpdate = _.colorsNeedUpdate),
              (this.lineDistancesNeedUpdate = _.lineDistancesNeedUpdate),
              (this.groupsNeedUpdate = _.groupsNeedUpdate),
              this
            );
          }
          toBufferGeometry() {
            let _ = new x7().fromGeometry(this),
              I = new ai(),
              R = new Float32Array(3 * _.vertices.length);
            if (
              (I.setAttribute("position", F0.call(new s0(R, 3), _.vertices)),
              _.normals.length > 0)
            ) {
              let R = new Float32Array(3 * _.normals.length);
              I.setAttribute("normal", F0.call(new s0(R, 3), _.normals));
            }
            if (_.colors.length > 0) {
              let R = new Float32Array(3 * _.colors.length);
              I.setAttribute("color", yI.call(new s0(R, 3), _.colors));
            }
            if (_.uvs.length > 0) {
              let R = new Float32Array(2 * _.uvs.length);
              I.setAttribute("uv", vI.call(new s0(R, 2), _.uvs));
            }
            if (_.uvs2.length > 0) {
              let R = new Float32Array(2 * _.uvs2.length);
              I.setAttribute("uv2", vI.call(new s0(R, 2), _.uvs2));
            }
            for (let R in ((I.groups = _.groups), _.morphTargets)) {
              let B = [],
                z = _.morphTargets[R];
              for (let _ = 0, I = z.length; _ < I; _++) {
                let I = z[_],
                  R = new s4(3 * I.data.length, 3);
                (R.name = I.name), B.push(F0.call(R, I.data));
              }
              I.morphAttributes[R] = B;
            }
            if (_.skinIndices.length > 0) {
              let R = new s4(4 * _.skinIndices.length, 4);
              I.setAttribute("skinIndex", xI.call(R, _.skinIndices));
            }
            if (_.skinWeights.length > 0) {
              let R = new s4(4 * _.skinWeights.length, 4);
              I.setAttribute("skinWeight", xI.call(R, _.skinWeights));
            }
            return (
              null !== _.boundingSphere &&
                (I.boundingSphere = _.boundingSphere.clone()),
              null !== _.boundingBox && (I.boundingBox = _.boundingBox.clone()),
              I
            );
          }
          computeTangents() {
            console.error(
              "THREE.Geometry: .computeTangents() has been removed."
            );
          }
          computeLineDistances() {
            console.error(
              "THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
            );
          }
          applyMatrix(_) {
            return (
              console.warn(
                "THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."
              ),
              this.applyMatrix4(_)
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
          static createBufferGeometryFromObject(_) {
            let I = new ai(),
              R = _.geometry;
            if (_.isPoints || _.isLine) {
              let _ = new s4(3 * R.vertices.length, 3),
                B = new s4(3 * R.colors.length, 3);
              if (
                (I.setAttribute("position", F0.call(_, R.vertices)),
                I.setAttribute("color", yI.call(B, R.colors)),
                R.lineDistances && R.lineDistances.length === R.vertices.length)
              ) {
                let _ = new s4(R.lineDistances.length, 1);
                I.setAttribute("lineDistance", M7.call(_, R.lineDistances));
              }
              null !== R.boundingSphere &&
                (I.boundingSphere = R.boundingSphere.clone()),
                null !== R.boundingBox &&
                  (I.boundingBox = R.boundingBox.clone());
            } else _.isMesh && (I = R.toBufferGeometry());
            return I;
          }
        };
      x9.prototype.isGeometry = !0;
      var x7 = class {
          constructor() {
            (this.vertices = []),
              (this.normals = []),
              (this.colors = []),
              (this.uvs = []),
              (this.uvs2 = []),
              (this.groups = []),
              (this.morphTargets = {}),
              (this.skinWeights = []),
              (this.skinIndices = []),
              (this.boundingBox = null),
              (this.boundingSphere = null),
              (this.verticesNeedUpdate = !1),
              (this.normalsNeedUpdate = !1),
              (this.colorsNeedUpdate = !1),
              (this.uvsNeedUpdate = !1),
              (this.groupsNeedUpdate = !1);
          }
          computeGroups(_) {
            let I = [],
              R,
              B,
              z,
              k = _.faces;
            for (B = 0; B < k.length; B++) {
              let _ = k[B];
              _.materialIndex !== z &&
                ((z = _.materialIndex),
                void 0 !== R && ((R.count = 3 * B - R.start), I.push(R)),
                (R = { start: 3 * B, materialIndex: z }));
            }
            void 0 !== R && ((R.count = 3 * B - R.start), I.push(R)),
              (this.groups = I);
          }
          fromGeometry(_) {
            let I = _.faces,
              R = _.vertices,
              B = _.faceVertexUvs,
              z = B[0] && B[0].length > 0,
              k = B[1] && B[1].length > 0,
              V = _.morphTargets,
              j = V.length,
              G;
            if (j > 0) {
              G = [];
              for (let _ = 0; _ < j; _++) G[_] = { name: V[_].name, data: [] };
              this.morphTargets.position = G;
            }
            let q = _.morphNormals,
              X = q.length,
              Q;
            if (X > 0) {
              Q = [];
              for (let _ = 0; _ < X; _++) Q[_] = { name: q[_].name, data: [] };
              this.morphTargets.normal = Q;
            }
            let $ = _.skinIndices,
              et = _.skinWeights,
              er = $.length === R.length,
              es = et.length === R.length;
            R.length > 0 &&
              0 === I.length &&
              console.error(
                "THREE.DirectGeometry: Faceless geometries are not supported."
              );
            for (let _ = 0; _ < I.length; _++) {
              let ea = I[_];
              this.vertices.push(R[ea.a], R[ea.b], R[ea.c]);
              let en = ea.vertexNormals;
              if (3 === en.length) this.normals.push(en[0], en[1], en[2]);
              else {
                let _ = ea.normal;
                this.normals.push(_, _, _);
              }
              let eo = ea.vertexColors;
              if (3 === eo.length) this.colors.push(eo[0], eo[1], eo[2]);
              else {
                let _ = ea.color;
                this.colors.push(_, _, _);
              }
              if (!0 === z) {
                let I = B[0][_];
                void 0 !== I
                  ? this.uvs.push(I[0], I[1], I[2])
                  : (console.warn(
                      "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
                      _
                    ),
                    this.uvs.push(new rs(), new rs(), new rs()));
              }
              if (!0 === k) {
                let I = B[1][_];
                void 0 !== I
                  ? this.uvs2.push(I[0], I[1], I[2])
                  : (console.warn(
                      "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
                      _
                    ),
                    this.uvs2.push(new rs(), new rs(), new rs()));
              }
              for (let _ = 0; _ < j; _++) {
                let I = V[_].vertices;
                G[_].data.push(I[ea.a], I[ea.b], I[ea.c]);
              }
              for (let I = 0; I < X; I++) {
                let R = q[I].vertexNormals[_];
                Q[I].data.push(R.a, R.b, R.c);
              }
              er && this.skinIndices.push($[ea.a], $[ea.b], $[ea.c]),
                es && this.skinWeights.push(et[ea.a], et[ea.b], et[ea.c]);
            }
            return (
              this.computeGroups(_),
              (this.verticesNeedUpdate = _.verticesNeedUpdate),
              (this.normalsNeedUpdate = _.normalsNeedUpdate),
              (this.colorsNeedUpdate = _.colorsNeedUpdate),
              (this.uvsNeedUpdate = _.uvsNeedUpdate),
              (this.groupsNeedUpdate = _.groupsNeedUpdate),
              null !== _.boundingSphere &&
                (this.boundingSphere = _.boundingSphere.clone()),
              null !== _.boundingBox &&
                (this.boundingBox = _.boundingBox.clone()),
              this
            );
          }
        },
        be = class {
          constructor(_, I, R, B, z, k = 0) {
            (this.a = _),
              (this.b = I),
              (this.c = R),
              (this.normal = B && B.isVector3 ? B : new rF()),
              (this.vertexNormals = Array.isArray(B) ? B : []),
              (this.color = z && z.isColor ? z : new ry()),
              (this.vertexColors = Array.isArray(z) ? z : []),
              (this.materialIndex = k);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(_) {
            (this.a = _.a),
              (this.b = _.b),
              (this.c = _.c),
              this.normal.copy(_.normal),
              this.color.copy(_.color),
              (this.materialIndex = _.materialIndex);
            for (let I = 0, R = _.vertexNormals.length; I < R; I++)
              this.vertexNormals[I] = _.vertexNormals[I].clone();
            for (let I = 0, R = _.vertexColors.length; I < R; I++)
              this.vertexColors[I] = _.vertexColors[I].clone();
            return this;
          }
        };
      function M7(_) {
        return this.array.set(_), this;
      }
      function yI(_) {
        let I = this.array,
          R = 0;
        for (let B = 0, z = _.length; B < z; B++) {
          let z = _[B];
          void 0 === z &&
            (console.warn(
              "THREE.BufferAttribute.copyColorsArray(): color is undefined",
              B
            ),
            (z = new ry())),
            (I[R++] = z.r),
            (I[R++] = z.g),
            (I[R++] = z.b);
        }
        return this;
      }
      function vI(_) {
        let I = this.array,
          R = 0;
        for (let B = 0, z = _.length; B < z; B++) {
          let z = _[B];
          void 0 === z &&
            (console.warn(
              "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
              B
            ),
            (z = new rs())),
            (I[R++] = z.x),
            (I[R++] = z.y);
        }
        return this;
      }
      function F0(_) {
        let I = this.array,
          R = 0;
        for (let B = 0, z = _.length; B < z; B++) {
          let z = _[B];
          void 0 === z &&
            (console.warn(
              "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
              B
            ),
            (z = new rF())),
            (I[R++] = z.x),
            (I[R++] = z.y),
            (I[R++] = z.z);
        }
        return this;
      }
      function xI(_) {
        let I = this.array,
          R = 0;
        for (let B = 0, z = _.length; B < z; B++) {
          let z = _[B];
          void 0 === z &&
            (console.warn(
              "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
              B
            ),
            (z = new rM())),
            (I[R++] = z.x),
            (I[R++] = z.y),
            (I[R++] = z.z),
            (I[R++] = z.w);
        }
        return this;
      }
      var bt = ["a", "b", "c"];
      function DA(_, I, R) {
        let B = Math.min(_, I),
          z = Math.max(_, I);
        return R.get(B + "_" + z);
      }
      function OA(_, I, R, B, z, k) {
        let V = Math.min(_, I),
          j = Math.max(_, I),
          G = V + "_" + j,
          q;
        B.has(G)
          ? (q = B.get(G))
          : ((q = { a: R[V], b: R[j], newEdge: null, faces: [] }), B.set(G, q)),
          q.faces.push(z),
          k[_].edges.push(q),
          k[I].edges.push(q);
      }
      function k0(_, I, R, B, z) {
        _.push(new be(I, R, B, void 0, void 0, z));
      }
      function kd(_, I) {
        return Math.abs(I - _) / 2 + Math.min(_, I);
      }
      function V0(_, I, R, B) {
        _.push([I.clone(), R.clone(), B.clone()]);
      }
      var ba = class {
          constructor(_ = 1) {
            this.subdivisions = _;
          }
          modify(_) {
            (_ =
              _ instanceof ai
                ? new x9().fromBufferGeometry(_)
                : _.clone()).mergeVertices();
            let I = this.subdivisions;
            for (; I-- > 0; ) this._smooth(_);
            return _.computeFaceNormals(), _.computeVertexNormals(), _;
          }
          _smooth(_) {
            let I = new rF(),
              R,
              B,
              z,
              k,
              V,
              j = _.vertices,
              G = _.faces,
              q = _.faceVertexUvs[0],
              X = void 0 !== q && q.length > 0,
              Q = [],
              $ = new Map();
            !(function (_, I, R, B) {
              let z, k, V;
              for (z = 0, k = _.length; z < k; z++) R[z] = { edges: [] };
              for (z = 0, k = I.length; z < k; z++)
                OA((V = I[z]).a, V.b, _, B, V, R),
                  OA(V.b, V.c, _, B, V, R),
                  OA(V.c, V.a, _, B, V, R);
            })(j, G, Q, $);
            let et = [],
              er,
              es,
              ea,
              en,
              eo,
              el,
              eh;
            for (let _ of Array.from($.keys())) {
              for (
                es = $.get(_),
                  ea = new rF(),
                  eo = 3 / 8,
                  el = 1 / 8,
                  2 != (eh = es.faces.length) && ((eo = 0.5), (el = 0)),
                  ea.addVectors(es.a, es.b).multiplyScalar(eo),
                  I.set(0, 0, 0),
                  k = 0;
                k < eh;
                k++
              ) {
                for (
                  en = es.faces[k], V = 0;
                  V < 3 &&
                  !(
                    (er =
                      j[
                        (function (_, I) {
                          switch (I) {
                            case "c":
                              return _.c;
                            case "b":
                              return _.b;
                            default:
                              return _.a;
                          }
                        })(en, bt[V])
                      ]) !== es.a && er !== es.b
                  );
                  V++
                );
                er && I.add(er);
              }
              I.multiplyScalar(el),
                ea.add(I),
                (es.newEdge = et.length),
                et.push(ea);
            }
            let ec,
              ed,
              ep,
              ef,
              em,
              ey,
              ex,
              eb = [];
            for (B = 0, z = j.length; B < z; B++) {
              for (
                ey = j[B],
                  3 == (R = (em = Q[B].edges).length)
                    ? (ec = 3 / 16)
                    : R > 3 && (ec = 3 / (8 * R)),
                  ed = 1 - R * Number(ec),
                  ep = ec,
                  R <= 2 && 2 == R && ((ed = 3 / 4), (ep = 1 / 8)),
                  ex = ey.clone().multiplyScalar(ed),
                  I.set(0, 0, 0),
                  k = 0;
                k < R;
                k++
              )
                (er = (ef = em[k]).a !== ey ? ef.a : ef.b), I.add(er);
              I.multiplyScalar(Number(ep)), ex.add(I), eb.push(ex);
            }
            let ew = eb.concat(et),
              e_ = eb.length,
              eS,
              eA,
              eC,
              eT = [],
              eP = [],
              eI,
              eR,
              eB,
              ez,
              eF = new rs(),
              ek = new rs(),
              eU = new rs();
            for (B = 0, z = G.length; B < z; B++)
              k0(
                eT,
                (eS = Number(DA((en = G[B]).a, en.b, $).newEdge) + e_),
                (eA = Number(DA(en.b, en.c, $).newEdge) + e_),
                (eC = Number(DA(en.c, en.a, $).newEdge) + e_),
                en.materialIndex
              ),
                k0(eT, en.a, eS, eC, en.materialIndex),
                k0(eT, en.b, eA, eS, en.materialIndex),
                k0(eT, en.c, eC, eA, en.materialIndex),
                X &&
                  ((eR = (eI = q[B])[0]),
                  (eB = eI[1]),
                  (ez = eI[2]),
                  eF.set(kd(eR.x, eB.x), kd(eR.y, eB.y)),
                  ek.set(kd(eB.x, ez.x), kd(eB.y, ez.y)),
                  eU.set(kd(eR.x, ez.x), kd(eR.y, ez.y)),
                  V0(eP, eF, ek, eU),
                  V0(eP, eR, eF, eU),
                  V0(eP, eB, ek, eF),
                  V0(eP, ez, eU, ek));
            (_.vertices = ew), (_.faces = eT), X && (_.faceVertexUvs[0] = eP);
          }
        },
        bo = new rF(),
        bc = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R =
                _.geometry ??
                I?.geometry ??
                new ai().copy(new aS(100, 100, 100)),
              B;
            void 0 === I
              ? (R.computeBoundingBox(),
                R.boundingBox.getSize(bo),
                (B = {
                  width: bo.x,
                  height: bo.y,
                  depth: bo.z,
                  subdivisions: 0,
                }))
              : (B = I.parameters);
            let z = { ...B, ..._.parameters };
            return {
              parameters: {
                width: Math.abs(z.width),
                height: Math.abs(z.height),
                depth: Math.abs(z.depth),
                subdivisions: Math.abs(z.subdivisions),
              },
              geometry: R,
            };
          }
          static build(_) {
            let {
                width: I,
                height: R,
                depth: B,
                subdivisions: z,
              } = _.parameters,
              k = _.geometry ?? new ai().copy(new aS(100, 100, 100)),
              V = k.userData.parameters;
            void 0 === V
              ? (k.computeBoundingBox(), k.boundingBox.getSize(bo))
              : bo.set(V.width, V.height, V.depth),
              (I !== bo.x || R !== bo.y || B !== bo.z) &&
                k.scale(
                  0 === bo.x ? 1 : I / bo.x,
                  0 === bo.y ? 1 : R / bo.y,
                  0 === bo.z ? 1 : B / bo.z
                );
            let j = k.originalGeometry;
            try {
              z > 0
                ? (void 0 === j || V?.subdivisions !== z) &&
                  (void 0 === j && (j = k),
                  (k = new ba(z).modify(j).toBufferGeometry()))
                : (void 0 !== j && (k = j),
                  (j = void 0),
                  void 0 === k.getAttribute("normal") &&
                    k.computeVertexNormals());
            } catch {
              void 0 !== j && (k = j),
                (j = void 0),
                void 0 === k.getAttribute("normal") && k.computeVertexNormals();
            }
            return (
              void 0 !== j && Object.assign(k, { originalGeometry: j }),
              delete _.geometry,
              Object.assign(k, {
                userData: { ..._, type: "NonParametricGeometry" },
              })
            );
          }
          static loadFromUrl(_, I, R) {
            new lv(R).load(_, (_) => {
              let R = this.normalizeInputs({ geometry: _ });
              _.boundingBox.getSize(bo);
              let B = 100 / bo.x;
              Object.assign(R.parameters, {
                width: 100,
                height: bo.y * B,
                depth: bo.z * B,
              }),
                I(this.build(R));
            });
          }
        },
        bd = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R = Object.assign(
              {},
              I?.parameters ?? {
                width: 100,
                depth: 0,
                spikes: 5,
                cornerRadius: 0,
                extrudeBevelSize: 0,
                extrudeBevelSegments: 3,
              },
              _.parameters
            );
            return {
              shape: _.shape && _.shape instanceof xT ? _.shape : new xT(),
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? 0),
              }),
            };
          }
          static build(_) {
            let {
                width: I,
                height: R,
                spikes: B,
                cornerRadius: z,
                depth: k,
                extrudeBevelSize: V,
                extrudeBevelSegments: j,
              } = _.parameters,
              G = _.shape,
              q = 0.5 * I,
              X = 0.5 * R,
              Q = (2 * Math.PI) / B;
            for (let _ = 0; _ < B; _++) {
              let I = Q * _,
                R = 0 + Math.sin(I) * q,
                B = 0 + Math.cos(I) * X;
              G.addPoint(G.createPoint(R, B));
            }
            G.isClosed = !0;
            for (let _ = 0, I = G.points.length; _ < I; _++)
              G.points[_].roundness = z;
            return (
              (G.roundness = z),
              G.update(),
              Object.assign(
                xQ.create({
                  shape: G,
                  parameters: {
                    roundness: z,
                    depth: k,
                    extrudeBevelSize: V,
                    extrudeBevelSegments: j,
                  },
                }),
                { userData: { ..._, type: "PolygonGeometry" } }
              )
            );
          }
        },
        bu = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R = Object.assign(
              {},
              I?.parameters ?? {
                width: 100,
                radialSegments: 4,
                heightSegments: 1,
                cornerRadius: 0,
                cornerSegments: 8,
                openEnded: !1,
              },
              _.parameters
            );
            return {
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? R.width),
              }),
            };
          }
          static build(_) {
            let {
                width: I,
                height: R,
                depth: B,
                radialSegments: z,
                heightSegments: k,
                openEnded: V,
                cornerRadius: j,
                cornerSegments: G,
              } = _.parameters,
              q = new bg(0.5 * I, R, z, k, V, j, G);
            return (
              q.scale(1, 1, B / I),
              Object.assign(q, { userData: { ..._, type: "PyramidGeometry" } })
            );
          }
        };
      function Tm(_, I, R) {
        (R.x = _.x * I.x), (R.y = _.y), (R.z = _.x * I.y);
      }
      function IA(_, I, R, B, z, k) {
        let V = I.clone().sub(_),
          j = R.clone().sub(_),
          G = V.angleTo(j);
        if ((V.normalize(), j.normalize(), B === z)) {
          let I = V.add(j).normalize();
          k.copy(_).addScaledVector(I, B / Math.sin(G / 2));
        } else {
          let I = V.angleTo(j);
          k.copy(_),
            k.addScaledVector(V, z / Math.sin(I)),
            k.addScaledVector(j, B / Math.sin(I));
        }
      }
      var bg = class extends ai {
          constructor(_ = 0.5, I = 1, R = 4, B = 1, z = !1, k = 0, V = 4) {
            let j;
            super(),
              (R = Math.floor(Math.max(3, R))),
              (B = Math.floor(B)),
              (V = Math.floor(V));
            let G = [],
              q = [],
              X = [],
              Q = [],
              $ = 0,
              et = I / 2,
              er = Math.PI / R,
              es = _ * Math.cos(Math.PI / R),
              ea = (2 * Math.PI) / R,
              en = Math.PI - ((R - 2) * Math.PI) / R,
              eo = new rF(0, -et, 0),
              el = new rF(0, et, 0),
              eh = new rs(_, -et),
              ec = new rs(es, -et),
              ed = new rs(0, el.y).sub(ec),
              ep = new rs(0, el.y).sub(eh),
              ef = new rs(ed.y, -ed.x).normalize(),
              em = new rs(ep.y, -ep.x).normalize();
            k = Math.min(
              k,
              _ * Math.cos(Math.PI / R) * Math.tan((Math.PI - ed.angle()) / 2) -
                1e-8
            );
            {
              let _ = new rF(ef.x, ef.y, 0),
                I = new rF(Math.cos(ea) * _.x, _.y, Math.sin(ea) * _.x);
              j = _.angleTo(I);
            }
            let ey = k / Math.tan((Math.PI - ed.angle()) / 2),
              ex = k / Math.tan((Math.PI - j) / 2),
              eb = new rF();
            if (!z) {
              q.push(eo.x, eo.y, eo.z), X.push(0, -1, 0), Q.push(0, 0);
              let _ = $++,
                I = [],
                B = eh.clone(),
                z = ey / Math.cos(Math.PI / R);
              B.x -= z;
              for (let _ = 0; _ < R; _++) {
                let z = (_ / R) * Math.PI * 2 + er;
                Tm(B, new rs(Math.sin(z), Math.cos(z)), eb),
                  q.push(eb.x, eb.y, eb.z),
                  X.push(0, -1, 0),
                  Q.push(0, 0),
                  I.push($++);
              }
              for (let R = 0; R < I.length; R++)
                G.push(I[R], _, I[(R + 1) % I.length]);
            }
            let ew = [];
            {
              let _ = new rF(),
                I = new rF(),
                B = new rF(),
                z = new rF(),
                et = new rF(),
                es = new rF();
              for (let ea = 0; ea < R; ea++) {
                let ec = (ea / R) * Math.PI * 2 + er,
                  eb = ((ea + 0.5) / R) * Math.PI * 2 + er,
                  e_ = ((ea + 1) / R) * Math.PI * 2 + er,
                  eS = new rs(Math.sin(ec), Math.cos(ec)),
                  eA = new rs(Math.sin(eb), Math.cos(eb)),
                  eC = new rs(Math.sin(e_), Math.cos(e_));
                Tm(eh, eS, I),
                  Tm(eh, eC, B),
                  Tm(ef, eA, _),
                  IA(el, I, B, ex, ex, z),
                  q.push(z.x, z.y, z.z),
                  IA(I, el, B, ex, ey, et),
                  q.push(et.x, et.y, et.z),
                  IA(B, I, el, ey, ex, es),
                  q.push(es.x, es.y, es.z),
                  X.push(_.x, _.y, _.z),
                  X.push(_.x, _.y, _.z),
                  X.push(_.x, _.y, _.z),
                  Q.push(0, 0),
                  Q.push(0, 0),
                  Q.push(0, 0);
                let eT = $++,
                  eP = $++,
                  eI = $++;
                if ((G.push(eT, eP, eI), k > 0)) {
                  let er, ea;
                  {
                    let _ = I.clone().add(B).multiplyScalar(0.5),
                      R = el.clone().sub(_).normalize(),
                      z = eo
                        .clone()
                        .sub(_)
                        .normalize()
                        .add(R)
                        .normalize()
                        .multiplyScalar(-1);
                    H(_, es.clone().sub(et), z, ed.angle());
                  }
                  {
                    let _ = new rF();
                    Tm(em, eC, _);
                    let I = es.clone().add(z).multiplyScalar(0.5);
                    I = (function (_, I, R) {
                      let B = _.clone().sub(I),
                        z = R.clone().sub(I);
                      return B.projectOnVector(z), B.add(I);
                    })(I, B, el);
                    let R = es.clone().sub(z);
                    [er, ea] = H(I, R, _, j, z.y);
                  }
                  {
                    let _ = er,
                      I = _.clone().setY(0).normalize(),
                      R = new rF(0, -1, 0),
                      B = I.clone().cross(R);
                    !(function (_, I, R, B) {
                      let z = Math.PI / 2,
                        j = ep.angle() - z,
                        et = [],
                        er = new rF(),
                        es = new rF();
                      for (let G = 0; G <= V; G++) {
                        let ea = [],
                          eo = G / V;
                        for (let V = 0; V <= G; V++) {
                          let et = ((G ? V / G : 0) - 0.5) * en,
                            el = Math.cos(et),
                            eh = Math.sin(et),
                            ec = (z + Math.atan(Math.tan(j) * el)) * eo,
                            ed = Math.cos(ec),
                            ep = Math.sin(ec);
                          er.set(0, 0, 0),
                            er.addScaledVector(I, ep * el),
                            er.addScaledVector(R, ed),
                            er.addScaledVector(B, ep * eh),
                            es.copy(_).addScaledVector(er, k),
                            q.push(es.x, es.y, es.z),
                            X.push(er.x, er.y, er.z),
                            Q.push(0, 0),
                            ea.push($++);
                        }
                        et.push(ea);
                      }
                      let ea = et.length - 1;
                      for (let _ = 0; _ < ea; _++) {
                        let I = et[_],
                          R = et[_ + 1],
                          B = I.length - 1;
                        G.push(I[0], R[1], R[0]);
                        for (let _ = 1; _ <= B; _++)
                          G.push(I[_ - 1], I[_], R[_]),
                            G.push(I[_], R[_ + 1], R[_]);
                      }
                    })(_, I, R, B);
                  }
                  ew.concat(ea);
                  {
                    let I = ed.angle(),
                      B = Math.PI - I,
                      z = el.clone();
                    z.y -= k / Math.sin(I - Math.PI / 2);
                    let j = new rF(),
                      et = [];
                    for (let I = 0; I < V; I++) {
                      let G = [],
                        er = Math.PI / 2 - (B * I) / V,
                        es = Math.cos(er),
                        ea = Math.sin(er),
                        en = eb;
                      for (let B = 0; B <= I; B++) {
                        let B = Math.cos(en),
                          V = Math.sin(en);
                        (_.x = es * V),
                          (_.y = ea),
                          (_.z = es * B),
                          j.copy(z).addScaledVector(_, k),
                          q.push(j.x, j.y, j.z),
                          X.push(_.x, _.y, _.z),
                          Q.push(0, 0),
                          G.push($++),
                          (en += (2 * Math.PI) / I / R);
                      }
                      et.push(G);
                    }
                    ea.reverse(), et.push(ea);
                    let er = et.length - 1;
                    for (let _ = 0; _ < er; _++) {
                      let I = et[_],
                        R = et[_ + 1],
                        B = I.length - 1;
                      G.push(R[1], I[0], R[0]);
                      for (let _ = 1; _ <= B; _++)
                        G.push(I[_], I[_ - 1], R[_]),
                          G.push(R[_ + 1], I[_], R[_]);
                    }
                  }
                }
              }
            }
            function H(_, I, R, B, z) {
              let j = -B / 2,
                et = (Math.PI - B) / 2,
                er = I.clone().normalize().cross(R);
              _.addScaledVector(R, -k / Math.sin(et));
              let es = new rF(),
                ea = new rF(),
                en = $,
                eo = [];
              for (let G = 0; G <= V; G++) {
                let et = j + (G / V) * B;
                ea.set(0, 0, 0),
                  ea.addScaledVector(er, Math.sin(et)),
                  ea.addScaledVector(R, Math.cos(et));
                for (let R = 0; R <= 1; R++) {
                  let B = R / 1 - 0.5;
                  if (
                    (es.copy(_),
                    es.addScaledVector(I, B),
                    es.addScaledVector(ea, k),
                    null != z)
                  ) {
                    let _ = Math.max(0, es.y - z);
                    es.addScaledVector(I, -_ / I.y);
                  }
                  q.push(es.x, es.y, es.z),
                    X.push(ea.x, ea.y, ea.z),
                    Q.push(0, 0),
                    0 === R && eo.push($),
                    $++;
                }
              }
              for (let _ = 0; _ < V; _++)
                for (let I = 0; I < 1; I++) {
                  let R = en + I + 2 * _,
                    B = R + 2,
                    z = B + 1,
                    k = R + 1;
                  G.push(R, B, k), G.push(B, z, k);
                }
              return [_.clone().addScaledVector(I, 0.5), eo];
            }
            this.setIndex(G),
              this.setAttribute("position", new s4(q, 3)),
              this.setAttribute("normal", new s4(X, 3)),
              this.setAttribute("uv", new s4(Q, 2));
          }
        },
        bv = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R = Object.assign(
                {},
                I?.parameters ?? {
                  width: 100,
                  depth: 0,
                  cornerRadius: [0, 0, 0, 0],
                  cornerType: 1,
                  extrudeBevelSize: 0,
                  extrudeBevelSegments: 1,
                },
                _.parameters
              ),
              B = Object.assign(I?.ui ?? { enabledIndieCorners: !1 }, _.ui);
            return {
              shape: _.shape && _.shape instanceof xT ? _.shape : new xT(),
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? 0),
              }),
              ui: B,
            };
          }
          static build(_) {
            let I = _.shape,
              {
                width: R,
                height: B,
                cornerRadius: z,
                cornerType: k,
                depth: V,
                extrudeBevelSize: j,
                extrudeBevelSegments: G,
              } = _.parameters,
              q = { x: 0.5 * R, y: 0.5 * B },
              X = { x: -q.x, y: -q.y },
              Q = { x: q.x, y: q.y };
            function d(_, I, z) {
              return I > R && z > B
                ? Math.min((_ * R) / I, (_ * B) / z)
                : I > R
                ? (_ * R) / I
                : z > B
                ? (_ * B) / z
                : _;
            }
            let $ = [];
            ($[0] = 0 === z[0] ? 0 : d(z[0], z[0] + z[3], z[0] + z[1])),
              ($[1] = 0 === z[1] ? 0 : d(z[1], z[1] + z[2], z[1] + z[0])),
              ($[2] = 0 === z[2] ? 0 : d(z[2], z[2] + z[1], z[2] + z[3])),
              ($[3] = 0 === z[3] ? 0 : d(z[3], z[3] + z[0], z[3] + z[2]));
            let et = X.x,
              er = Q.x,
              es = Q.y,
              ea = X.y;
            I.addPoint(I.createPoint(et, es)),
              I.addPoint(I.createPoint(er, es)),
              I.addPoint(I.createPoint(er, ea)),
              I.addPoint(I.createPoint(et, ea)),
              (I.isClosed = !0);
            let en = !0;
            for (let _ = 0, R = I.points.length; _ < R; _++)
              (I.points[_].roundness = $[_]),
                _ > 0 && $[_] !== $[_ - 1] && (en = !1);
            return (
              en && (I.roundness = $[0]),
              (I.useCubicForRoundedCorners = 1 !== k),
              I.update(),
              Object.assign(
                xQ.create({
                  shape: I,
                  parameters: {
                    depth: V,
                    extrudeBevelSize: j,
                    extrudeBevelSegments: G,
                  },
                }),
                { userData: { ..._, type: "RectangleGeometry" } }
              )
            );
          }
        },
        by = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R = Object.assign(
              {},
              I?.parameters ?? {
                width: 100,
                widthSegments: 64,
                heightSegments: 64,
                phiStart: 0,
                phiLength: 2 * Math.PI,
                thetaStart: 0,
                thetaLength: 180,
              },
              _.parameters
            );
            return (
              (R.thetaLength = rr.clamp(R.thetaLength, 0, 180)),
              {
                parameters: Object.assign(R, {
                  width: Math.abs(R.width),
                  height: Math.abs(R.height ?? R.width),
                  depth: Math.abs(R.depth ?? R.width),
                }),
              }
            );
          }
          static build(_) {
            let {
                width: I = 100,
                height: R = I,
                depth: B = I,
                widthSegments: z = 64,
                heightSegments: k = 64,
                phiStart: V,
                phiLength: j,
                thetaStart: G,
                thetaLength: q,
              } = _.parameters,
              X;
            return (
              0 === q
                ? (X = new ai()).setAttribute("position", new s4([], 3))
                : (X = new oN(0.5 * I, z, k, V, j, G, q * rr.DEG2RAD)),
              X.scale(1, R / I, B / I),
              Object.assign(X, { userData: { ..._, type: "SphereGeometry" } })
            );
          }
        },
        bx = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R = Object.assign(
              {},
              I?.parameters ?? {
                width: 100,
                depth: 0,
                widthSegments: 8,
                heightSegments: 8,
              },
              _.parameters
            );
            return {
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: 0,
              }),
            };
          }
          static build(_) {
            let {
                width: I = 100,
                height: R = I,
                widthSegments: B = 8,
                heightSegments: z = 8,
              } = _.parameters,
              k = new aq(I, R, B, z);
            return (
              k.scale(1, 1, 1),
              Object.assign(k, { userData: { ..._, type: "PlaneGeometry" } })
            );
          }
        },
        bb = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R = Object.assign(
              {},
              I?.parameters ?? {
                width: 100,
                angle: 90,
                cornerRadius: 24,
                cornerSegments: 8,
              },
              _.parameters
            );
            return {
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? R.width),
              }),
            };
          }
          static build(_) {
            let {
              width: I,
              height: R,
              depth: B,
              angle: z,
              cornerRadius: k,
              cornerSegments: V,
            } = _.parameters;
            return Object.assign(new bw(I, R, B, z, k, V), {
              userData: { ..._, type: "BackdropGeometry" },
            });
          }
        },
        bw = class extends ai {
          constructor(_ = 1, I = 1, R = 1, B = 90, z = 10, k = 24) {
            super(), (this.type = "BackdropGeometry");
            let V = [],
              j = [],
              G = [];
            0 == z && (k = 1),
              (k = Math.max(1, Math.floor(k))),
              (z = Math.min(z, 100)),
              (B = Math.min(179.999, B) * (Math.PI / 180));
            let q = [],
              X = Math.PI / 2,
              f = (_ = 0, I = 0, R = 0) => new rF(_, I, R),
              Q = f(),
              $ = f(),
              [et, er, es] = [I / 2, _ / 2, R / 2],
              ea = -er,
              en = +er,
              [eo, el, eh] = [
                f(ea, -et, +es),
                f(ea, -et, -es),
                f(ea, +et, -es),
              ],
              b = (_, I = !1) => Math.sin(_ - Math.PI / (1 + +I)),
              T = (_, I = !1) => Math.cos(_ - Math.PI / (1 + +I));
            eh.y = Math.sin(B) * I - et;
            let ec = Math.cos(B) * I - es,
              ed = eo.z - 0.001;
            B <= X
              ? ((eh.z = Math.min(ec, ed)),
                eh.z == ed && (eh.y -= (ec - ed) / Math.tan(X - B)))
              : (el.z = Math.min(el.z - ec - es, eo.z - 0.001)),
              Q.subVectors(eo, el),
              $.subVectors(eh, el);
            let ep = (Math.min(Q.length(), $.length()) * z) / 100,
              ef = ep * Math.tan(B / 2),
              em = ep / Math.cos(B / 2),
              ey = Q.clone()
                .normalize()
                .add($.normalize())
                .setLength(em)
                .add(el);
            Q.set(0, b(B, !0), T(B, !0)), q.push([eh, Q.clone()]);
            let ex = (Math.PI - B) / k;
            for (let _ = 0; _ <= k; _++) {
              let I = X + B + _ * ex;
              Q.set(0, Math.sin(I) * ef, Math.cos(I) * ef),
                Q.add(ey),
                $.set(0, b(I), T(I)),
                q.push([Q.clone(), $.clone()]);
            }
            q.push([eo, f(0, 1, 0)]);
            let eb = Math.sin(ex / 2) * ef * 2,
              ew = q.length - 1,
              e_ = q[0][0].distanceTo(q[1][0]),
              eS = e_ + eb * k + q[ew - 1][0].distanceTo(q[ew][0]);
            q[0].push(1);
            for (let _ = 0; _ <= k; _++) q[_ + 1].push(1 - (e_ + _ * eb) / eS);
            q[ew].push(0);
            let [eA, eC, eT] = q[0],
              eP,
              eI,
              eR;
            for (let _ = 1; _ < q.length; _++)
              ([eP, eI, eR] = q[_]),
                V.push(
                  ea,
                  eA.y,
                  eA.z,
                  ea,
                  eP.y,
                  eP.z,
                  en,
                  eA.y,
                  eA.z,
                  en,
                  eA.y,
                  eA.z,
                  ea,
                  eP.y,
                  eP.z,
                  en,
                  eP.y,
                  eP.z
                ),
                j.push(
                  0,
                  eC.y,
                  eC.z,
                  0,
                  eI.y,
                  eI.z,
                  0,
                  eC.y,
                  eC.z,
                  0,
                  eC.y,
                  eC.z,
                  0,
                  eI.y,
                  eI.z,
                  0,
                  eI.y,
                  eI.z
                ),
                G.push(0, eT, 0, eR, 1, eT, 1, eT, 0, eR, 1, eR),
                ([eA, eC, eT] = [eP, eI, eR]);
            this.setAttribute("position", new s4(V, 3)),
              this.setAttribute("normal", new s4(j, 3)),
              this.setAttribute("uv", new s4(G, 2));
          }
        },
        b_ = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R = Object.assign(
              {},
              I?.parameters ?? {
                width: 100,
                depth: 0,
                innerRadiusPercent: 38.19,
                spikes: 5,
                cornerRadius: 0,
                angle: 360,
                extrudeBevelSize: 0,
                extrudeBevelSegments: 1,
              },
              _.parameters
            );
            return {
              shape: _.shape && _.shape instanceof xT ? _.shape : new xT(),
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? 0),
              }),
            };
          }
          static build(_) {
            let {
                width: I,
                height: R,
                innerRadiusPercent: B,
                spikes: z,
                cornerRadius: k,
                angle: V,
                depth: j,
                extrudeBevelSize: G,
                extrudeBevelSegments: q,
              } = _.parameters,
              X = _.shape,
              Q = 0.5 * I,
              $ = 0.5 * R,
              et = (V * Math.PI) / 360 / z,
              er = -((Math.PI / 2) * 3),
              es = (Q * B) / 100,
              ea = ($ * B) / 100;
            if (3 === z && 50 === B) {
              et = (2 * Math.PI) / z;
              for (let _ = 0; _ < z; _++) {
                let I = et * _,
                  R = 0 + Math.sin(I) * Q,
                  B = 0 + Math.cos(I) * $;
                X.addPoint(X.createPoint(R, B));
              }
            } else
              for (let _ = 0; _ < z; _++) {
                let _ = 0 + Math.cos(er) * Q,
                  I = 0 + Math.sin(er) * $;
                X.addPoint(X.createPoint(_, I)),
                  (er += et),
                  (_ = 0 + Math.cos(er) * es),
                  (I = 0 + Math.sin(er) * ea),
                  X.addPoint(X.createPoint(_, I)),
                  (er += et);
              }
            X.isClosed = !0;
            for (let _ = 0, I = X.points.length; _ < I; _++)
              X.points[_].roundness = k;
            return (
              (X.roundness = k),
              X.update(),
              Object.assign(
                xQ.create({
                  shape: X,
                  parameters: {
                    roundness: k,
                    depth: j,
                    extrudeBevelSize: G,
                    extrudeBevelSegments: q,
                  },
                }),
                { userData: { ..._, type: "StarGeometry" } }
              )
            );
          }
        },
        bS = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R = Object.assign(
              {},
              I?.parameters ?? { width: 100, depth: 0 },
              _.parameters
            );
            return {
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? 0),
              }),
            };
          }
          static build(_) {
            let { width: I, height: R } = _.parameters;
            return Object.assign(new aq(I, R), {
              userData: { ..._, type: "TextFrameGeometry" },
            });
          }
        },
        bM = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R = Object.assign(
                {},
                I?.parameters ?? {
                  width: 100,
                  radialSegments: 32,
                  tubularSegments: 64,
                  arc: 360,
                  cornerRadius: 30,
                  cornerSegments: 8,
                },
                _.parameters
              ),
              B = Math.abs(R.width),
              z = Math.abs(R.height ?? R.width),
              k = Math.round(Math.abs(R.depth ?? 0.25 * R.width));
            return {
              parameters: Object.assign(R, { width: B, height: z, depth: k }),
            };
          }
          static build(_) {
            let {
                width: I,
                height: R,
                depth: B,
                radialSegments: z,
                tubularSegments: k,
                arc: V,
                cornerRadius: j,
                cornerSegments: G,
              } = _.parameters,
              q = (function (_, I, R, B, z, k, V, j, G, q, X) {
                ([I, R] = [R, I]), (V = I / 2);
                let Q = rr.clamp(z / 360, 0, 1);
                if (0 === Q) {
                  let _ = new ai();
                  return _.setAttribute("position", new s4([], 3)), _;
                }
                return (
                  1 === Q && (q = 0),
                  new x0(!0, _, I, R, B, Q, k, V, 0, G, q, X)
                );
              })(I, R, B, 0.5 * I, V, k, 0, 0, z, j, G);
            return (
              q.scale(1, R / I, 1),
              Object.assign(q, { userData: { ..._, type: "TorusGeometry" } })
            );
          }
        },
        bC = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R = Object.assign(
              {},
              I?.parameters ?? {
                width: 100,
                tubularSegments: 64,
                radialSegments: 32,
                p: 2,
                q: 3,
              },
              _.parameters
            );
            return {
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? R.width),
                tube: R.tube ?? 0.125 * R.width,
              }),
            };
          }
          static build(_) {
            let {
                width: I,
                tube: R,
                tubularSegments: B,
                radialSegments: z,
                p: k,
                q: V,
              } = _.parameters,
              j = 0.5 * I;
            return (
              j !== R && (j -= R),
              Object.assign(new oU(j, R, B, z, k, V), {
                userData: { ..._, type: "TorusKnotGeometry" },
              })
            );
          }
        },
        bT = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R = Object.assign(
              {},
              I?.parameters ?? {
                width: 100,
                depth: 0,
                spikes: 5,
                cornerRadius: 0,
                extrudeBevelSize: 0,
                extrudeBevelSegments: 1,
                isRect: !1,
              },
              _.parameters
            );
            return {
              shape: _.shape && _.shape instanceof xT ? _.shape : new xT(),
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(
                  R.height ?? R.width * (R.isRect ? 1 : Math.sqrt(3) / 2)
                ),
                depth: Math.abs(R.depth ?? 0),
              }),
            };
          }
          static build(_) {
            let {
                width: I = 100,
                height: R,
                cornerRadius: B,
                depth: z,
                extrudeBevelSize: k,
                extrudeBevelSegments: V,
                isRect: j,
              } = _.parameters,
              G = _.shape,
              q = 0.5 * I,
              X = 0.5 * R;
            j
              ? G.addPoint(G.createPoint(-q, X))
              : G.addPoint(G.createPoint(0, X)),
              G.addPoint(G.createPoint(q, -X)),
              G.addPoint(G.createPoint(-q, -X)),
              (G.isClosed = !0);
            for (let _ = 0, I = G.points.length; _ < I; _++)
              G.points[_].roundness = B;
            return (
              (G.roundness = B),
              G.update(),
              Object.assign(
                xQ.create({
                  shape: G,
                  parameters: {
                    roundness: B,
                    depth: z,
                    extrudeBevelSize: k,
                    extrudeBevelSegments: V,
                  },
                }),
                { userData: { ..._, type: "TriangleGeometry" } }
              )
            );
          }
        },
        bD = class {
          add(_, I, R) {
            if ("string" != typeof arguments[0])
              for (let _ in arguments[0])
                this.add(_, arguments[0][_], arguments[1]);
            else
              (Array.isArray(_) ? _ : [_]).forEach(function (_) {
                (this[_] = this[_] || []),
                  I && this[_][R ? "unshift" : "push"](I);
              }, this);
          }
          run(_, I) {
            (this[_] = this[_] || []),
              this[_].forEach(function (_) {
                _.call(I && I.context ? I.context : I, I);
              });
          }
        },
        bO = class {
          constructor(_) {
            (this.jsep = _), (this.registered = {});
          }
          register(..._) {
            _.forEach((_) => {
              if ("object" != typeof _ || !_.name || !_.init)
                throw Error("Invalid JSEP plugin format");
              this.registered[_.name] ||
                (_.init(this.jsep), (this.registered[_.name] = _));
            });
          }
        },
        bI = class {
          static get version() {
            return "1.3.8";
          }
          static toString() {
            return "JavaScript Expression Parser (JSEP) v" + bI.version;
          }
          static addUnaryOp(_) {
            return (
              (bI.max_unop_len = Math.max(_.length, bI.max_unop_len)),
              (bI.unary_ops[_] = 1),
              bI
            );
          }
          static addBinaryOp(_, I, R) {
            return (
              (bI.max_binop_len = Math.max(_.length, bI.max_binop_len)),
              (bI.binary_ops[_] = I),
              R ? bI.right_associative.add(_) : bI.right_associative.delete(_),
              bI
            );
          }
          static addIdentifierChar(_) {
            return bI.additional_identifier_chars.add(_), bI;
          }
          static addLiteral(_, I) {
            return (bI.literals[_] = I), bI;
          }
          static removeUnaryOp(_) {
            return (
              delete bI.unary_ops[_],
              _.length === bI.max_unop_len &&
                (bI.max_unop_len = bI.getMaxKeyLen(bI.unary_ops)),
              bI
            );
          }
          static removeAllUnaryOps() {
            return (bI.unary_ops = {}), (bI.max_unop_len = 0), bI;
          }
          static removeIdentifierChar(_) {
            return bI.additional_identifier_chars.delete(_), bI;
          }
          static removeBinaryOp(_) {
            return (
              delete bI.binary_ops[_],
              _.length === bI.max_binop_len &&
                (bI.max_binop_len = bI.getMaxKeyLen(bI.binary_ops)),
              bI.right_associative.delete(_),
              bI
            );
          }
          static removeAllBinaryOps() {
            return (bI.binary_ops = {}), (bI.max_binop_len = 0), bI;
          }
          static removeLiteral(_) {
            return delete bI.literals[_], bI;
          }
          static removeAllLiterals() {
            return (bI.literals = {}), bI;
          }
          get char() {
            return this.expr.charAt(this.index);
          }
          get code() {
            return this.expr.charCodeAt(this.index);
          }
          constructor(_) {
            (this.expr = _), (this.index = 0);
          }
          static parse(_) {
            return new bI(_).parse();
          }
          static getMaxKeyLen(_) {
            return Math.max(0, ...Object.keys(_).map((_) => _.length));
          }
          static isDecimalDigit(_) {
            return _ >= 48 && _ <= 57;
          }
          static binaryPrecedence(_) {
            return bI.binary_ops[_] || 0;
          }
          static isIdentifierStart(_) {
            return (
              (_ >= 65 && _ <= 90) ||
              (_ >= 97 && _ <= 122) ||
              (_ >= 128 && !bI.binary_ops[String.fromCharCode(_)]) ||
              bI.additional_identifier_chars.has(String.fromCharCode(_))
            );
          }
          static isIdentifierPart(_) {
            return bI.isIdentifierStart(_) || bI.isDecimalDigit(_);
          }
          throwError(_) {
            let I = Error(_ + " at character " + this.index);
            throw ((I.index = this.index), (I.description = _), I);
          }
          runHook(_, I) {
            if (bI.hooks[_]) {
              let R = { context: this, node: I };
              return bI.hooks.run(_, R), R.node;
            }
            return I;
          }
          searchHook(_) {
            if (bI.hooks[_]) {
              let I = { context: this };
              return (
                bI.hooks[_].find(function (_) {
                  return _.call(I.context, I), I.node;
                }),
                I.node
              );
            }
          }
          gobbleSpaces() {
            let _ = this.code;
            for (
              ;
              _ === bI.SPACE_CODE ||
              _ === bI.TAB_CODE ||
              _ === bI.LF_CODE ||
              _ === bI.CR_CODE;

            )
              _ = this.expr.charCodeAt(++this.index);
            this.runHook("gobble-spaces");
          }
          parse() {
            this.runHook("before-all");
            let _ = this.gobbleExpressions(),
              I = 1 === _.length ? _[0] : { type: bI.COMPOUND, body: _ };
            return this.runHook("after-all", I);
          }
          gobbleExpressions(_) {
            let I = [],
              R,
              B;
            for (; this.index < this.expr.length; )
              if ((R = this.code) === bI.SEMCOL_CODE || R === bI.COMMA_CODE)
                this.index++;
              else if ((B = this.gobbleExpression())) I.push(B);
              else if (this.index < this.expr.length) {
                if (R === _) break;
                this.throwError('Unexpected "' + this.char + '"');
              }
            return I;
          }
          gobbleExpression() {
            let _ =
              this.searchHook("gobble-expression") ||
              this.gobbleBinaryExpression();
            return this.gobbleSpaces(), this.runHook("after-expression", _);
          }
          gobbleBinaryOp() {
            this.gobbleSpaces();
            let _ = this.expr.substr(this.index, bI.max_binop_len),
              I = _.length;
            for (; I > 0; ) {
              if (
                bI.binary_ops.hasOwnProperty(_) &&
                (!bI.isIdentifierStart(this.code) ||
                  (this.index + _.length < this.expr.length &&
                    !bI.isIdentifierPart(
                      this.expr.charCodeAt(this.index + _.length)
                    )))
              )
                return (this.index += I), _;
              _ = _.substr(0, --I);
            }
            return !1;
          }
          gobbleBinaryExpression() {
            let _, I, R, B, z, k, V, j, G;
            if (!(k = this.gobbleToken()) || !(I = this.gobbleBinaryOp()))
              return k;
            for (
              z = {
                value: I,
                prec: bI.binaryPrecedence(I),
                right_a: bI.right_associative.has(I),
              },
                (V = this.gobbleToken()) ||
                  this.throwError("Expected expression after " + I),
                B = [k, z, V];
              (I = this.gobbleBinaryOp());

            ) {
              if (0 === (R = bI.binaryPrecedence(I))) {
                this.index -= I.length;
                break;
              }
              (z = { value: I, prec: R, right_a: bI.right_associative.has(I) }),
                (G = I);
              let c = (_) =>
                z.right_a && _.right_a ? R > _.prec : R <= _.prec;
              for (; B.length > 2 && c(B[B.length - 2]); )
                (V = B.pop()),
                  (I = B.pop().value),
                  (k = B.pop()),
                  (_ = { type: bI.BINARY_EXP, operator: I, left: k, right: V }),
                  B.push(_);
              (_ = this.gobbleToken()) ||
                this.throwError("Expected expression after " + G),
                B.push(z, _);
            }
            for (j = B.length - 1, _ = B[j]; j > 1; )
              (_ = {
                type: bI.BINARY_EXP,
                operator: B[j - 1].value,
                left: B[j - 2],
                right: _,
              }),
                (j -= 2);
            return _;
          }
          gobbleToken() {
            let _, I, R, B;
            if ((this.gobbleSpaces(), (B = this.searchHook("gobble-token"))))
              return this.runHook("after-token", B);
            if (((_ = this.code), bI.isDecimalDigit(_) || _ === bI.PERIOD_CODE))
              return this.gobbleNumericLiteral();
            if (_ === bI.SQUOTE_CODE || _ === bI.DQUOTE_CODE)
              B = this.gobbleStringLiteral();
            else if (_ === bI.OBRACK_CODE) B = this.gobbleArray();
            else {
              for (
                R = (I = this.expr.substr(this.index, bI.max_unop_len)).length;
                R > 0;

              ) {
                if (
                  bI.unary_ops.hasOwnProperty(I) &&
                  (!bI.isIdentifierStart(this.code) ||
                    (this.index + I.length < this.expr.length &&
                      !bI.isIdentifierPart(
                        this.expr.charCodeAt(this.index + I.length)
                      )))
                ) {
                  this.index += R;
                  let _ = this.gobbleToken();
                  return (
                    _ || this.throwError("missing unaryOp argument"),
                    this.runHook("after-token", {
                      type: bI.UNARY_EXP,
                      operator: I,
                      argument: _,
                      prefix: !0,
                    })
                  );
                }
                I = I.substr(0, --R);
              }
              bI.isIdentifierStart(_)
                ? ((B = this.gobbleIdentifier()),
                  bI.literals.hasOwnProperty(B.name)
                    ? (B = {
                        type: bI.LITERAL,
                        value: bI.literals[B.name],
                        raw: B.name,
                      })
                    : B.name === bI.this_str && (B = { type: bI.THIS_EXP }))
                : _ === bI.OPAREN_CODE && (B = this.gobbleGroup());
            }
            return B
              ? ((B = this.gobbleTokenProperty(B)),
                this.runHook("after-token", B))
              : this.runHook("after-token", !1);
          }
          gobbleTokenProperty(_) {
            this.gobbleSpaces();
            let I = this.code;
            for (
              ;
              I === bI.PERIOD_CODE ||
              I === bI.OBRACK_CODE ||
              I === bI.OPAREN_CODE ||
              I === bI.QUMARK_CODE;

            ) {
              let R;
              if (I === bI.QUMARK_CODE) {
                if (this.expr.charCodeAt(this.index + 1) !== bI.PERIOD_CODE)
                  break;
                (R = !0),
                  (this.index += 2),
                  this.gobbleSpaces(),
                  (I = this.code);
              }
              this.index++,
                I === bI.OBRACK_CODE
                  ? ((_ = {
                      type: bI.MEMBER_EXP,
                      computed: !0,
                      object: _,
                      property: this.gobbleExpression(),
                    }),
                    this.gobbleSpaces(),
                    (I = this.code) !== bI.CBRACK_CODE &&
                      this.throwError("Unclosed ["),
                    this.index++)
                  : I === bI.OPAREN_CODE
                  ? (_ = {
                      type: bI.CALL_EXP,
                      arguments: this.gobbleArguments(bI.CPAREN_CODE),
                      callee: _,
                    })
                  : (I === bI.PERIOD_CODE || R) &&
                    (R && this.index--,
                    this.gobbleSpaces(),
                    (_ = {
                      type: bI.MEMBER_EXP,
                      computed: !1,
                      object: _,
                      property: this.gobbleIdentifier(),
                    })),
                R && (_.optional = !0),
                this.gobbleSpaces(),
                (I = this.code);
            }
            return _;
          }
          gobbleNumericLiteral() {
            let _ = "",
              I,
              R;
            for (; bI.isDecimalDigit(this.code); )
              _ += this.expr.charAt(this.index++);
            if (this.code === bI.PERIOD_CODE)
              for (
                _ += this.expr.charAt(this.index++);
                bI.isDecimalDigit(this.code);

              )
                _ += this.expr.charAt(this.index++);
            if ("e" === (I = this.char) || "E" === I) {
              for (
                _ += this.expr.charAt(this.index++),
                  ("+" === (I = this.char) || "-" === I) &&
                    (_ += this.expr.charAt(this.index++));
                bI.isDecimalDigit(this.code);

              )
                _ += this.expr.charAt(this.index++);
              bI.isDecimalDigit(this.expr.charCodeAt(this.index - 1)) ||
                this.throwError("Expected exponent (" + _ + this.char + ")");
            }
            return (
              (R = this.code),
              bI.isIdentifierStart(R)
                ? this.throwError(
                    "Variable names cannot start with a number (" +
                      _ +
                      this.char +
                      ")"
                  )
                : (R === bI.PERIOD_CODE ||
                    (1 === _.length && _.charCodeAt(0) === bI.PERIOD_CODE)) &&
                  this.throwError("Unexpected period"),
              { type: bI.LITERAL, value: parseFloat(_), raw: _ }
            );
          }
          gobbleStringLiteral() {
            let _ = "",
              I = this.index,
              R = this.expr.charAt(this.index++),
              B = !1;
            for (; this.index < this.expr.length; ) {
              let I = this.expr.charAt(this.index++);
              if (I === R) {
                B = !0;
                break;
              }
              if ("\\" === I)
                switch ((I = this.expr.charAt(this.index++))) {
                  case "n":
                    _ += `
`;
                    break;
                  case "r":
                    _ += "\r";
                    break;
                  case "t":
                    _ += "	";
                    break;
                  case "b":
                    _ += "\b";
                    break;
                  case "f":
                    _ += "\f";
                    break;
                  case "v":
                    _ += "\v";
                    break;
                  default:
                    _ += I;
                }
              else _ += I;
            }
            return (
              B || this.throwError('Unclosed quote after "' + _ + '"'),
              {
                type: bI.LITERAL,
                value: _,
                raw: this.expr.substring(I, this.index),
              }
            );
          }
          gobbleIdentifier() {
            let _ = this.code,
              I = this.index;
            for (
              bI.isIdentifierStart(_)
                ? this.index++
                : this.throwError("Unexpected " + this.char);
              this.index < this.expr.length &&
              ((_ = this.code), bI.isIdentifierPart(_));

            )
              this.index++;
            return {
              type: bI.IDENTIFIER,
              name: this.expr.slice(I, this.index),
            };
          }
          gobbleArguments(_) {
            let I = [],
              R = !1,
              B = 0;
            for (; this.index < this.expr.length; ) {
              this.gobbleSpaces();
              let z = this.code;
              if (z === _) {
                (R = !0),
                  this.index++,
                  _ === bI.CPAREN_CODE &&
                    B &&
                    B >= I.length &&
                    this.throwError(
                      "Unexpected token " + String.fromCharCode(_)
                    );
                break;
              }
              if (z === bI.COMMA_CODE) {
                if ((this.index++, ++B !== I.length)) {
                  if (_ === bI.CPAREN_CODE)
                    this.throwError("Unexpected token ,");
                  else if (_ === bI.CBRACK_CODE)
                    for (let _ = I.length; _ < B; _++) I.push(null);
                }
              } else if (I.length !== B && 0 !== B)
                this.throwError("Expected comma");
              else {
                let _ = this.gobbleExpression();
                (_ && _.type !== bI.COMPOUND) ||
                  this.throwError("Expected comma"),
                  I.push(_);
              }
            }
            return (
              R || this.throwError("Expected " + String.fromCharCode(_)), I
            );
          }
          gobbleGroup() {
            this.index++;
            let _ = this.gobbleExpressions(bI.CPAREN_CODE);
            if (this.code === bI.CPAREN_CODE)
              return (
                this.index++,
                1 === _.length
                  ? _[0]
                  : !!_.length && { type: bI.SEQUENCE_EXP, expressions: _ }
              );
            this.throwError("Unclosed (");
          }
          gobbleArray() {
            return (
              this.index++,
              {
                type: bI.ARRAY_EXP,
                elements: this.gobbleArguments(bI.CBRACK_CODE),
              }
            );
          }
        };
      Object.assign(bI, {
        hooks: new bD(),
        plugins: new bO(bI),
        COMPOUND: "Compound",
        SEQUENCE_EXP: "SequenceExpression",
        IDENTIFIER: "Identifier",
        MEMBER_EXP: "MemberExpression",
        LITERAL: "Literal",
        THIS_EXP: "ThisExpression",
        CALL_EXP: "CallExpression",
        UNARY_EXP: "UnaryExpression",
        BINARY_EXP: "BinaryExpression",
        ARRAY_EXP: "ArrayExpression",
        TAB_CODE: 9,
        LF_CODE: 10,
        CR_CODE: 13,
        SPACE_CODE: 32,
        PERIOD_CODE: 46,
        COMMA_CODE: 44,
        SQUOTE_CODE: 39,
        DQUOTE_CODE: 34,
        OPAREN_CODE: 40,
        CPAREN_CODE: 41,
        OBRACK_CODE: 91,
        CBRACK_CODE: 93,
        QUMARK_CODE: 63,
        SEMCOL_CODE: 59,
        COLON_CODE: 58,
        unary_ops: { "-": 1, "!": 1, "~": 1, "+": 1 },
        binary_ops: {
          "||": 1,
          "&&": 2,
          "|": 3,
          "^": 4,
          "&": 5,
          "==": 6,
          "!=": 6,
          "===": 6,
          "!==": 6,
          "<": 7,
          ">": 7,
          "<=": 7,
          ">=": 7,
          "<<": 8,
          ">>": 8,
          ">>>": 8,
          "+": 9,
          "-": 9,
          "*": 10,
          "/": 10,
          "%": 10,
        },
        right_associative: new Set(),
        additional_identifier_chars: new Set(["$", "_"]),
        literals: { true: !0, false: !1, null: null },
        this_str: "this",
      }),
        (bI.max_unop_len = bI.getMaxKeyLen(bI.unary_ops)),
        (bI.max_binop_len = bI.getMaxKeyLen(bI.binary_ops));
      var Yc = (_) => new bI(_).parse();
      Object.getOwnPropertyNames(bI).forEach((_) => {
        void 0 === Yc[_] && "prototype" !== _ && (Yc[_] = bI[_]);
      }),
        (Yc.Jsep = bI),
        Yc.plugins.register({
          name: "ternary",
          init(_) {
            _.hooks.add("after-expression", function (I) {
              if (I.node && this.code === _.QUMARK_CODE) {
                this.index++;
                let R = I.node,
                  B = this.gobbleExpression();
                if (
                  (B || this.throwError("Expected expression"),
                  this.gobbleSpaces(),
                  this.code === _.COLON_CODE)
                ) {
                  this.index++;
                  let z = this.gobbleExpression();
                  if (
                    (z || this.throwError("Expected expression"),
                    (I.node = {
                      type: "ConditionalExpression",
                      test: R,
                      consequent: B,
                      alternate: z,
                    }),
                    R.operator && _.binary_ops[R.operator] <= 0.9)
                  ) {
                    let B = R;
                    for (
                      ;
                      B.right.operator && _.binary_ops[B.right.operator] <= 0.9;

                    )
                      B = B.right;
                    (I.node.test = B.right), (B.right = I.node), (I.node = R);
                  }
                } else this.throwError("Expected :");
              }
            });
          },
        });
      var bR = [
          "+",
          "-",
          "*",
          "/",
          "(",
          ")",
          "==",
          "!=",
          ">",
          "<",
          ">=",
          "<=",
          "and",
          "or",
          "!",
          "%",
          "^",
          ",",
        ],
        bB = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "."],
        bL = [
          "sin",
          "cos",
          "tan",
          "asin",
          "acos",
          "atan",
          "atan2",
          "sqrt",
          "abs",
          "log",
          "exp",
          "floor",
          "ceil",
          "round",
          "min",
          "max",
          "random",
        ];
      function j0(_, I, R = "number") {
        let B,
          z,
          k = "";
        for (let B = 0; B < _.length; B++) {
          var V;
          let z = _[B];
          if ("id" in z) {
            let V = _[B - 1];
            if (B > 0 && "id" in V) {
              console.error("Two variables in a row", _);
              return;
            }
            let j = I.getVariable(z.id),
              G = vR.getDisplayedValue(j);
            "number" === R &&
            vR.isTextValue(j) &&
            Array.isArray(j.textValue) &&
            1 === j.textValue.length
              ? (G = parseFloat(G).toString())
              : "boolean" === R && vR.isBoolean(j)
              ? (G = j ? "true" : "false")
              : "boolean" === R &&
                vR.isTextValue(j) &&
                !Array.isArray(j.textValue) &&
                (G = '"' + G + '"'),
              (k += G);
            continue;
          }
          if ("string" === R) {
            '"' !== z.name && "+" !== z.name && (k += z.name),
              "+" === z.name &&
                "\\" === k[k.length - 1] &&
                (k = k.slice(0, -1) + z.name);
            continue;
          }
          if ("and" === z.name) {
            k += "&&";
            continue;
          }
          if ("or" === z.name) {
            k += "||";
            continue;
          }
          if ("True" === z.name) {
            k += "true";
            continue;
          }
          if ("False" === z.name) {
            k += "false";
            continue;
          }
          if (
            "boolean" === R &&
            !(
              "string" == typeof (V = z.name) &&
              !isNaN(V) &&
              !isNaN(parseFloat(V))
            ) &&
            !bB.includes(z.name) &&
            !bR.includes(z.name) &&
            !bL.includes(z.name.replace(/\($/g, ""))
          ) {
            k += '"' + z.name + '"';
            continue;
          }
          k += z.name;
        }
        if ("string" === R) return k;
        if (0 === _.length) {
          if ("number" === R) return 0;
          if ("boolean" === R) return !1;
        }
        try {
          B = Yc(k);
        } catch (_) {
          console.error(k, _);
          return;
        }
        try {
          z = (function qt(_) {
            switch (_.type) {
              case "BinaryExpression":
                switch (_.operator) {
                  case "==":
                    return Number(qt(_.left) === qt(_.right));
                  case "!=":
                    return Number(qt(_.left) !== qt(_.right));
                  case ">":
                    return Number(qt(_.left) > qt(_.right));
                  case ">=":
                    return Number(qt(_.left) >= qt(_.right));
                  case "<":
                    return Number(qt(_.left) < qt(_.right));
                  case "<=":
                    return Number(qt(_.left) <= qt(_.right));
                  case "+":
                    return qt(_.left) + qt(_.right);
                  case "-":
                    return qt(_.left) - qt(_.right);
                  case "*":
                    return qt(_.left) * qt(_.right);
                  case "/":
                    return qt(_.left) / qt(_.right);
                  case "%":
                    return qt(_.left) % qt(_.right);
                  case "&&":
                    return qt(_.left) && qt(_.right);
                  case "||":
                    return qt(_.left) || qt(_.right);
                  case "^":
                    return Math.pow(qt(_.left), qt(_.right));
                  default:
                    throw Error("Unknown operator: " + _.operator);
                }
              case "UnaryExpression":
                switch (_.operator) {
                  case "-":
                    return -qt(_.argument);
                  case "!":
                    return Number(!qt(_.argument));
                  default:
                    throw Error("Unknown operator: " + _.operator);
                }
              case "Identifier":
                throw Error("Unknown identifier: " + _.name);
              case "Literal":
                return _.value;
              case "CallExpression":
                if ("Identifier" === _.callee.type) {
                  if ("random" === _.callee.name) {
                    let I = 0,
                      R = 1;
                    if (_.arguments.length >= 1)
                      try {
                        I = qt(_.arguments[0]);
                      } catch (_) {
                        console.warn(_);
                      }
                    if (_.arguments.length >= 2)
                      try {
                        R = qt(_.arguments[1]);
                      } catch (_) {
                        console.warn(_);
                      }
                    return (
                      (I = Math.min(R, I)),
                      (R = Math.max(R, I)),
                      I + Math.random() * (R - I)
                    );
                  }
                  return Math[_.callee.name].apply(null, _.arguments.map(qt));
                }
                throw Error("Unknown node");
              default:
                throw Error("Unknown node type: " + _.type);
            }
          })(B);
        } catch (_) {
          console.error(k, B, _);
        }
        return z;
      }
      Yc.addBinaryOp("^", 11, !0);
      var bz = new sa(),
        bF = new sa(),
        bN = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, I) {
            let R = Object.assign(
                {},
                I?.parameters ?? {
                  width: 100,
                  height: 100,
                  depth: 1,
                  subdivisions: 12,
                  roundness: 0,
                  extrudeBevelSize: 0,
                  extrudeBevelSegments: 3,
                },
                _.parameters
              ),
              B = Math.abs(R.width),
              z = Math.abs(R.height ?? R.width),
              k = Math.abs(R.depth ?? 0),
              V = I?.shapeData ?? xK.create({ parameters: mQ }).userData.shape;
            return {
              path: _.path ?? gW.defaultData(),
              parameters: Object.assign(R, {
                width: B,
                height: z,
                depth: k,
                extrusion: { ...mZ, ...R.extrusion },
              }),
              shapeData: V,
            };
          }
          static build(_) {
            return _.path.points.length >= 2
              ? Object.assign(new bk(_), {
                  userData: { ..._, type: "PathGeometry" },
                })
              : Object.assign(new ai(), {
                  userData: { ..._, type: "PathGeometry" },
                });
          }
        },
        bk = class extends ai {
          constructor(_) {
            super(),
              (this.type = "PathExtrusionGeometry"),
              (this.inputs = _),
              this.build();
          }
          _isGeometryClosed() {
            return (
              this.inputs.path.isClosed &&
              1 === this.inputs.parameters.extrusion.depth
            );
          }
          _isOpenEnded() {
            let _,
              I = this.inputs.parameters.extrusion;
            return (
              !(this.inputs.path.isClosed && 1 === I.depth) ||
              ((I.twist % (_ = 2 * Math.PI)) + _) % _ != ((0 % _) + _) % _ ||
              I.startScale !== I.endScale
            );
          }
          build() {
            let _ = this._extractPathPoints();
            if (_.length < 2) return;
            let I = this._computeBasisMatrices(_),
              { depth: R, offset: B } = this.inputs.parameters.extrusion;
            (R = Math.max(0, Math.min(R, 1))),
              (B = Math.max(0, Math.min(B, 1)));
            let z = this.inputs.path.isClosed ? _.length : _.length - 1,
              k = Math.floor(B * z),
              V = Math.min(
                Math.max(
                  2,
                  (this.inputs.path.isClosed
                    ? Math.ceil((R + B) * z)
                    : Math.ceil(Math.min(1, R + B) * z)) -
                    k +
                    1
                ),
                z + 2
              ),
              j = [],
              G = [];
            for (let R = 0; R < V; R++) {
              let B = this.inputs.path.isClosed
                ? (R + k) % _.length
                : Math.min(R + k, _.length - 1);
              j.push(_[B].clone()), G.push(I[B].clone());
            }
            let d = (_, I, R) => {
                var B, z;
                let k, V;
                (j[_] = j[_].clone().lerp(j[I], R)),
                  (G[_] =
                    ((B = G[_]),
                    (z = G[I]),
                    (k = [new rF(), new rF(), new rF()]),
                    (V = [new rF(), new rF(), new rF()]),
                    B.extractBasis(k[0], k[1], k[2]),
                    z.extractBasis(V[0], V[1], V[2]),
                    k.forEach((_, I) => {
                      let B = V[I],
                        z = rr.lerp(_.length(), B.length(), R);
                      _.lerp(B, R).setLength(z);
                    }),
                    new sa().makeBasis(k[0], k[1], k[2])));
              },
              q = 0,
              X = (B * z) % 1;
            (!this.inputs.path.isClosed || R <= 1) &&
              (X || 0 === B) &&
              d(0, 1, (q = X));
            let Q = 0,
              $ = ((B + R) * z) % 1;
            if (
              (((this.inputs.path.isClosed && R <= 1) ||
                (!this.inputs.path.isClosed && B + R < 1)) &&
                $ &&
                ((Q = $), d(j.length - 1, j.length - 2, 1 - Q)),
              0 === R)
            ) {
              let _ = j.length - 1;
              j[_].copy(j[0]), G[_].copy(G[0]);
            }
            this._applyPathModifiers(G, q, Q);
            let { bevel: et, bevelSides: er } =
                this.inputs.parameters.extrusion,
              es = et > 0 ? this.inputs.parameters.extrusion.capType : "flat",
              ea = 5;
            "Custom" === this.inputs.parameters.extrusion.shape.type &&
              (ea =
                "low" === this.inputs.parameters.extrusion.shape.shapeQuality
                  ? 5
                  : 12);
            let {
                regions: en,
                infos: eo,
                vertices: el,
              } = this._computeShapePoints(ea),
              eh = 0,
              ec;
            "round" === es &&
              (eh = (ec = new xq(
                this.inputs.shapeData,
                2 * et,
                et,
                ea,
                er,
                void 0,
                !0
              )).getAttribute("position").count);
            let ed = 0,
              ep = 0;
            eo.sort((_, I) => _.start - I.start),
              eo.forEach((_) => {
                (_.verticesStart = ed),
                  (_.verticesCount = _.continuous.reduce(
                    (_, I, R) => _ + (0 !== R && I ? 1 : 2),
                    0
                  )),
                  (ep += _.verticesCount),
                  (ed = ep);
              });
            let ef = ep * V,
              em,
              ey = 0;
            if (this._isOpenEnded() && "flat" === es) {
              try {
                em = io({
                  windingRule: bH.ODD,
                  elementType: bW.POLYGONS,
                  polySize: 3,
                  vertexSize: 2,
                  strict: !0,
                  contours: en,
                });
              } catch {
                em = xW;
              }
              ey = em.vertexCount;
            }
            let ex = ef + 2 * ey + 2 * eh,
              eb = ef + 2 * ey,
              ew = {
                positions: new Float32Array(3 * ex),
                normals: new Float32Array(3 * ex),
                uvs: new Float32Array(2 * ex),
              },
              e_ = [];
            if (
              (eo.forEach((_) => {
                this._extrudeRegion(
                  _,
                  el,
                  G,
                  j,
                  ew,
                  e_,
                  this._isGeometryClosed() && !this._isOpenEnded()
                );
              }),
              em &&
                (this._closeEnd(em, ef, e_, ew, G[0], j[0], !1),
                this._closeEnd(
                  em,
                  ef + ey,
                  e_,
                  ew,
                  G[G.length - 1],
                  j[j.length - 1],
                  !0
                )),
              ec)
            ) {
              ew.positions.set(ec.getAttribute("position").array, 3 * eb),
                ew.normals.set(ec.getAttribute("normal").array, 3 * eb),
                ew.uvs.set(ec.getAttribute("uv").array, 2 * eb);
              let _ = e_.length;
              e_.push(...ec.getIndex().array.map((_) => _ + eb)),
                (eb += eh),
                ew.positions.set(ec.getAttribute("position").array, 3 * eb),
                ew.normals.set(ec.getAttribute("normal").array, 3 * eb),
                ew.uvs.set(ec.getAttribute("uv").array, 2 * eb);
              let I = e_.length;
              e_.push(...ec.getIndex().array.map((_) => _ + eb)),
                this.setAttribute("position", new s0(ew.positions, 3)),
                this.setAttribute("normal", new s0(ew.normals, 3)),
                this.setAttribute("uv", new s0(ew.uvs, 2)),
                this.setIndex(e_),
                bz.copy(G[G.length - 1]).setPosition(j[j.length - 1]),
                this.applyMatrix4OnRange(bz, eb, ex),
                bz
                  .copy(G[0])
                  .setPosition(j[0])
                  .multiply(bF.makeScale(1, 1, -1)),
                this.applyMatrix4OnRange(bz, eb - eh, eb),
                this.reverseIndicesOnRange(_, I);
            } else
              this.setAttribute("position", new s0(ew.positions, 3)),
                this.setAttribute("normal", new s0(ew.normals, 3)),
                this.setAttribute("uv", new s0(ew.uvs, 2)),
                this.setIndex(e_);
          }
          _extractPathPoints() {
            let _ = P0(this.inputs.path).getPoints(
              this.inputs.path.subdivisions
            );
            if (_.length < 2) return [];
            let I = [_[0]];
            return (
              _.forEach((_) => {
                I[I.length - 1].distanceToSquared(_) > 0.001 && I.push(_);
              }),
              this.inputs.path.isClosed &&
                0.001 > I[I.length - 1].distanceTo(I[0]) &&
                I.pop(),
              I
            );
          }
          _computeBasisMatrices(_) {
            let I = [],
              R = _.length,
              B = this.inputs.path.isClosed,
              z = new rF(),
              k = new rF(),
              V = new rF(),
              j = new rF(),
              G = new rF(0, 1, 0);
            for (let q = 0; q < R; q++) {
              let X,
                Q = _[q],
                $;
              ($ =
                0 === q
                  ? B
                    ? _[_.length - 2]
                    : Q.clone().multiplyScalar(2).sub(_[1])
                  : _[q - 1]),
                (X =
                  q === R - 1
                    ? B
                      ? _[1]
                      : Q.clone()
                          .multiplyScalar(2)
                          .sub(_[q - 1])
                    : _[q + 1]);
              let et = Q.clone().sub($).normalize(),
                er = X.clone().sub(Q).normalize(),
                es = et.clone().add(er).normalize();
              V.copy(es),
                0 === q &&
                  (es.equals(G) || es.clone().negate().equals(G)) &&
                  G.set(0, 0, 1);
              let ea = G.clone().cross(es).normalize(),
                en = es.clone().cross(ea).normalize();
              G.copy(en), j.copy(ea), 0 === q && (z.copy(en), k.copy(es));
              let eo = new sa().makeBasis(ea, en, es);
              I.push(eo);
            }
            let q = B ? k : V,
              X = B ? z : new rF(0, 1, 0),
              Q = q.clone().cross(j).normalize(),
              $ = Math.acos(X.dot(Q));
            if (isNaN($)) return I;
            let et = X.clone().cross(Q);
            q.dot(et) > 0 && ($ *= -1);
            for (let _ = 1; _ < I.length; _++) {
              let R = new sa().makeRotationZ(($ * _) / I.length);
              I[_].multiply(R);
            }
            return I;
          }
          _applyPathModifiers(_, I, R) {
            let B = _.length,
              {
                angle: z,
                twist: k,
                startScale: V,
                endScale: j,
              } = this.inputs.parameters.extrusion,
              G = new sa(),
              q = new sa();
            return (
              _.forEach((_, X) => {
                let Q =
                  0 === X
                    ? 0
                    : X === B - 1
                    ? 1
                    : (X - I) / (B - (0 === R ? 0 : 1) - (I + (1 - R)));
                G.makeRotationZ(rr.lerp(z, z + k, Q) * rr.DEG2RAD);
                let $ = rr.lerp(V, j, Q);
                q.makeScale($, $, $), _.multiply(G).multiply(q);
              }),
              _
            );
          }
          _computeShapePoints(_ = 12, I = bH.ODD) {
            let R,
              B = this.inputs.shapeData,
              z = B.extractShapePointsToFlatArray([], _),
              k = B.shapeHoles.map((I) => {
                let R = I.extractShapePointsToFlatArray([], _),
                  B = [];
                for (let _ = R.length - 1; _ >= 1; _ -= 2) {
                  let I = R[_ - 1],
                    z = R[_ - 0];
                  B.push(I, z);
                }
                return B;
              }),
              V;
            try {
              V = io({
                windingRule: I,
                elementType: bW.BOUNDARY_CONTOURS,
                vertexSize: 2,
                strict: !0,
                contours: [z],
              });
            } catch {
              V = xG;
            }
            try {
              R = io({
                windingRule: bH.ODD,
                elementType: bW.BOUNDARY_CONTOURS,
                vertexSize: 2,
                strict: !0,
                contours: [...k],
              });
            } catch {
              R = xH;
            }
            if (!V) throw Error("error generating geometry");
            let j = V.elementCount;
            if (R) {
              V.elementCount += R.elementCount;
              for (let _ = 0; _ < R.elements.length; _++) {
                let I = R.elements[_],
                  B = _ % 2 == 0 ? V.vertexCount : 0;
                V.elements.push(I + B);
              }
              for (let _ = 0; _ < R.vertexIndices.length; _++) {
                let I = R.vertexIndices[_],
                  B = V.vertexCount;
                V.vertexIndices.push(I + B);
              }
              for (let _ = 0; _ < R.vertices.length; _++) {
                let I = R.vertices[_];
                V.vertices.push(I);
              }
            }
            let G = 1 / 0,
              q = -1 / 0,
              X = 1 / 0,
              Q = -1 / 0;
            for (let _ = 0, I = V.vertexCount; _ < I; _++) {
              let I = 2 * _,
                R = V.vertices[I + 0],
                B = V.vertices[I + 1];
              R < G && (G = R),
                R > q && (q = R),
                B < X && (X = B),
                B > Q && (Q = B);
            }
            let $ = [];
            for (let _ = V.elementCount - 1; _ >= 0; _--) {
              let I = _ >= j,
                R = 2 * _,
                z = V.elements[R + 0],
                k = V.elements[R + 1],
                G = z + k,
                q = {
                  start: z,
                  count: k,
                  normals: [],
                  isHole: I,
                  continuous: [],
                  verticesStart: 0,
                  verticesCount: 0,
                };
              $.push(q);
              let X = z,
                Q = G - 1,
                et = z + 1,
                er = B.roundedCurves.length;
              do {
                let _ = X - z,
                  R = V.vertices[2 * Q + 0],
                  j = V.vertices[2 * Q + 1],
                  $ = V.vertices[2 * X + 0],
                  es = V.vertices[2 * X + 1],
                  ea = V.vertices[2 * et + 0],
                  en = V.vertices[2 * et + 1],
                  eo = $ - R,
                  el = es - j,
                  eh = Math.sqrt(eo * eo + el * el);
                (eo /= eh), (el /= eh);
                let ec = $ - ea,
                  ed = es - en,
                  ep = Math.sqrt(ec * ec + ed * ed);
                (ec /= ep),
                  (ed /= ep),
                  (q.normals[2 * _ + 0] = -ed),
                  (q.normals[2 * _ + 1] = ec);
                let ef = V.vertexIndices[X];
                if (Array.isArray(ef)) q.continuous[_] = !1;
                else {
                  let [I, R] = B.getCurveIndexFromVertexId(ef - 1, !0);
                  if (R > 0 && R < 1) q.continuous[_] = !0;
                  else {
                    let z = 1 === R ? I + 1 : I - 1;
                    z = (z + er) % er;
                    let k = 1 === R ? 0 : 1,
                      V = B.roundedCurves[I].getTangent(R),
                      j = B.roundedCurves[z].getTangent(k);
                    q.continuous[_] = V.dot(j) > 0.95;
                  }
                }
                I &&
                  ((q.normals[2 * _ + 0] *= -1), (q.normals[2 * _ + 1] *= -1)),
                  ([Q, X, et] = [X, et, et + 1]),
                  et >= G && (et -= k);
              } while (et !== z + 1);
            }
            return { regions: [z, ...k], infos: $, vertices: V.vertices };
          }
          _insertVertex(_, I, R, B, z) {
            let k = 2 * I,
              V = 3 * I;
            (_.positions[V + 0] = R.x),
              (_.positions[V + 1] = R.y),
              (_.positions[V + 2] = R.z),
              (_.normals[V + 0] = B.x),
              (_.normals[V + 1] = B.y),
              (_.normals[V + 2] = B.z),
              (_.uvs[k + 0] = z.x),
              (_.uvs[k + 1] = z.y);
          }
          _extrudeRegion(_, I, R, B, z, k, V) {
            let j = new rF(),
              G = new rF(),
              q = new rF(),
              X = new rF(),
              Q = new rs();
            R.forEach((k, V) => {
              let $ = B[V],
                et = _.verticesStart * R.length + _.verticesCount * V;
              for (let B = 0; B < _.count; B++) {
                let er = (_.start + B) * 2;
                if (
                  (j.set(I[er + 0], I[er + 1], 0),
                  q.copy(j).applyMatrix4(k).add($),
                  _.continuous[B])
                )
                  X.set(_.normals[2 * B + 0], _.normals[2 * B + 1], 0);
                else {
                  let R = 0 === B ? (_.start + _.count - 1) * 2 : er - 2;
                  G.set(I[R + 0], I[R + 1], 0),
                    X.copy(j).sub(G),
                    X.set(-X.y, X.x, 0),
                    _.isHole || X.negate();
                }
                if (
                  (X.applyMatrix4(k).normalize(),
                  Q.set(0 === B ? 1 : B / _.count, V / (R.length - 1)),
                  this._insertVertex(z, et, q, X, Q),
                  et++,
                  !_.continuous[B] || 0 === B)
                ) {
                  if (0 === B)
                    X.set(_.normals[2 * B + 0], _.normals[2 * B + 1], 0),
                      Q.set(0, V / (R.length - 1));
                  else {
                    let R = B === _.count - 1 ? 2 * _.start : er + 2;
                    G.set(I[R + 0], I[R + 1], 0),
                      X.copy(G).sub(j),
                      X.set(-X.y, X.x, 0),
                      _.isHole || X.negate();
                  }
                  X.applyMatrix4(k).normalize(),
                    this._insertVertex(z, et, q, X, Q),
                    et++;
                }
              }
            });
            let $ = R.length - 1;
            for (let I = 0; I < $; I++) {
              let B = _.verticesStart * R.length + _.verticesCount * I,
                z = _.verticesStart * R.length + _.verticesCount * (I + 1),
                V = 0;
              for (let I = 0; I < _.count; I++) {
                (!_.continuous[I] || 0 === I) && V++;
                let R = I === _.count - 1 ? 0 : V + 1,
                  j = B + V,
                  G = B + R,
                  q = z + R,
                  X = z + V;
                _.isHole ? k.push(j, q, G, j, X, q) : k.push(j, G, q, j, q, X),
                  V++;
              }
            }
          }
          _closeEnd(_, I, R, B, z, k, V) {
            let j = _.vertexCount,
              G = new rF(0, 0, V ? -1 : 1).applyMatrix4(z),
              q = new rF(),
              X = new rs();
            for (let R = 0; R < j; R++) {
              let V = 2 * R;
              q
                .set(_.vertices[V + 0], _.vertices[V + 1], 0)
                .applyMatrix4(z)
                .add(k),
                this._insertVertex(B, I + R, q, G, X);
            }
            let Q = _.elements;
            for (let B = 0; B < _.elementCount; B++) {
              let _ = 3 * B,
                z = Q[_ + 0] + I,
                k = Q[_ + (V ? 1 : 2)] + I,
                j = Q[_ + (V ? 2 : 1)] + I;
              R.push(z, k, j);
            }
          }
          applyMatrix4OnRange(_, I, R) {
            let B = _.elements,
              z = new ro().getNormalMatrix(_).elements,
              k,
              V,
              j,
              G,
              q = this.attributes.position,
              X = this.attributes.normal;
            if (!q || !X) return;
            let Q = q.array,
              $ = X.array,
              et = q.itemSize;
            for (let _ = I * et, q = R * et; _ < q; _ += et)
              (k = Q[_ + 0]),
                (V = Q[_ + 1]),
                (j = Q[_ + 2]),
                (G = 1 / (B[3] * k + B[7] * V + B[11] * j + B[15])),
                (Q[_ + 0] = (B[0] * k + B[4] * V + B[8] * j + B[12]) * G),
                (Q[_ + 1] = (B[1] * k + B[5] * V + B[9] * j + B[13]) * G),
                (Q[_ + 2] = (B[2] * k + B[6] * V + B[10] * j + B[14]) * G),
                (k = $[_ + 0]),
                (V = $[_ + 1]),
                (j = $[_ + 2]),
                ($[_ + 0] = z[0] * k + z[3] * V + z[6] * j),
                ($[_ + 1] = z[1] * k + z[4] * V + z[7] * j),
                ($[_ + 2] = z[2] * k + z[5] * V + z[8] * j);
            (q.needsUpdate = !0), (X.needsUpdate = !0);
          }
          reverseIndicesOnRange(_, I) {
            let R = this.index;
            if (R) {
              for (let B = _; B < I; B += 3) {
                let _ = R.getX(B),
                  I = R.getX(B + 1),
                  z = R.getX(B + 2);
                R.setXYZ(B, z, I, _);
              }
              R.needsUpdate = !0;
            }
          }
        };
      function OI() {
        let _ = new ai();
        return (
          _.setAttribute("position", new s0(new Float32Array([]), 3)),
          _.setIndex(new s0(new Uint16Array([]), 1)),
          _
        );
      }
      var bV,
        bj,
        bG,
        bH,
        bW,
        bq,
        bY = OI().attributes,
        bX = class extends ai {
          constructor(_, I) {
            super(),
              (this.charWidths = []),
              (this.charCoords = []),
              (this.wrappedText = []),
              (this.isLowResolution = !1),
              (this.vectorShapes = []),
              Object.assign(this.attributes, bY),
              (this.userData = { parameters: _, type: "TextGeometry" });
            let R = I.getFont(_.font);
            R?.isLoaded
              ? ((this.font = R), this.update(_))
              : this.updateFont(_.font, I).then(() => {
                  this.update(_), I?.requestRender();
                });
          }
          async updateFont(_, I) {
            let R = I.getFont(_);
            R && ((this.font = R), await R.loadingPromise);
          }
          update(_) {
            let I = this.font;
            if (
              ((this.userData = { parameters: _, type: "TextGeometry" }),
              !I?.isLoaded)
            ) {
              console.warn("Cannot update text because its font is not loaded");
              return;
            }
            let {
                width: R,
                height: B,
                depth: z,
                extrudeBevelSize: k,
                extrudeBevelSegments: V,
                text: j,
                textTransform: G,
              } = _,
              q = vR.getDisplayedValue(j),
              X = (function (_, I, R) {
                let B = [""],
                  z = "";
                for (let k of R)
                  (z += k),
                    " " === k ||
                    k ===
                      `
`
                      ? ((B[B.length - 1] += z),
                        (z = ""),
                        k ===
                          `
` && B.push(""))
                      : I.getTextWidth(B[B.length - 1] + z, _) > _.width &&
                        (B[B.length - 1].length && B.push(""),
                        I.getTextWidth(B[B.length - 1] + z, _) > _.width &&
                          (1 === z.length
                            ? ((B[B.length - 1] += z), (z = ""))
                            : ((B[B.length - 1] += z.slice(0, -1)),
                              (z = z[z.length - 1]),
                              B.push(""))));
                return (B[B.length - 1] += z), B;
              })(
                _,
                I,
                2 === G ? q.toUpperCase() : 3 === G ? q.toLowerCase() : q
              ),
              {
                shapes: Q,
                charWidths: $,
                charCoords: et,
              } = I.generateShapes(X, _),
              er = ("number" == typeof R ? R : 1) * 0.5,
              es = ("number" == typeof B ? B : 1) * 0.5,
              ea = Q.map((_) => new xT().fromShape(_, !0));
            this.vectorShapes = ea;
            let en = ea.map((_) =>
                xQ.create({
                  shape: _,
                  parameters: {
                    depth: z,
                    extrudeBevelSegments: V,
                    extrudeBevelSize: k,
                    windingRule: z <= 0 ? bH.NONZERO : bH.ODD,
                    subdivisions: this.isLowResolution && z > 0 ? 1 : 12,
                  },
                })
              ),
              eo = en.length ? $s(en) : OI();
            eo.translate(-er, es, 0),
              this.dispose(),
              (this.wrappedText = X),
              (this.charCoords = et),
              (this.charWidths = $),
              this.deleteAttribute("extrudeNormal"),
              Object.entries(eo.attributes).forEach(([_, I]) => {
                this.setAttribute(_, I);
              }),
              this.setIndex(eo.index),
              this.computeBoundingSphere();
          }
          clone() {
            let _ = _n(new ai(), bX.prototype);
            return _.copy(this), console.log("CloneGeometry", this, _), _;
          }
          copy(_) {
            return (
              Object.entries(_.attributes).forEach(([_, I]) => {
                this.setAttribute(_, I);
              }),
              this.setIndex(_.index),
              (this.userData = {
                parameters: { ..._.userData.parameters },
                type: "TextGeometry",
              }),
              this
            );
          }
          async setText(_) {
            this.font && (await this.font.loadingPromise),
              await this.update({ ...this.userData.parameters, text: _ });
          }
          get text() {
            return this.userData.parameters.text ?? "";
          }
        },
        bQ = new Promise((_) => {
          bq = _;
        }),
        bZ = !1,
        bK = ["font"];
      function Va(_, I, R, B) {
        let z, k, V, j;
        for (let R of ("PathGeometry" === _.type
          ? ((k = JSON.parse(JSON.stringify(_))), (V = [[], ["extrusion"]]))
          : ((k = { ..._ }), (V = [[]])),
        V)) {
          let _ = k;
          for (let I of R) _ = _[I];
          for (z in _) {
            let k = _[z];
            v1(k) &&
              !bK.includes(z) &&
              ((_[z] = I.getVariable(k, [B.uuid, "geometry", ...R, z])),
              v1(_[z]) && (_[z] = 1));
          }
        }
        let G = { parameters: k, type: k.type };
        if ("PathGeometry" === k.type) G.path = k.path;
        else if ("VectorGeometry" === k.type) {
          let _ = xT.createFromState(k.shape, k.width, k.height);
          G.shape = _;
        } else if ("NonParametricGeometry" === k.type)
          k.data.groups &&
            k.data.groups?.forEach(
              (_) => (_.materialIndex = Math.max(_.materialIndex ?? 0, 0))
            ),
            (G.geometry = new lv().parse(k));
        else if ("SubdivGeometry" === k.type) {
          let I = new b8(k, R);
          return (I.data = _), I;
        } else {
          if ("TextGeometry" === k.type) return new bX(k, I);
          if ("UIGeometry" === k.type)
            return bv.create({
              parameters: {
                width: k.width,
                height: k.height,
                cornerRadius: k.cornerRadius,
                cornerType: k.cornerType,
              },
            });
        }
        try {
          j = kA(G);
        } catch (_) {
          console.error(_);
        }
        if (!j) {
          let _ = xT.createFromState(gH.defaultData(), 100, 100);
          (G.shape = _), (j = kA(G));
        }
        return j;
      }
      var bJ = new sa();
      function Mm(_, I, R, B) {
        let z = _.position.array,
          k = _.normal.array,
          V = bJ.makeScale(I, R, B).invert().elements,
          j,
          G,
          q;
        for (var X = 0, Q = z.length; X < Q; X += 3)
          (z[X] *= I),
            (z[X + 1] *= R),
            (z[X + 2] *= B),
            (j = k[X]),
            (G = k[X + 1]),
            (q = k[X + 2]),
            (k[X] = V[0] * j + V[4] * G + V[8] * q),
            (k[X + 1] = V[1] * j + V[5] * G + V[9] * q),
            (k[X + 2] = V[2] * j + V[6] * G + V[10] * q);
        (_.position.needsUpdate = !0), (_.normal.needsUpdate = !0);
      }
      var b$,
        b0,
        b1 = new rU(),
        b3 = new rF();
      bQ.then((_) => {
        b0 = _;
      });
      var b4 = new Float32Array([
          10, 10, 0, -10, 10, 0, -10, -10, 0, 10, -10, 0,
        ]),
        b5 = new Uint32Array([0, 1, 2, 3]),
        b6 = new Uint8Array([4]),
        b8 = class extends ai {
          constructor(_, I) {
            super(),
              (this.data = _),
              (this.flatShading = I),
              (this.subdivPointer = 0),
              this.rebuild(),
              this.freeSubdivPointer();
          }
          mutateDirectlyScaleBaked(_, I) {
            this.freeSubdivPointer();
            let R = this.data.scaleBaked,
              B = mp.div(I, R);
            this.subdividedGeometry &&
              Mm(this.subdividedGeometry.attributes, ...B),
              this.originalGeometry &&
                Mm(this.originalGeometry.attributes, ...B),
              (this.data = _);
            let z = this.userData.parameters;
            (this.userData.parameters = {
              width: z.width * B[0],
              height: z.height * B[1],
              depth: z.depth * B[2],
            }),
              this.originalGeometry.boundingSphere.center.multiply(
                b3.fromArray(B)
              );
            let k = b3.set(z.width, z.height, z.depth).length();
            this.originalGeometry.boundingSphere.radius = k / 2;
          }
          ensureSubdivPointer() {
            return (
              0 === this.subdivPointer && this.rebuild(), this.subdivPointer
            );
          }
          rebuild() {
            let _, I, R;
            try {
              ({
                originalGeometry: _,
                subdividedGeometry: I,
                subdivPointer: R,
              } = b8.build(this.data, void 0, !this.flatShading, void 0));
            } catch {
              (_ = new aS(100, 100, 100)), (R = 0);
            }
            (this.subdivPointer = R),
              (this.originalGeometry = _),
              (this.subdividedGeometry = I ?? void 0),
              Object.assign(
                this,
                this.subdividedGeometry ?? this.originalGeometry
              ),
              this.calcBoundingBox();
          }
          freeSubdivPointer() {
            this.subdivPointer &&
              (b8.freeSubdivPointer(this.subdivPointer),
              (this.subdivPointer = 0));
          }
          dispose() {
            super.dispose(), this.freeSubdivPointer();
          }
          calcBoundingBox() {
            let _ = this.originalGeometry;
            null === _.boundingSphere &&
              ((_.boundingSphere = new r5()),
              this.subdividedGeometry &&
                (this.subdividedGeometry.boundingSphere = _.boundingSphere));
            let I = _.attributes.position,
              R = _.boundingSphere.center;
            b1.setFromBufferAttribute(I),
              b1.getCenter(R),
              (_.boundingSphere.radius = R.distanceTo(b1.max)),
              isNaN(_.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                ),
              b1.getSize(b3);
            let B = { width: b3.x, height: b3.y, depth: b3.z };
            return (this.userData.parameters = B), B;
          }
          static build(_, I, R, B) {
            let z,
              k,
              V,
              j = _?.phongAngle ?? 35;
            !1 === R && (j = -1),
              I && (b0.free_bvh(I), b0.free_subdivision_surface(I));
            try {
              z = b8.allocate(_, B);
            } catch (I) {
              console.error(I, _),
                (z = b8.allocate(
                  { positionWASM: b4, indexWASM: b5, verticesPerFaceWASM: b6 },
                  B
                ));
            }
            if (
              (b0.set_destination_refinement_level(z, 0),
              (k = b8.buildLevel(z, !0, j)),
              _.subdivisions > 0)
            )
              try {
                b0.set_destination_refinement_level(z, _.subdivisions),
                  (V = b8.buildLevel(z, !1, j));
              } catch {
                try {
                  b0.set_destination_refinement_level(z, _.subdivisions - 1),
                    (V = b8.buildLevel(z, !1, j));
                } catch {
                  V = null;
                }
              }
            else V = null;
            return {
              subdivPointer: z,
              originalGeometry: k,
              subdividedGeometry: V,
            };
          }
          static primitiveToQuads(_, I, R) {
            let B, z, k, V, j;
            _.widthSegments > 16 && (_.widthSegments = 16),
              _.heightSegments > 16 && (_.heightSegments = 16),
              _.depthSegments > 16 && (_.depthSegments = 16),
              _.radialSegments > 16 && (_.radialSegments = 16),
              "DodecahedronGeometry" === _.type && (_.detail = 0);
            let G =
                void 0 !== _.shape || void 0 !== _.path
                  ? I.geometry
                  : Va(_, R, !1),
              q;
            if (
              ((q =
                "TorusGeometry" === _.type && _.arc === 2 * Math.PI
                  ? G.getClosedTorusIndicesForBooleanOrSubdiv()
                  : G.getIndex()),
              ({ positions: B, triIndices: V } = Xc(
                G.getAttribute("position"),
                q
              )),
              "CylinderGeometry" === _.type &&
                0 === _.cornerRadius &&
                0 === _.hollow &&
                !1 === _.openEnded)
            ) {
              let I = _.radialSegments * _.heightSegments * 6,
                R = I + 3 * _.radialSegments;
              j = [I, R];
            }
            return (
              ({ indices: z, verticesPerFace: k } = GA(B, V, G, j)),
              { positions: B, indices: z, verticesPerFace: k }
            );
          }
          static allocate(_, I) {
            let R,
              B,
              z,
              k,
              V = [],
              j = [];
            _.positionWASM && _.positionWASM.length > 0
              ? ((B = _.positionWASM),
                (z = _.indexWASM),
                (k = _.verticesPerFaceWASM))
              : ((B = b4), (z = b5), (k = b6));
            let G = B.length,
              q = z.length,
              X = k.length,
              Q = B.length + V.length + j.length,
              $ = z.length + k.length,
              et =
                Q * Float32Array.BYTES_PER_ELEMENT +
                $ * Uint32Array.BYTES_PER_ELEMENT,
              er = Q * Float32Array.BYTES_PER_ELEMENT,
              es = (Uint32Array.BYTES_PER_ELEMENT, b0._malloc(et)),
              ea = new Float32Array(b0.HEAPF32.buffer, es, Q),
              en = new Uint32Array(b0.HEAPU32.buffer, es + er, $);
            ea.set(B, 0),
              ea.set(V, B.length),
              ea.set(j, B.length + V.length),
              en.set(z, 0),
              en.set(k, z.length),
              _?.scaleBaked?.some((_) => 1 !== _) &&
                (R = new sa().makeScale(..._.scaleBaked)),
              I && (R ? R.premultiply(I) : (R = I));
            let eo = R
              ? b0.alloc_subdivision_surface2(
                  es,
                  G,
                  es + er,
                  q,
                  es + er + z.length * Uint32Array.BYTES_PER_ELEMENT,
                  X,
                  R.elements
                )
              : b0.alloc_subdivision_surface(
                  es,
                  G,
                  es + er,
                  q,
                  es + er + z.length * Uint32Array.BYTES_PER_ELEMENT,
                  X
                );
            return b0._free(es), eo;
          }
          static buildLevel(_, I, R, B, z) {
            let k = z
                ? b0.get_mesh_data2(
                    _,
                    I ? b0.Level.CONTROL : b0.Level.REFINED,
                    R,
                    z.elements
                  )
                : b0.get_mesh_data(
                    _,
                    I ? b0.Level.CONTROL : b0.Level.REFINED,
                    R
                  ),
              V = b0.HEAPU32.subarray(k >> 2, (k >> 2) + 8),
              j = V.subarray(4, 8),
              G = 0,
              q = b0.HEAPU32[V[G] >> 2],
              X = b0.HEAPF32.subarray(q >> 2, (q >> 2) + j[G]);
            G++;
            let Q = b0.HEAPU32[V[G] >> 2],
              $ = b0.HEAPF32.subarray(Q >> 2, (Q >> 2) + j[G]);
            G++;
            let et = b0.HEAPU32[V[G] >> 2],
              er = b0.HEAPU32.subarray(et >> 2, (et >> 2) + j[G]);
            G++;
            let es = b0.HEAPU32[V[G] >> 2],
              ea = b0.HEAPU32.subarray(es >> 2, (es >> 2) + j[G]);
            if ((G++, void 0 === B)) {
              let _ = new ai();
              if (
                (_.setIndex(new s3(ea, 1)),
                _.setAttribute("position", new s4(X, 3)),
                _.setAttribute("normal", new s4($, 3)),
                I)
              ) {
                _.setAttribute("faceMap", new s3(er, 1));
                let I = new Float32Array(($.length / 3) * 4).fill(0);
                _.setAttribute("color", new s0(I, 4));
              }
              return (
                b0.free_mesh_data(k), (_.userData.type = "SubdivGeometry"), _
              );
            }
            B.getAttribute("position").copyArray(X),
              B.getAttribute("normal").copyArray($),
              (B.attributes.position.needsUpdate = !0),
              (B.attributes.normal.needsUpdate = !0),
              b0.free_mesh_data(k);
          }
          static freeSubdivPointer(_) {
            b0.free_bvh(_), b0.free_subdivision_surface(_);
          }
          static buildControlCageWireframe(_, I, R) {
            let B = b0.get_wireframe_data_for_base_level(_),
              z = b0.HEAPU32.subarray(B >> 2, (B >> 2) + 4),
              k = z.subarray(2, 4),
              V = 0,
              j = b0.HEAPU32[z[V] >> 2],
              G = b0.HEAPF32.subarray(j >> 2, (j >> 2) + k[V]);
            V++;
            let q = b0.HEAPU32[z[V] >> 2],
              X = b0.HEAPU32.subarray(q >> 2, (q >> 2) + k[V]);
            if (void 0 === I) {
              let _ = new ai();
              _.setAttribute("position", new s4(G, 3));
              let I = new Float32Array(G.length);
              for (let _ = 0, B = G.length; _ < B; )
                (I[_++] = R.r), (I[_++] = R.g), (I[_++] = R.b);
              return (
                _.setAttribute("color", new s0(I, 3)),
                _.setIndex(new s3(X, 1)),
                b0.free_wireframe_data_for_base_level(B),
                _
              );
            }
            I.getAttribute("position").copyArray(G),
              (I.attributes.position.needsUpdate = !0),
              b0.free_wireframe_data_for_base_level(B);
          }
          static updateCollabMesh(_, I, R) {
            let B = 0 === I;
            B || b0.set_destination_refinement_level(_, I);
            let z = R
                ? b0.get_topological_data2(
                    _,
                    B ? b0.Level.CONTROL : b0.Level.REFINED,
                    R.elements
                  )
                : b0.get_topological_data(
                    _,
                    B ? b0.Level.CONTROL : b0.Level.REFINED
                  ),
              k = b0.HEAPU32.subarray(z >> 2, (z >> 2) + 6),
              V = k.subarray(3, 6),
              j = 0,
              G = b0.HEAPU32[k[j] >> 2],
              q = new Float32Array(
                b0.HEAPF32.subarray(G >> 2, (G >> 2) + V[j])
              );
            j++;
            let X = b0.HEAPU32[k[j] >> 2],
              Q = new Uint32Array(b0.HEAPU32.subarray(X >> 2, (X >> 2) + V[j]));
            j++;
            let $ = b0.HEAPU32[k[j] >> 2],
              et = new Uint8Array(b0.HEAPU32.subarray($ >> 2, ($ >> 2) + V[j]));
            return (
              b0.free_topological_data(z),
              { positions: q, indices: Q, verticesPerFace: et }
            );
          }
        },
        b9 = ["getX", "getY", "getZ"];
      function Xc(_, I) {
        let R = {},
          B = I ? I.count : _.count,
          z = 0,
          k = [],
          V = [];
        for (let j = 0; j < B; j++) {
          let B = I ? I.getX(j) : j,
            G = "";
          for (let I = 0; I < 3; I++) G += `${~~(1e4 * _[b9[I]](B))},`;
          if (G in R) k.push(R[G]);
          else {
            for (let I = 0; I < 3; I++) V.push(_[b9[I]](B));
            (R[G] = z), k.push(z), z++;
          }
        }
        let j = [];
        for (let _ = 0; _ < k.length; _ += 3)
          k[_] === k[_ + 1] ||
            k[_] === k[_ + 2] ||
            k[_ + 1] === k[_ + 2] ||
            j.push(k[_], k[_ + 1], k[_ + 2]);
        return { positions: V, triIndices: j };
      }
      var wt = new rF(),
        wi = new rF(),
        wr = new rF(),
        ws = new rF();
      function GA(_, I, R, B) {
        let z = [],
          k = [];
        if (
          void 0 !== R.userData.shape &&
          0 === R.userData.parameters.depth &&
          0 === R.userData.shape.shapeHoles.length
        ) {
          let I = R.userData.shape.extractShapePointsToFlatArray([]),
            B = R.userData.parameters.spikes;
          if (
            "EllipseGeometry" === R.userData.type &&
            B <= 24 &&
            B % 4 == 0 &&
            R.userData.parameters.angle >= 360
          ) {
            let _ = I.length / 2 / B;
            I = I.filter((I, R) => Math.floor(R / 2) % _ == 0);
          }
          let V = 0;
          for (let _ = 0; _ < I.length; _ += 2)
            V +=
              (I[_] - I[(0 === _ ? I.length : _) - 2]) *
              (I[_ + 1] + I[(0 === _ ? I.length : _) - 1]);
          _.length = 0;
          let j = 0;
          if (V < 0)
            for (let R = 0; R < I.length; R += 2)
              _.push(I[R], I[R + 1], 0), z.push(j++);
          else
            for (let R = I.length - 2; R >= 0; R -= 2)
              _.push(I[R], I[R + 1], 0), z.push(j++);
          return k.push(j), { indices: z, verticesPerFace: k };
        }
        let V = new Float32Array([R.userData.parameters.depth])[0],
          j = 0;
        for (; j < I.length; ) {
          if (R.useNgonForTopBottomFaceDuringBake) {
            let R = 0;
            if (
              ((_[3 * I[j] + 2] === V || 0 === _[3 * I[j] + 2]) && R++,
              (_[3 * I[j + 1] + 2] === V || 0 === _[3 * I[j + 1] + 2]) && R++,
              (_[3 * I[j + 2] + 2] === V || 0 === _[3 * I[j + 2] + 2]) && R++,
              3 === R)
            )
              break;
          }
          (I[j + 1] === I[j + 3] && I[j + 2] === I[j + 5]) ||
          (I[j + 0] === I[j + 3] && I[j + 2] === I[j + 4])
            ? (wt.set(_[3 * I[j]], _[3 * I[j] + 1], _[3 * I[j] + 2]),
              wi.set(_[3 * I[j + 1]], _[3 * I[j + 1] + 1], _[3 * I[j + 1] + 2]),
              wr.set(_[3 * I[j + 4]], _[3 * I[j + 4] + 1], _[3 * I[j + 4] + 2]),
              ws.set(_[3 * I[j + 5]], _[3 * I[j + 5] + 1], _[3 * I[j + 5] + 2]),
              wi.sub(wt).normalize(),
              wr.sub(wt).normalize(),
              ws.sub(wt).normalize(),
              Math.abs(wi.cross(wr).dot(ws)) > 0.005 ||
              (B && B.some((_, I) => I % 2 != 1 && j >= B[I] && j < B[I + 1]))
                ? (z.push(I[j], I[j + 1], I[j + 2]), k.push(3), (j += 3))
                : (z.push(I[j], I[j + 1], I[j + 4], I[j + 5]),
                  k.push(4),
                  (j += 6)))
            : (z.push(I[j], I[j + 1], I[j + 2]), k.push(3), (j += 3));
        }
        if (R.useNgonForTopBottomFaceDuringBake) {
          let I = [],
            B = [],
            j = 0;
          for (let R = 0, z = 0; R < _.length; R += 3, z++)
            0 === _[R + 2] && (I.push(z), j++), _[R + 2] === V && B.push(z);
          if (0 === R.userData.parameters.extrudeBevelSize) {
            let _ = B[0];
            (B[0] = B[1]), (B[1] = _);
          }
          I.reverse(), z.push(...I, ...B), k.push(j, j);
        }
        return { indices: z, verticesPerFace: k };
      }
      var wa = {};
      function GI(_) {
        let I = _.length,
          R = I * Uint32Array.BYTES_PER_ELEMENT,
          B = I * Float32Array.BYTES_PER_ELEMENT,
          z = Number.isInteger(_[0]) ? R : B,
          k = _Y._malloc(z);
        return (
          (Number.isInteger(_[0])
            ? new Uint32Array(_Y.HEAPU32.buffer, k, I)
            : new Float32Array(_Y.HEAPF32.buffer, k, I)
          ).set(_, 0),
          k
        );
      }
      function jI(_) {
        switch (_) {
          case 0:
            return _Y.OP.UNION;
          case 1:
            return _Y.OP.INTERSECTION;
          case 2:
            return _Y.OP.A_MINUS_B;
          case 3:
            return _Y.OP.B_MINUS_A;
          case 4:
            return _Y.OP.SYMMETRIC_DIFFERENCE;
          case 5:
            return _Y.OP.ALL;
          default:
            throw Error("Unknown boolean operation " + _);
        }
      }
      function J7(_, I) {
        void 0 === _X && (_X = _Y.init_csg());
        let R = GI(_),
          B = _Y.csg_calc_topological(_X, R, _.length, jI(I));
        _Y._free(R);
        let z = _Y.HEAPU32.subarray(B >> 2, (B >> 2) + 6),
          k = z.subarray(3, 6),
          V = 0,
          j = _Y.HEAPU32[z[V] >> 2],
          G = new Float32Array(_Y.HEAPF32.subarray(j >> 2, (j >> 2) + k[V]));
        V++;
        let q = _Y.HEAPU32[z[V] >> 2],
          X = new Uint32Array(_Y.HEAPU32.subarray(q >> 2, (q >> 2) + k[V]));
        V++;
        let Q = _Y.HEAPU32[z[V] >> 2],
          $ = new Uint8Array(_Y.HEAPU32.subarray(Q >> 2, (Q >> 2) + k[V]));
        return (
          _Y.free_mesh_data(B), { positions: G, indices: X, verticesPerFace: $ }
        );
      }
      function $7(_, I, R, B) {
        void 0 === _X && (_X = _Y.init_csg());
        let z = GI(_),
          k = _Y.csg_calc(_X, z, _.length, B, jI(I));
        _Y._free(z);
        let V = _Y.HEAPU32.subarray(k >> 2, (k >> 2) + 5),
          j = V.subarray(2, 5),
          G = 0,
          q = _Y.HEAPU32[V[G] >> 2],
          X = _Y.HEAPF32.subarray(q >> 2, (q >> 2) + j[G]);
        G++;
        let Q = _Y.HEAPU32[V[G] >> 2],
          $ = _Y.HEAPF32.subarray(Q >> 2, (Q >> 2) + j[G]),
          et = j[++G];
        R.setAttribute("position", new s4(X, 3)),
          R.setAttribute("normal", new s4($, 3));
        let er = _Y.HEAPF32.subarray((k >> 2) + 5, (k >> 2) + 5 + 6);
        return (
          null === R.boundingSphere && (R.boundingSphere = new r5()),
          R.boundingSphere.center.set(er[0], er[1], er[2]),
          (R.boundingSphere.radius =
            (er[3] ** 2 + er[4] ** 2 + er[5] ** 2) ** 0.5),
          (R.userData.parameters = {
            width: 2 * er[3],
            height: 2 * er[4],
            depth: 2 * er[5],
          }),
          _Y.free_mesh_data(k),
          et
        );
      }
      function eY(_, I, R) {
        let B, z, k;
        if (void 0 === _Y) return -1;
        if (I && void 0 !== _.userData.positions) {
          let I = _.userData;
          (k = I.verticesPerFace.length),
            (B = I.positions),
            (z = Array(I.verticesPerFace.reduce((_, I) => _ + I, 0) + k));
          for (let _ = 0, R = 0, B = 0; _ < I.verticesPerFace.length; _++) {
            z[B++] = I.verticesPerFace[_];
            for (let k = 0; k < I.verticesPerFace[_]; k++)
              z[B++] = I.indices[R++];
          }
        } else
          ({
            positions: B,
            faceIndices: z,
            nFaces: k,
          } = (function (_, I, R) {
            let B, z;
            z =
              "TorusGeometry" === _.userData.parameters.type &&
              _.userData.parameters.arc === 2 * Math.PI
                ? _.getClosedTorusIndicesForBooleanOrSubdiv()
                : _.getIndex();
            let { positions: k, triIndices: V } = Xc(
                _.getAttribute("position"),
                z
              ),
              j;
            if (I && R) {
              let { indices: I, verticesPerFace: R } = GA(k, V, _);
              (j = R.length), (B = []);
              for (let _ = 0, z = 0; _ < j; _++) {
                B.push(R[_]);
                for (let k = 0; k < R[_]; k++) B.push(I[z++]);
              }
            } else {
              let _ = V.length;
              (B = Array(_ + _ / 3)), (j = 0);
              for (let _ = 0, I = 0; I < B.length; )
                (B[I++] = 3),
                  j++,
                  (B[I++] = V[_++]),
                  (B[I++] = V[_++]),
                  (B[I++] = V[_++]);
            }
            return { positions: k, faceIndices: B, nFaces: j };
          })(_, I, R));
        let V = B.length,
          j = z.length,
          G = B.length,
          q = z.length,
          X =
            G * Float32Array.BYTES_PER_ELEMENT +
            q * Uint32Array.BYTES_PER_ELEMENT,
          Q = G * Float32Array.BYTES_PER_ELEMENT,
          $ = (Uint32Array.BYTES_PER_ELEMENT, _Y._malloc(X)),
          et = new Float32Array(_Y.HEAPF32.buffer, $, G),
          er = new Uint32Array(_Y.HEAPU32.buffer, $ + Q, q);
        et.set(B, 0), er.set(z, 0);
        let es = _Y.get_csg_mesh($, V, $ + Q, j, k);
        return _Y._free($), es;
      }
      function tY(_) {
        return _Y.has_open_edges(_);
      }
      function rY(_, I) {
        _Y.transform_csg_mesh(_, I.elements);
      }
      function iY(_) {
        _Y.free_csg_mesh(_);
      }
      ((_, I) => {
        for (var R in I) iT(_, R, { get: I[R], enumerable: !0 });
      })(wa, {
        calcBoolean: () => $7,
        calcBooleanTopological: () => J7,
        freeMeshSet: () => iY,
        getMeshSet: () => eY,
        hasOpenEdges: () => tY,
        transformMeshSet: () => rY,
      }),
        new Promise((_) => {
          _G = _;
        }).then((_) => (_Y = _));
      var wn = {
          ConeGeometry: y6,
          CubeGeometry: y8,
          CylinderGeometry: y4,
          DodecahedronGeometry: xi,
          EllipseGeometry: xK,
          HelixGeometry: xJ,
          IcosahedronGeometry: x1,
          LatheGeometry: x4,
          NonParametricGeometry: bc,
          PolygonGeometry: bd,
          PyramidGeometry: bu,
          RectangleGeometry: bv,
          SphereGeometry: by,
          PlaneGeometry: bx,
          BackdropGeometry: bb,
          StarGeometry: b_,
          TextFrameGeometry: bS,
          TorusGeometry: bM,
          TorusKnotGeometry: bC,
          TriangleGeometry: bT,
          PathGeometry: bN,
          VectorGeometry: xQ,
        },
        kA = (_) => wn[_.type].create(_);
      function jd(_) {
        return null !== _ && "booleanOp" in _;
      }
      var wl = class extends Cd(aw) {
          constructor() {
            super(...arguments),
              (this.booleanMeshSetAddress = -1),
              (this.booleanWasTransformed = !1),
              (this.booleanMatrixInvOld = new sa());
          }
          updateVisible(_) {
            super.updateVisible(_),
              (this.visible = !jd(this.parent) && this.visible),
              jd(this.parent) && this.parent.invalidateDownstreamBooleanData();
          }
          freeBooleanPointer() {
            -1 !== this.booleanMeshSetAddress &&
              (wa.freeMeshSet(this.booleanMeshSetAddress),
              (this.booleanMeshSetAddress = -1));
          }
          invalidateDownstreamBooleanData(_ = !1) {
            return (
              _ ? (this.booleanWasTransformed = !0) : this.freeBooleanPointer(),
              jd(this.parent)
                ? this.parent.invalidateDownstreamBooleanData()
                : this
            );
          }
          invalidateUpstreamBooleanData() {
            for (let _ of (this.freeBooleanPointer(), this.children))
              _ instanceof wl &&
                (_.freeBooleanPointer(),
                jd(_) && _.invalidateUpstreamBooleanData());
          }
          updateTransformState(_, I) {
            let R = super.updateTransformState(_, I);
            return (
              R && jd(this.parent) && this.invalidateDownstreamBooleanData(!0),
              R
            );
          }
          onVariableUpdate(_ = !1) {
            super.onVariableUpdate(_),
              jd(this.parent) && this.invalidateDownstreamBooleanData(!0);
          }
        },
        wc = new rU();
      function Cm(_, I = 0, R = _.count, B, z) {
        let k = 1 / 0,
          V = 1 / 0,
          j = 1 / 0,
          G = -1 / 0,
          q = -1 / 0,
          X = -1 / 0;
        for (let B = I; B < R; B++) {
          let I = _.getX(B),
            R = _.getY(B),
            z = _.getZ(B);
          I < k && (k = I),
            R < V && (V = R),
            z < j && (j = z),
            I > G && (G = I),
            R > q && (q = R),
            z > X && (X = z);
        }
        wc.min.set(k, V, j),
          wc.max.set(G, q, X),
          wc.getCenter(B),
          wc.getSize(z).multiplyScalar(0.5);
      }
      var wd = new ai(),
        wu = new sK(),
        wp = class extends wl {
          constructor(_, I) {
            super(wd, wu), this.super_Entity(_, I);
          }
          updateState(_, I) {
            this.updateState_Entity(_, I);
          }
          updateEntityBoxSize(_, I) {
            let R = this.geometry.getAttribute("position");
            void 0 !== R
              ? Cm(
                  R,
                  this.geometry.drawRange.start,
                  this.geometry.drawRange.count < 1 / 0
                    ? this.geometry.drawRange.count
                    : R.count,
                  _,
                  I
                )
              : super.updateEntityBoxSize(_, I);
          }
        },
        wf = class {
          constructor(_) {
            (_ = _ ?? {}),
              (this.name = _.name),
              (this.type = _.type),
              (this.node = _.node),
              (this.size = _.size),
              (this.needsUpdate = _.needsUpdate);
          }
          get value() {
            return this.node.value;
          }
          set value(_) {
            this.node.value = _;
          }
        },
        wm = class {
          constructor(_) {
            (this.hashProperties = void 0),
              (this.isNode = !0),
              (this.shortcuts = {}),
              (this.uuid = rr.generateUUID()),
              (this.type = _),
              (this.name = "");
          }
          analyze(_, I) {
            (I = I ?? {}),
              (_.analyzing = !0),
              this.build(_.addFlow(I.slot, I.cache, I.context), "v4"),
              _.clearVertexNodeCode(),
              _.clearFragmentNodeCode(),
              _.removeFlow(),
              (_.analyzing = !1);
          }
          analyzeAndFlow(_, I, R) {
            return (R = R ?? {}), this.analyze(_, R), this.flow(_, I, R);
          }
          flow(_, I, R) {
            (R = R ?? {}), _.addFlow(R.slot, R.cache, R.context);
            let B = {
              result: this.build(_, I),
              code: _.clearNodeCode(),
              extra: _.context.extra,
            };
            return _.removeFlow(), B;
          }
          build(_, I, R) {
            I = I ?? this.getType(_, I);
            let B = _.getNodeData(R ?? this);
            return (
              _.analyzing && this.appendDepsNode(_, B, I),
              -1 === _.nodes.indexOf(this) && _.nodes.push(this),
              void 0 !== this.updateFrame &&
                -1 === _.updaters.indexOf(this) &&
                _.updaters.push(this),
              this.generate(_, I, R)
            );
          }
          updateFrame(_) {}
          generateReadonly(_, I, R, B, z, k) {
            return "";
          }
          generate(_, I, R, B, z) {
            return "";
          }
          parse(_, I, R, B) {}
          appendDepsNode(_, I, R) {
            I.deps = (I.deps || 0) + 1;
            let B = _.getTypeLength(R);
            (B > (I.outputMax || 0) || this.getType(_, R)) &&
              ((I.outputMax = B), (I.output = R));
          }
          setName(_) {
            this.name = _;
          }
          getName() {
            return this.name;
          }
          getType(_, I) {
            return "sampler2D" === I || "samplerCube" === I ? I : this.type;
          }
          getHash() {
            let _ = "{",
              I,
              R;
            for (I in this)
              (R = this[I]) instanceof wm &&
                (_ += '"' + I + '":' + R.getHash() + ",");
            if (this.hashProperties)
              for (let B = 0; B < this.hashProperties.length; B++)
                (R = this[(I = this.hashProperties[B])]),
                  (_ += '"' + I + '":"' + String(R) + '",');
            return _ + '"id":"' + this.uuid + '"}';
          }
        },
        wg = new (class {
          constructor() {
            (this.nodes = {}), (this.keywords = {});
          }
          add(_) {
            this.nodes[_.name] = _;
          }
          addKeyword(_, I, R) {
            (R = void 0 === R || R),
              (this.keywords[_] = { callback: I, cache: R });
          }
          remove(_) {
            delete this.nodes[_.name];
          }
          removeKeyword(_) {
            delete this.keywords[_];
          }
          get(_) {
            return this.nodes[_];
          }
          getKeyword(_, I) {
            return this.keywords[_].callback(I);
          }
          getKeywordData(_) {
            return this.keywords[_];
          }
          contains(_) {
            return void 0 !== this.nodes[_];
          }
          containsKeyword(_) {
            return void 0 !== this.keywords[_];
          }
        })(),
        wy = class extends wm {
          constructor(_, I) {
            super(_),
              (this.scope = ""),
              (I = I ?? {}),
              (this.shared = void 0 === I.shared || I.shared),
              (this.unique = void 0 !== I.unique && I.unique);
          }
          build(_, I, R, B) {
            if (((I = I ?? this.getType(_)), this.getShared(_, I))) {
              let z = this.getUnique(_, I);
              z && void 0 === this.uuid && (this.uuid = rr.generateUUID()),
                (R = _.getUUID(R ?? this.getUUID(), !z));
              let k = _.getNodeData(R),
                V = k.output || this.getType(_);
              if (_.analyzing)
                return (k.deps || 0) > 0 || this.getLabel()
                  ? (this.appendDepsNode(_, k, I), this.generate(_, I, R))
                  : super.build(_, I, R);
              if (z) return (k.name = k.name || super.build(_, I, R)), k.name;
              if (
                !this.getLabel() &&
                (!this.getShared(_, V) || _.context.ignoreCache || 1 === k.deps)
              )
                return super.build(_, I, R);
              R = this.getUUID(!1);
              let j = this.getTemp(_, R);
              if (j) return _.format(j, V, I);
              {
                j = super.generate(_, I, R, k.output, B);
                let z = this.generate(_, V, R);
                return _.addNodeCode(j + " = " + z + ";"), _.format(j, V, I);
              }
            }
            return super.build(_, I, R);
          }
          getShared(_, I) {
            return "sampler2D" !== I && "samplerCube" !== I && this.shared;
          }
          getUnique(_, I) {
            return this.unique;
          }
          setLabel(_) {
            return (this.label = _), this;
          }
          getLabel() {
            return this.label;
          }
          getUUID(_) {
            let I = this.uuid;
            return (
              "string" == typeof this.scope && (I = this.scope + "-" + I), I
            );
          }
          getTemp(_, I) {
            I = I || this.uuid;
            let R = _.getVars()[I];
            return R ? R.name : void 0;
          }
          generate(_, I, R, B, z) {
            return (
              this.getShared(_, I) || console.error("TempNode is not shared"),
              (R = R ?? this.uuid),
              _.getTempVar(R, B ?? this.getType(_), z, this.getLabel()).name
            );
          }
        },
        wx = class extends wy {
          constructor(_, I) {
            ((I = I ?? {}).shared = void 0 !== I.shared && I.shared),
              super(_, I),
              (this.readonly = !1);
          }
          setReadonly(_) {
            return (
              (this.readonly = _),
              (this.hashProperties = this.readonly ? ["value"] : void 0),
              this
            );
          }
          getReadonly() {
            return this.readonly;
          }
          generate(_, I, R, B, z, k) {
            (R = _.getUUID(R ?? this.getUUID())), (B = B ?? this.getType(_));
            let V = _.getNodeData(R);
            return this.getReadonly() && void 0 !== this.generateReadonly
              ? this.generateReadonly(_, I, R, B, z, k)
              : _.isShader("vertex")
              ? (V.vertex ||
                  (V.vertex = _.createVertexUniform(
                    B,
                    this,
                    z,
                    k,
                    this.getLabel()
                  )),
                _.format(V.vertex.name, B, I))
              : (V.fragment ||
                  (V.fragment = _.createFragmentUniform(
                    B,
                    this,
                    z,
                    k,
                    this.getLabel()
                  )),
                _.format(V.fragment.name, B, I));
          }
        },
        wb = class extends wx {
          constructor(_ = 0, I) {
            super("v2"),
              (this.nodeType = "Vector2"),
              (this.value = _ instanceof rs ? _ : new rs(_, I));
          }
          get x() {
            return this.value.x;
          }
          set x(_) {
            this.value.x = _;
          }
          get y() {
            return this.value.y;
          }
          set y(_) {
            this.value.y = _;
          }
          generateReadonly(_, I, R, B, z, k) {
            return _.format(
              "vec2(" + this.value.x + ", " + this.value.y + ")",
              B,
              I
            );
          }
        },
        wS = class extends wx {
          constructor(_ = 0, I, R) {
            super("v3"),
              (this.nodeType = "Vector3"),
              (this.value = _ instanceof rF ? _ : new rF(_, I, R));
          }
          get x() {
            return this.value.x;
          }
          set x(_) {
            this.value.x = _;
          }
          get y() {
            return this.value.y;
          }
          set y(_) {
            this.value.y = _;
          }
          get z() {
            return this.value.z;
          }
          set z(_) {
            this.value.z = _;
          }
          generateReadonly(_, I, R, B, z, k) {
            return _.format(
              "vec3(" +
                this.value.x +
                ", " +
                this.value.y +
                ", " +
                this.value.z +
                ")",
              B,
              I
            );
          }
        },
        wA = class extends ry {
          constructor(_, I, R, B) {
            super(_, I, R), (this.isColorA = !0), (this.a = B);
          }
          setRGBA(_, I, R, B) {
            super.setRGB(_, I, R), (this.a = B);
          }
          copy(_) {
            return super.copy(_), (this.a = "a" in _ ? _.a : 1), this;
          }
          clone() {
            return new this.constructor(this.r, this.g, this.b, this.a);
          }
          equals(_) {
            return super.equals(_) && this.a === _.a;
          }
          setStyle(_, I = "srgb") {
            let R;
            if ("transparent" === _) return this.setRGBA(0, 0, 0, 0), this;
            if ((R = /^((?:rgb|hsl)a?)\(([^)]*)\)/.exec(_))) {
              let B,
                z = R[1],
                k = R[2];
              switch (z) {
                case "rgb":
                case "rgba":
                  if (
                    (B =
                      /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        k
                      ))
                  )
                    return (
                      (this.a = "rgba" === z ? parseFloat(B[4]) : 1),
                      super.setStyle(_, I)
                    );
                  break;
                case "hsl":
                case "hsla":
                  if (
                    (B =
                      /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)%\s*,\s*(\d*\.?\d+)%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        k
                      ))
                  )
                    return (
                      (this.a = "hsla" === z ? parseFloat(B[4]) : 1),
                      super.setStyle(_, I)
                    );
              }
            }
            return super.setStyle(_, I);
          }
          get x() {
            return this.r;
          }
          get y() {
            return this.g;
          }
          get z() {
            return this.b;
          }
          get w() {
            return this.a;
          }
          set x(_) {
            this.r = _;
          }
          set y(_) {
            this.g = _;
          }
          set z(_) {
            this.b = _;
          }
          set w(_) {
            this.a = _;
          }
        },
        wM = class extends wx {
          constructor(_) {
            super("v4"),
              (this.nodeType = "Vector4"),
              (this.value = _ instanceof wA ? _ : new wA(_.r, _.g, _.b, _.a));
          }
          generateReadonly(_, I, R, B, z, k) {
            return _.format(
              "vec4(" +
                this.value.r +
                ", " +
                this.value.g +
                ", " +
                this.value.b +
                ", " +
                this.value.a +
                ")",
              B,
              I
            );
          }
        },
        wC = /^\s*([a-z_0-9]+)\s([a-z_0-9]+)\s*\((.*?)\)/i,
        wT = /[a-z_0-9]+/gi,
        wP = class extends wy {
          constructor(_, I, R, B, z) {
            super(z),
              (this.src = ""),
              (this.nodeType = "Function"),
              (this.useKeywords = !0),
              (this.includes = []),
              (this.extensions = {}),
              (this.keywords = {}),
              (this.isMethod = void 0 === z),
              (this.isInterface = !1),
              this.parse(_, I, R, B);
          }
          getShared(_, I) {
            return !this.isMethod;
          }
          getType(_) {
            return _.getTypeByFormat(this.type);
          }
          getInputByName(_) {
            if (this.inputs) {
              let I = this.inputs.length;
              for (; I--; )
                if (this.inputs[I].name === _) return this.inputs[I];
            }
          }
          getIncludeByName(_) {
            if (this.includes) {
              let I = this.includes.length;
              for (; I--; )
                if (this.includes[I].name === _) return this.includes[I];
            }
          }
          generate(_, I, R, B, z) {
            let k,
              V = 0,
              j = this.src;
            if (this.includes)
              for (let I = 0; I < this.includes.length; I++)
                _.include(this.includes[I], this);
            for (let I in this.extensions) _.extensions[I] = !0;
            let G = [];
            for (; (k = wT.exec(this.src)); ) G.push(k);
            for (let I = 0; I < G.length; I++) {
              let R = G[I],
                B = R[0],
                z = !this.isMethod || !this.getInputByName(B),
                k = B;
              if (
                this.keywords[B] ||
                (this.useKeywords && z && wg.containsKeyword(B))
              ) {
                let I = this.keywords[B];
                if (!I) {
                  let R = wg.getKeywordData(B);
                  R.cache && (I = _.keywords[B]),
                    (I = I || wg.getKeyword(B, _)),
                    R.cache && (_.keywords[B] = I);
                }
                k = I.build(_);
              }
              B !== k &&
                "." !== j[R.index + V - 1] &&
                ((j =
                  j.substring(0, R.index + V) +
                  k +
                  j.substring(R.index + B.length + V)),
                (V += k.length - B.length)),
                void 0 === this.getIncludeByName(k) &&
                  wg.contains(k) &&
                  _.include(wg.get(k));
            }
            return "source" === I
              ? j
              : this.isMethod
              ? (this.isInterface || _.include(this, void 0, j), this.name)
              : _.format("( " + j + " )", this.getType(_), I);
          }
          parse(_, I, R, B) {
            if (
              ((this.src = _ || ""),
              (this.includes = I ?? []),
              (this.extensions = R ?? {}),
              (this.keywords = B ?? {}),
              this.isMethod)
            ) {
              let _ = wC.exec(this.src);
              if (((this.inputs = []), _ && 4 == _.length)) {
                (this.type = _[1]), (this.name = _[2]);
                let I = _[3].match(wT);
                if (I) {
                  let _ = 0;
                  for (; _ < I.length; ) {
                    let R = I[_++],
                      B;
                    "in" === R || "out" === R || "inout" === R
                      ? (B = I[_++])
                      : ((B = R), (R = ""));
                    let z = I[_++];
                    this.inputs.push({ name: z, type: B, qualifier: R });
                  }
                }
                this.isInterface = -1 === this.src.indexOf("{");
              } else (this.type = ""), (this.name = "");
            }
          }
        },
        wO = /^([a-z_0-9]+)\s([a-z_0-9]+)\s?\=?\s?(.*?)(\;|$)/i,
        wI = class extends wy {
          constructor(_ = "", I) {
            super(),
              (this.src = ""),
              (this.useDefine = !1),
              (this.nodeType = "Const"),
              this.parse(_ || wI.PI, void 0, void 0, void 0, I);
          }
          getType(_) {
            return _.getTypeByFormat(this.type);
          }
          parse(_, I, R, B, z) {
            this.src = _ || "";
            let k,
              V,
              j = "",
              G = wO.exec(_);
            (this.useDefine = z ?? "#" === this.src.charAt(0)),
              G && G.length > 1
                ? ((V = G[1]), (k = G[2]), (j = G[3]))
                : ((k = this.src), (V = "f")),
              (this.name = k),
              (this.type = V),
              (this.value = j);
          }
          build(_, I) {
            if ("source" === I) {
              if (this.value)
                return this.useDefine
                  ? "#define " + this.name + " " + this.value
                  : "const " +
                      this.type +
                      " " +
                      this.name +
                      " = " +
                      this.value +
                      ";";
              if (this.useDefine) return this.src;
            }
            return _.include(this), _.format(this.name, this.getType(_), I);
          }
          generate(_, I, R, B, z) {
            return _.format(this.name, this.getType(_), I);
          }
        };
      (wI.PI = "PI"),
        (wI.PI2 = "PI2"),
        (wI.RECIPROCAL_PI = "RECIPROCAL_PI"),
        (wI.RECIPROCAL_PI2 = "RECIPROCAL_PI2"),
        (wI.LOG2 = "LOG2"),
        (wI.EPSILON = "EPSILON");
      var wR = RegExp(
          `^structs*([a-z_0-9]+)s*{s*((.|
)*?)}`,
          "gim"
        ),
        wL = RegExp("s*(w*?)s*(w*?)(=|;)", "gim"),
        wz = class extends wy {
          constructor(_ = "") {
            super(),
              (this.inputs = []),
              (this.src = ""),
              (this.nodeType = "Struct"),
              this.parse(_);
          }
          getType(_) {
            return _.getTypeByFormat(this.name);
          }
          getInputByName(_) {
            let I = this.inputs.length;
            for (; I--; ) if (this.inputs[I].name === _) return this.inputs[I];
          }
          generate(_, I, R, B, z) {
            return "source" === I
              ? this.src + ";"
              : _.format("( " + this.src + " )", this.getType(_), I);
          }
          parse(_ = "") {
            (this.src = _), (this.inputs = []);
            let I = wR.exec(_);
            if (I) {
              let _ = I[2],
                R;
              for (; (R = wL.exec(_)); )
                this.inputs.push({ type: R[1], name: R[2] });
              this.name = I[1];
            } else this.name = "";
            this.type = this.name;
          }
        },
        wF = class extends wy {
          constructor(_) {
            super("v2", { shared: !1 }),
              (this.nodeType = "UV"),
              (this.index = _ ?? 0);
          }
          generate(_, I) {
            _.requires.uv[this.index] = !0;
            let R = this.index > 0 ? this.index + 1 : "",
              B = _.isShader("vertex") ? "uv" + R : "vUv" + R;
            return _.format(B, this.getType(_), I);
          }
        };
      wg.addKeyword("uv", function () {
        return new wF();
      }),
        wg.addKeyword("uv2", function () {
          return new wF(1);
        });
      var wN = class extends wy {
        constructor(_, I) {
          super("v4"),
            (this.nodeType = "ColorSpace"),
            (this.input = _),
            (this.method = I ?? wN.LINEAR_TO_LINEAR),
            (this.hashProperties = ["method"]);
        }
        static getEncodingComponents(_) {
          switch (_) {
            case 3e3:
              return ["Linear"];
            case 3001:
              return ["sRGB"];
            default:
              return [];
          }
        }
        generate(_, I) {
          let R = this.input.build(_, "v4"),
            B = this.getType(_),
            z = wN.Nodes[this.method],
            k = _.include(z);
          if (k === wN.LINEAR_TO_LINEAR) return _.format(R, B, I);
          if (z.inputs?.length !== 2)
            return _.format(k + "( " + R + " )", B, I);
          {
            let z = this.factor.build(_, "f");
            return _.format(k + "( " + R + ", " + z + " )", B, I);
          }
        }
        fromEncoding(_) {
          let I = wN.getEncodingComponents(_);
          (this.method = "LinearTo" + I[0]), (this.factor = I[1]);
        }
        fromDecoding(_) {
          let I = wN.getEncodingComponents(_);
          (this.method = I[0] + "ToLinear"), (this.factor = I[1]);
        }
      };
      (wN.Nodes = {
        LinearToLinear: new wP(
          ["vec4 LinearToLinear( in vec4 value ) {", "	return value;", "}"]
            .join(`
`)
        ),
        sRGBToLinear: new wP(
          [
            "vec4 sRGBToLinear( in vec4 value ) {",
            "	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );",
            "}",
          ].join(`
`)
        ),
        LinearTosRGB: new wP(
          [
            "vec4 LinearTosRGB( in vec4 value ) {",
            "	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );",
            "}",
          ].join(`
`)
        ),
      }),
        (wN.LINEAR_TO_LINEAR = "LinearToLinear"),
        (wN.SRGB_TO_LINEAR = "sRGBToLinear"),
        (wN.LINEAR_TO_SRGB = "LinearTosRGB");
      var wk = class extends wP {
          constructor(_ = "", I, R, B, z) {
            super(_, z, B, R, I), (this.nodeType = "Expression");
          }
        },
        wV = class extends wx {
          constructor(_ = new rA(), I, R, B) {
            super("v4", { shared: !0 }),
              (this.nodeType = "Texture"),
              (this.value = _),
              (this.uv = I ?? new wF()),
              (this.bias = R),
              (this.project = void 0 !== B && B);
          }
          getTexture(_, I) {
            return super.generate(_, I, this.value.uuid, "t");
          }
          generate(_, I) {
            let R, B;
            if ("sampler2D" === I) return this.getTexture(_, I);
            let z = this.getTexture(_, I),
              k = this.uv.build(_, this.project ? "v4" : "v2"),
              V = this.bias ? this.bias.build(_, "f") : void 0;
            void 0 === V &&
              _.context.bias &&
              (V = _.context.bias.setTexture(this).build(_, "f")),
              (R = this.project ? "texture2DProj" : V ? "tex2DBias" : "tex2D"),
              (B = V
                ? R + "( " + z + ", " + k + ", " + V + " )"
                : R + "( " + z + ", " + k + " )");
            let j = { include: _.isShader("vertex"), ignoreCache: !0 },
              G = this.getType(_);
            return (
              _.addContext(j),
              (this.colorSpace = this.colorSpace ?? new wN(new wk("", G))),
              this.colorSpace.fromDecoding(
                _.getTextureEncodingFromMap(this.value)
              ),
              this.colorSpace.input.parse(B),
              (B = this.colorSpace.build(_, G)),
              _.removeContext(),
              _.format(B, G, I)
            );
          }
        },
        wj = class extends wx {
          constructor(_) {
            super("f"), (this.nodeType = "Float"), (this.value = _ ?? 0);
          }
          generateReadonly(_, I, R, B, z, k) {
            return _.format(this.value + (this.value % 1 ? "" : ".0"), B, I);
          }
        },
        wG = class extends wy {
          constructor(_, I) {
            super(),
              (this.inputs = []),
              (this.nodeType = "FunctionCall"),
              (this.value = _),
              (this.inputs = I ?? []);
          }
          getFunction() {
            return this.value;
          }
          getType(_) {
            return this.value.getType(_);
          }
          generate(_, I, R, B, z) {
            B = this.getType(_);
            let k = this.value,
              V = k.build(_, I) + "( ",
              j = [];
            if (k.inputs) {
              for (let I = 0; I < k.inputs.length; I++) {
                let R = k.inputs[I],
                  B = this.inputs[I] || this.inputs[R.name];
                j.push(B.build(_, _.getTypeByFormat(R.type)));
              }
              V += j.join(", ") + " )";
            }
            return _.format(V, B, I);
          }
        },
        wH = class extends wy {
          constructor(_, I, R = wH.ADD) {
            super(),
              (this.nodeType = "Operator"),
              (this.type = _.type),
              (this.a = _),
              (this.b = I),
              (this.op = R);
          }
          getType(_) {
            let I = this.a.getType(_),
              R = this.b.getType(_);
            return _.isTypeMatrix(I)
              ? "v4"
              : _.getTypeLength(R) > _.getTypeLength(I)
              ? R
              : I;
          }
          generate(_, I) {
            let R = this.getType(_);
            this.type = R;
            let B = this.a.build(_, R),
              z = this.b.build(_, R);
            return _.format("( " + B + " " + this.op + " " + z + " )", R, I);
          }
        };
      (wH.ADD = "+"), (wH.SUB = "-"), (wH.MUL = "*"), (wH.DIV = "/");
      var wW = class extends wy {
        constructor(_, I = wW.ABS, R, B) {
          super(),
            (this.nodeType = "Math"),
            (this.a = _),
            "string" != typeof I ? (this.b = I) : (B = I),
            "string" != typeof R ? (this.c = R) : (B = R),
            (this.method = B),
            (this.hashProperties = ["method"]);
        }
        getNumInputs(_) {
          switch (this.method) {
            case wW.MIX:
            case wW.CLAMP:
            case wW.REFRACT:
            case wW.SMOOTHSTEP:
            case wW.FACEFORWARD:
              return 3;
            case wW.MIN:
            case wW.MAX:
            case wW.MOD:
            case wW.STEP:
            case wW.REFLECT:
            case wW.DISTANCE:
            case wW.DOT:
            case wW.CROSS:
            case wW.POW:
              return 2;
            default:
              return 1;
          }
        }
        getInputType(_) {
          let I = _.getTypeLength(this.a.getType(_)),
            R = this.b ? _.getTypeLength(this.b.getType(_)) : 0,
            B = this.c ? _.getTypeLength(this.c.getType(_)) : 0;
          return I > R && I > B
            ? this.a.getType(_)
            : R > B
            ? this.b.getType(_)
            : this.c.getType(_);
        }
        getType(_) {
          switch (this.method) {
            case wW.LENGTH:
            case wW.DISTANCE:
            case wW.DOT:
              return "f";
            case wW.CROSS:
              return "v3";
          }
          return this.getInputType(_);
        }
        generate(_, I) {
          let R,
            B,
            z,
            k = this.a ? _.getTypeLength(this.a.getType(_)) : 0,
            V = this.b ? _.getTypeLength(this.b.getType(_)) : 0,
            j = this.c ? _.getTypeLength(this.c.getType(_)) : 0,
            G = this.getInputType(_),
            q = this.getType(_);
          switch (((this.type = q), this.method)) {
            case wW.NEGATE:
              return _.format("( -" + this.a.build(_, G) + " )", G, I);
            case wW.INVERT:
              return _.format("( 1.0 - " + this.a.build(_, G) + " )", G, I);
            case wW.CROSS:
              (R = this.a.build(_, "v3")), (B = this.b.build(_, "v3"));
              break;
            case wW.STEP:
              (R = this.a.build(_, 1 === k ? "f" : G)),
                (B = this.b.build(_, G));
              break;
            case wW.MIN:
            case wW.MAX:
            case wW.MOD:
              (R = this.a.build(_, G)),
                (B = this.b.build(_, 1 === V ? "f" : G));
              break;
            case wW.REFRACT:
              (R = this.a.build(_, G)),
                (B = this.b.build(_, G)),
                (z = this.c.build(_, "f"));
              break;
            case wW.MIX:
              (R = this.a.build(_, G)),
                (B = this.b.build(_, G)),
                (z = this.c.build(_, 1 === j ? "f" : G));
              break;
            default:
              (R = this.a.build(_, G)),
                this.b && (B = this.b.build(_, G)),
                this.c && (z = this.c.build(_, G));
          }
          let X = [];
          X.push(R), B && X.push(B), z && X.push(z);
          let Q = this.getNumInputs(_);
          if (X.length !== Q)
            throw Error(
              `Arguments not match used in "${this.method}". Require ${Q}, currently ${X.length}.`
            );
          return _.format(this.method + "( " + X.join(", ") + " )", q, I);
        }
      };
      (wW.RAD = "radians"),
        (wW.DEG = "degrees"),
        (wW.EXP = "exp"),
        (wW.EXP2 = "exp2"),
        (wW.LOG = "log"),
        (wW.LOG2 = "log2"),
        (wW.SQRT = "sqrt"),
        (wW.INV_SQRT = "inversesqrt"),
        (wW.FLOOR = "floor"),
        (wW.CEIL = "ceil"),
        (wW.NORMALIZE = "normalize"),
        (wW.FRACT = "fract"),
        (wW.SATURATE = "saturate"),
        (wW.SIN = "sin"),
        (wW.COS = "cos"),
        (wW.TAN = "tan"),
        (wW.ASIN = "asin"),
        (wW.ACOS = "acos"),
        (wW.ARCTAN = "atan"),
        (wW.ABS = "abs"),
        (wW.SIGN = "sign"),
        (wW.LENGTH = "length"),
        (wW.NEGATE = "negate"),
        (wW.INVERT = "invert"),
        (wW.MIN = "min"),
        (wW.MAX = "max"),
        (wW.MOD = "mod"),
        (wW.STEP = "step"),
        (wW.REFLECT = "reflect"),
        (wW.DISTANCE = "distance"),
        (wW.DOT = "dot"),
        (wW.CROSS = "cross"),
        (wW.POW = "pow"),
        (wW.MIX = "mix"),
        (wW.CLAMP = "clamp"),
        (wW.REFRACT = "refract"),
        (wW.SMOOTHSTEP = "smoothstep"),
        (wW.FACEFORWARD = "faceforward");
      var wq = class extends wy {
        constructor(_, I, R) {
          super("v4"),
            (this.nodeType = "TextureCubeUV"),
            (this.value = _),
            (this.uv = I),
            (this.bias = R);
        }
        bilinearCubeUV(_, I, R, B) {
          let z = new wG(wq.Nodes.bilinearCubeUV, [I, R, B]);
          (this.colorSpaceTL = this.colorSpaceTL ?? new wN(new wk("", "v4"))),
            this.colorSpaceTL.fromDecoding(
              _.getTextureEncodingFromMap(this.value.value)
            ),
            this.colorSpaceTL.input.parse(z.build(_) + ".tl"),
            (this.colorSpaceTR = this.colorSpaceTR ?? new wN(new wk("", "v4"))),
            this.colorSpaceTR.fromDecoding(
              _.getTextureEncodingFromMap(this.value.value)
            ),
            this.colorSpaceTR.input.parse(z.build(_) + ".tr"),
            (this.colorSpaceBL = this.colorSpaceBL ?? new wN(new wk("", "v4"))),
            this.colorSpaceBL.fromDecoding(
              _.getTextureEncodingFromMap(this.value.value)
            ),
            this.colorSpaceBL.input.parse(z.build(_) + ".bl"),
            (this.colorSpaceBR = this.colorSpaceBR ?? new wN(new wk("", "v4"))),
            this.colorSpaceBR.fromDecoding(
              _.getTextureEncodingFromMap(this.value.value)
            ),
            this.colorSpaceBR.input.parse(z.build(_) + ".br");
          let k = { include: _.isShader("vertex"), ignoreCache: !0 };
          _.addContext(k),
            (this.colorSpaceTLExp = new wk(
              this.colorSpaceTL.build(_, "v4"),
              "v4"
            )),
            (this.colorSpaceTRExp = new wk(
              this.colorSpaceTR.build(_, "v4"),
              "v4"
            )),
            (this.colorSpaceBLExp = new wk(
              this.colorSpaceBL.build(_, "v4"),
              "v4"
            )),
            (this.colorSpaceBRExp = new wk(
              this.colorSpaceBR.build(_, "v4"),
              "v4"
            )),
            _.removeContext();
          let V = new wk(
            "mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )",
            "v4"
          );
          return (
            (V.keywords.cubeUV_TL = this.colorSpaceTLExp),
            (V.keywords.cubeUV_TR = this.colorSpaceTRExp),
            (V.keywords.cubeUV_BL = this.colorSpaceBLExp),
            (V.keywords.cubeUV_BR = this.colorSpaceBRExp),
            (V.keywords.cubeUV = z),
            V
          );
        }
        generate(_, I) {
          if (!_.isShader("fragment"))
            return (
              console.warn(
                "TextureCubeUVNode is not compatible with " +
                  _.shader +
                  " shader."
              ),
              _.format("vec4( 0.0 )", this.getType(_), I)
            );
          {
            let R = this.uv,
              B = this.bias || _.context.roughness,
              z = new wG(wq.Nodes.roughnessToMip, [B]),
              k = new wW(z, wq.Nodes.m0, wq.Nodes.cubeUV_maxMipLevel, wW.CLAMP),
              V = new wW(k, wW.FLOOR),
              j = new wW(k, wW.FRACT),
              G = this.bilinearCubeUV(_, this.value, R, V),
              q = this.bilinearCubeUV(
                _,
                this.value,
                R,
                new wH(V, new wj(1).setReadonly(!0), wH.ADD)
              ),
              X = new wW(G, q, j, wW.MIX);
            return _.format(X.build(_), "v4", I);
          }
        }
      };
      wq.Nodes =
        ((e6 = new wz(`struct TextureCubeUVData {
			vec4 tl;
			vec4 tr;
			vec4 br;
			vec4 bl;
			vec2 f;
		}`)),
        (e8 = new wI("float cubeUV_maxMipLevel 8.0", !0)),
        (e9 = new wI("float cubeUV_minMipLevel 4.0", !0)),
        (e7 = new wI("float cubeUV_maxTileSize 256.0", !0)),
        (te = new wI("float cubeUV_minTileSize 16.0", !0)),
        ((tt = new wP(`float getFace(vec3 direction) {
				vec3 absDirection = abs(direction);
				float face = -1.0;
				if (absDirection.x > absDirection.z) {
					if (absDirection.x > absDirection.y)
						face = direction.x > 0.0 ? 0.0 : 3.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				} else {
					if (absDirection.z > absDirection.y)
						face = direction.z > 0.0 ? 2.0 : 5.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				}
				return face;
		}`)).useKeywords = !1),
        ((tr = new wP(`vec2 getUV(vec3 direction, float face) {
				vec2 uv;
				if (face == 0.0) {
					uv = vec2(direction.z, direction.y) / abs(direction.x); // pos x
				} else if (face == 1.0) {
					uv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y
				} else if (face == 2.0) {
					uv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z
				} else if (face == 3.0) {
					uv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x
				} else if (face == 4.0) {
					uv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y
				} else {
					uv = vec2(direction.x, direction.y) / abs(direction.z); // neg z
				}
				return 0.5 * (uv + 1.0);
		}`)).useKeywords = !1),
        ((ts = new wP(
          `TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {
			float face = getFace(direction);
			float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);
			mipInt = max(mipInt, cubeUV_minMipLevel);
			float faceSize = exp2(mipInt);
			float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);
			vec2 uv = getUV(direction, face) * (faceSize - 1.0);
			vec2 f = fract(uv);
			uv += 0.5 - f;
			if (face > 2.0) {
				uv.y += faceSize;
				face -= 3.0;
			}
			uv.x += face * faceSize;
			if(mipInt < cubeUV_maxMipLevel){
				uv.y += 2.0 * cubeUV_maxTileSize;
			}
			uv.y += filterInt * 2.0 * cubeUV_minTileSize;
			uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);
			uv *= texelSize;
			vec4 tl = texture2D(envMap, uv);
			uv.x += texelSize;
			vec4 tr = texture2D(envMap, uv);
			uv.y += texelSize;
			vec4 br = texture2D(envMap, uv);
			uv.x -= texelSize;
			vec4 bl = texture2D(envMap, uv);
			return TextureCubeUVData( tl, tr, br, bl, f );
		}`,
          [e6, tt, tr, e8, e9, e7, te]
        )).useKeywords = !1),
        (ta = new wI("float r0 1.0", !0)),
        (tn = new wI("float v0 0.339", !0)),
        (to = new wI("float m0 -2.0", !0)),
        (tl = new wI("float r1 0.8", !0)),
        (th = new wI("float v1 0.276", !0)),
        (tc = new wI("float m1 -1.0", !0)),
        (td = new wI("float r4 0.4", !0)),
        (tu = new wI("float v4 0.046", !0)),
        (tp = new wI("float m4 2.0", !0)),
        (tf = new wI("float r5 0.305", !0)),
        (tm = new wI("float v5 0.016", !0)),
        (tg = new wI("float m5 3.0", !0)),
        (tx = new wI("float r6 0.21", !0)),
        (tb = new wI("float v6 0.0038", !0)),
        (tw = new wI("float m6 4.0", !0)),
        {
          bilinearCubeUV: ts,
          roughnessToMip: new wP(
            `float roughnessToMip(float roughness) {
			float mip = 0.0;
			if (roughness >= r1) {
				mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;
			} else if (roughness >= r4) {
				mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;
			} else if (roughness >= r5) {
				mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;
			} else if (roughness >= r6) {
				mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;
			} else {
				mip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25
			}
			return mip;
		}`,
            [ta, tn, to, tl, th, tc, td, tu, tp, tf, tm, tg, tx, tb, tw]
          ),
          m0: to,
          cubeUV_maxMipLevel: e8,
        });
      var wY = class extends wy {
        constructor(_) {
          super("v3"), (this.nodeType = "Normal"), (this.scope = _ ?? wY.VIEW);
        }
        getShared() {
          return this.scope === wY.WORLD;
        }
        build(_, I, R, B) {
          let z = _.context[this.scope + "Normal"];
          return z ? z.build(_, I, R, B) : super.build(_, I, R);
        }
        generate(_, I, R, B, z) {
          let k;
          switch (this.scope) {
            case wY.VIEW:
              k = _.isShader("vertex") ? "transformedNormal" : "geometryNormal";
              break;
            case wY.LOCAL:
              _.isShader("vertex")
                ? (k = "objectNormal")
                : ((_.requires.normal = !0), (k = "vObjectNormal"));
              break;
            case wY.WORLD:
              _.isShader("vertex")
                ? (k =
                    "inverseTransformDirection( transformedNormal, viewMatrix ).xyz")
                : ((_.requires.worldNormal = !0), (k = "vWNormal"));
          }
          return _.format(k, this.getType(_), I);
        }
      };
      (wY.LOCAL = "local"),
        (wY.WORLD = "world"),
        (wY.VIEW = "view"),
        (wY.NORMAL = "normal"),
        wg.addKeyword("viewNormal", function () {
          return new wY(wY.VIEW);
        }),
        wg.addKeyword("localNormal", function () {
          return new wY(wY.NORMAL);
        }),
        wg.addKeyword("worldNormal", function () {
          return new wY(wY.WORLD);
        });
      var wX = class extends wy {
        constructor(_) {
          super("v3"),
            (this.nodeType = "Position"),
            (this.scope = _ ?? wX.LOCAL);
        }
        getType() {
          return this.scope === wX.PROJECTION ? "v4" : this.type;
        }
        getShader() {
          switch (this.scope) {
            case wX.LOCAL:
            case wX.WORLD:
              return !1;
          }
          return !0;
        }
        generate(_, I, R, B, z) {
          let k;
          switch (this.scope) {
            case wX.LOCAL:
              _.isShader("vertex")
                ? (k = "transformed")
                : ((_.requires.position = !0), (k = "vPosition"));
              break;
            case wX.WORLD:
              if (_.isShader("vertex"))
                return "( modelMatrix * vec4( transformed, 1.0 ) ).xyz";
              (_.requires.worldPosition = !0), (k = "vWPosition");
              break;
            case wX.VIEW:
              k = _.isShader("vertex") ? "-mvPosition.xyz" : "vViewPosition";
              break;
            case wX.PROJECTION:
              k = _.isShader("vertex")
                ? "( projectionMatrix * modelViewMatrix * vec4( position, 1.0 ) )"
                : "vec4( 0.0 )";
          }
          return _.format(k, this.getType(), I);
        }
      };
      (wX.LOCAL = "local"),
        (wX.WORLD = "world"),
        (wX.VIEW = "view"),
        (wX.PROJECTION = "projection"),
        wg.addKeyword("position", function () {
          return new wX();
        }),
        wg.addKeyword("worldPosition", function () {
          return new wX(wX.WORLD);
        }),
        wg.addKeyword("viewPosition", function () {
          return new wX(wX.VIEW);
        });
      var wQ = class extends wy {
        constructor(_) {
          super("v3"), (this.nodeType = "Reflect"), (this.scope = _ ?? wQ.CUBE);
        }
        getUnique(_) {
          return !_.context.viewNormal;
        }
        getType() {
          return this.scope === wQ.SPHERE ? "v2" : this.type;
        }
        generate(_, I) {
          let R = this.getUnique(_);
          if (!_.isShader("fragment"))
            return (
              console.warn(
                "ReflectNode is not compatible with " + _.shader + " shader."
              ),
              _.format("vec3( 0.0 )", this.type, I)
            );
          {
            let B;
            switch (this.scope) {
              case wQ.VECTOR: {
                let I = new wY(wY.VIEW),
                  z = _.context.roughness,
                  k = I.build(_, "v3"),
                  V = new wX(wX.VIEW).build(_, "v3"),
                  j = z ? z.build(_, "f") : void 0,
                  G = `reflect( -normalize( ${V} ), ${k} )`;
                j && (G = `normalize( mix( ${G}, ${k}, ${j} * ${j} ) )`);
                let q = `inverseTransformDirection( ${G}, viewMatrix )`;
                R
                  ? (_.addNodeCode(`vec3 reflectVec = ${q};`),
                    (B = "reflectVec"))
                  : (B = q);
                break;
              }
              case wQ.CUBE: {
                let I = new wQ(wQ.VECTOR).build(_, "v3"),
                  z = "vec3( -" + I + ".x, " + I + ".yz )";
                R
                  ? (_.addNodeCode(`vec3 reflectCubeVec = ${z};`),
                    (B = "reflectCubeVec"))
                  : (B = z);
                break;
              }
              case wQ.SPHERE: {
                let I =
                  "normalize( ( viewMatrix * vec4( " +
                  new wQ(wQ.VECTOR).build(_, "v3") +
                  ", 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5";
                R
                  ? (_.addNodeCode(`vec2 reflectSphereVec = ${I};`),
                    (B = "reflectSphereVec"))
                  : (B = I);
              }
            }
            return _.format(B, this.getType(), I);
          }
        }
      };
      (wQ.CUBE = "cube"), (wQ.SPHERE = "sphere"), (wQ.VECTOR = "vector");
      var wZ = class extends wy {
          constructor(_ = new wV(), I, R) {
            super("v4"),
              (this.nodeType = "TextureCube"),
              (this.value = _),
              (this.radianceNode = new wq(
                this.value,
                I ?? new wQ(wQ.VECTOR),
                R
              )),
              (this.irradianceNode = new wq(
                this.value,
                new wY(wY.WORLD),
                new wj(1).setReadonly(!0)
              ));
          }
          generate(_, I) {
            return _.isShader("fragment")
              ? (_.require("irradiance"),
                _.context.bias && _.context.bias.setTexture(this.value),
                ("irradiance" === _.slot
                  ? this.irradianceNode
                  : this.radianceNode
                ).build(_, I))
              : (console.warn(
                  "TextureCubeNode is not compatible with " +
                    _.shader +
                    " shader."
                ),
                _.format("vec4( 0.0 )", this.getType(_), I));
          }
        },
        wK = class extends wx {
          constructor(_ = new aL(), I, R) {
            super("v4", { shared: !0 }),
              (this.nodeType = "CubeTexture"),
              (this.value = _),
              (this.uv = I ?? new wQ()),
              (this.bias = R);
          }
          getTexture(_, I) {
            return super.generate(_, I, this.value.uuid, "tc");
          }
          generate(_, I) {
            let R;
            if ("samplerCube" === I) return this.getTexture(_, I);
            let B = this.getTexture(_, I),
              z = this.uv?.build(_, "v3"),
              k = this.bias ? this.bias.build(_, "f") : void 0;
            void 0 === k &&
              _.context.bias &&
              (k = _.context.bias.setTexture(this).build(_, "f")),
              (R = k
                ? "texCubeBias( " + B + ", " + z + ", " + k + " )"
                : "texCube( " + B + ", " + z + " )");
            let V = { include: _.isShader("vertex"), ignoreCache: !0 },
              j = this.getType(_);
            return (
              _.addContext(V),
              (this.colorSpace = this.colorSpace ?? new wN(new wk("", j))),
              this.colorSpace.fromDecoding(
                _.getTextureEncodingFromMap(this.value)
              ),
              this.colorSpace.input.parse(R),
              (R = this.colorSpace.build(_, j)),
              _.removeContext(),
              _.format(R, j, I)
            );
          }
        },
        wJ = `
uniform int frameIndex;
uniform vec2 resolution;
uniform mat4 previousModelViewMatrix;
uniform mat4 previousProjectionMatrix;

varying vec4 vCurrentPosition;
varying vec4 vPreviousPosition;
`,
        w$ = `
layout(location = 1) out vec4 gVelocity;

uniform int frameIndex;
uniform vec2 resolution;

varying vec4 vCurrentPosition;
varying vec4 vPreviousPosition;

const vec2 haltonSequence[16] = vec2[16](
vec2( 0.000000,-0.333334),
vec2(-0.500000, 0.333334),
vec2( 0.500000,-0.777778),
vec2(-0.750000,-0.111112),
vec2( 0.250000, 0.555556),
vec2(-0.250000,-0.555556),
vec2( 0.750000, 0.111112),
vec2(-0.875000, 0.777778),
vec2(0.125000, -0.925926),
vec2(-0.375000, -0.259260),
vec2(0.625000, 0.407408),
vec2(-0.625000, -0.703704),
vec2(0.375000, -0.037038),
vec2(-0.125000, 0.629630),
vec2(0.875000, -0.481482),
vec2(-0.937500, 0.185186));

vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {
  const float goldenAngle = 2.399963f; // radians
  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));
  float theta = float(sampleIndex) * goldenAngle + angle;
  float sine = sin(theta);
  float cosine = cos(theta);
  return vec2(cosine, sine) * r;
}

// Derived from the interleaved gradient function from Jimenez 2014 http:goo.gl/eomGso
float getNoiseInterleavedGradient(vec2 screenPos) {
    vec3 magic = vec3(0.06711056f, 0.00583715f, 52.9829189f);
    return fract(magic.z * fract(dot(screenPos, magic.xy)));
}

`,
        w1 = `
// TODO: This could be generated CPU side and passed to the shader every frame
const vec2 haltonSequence[16] = vec2[16](
vec2( 0.000000,-0.333334),
vec2(-0.500000, 0.333334),
vec2( 0.500000,-0.777778),
vec2(-0.750000,-0.111112),
vec2( 0.250000, 0.555556),
vec2(-0.250000,-0.555556),
vec2( 0.750000, 0.111112),
vec2(-0.875000, 0.777778),
vec2(0.125000, -0.925926),
vec2(-0.375000, -0.259260),
vec2(0.625000, 0.407408),
vec2(-0.625000, -0.703704),
vec2(0.375000, -0.037038),
vec2(-0.125000, 0.629630),
vec2(0.875000, -0.481482),
vec2(-0.937500, 0.185186));

// TODO: Pass correct view size
vec2 offset = haltonSequence[frameIndex];
offset.x /= resolution.x;
offset.y /= resolution.y;

vec4 currentPosition = gl_Position;
vec4 currentPositionJittered = currentPosition + (vec4(offset.x, offset.y, 0.0, 0.0) * currentPosition.w);

// We want to calculate the velocity with unjittered positions
// so that things that are not moving get a velocity = 0
vCurrentPosition = currentPosition;
vPreviousPosition = previousProjectionMatrix * previousModelViewMatrix * vec4(transformed, 1.0);
#ifdef OUTLINE_COMPENSATION
vPreviousPosition.xy += OUTLINE_COMPENSATION;
#endif
gl_Position = currentPositionJittered;

`,
        w2 = `
vec2 oldPos = vPreviousPosition.xy;
    oldPos /= vPreviousPosition.w;
    oldPos.xy = (oldPos.xy+1.)/2.0;

vec2 newPos = vCurrentPosition.xy;
    newPos /= vCurrentPosition.w;
    newPos.xy = (newPos.xy+1.)/2.0;

vec2 velocity = (newPos - oldPos);

// Discard fully transparent pixels 
if (gl_FragColor.a <= 0.0) discard;

gVelocity = vec4(velocity, 0.0, 1.0);
`,
        w3 = `
layout(location = 1) out vec4 gVelocity;
`,
        w4 = `
    // Discard fully transparent pixels 
    if (gl_FragColor.a <= 0.0) discard;

    gVelocity = vec4(0.0, 0.0, 0.0, 1.0);
`,
        w5 = ["x", "y", "z", "w"],
        w6 = ["float", "vec2", "vec3", "vec4"],
        w8 = {
          float: "f",
          vec2: "v2",
          vec3: "v3",
          vec4: "v4",
          mat4: "v4",
          int: "i",
          bool: "b",
          "float[]": "f[]",
          "vec4[]": "v4[]",
        },
        w9 = {
          t: "sampler2D",
          tc: "samplerCube",
          b: "bool",
          i: "int",
          f: "float",
          c: "vec3",
          v2: "vec2",
          v3: "vec3",
          v4: "vec4",
          m3: "mat3",
          m4: "mat4",
          "f[]": "float[]",
          "v4[]": "vec4[]",
        },
        w7 = class {
          constructor() {
            (this.includes = { consts: {}, functions: {}, structs: {} }),
              (this.cache = ""),
              (this.slot = ""),
              (this.shader = ""),
              (this.context = {}),
              (this.needsJitter = !0),
              (this.getIncludesCode = (function () {
                function t(_, I) {
                  return _.deps.length - I.deps.length;
                }
                return function (_, I) {
                  let R = this.getIncludes(_, I);
                  if (!R) return "";
                  let B = "";
                  R = R.sort(t);
                  for (let _ = 0; _ < R.length; _++)
                    R[_].src &&
                      (B +=
                        R[_].src +
                        `
`);
                  return B;
                };
              })()),
              (this.slots = []),
              (this.caches = []),
              (this.contexts = []),
              (this.keywords = {}),
              (this.nodeData = {}),
              (this.fragmentVariables = {}),
              (this.fragmentParsVariables = {}),
              (this.vertexParsVariables = {}),
              (this.requires = {
                uv: [],
                color: [],
                transparent: !1,
                irradiance: !1,
                position: !1,
                worldPosition: !1,
                normal: !1,
                worldNormal: !1,
                vWorldViewDir: !1,
                modelMatrix: !1,
                viewMatrix: !1,
                projectionMatrix: !1,
              }),
              (this.includes = { consts: [], functions: [], structs: [] }),
              (this.attributes = {}),
              (this.prefixCode = [
                "#ifdef TEXTURE_LOD_EXT",
                "	#define texCube(a, b) textureCube(a, b)",
                "	#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)",
                "	#define tex2D(a, b) texture2D(a, b)",
                "	#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)",
                "#else",
                "	#define texCube(a, b) textureCube(a, b)",
                "	#define texCubeBias(a, b, c) textureCube(a, b, c)",
                "	#define tex2D(a, b) texture2D(a, b)",
                "	#define tex2DBias(a, b, c) texture2D(a, b, c)",
                "#endif",
                `
			// NOTE: Include Spline's blending modes. This could be part of BlendNode
			#define SPE_BLENDING_NORMAL 0
			#define SPE_BLENDING_MULTIPLY 1
			#define SPE_BLENDING_SCREEN 2
			#define SPE_BLENDING_OVERLAY 3

			vec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, b, alpha );
			}

			vec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, a * b, alpha );
			}

			vec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );
				return mix( a, tmp, alpha );
			}

			vec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );
				return clamp( mix( a, tmp, alpha ), 0.0, 1.0 );
			}

			vec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {
				if ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );
				return vec3( 1.0 );
			}
			`,
                "#include <packing>",
                "#include <common>",
              ].join(`
`)),
              (this.parsCode = {
                vertex: ["float neighbor_offset = 0.0001;", ""].join(`
`),
                fragment: [
                  "float accumAlpha = 0.0;",
                  `void accumulateAlpha(float alpha) {
					accumAlpha += (1.0 - accumAlpha) * alpha;
				}`,
                  "",
                ].join(`
`),
              }),
              (this.code = { vertex: "", fragment: "" }),
              (this.nodeCode = { vertex: "", fragment: "" }),
              (this.resultCode = { vertex: "", fragment: "" }),
              (this.finalCode = { vertex: "", fragment: "" }),
              (this.inputs = {
                uniforms: { list: [], vertex: [], fragment: [] },
                arrayUniforms: { list: [], vertex: [], fragment: [] },
                vars: { varying: [], vertex: [], fragment: [] },
              }),
              (this.defines = {}),
              (this.uniforms = {}),
              (this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1,
              }),
              (this.updaters = []),
              (this.nodes = []),
              (this.analyzing = !1);
          }
          build(_, I) {
            this.addVertexParsCode(wJ),
              this.addFragmentParsCode(w$),
              this.buildShader("vertex", _),
              this.buildShader("fragment", I);
            for (let _ = 0; _ < this.requires.uv.length; _++)
              if (this.requires.uv[_]) {
                let I = _ > 0 ? _ + 1 : "";
                this.addVaryCode("varying vec2 vUv" + I + ";"),
                  _ > 0 &&
                    this.addVertexParsCode("attribute vec2 uv" + I + ";"),
                  this.addVertexFinalCode("vUv" + I + " = uv" + I + ";");
              }
            return (
              this.requires.color[0] &&
                (this.addVaryCode("varying vec4 vColor;"),
                this.addVertexParsCode("attribute vec4 color;"),
                this.addVertexFinalCode("vColor = color;")),
              this.requires.color[1] &&
                (this.addVaryCode("varying vec4 vColor2;"),
                this.addVertexParsCode("attribute vec4 color2;"),
                this.addVertexFinalCode("vColor2 = color2;")),
              this.requires.position &&
                (this.addVaryCode("varying vec3 vPosition;"),
                this.addVertexFinalCode("vPosition = transformed;")),
              this.requires.worldPosition,
              this.requires.normal &&
                (this.addVaryCode("varying vec3 vObjectNormal;"),
                this.addVertexFinalCode("vObjectNormal = normal;")),
              this.requires.modelMatrix &&
                this.addFragmentParsCode("uniform mat4 modelMatrix;"),
              this.requires.viewMatrix &&
                this.addFragmentParsCode("uniform mat4 viewMatrix;"),
              this.requires.projectionMatrix &&
                this.addFragmentParsCode("uniform mat4 projectionMatrix;"),
              this.requires.worldNormal &&
                (this.addVaryCode("varying vec3 vWNormal;"),
                this.addVertexFinalCode(
                  "vWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;"
                )),
              this.requires.vWorldViewDir &&
                (this.addVaryCode("varying vec3 vWorldViewDir;"),
                this.addVertexFinalCode(
                  "vWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );"
                )),
              this.needsJitter &&
                (this.addVertexFinalCode(w1), this.addFragmentFinalCode(w2)),
              this
            );
          }
          buildShader(_, I) {
            this.resultCode[_] = I.build(this.setShader(_), "v4");
          }
          setMaterial(_, I) {
            return (this.defines = {}), this;
          }
          addFlow(_, I, R) {
            return this.addSlot(_).addCache(I).addContext(R);
          }
          removeFlow() {
            return this.removeSlot().removeCache().removeContext();
          }
          addCache(_) {
            return (this.cache = _ ?? ""), this.caches.push(this.cache), this;
          }
          removeCache() {
            return (
              this.caches.pop(),
              (this.cache = this.caches[this.caches.length - 1] || ""),
              this
            );
          }
          addContext(_) {
            return (
              (this.context = Object.assign({}, this.context, _)),
              (this.context.extra = this.context.extra || {}),
              this.contexts.push(this.context),
              this
            );
          }
          removeContext() {
            return (
              this.contexts.pop(),
              (this.context = this.contexts[this.contexts.length - 1] || {}),
              this
            );
          }
          addSlot(_) {
            return (this.slot = _ || ""), this.slots.push(this.slot), this;
          }
          removeSlot() {
            return (
              this.slots.pop(),
              (this.slot = this.slots[this.slots.length - 1] || ""),
              this
            );
          }
          addFragmentVariable(_, I) {
            void 0 === this.fragmentVariables[_] &&
              (this.addFragmentCode(`${I} ${_};`),
              (this.fragmentVariables[_] = ""));
          }
          addFragmentParsVariable(_, I) {
            void 0 === this.fragmentParsVariables[_] &&
              (this.addFragmentParsCode(`${I} ${_};`),
              (this.fragmentParsVariables[_] = ""));
          }
          addVertexParsVariable(_, I) {
            void 0 === this.vertexParsVariables[_] &&
              (this.addVertexParsCode(`${I} ${_};`),
              (this.vertexParsVariables[_] = ""));
          }
          addVertexCode(_) {
            this.addCode(_, "vertex");
          }
          addFragmentCode(_) {
            this.addCode(_, "fragment");
          }
          addCode(_, I) {
            this.code[I ?? this.shader] +=
              _ +
              `
`;
          }
          addVertexNodeCode(_) {
            this.addNodeCode(_, "vertex");
          }
          addFragmentNodeCode(_) {
            this.addNodeCode(_, "fragment");
          }
          addNodeCode(_, I) {
            this.nodeCode[I ?? this.shader] +=
              _ +
              `
`;
          }
          clearNodeCode(_) {
            _ = _ ?? this.shader;
            let I = this.nodeCode[_];
            return (this.nodeCode[_] = ""), I;
          }
          clearVertexNodeCode() {
            return this.clearNodeCode("vertex");
          }
          clearFragmentNodeCode() {
            return this.clearNodeCode("fragment");
          }
          addVertexFinalCode(_) {
            this.addFinalCode(_, "vertex");
          }
          addFragmentFinalCode(_) {
            this.addFinalCode(_, "fragment");
          }
          addFinalCode(_, I) {
            this.finalCode[I ?? this.shader] +=
              _ +
              `
`;
          }
          addVertexParsCode(_) {
            this.addParsCode(_, "vertex");
          }
          addFragmentParsCode(_) {
            this.addParsCode(_, "fragment");
          }
          addParsCode(_, I) {
            this.parsCode[I ?? this.shader] +=
              _ +
              `
`;
          }
          addVaryCode(_) {
            this.addVertexParsCode(_), this.addFragmentParsCode(_);
          }
          isCache(_) {
            return -1 !== this.caches.indexOf(_);
          }
          isSlot(_) {
            return -1 !== this.slots.indexOf(_);
          }
          define(_, I) {
            this.defines[_] = void 0 === I ? 1 : I;
          }
          require(_) {
            this.requires[_] = !0;
          }
          isDefined(_) {
            return void 0 !== this.defines[_];
          }
          getVar(_, I, R, B = "varying", z = "V", k = "") {
            let V = this.getVars(B),
              j = V[_];
            if (!j) {
              let B = V.length;
              (j = { name: R || "node" + z + B + (k ? "_" + k : ""), type: I }),
                V.push(j),
                (V[_] = j);
            }
            return j;
          }
          getTempVar(_, I, R, B) {
            return this.getVar(_, I, R, this.shader, "T", B);
          }
          getAttribute(_, I) {
            if (!this.attributes[_]) {
              let R = this.getVar(_, I);
              this.addVertexParsCode("attribute " + I + " " + _ + ";"),
                this.addVertexFinalCode(R.name + " = " + _ + ";"),
                (this.attributes[_] = { varying: R, name: _, type: I });
            }
            return this.attributes[_];
          }
          getCode(_) {
            return [
              this.prefixCode,
              this.parsCode[_],
              this.getVarListCode(this.getVars("varying"), "varying"),
              this.getVarListCode(this.inputs.uniforms[_], "uniform"),
              this.getVarListCode(this.inputs.arrayUniforms[_], "uniform"),
              this.getIncludesCode("consts", _),
              this.getIncludesCode("structs", _),
              this.getIncludesCode("functions", _),
              "void main() {",
              this.getVarListCode(this.getVars(_)),
              this.code[_],
              this.resultCode[_],
              this.finalCode[_],
              "}",
            ].join(`
`);
          }
          getVarListCode(_, I) {
            I = I ?? "";
            let R = "";
            for (let B = 0, z = _.length; B < z; ++B) {
              let z = _[B],
                k = z.type,
                V = z.name,
                j = z.size,
                G = this.getFormatByType(k);
              if (void 0 === G) throw Error("Node pars " + G + " not found.");
              G.includes("[]")
                ? (R +=
                    I +
                    " " +
                    G.substring(0, G.length - 2) +
                    " " +
                    V +
                    `[${j}];
`)
                : (R +=
                    I +
                    " " +
                    G +
                    " " +
                    V +
                    `;
`);
            }
            return R;
          }
          getVars(_) {
            return this.inputs.vars[_ ?? this.shader];
          }
          getNodeData(_) {
            let I = _ instanceof wm ? _.uuid : _;
            return (this.nodeData[I] = this.nodeData[I] || {});
          }
          createUniform(_, I, R, B, z, k) {
            if (I.includes("[]")) {
              let V = this.inputs.arrayUniforms,
                j = V.list.length,
                G = new wf({
                  type: I,
                  size: R.size,
                  name: B || "nodeUA" + j + (k ? "_" + k : ""),
                  node: R,
                  needsUpdate: z,
                });
              return (
                V.list.push(G),
                V[_].push(G),
                (V[_][G.name] = G),
                (this.uniforms[G.name] = G),
                G
              );
            }
            {
              let V = this.inputs.uniforms,
                j = V.list.length,
                G = new wf({
                  type: I,
                  name: B || "nodeU" + j + (k ? "_" + k : ""),
                  node: R,
                  needsUpdate: z,
                });
              return (
                V.list.push(G),
                V[_].push(G),
                (V[_][G.name] = G),
                (this.uniforms[G.name] = G),
                G
              );
            }
          }
          createVertexUniform(_, I, R, B, z) {
            return this.createUniform("vertex", _, I, R, B, z);
          }
          createFragmentUniform(_, I, R, B, z) {
            return this.createUniform("fragment", _, I, R, B, z);
          }
          include(_, I, R) {
            let B;
            if (
              ((_ = "string" == typeof _ ? wg.get(_) : _),
              !1 === this.context.include)
            )
              return _.name;
            _ instanceof wP
              ? (B = this.includes.functions)
              : _ instanceof wI
              ? (B = this.includes.consts)
              : _ instanceof wz && (B = this.includes.structs);
            let z = (B[this.shader] = B[this.shader] || []);
            if (_) {
              let B = z[_.name];
              if (
                (B ||
                  ((B = z[_.name] = { node: _, deps: [] }),
                  z.push(B),
                  (B.src = _.build(this, "source"))),
                _ instanceof wP &&
                  I &&
                  z[I.name] &&
                  -1 === z[I.name].deps.indexOf(_) &&
                  (z[I.name].deps.push(_), _.includes?.length))
              ) {
                let R = 0;
                do this.include(_.includes[R++], I);
                while (R < _.includes.length);
              }
              return R && (B.src = R), _.name;
            }
            throw Error("Include not found.");
          }
          colorToVectorProperties(_) {
            return _.replace("r", "x")
              .replace("g", "y")
              .replace("b", "z")
              .replace("a", "w");
          }
          colorToVector(_) {
            return _.replace(/c/g, "v3");
          }
          getIncludes(_, I) {
            return this.includes[_][I || this.shader];
          }
          getConstructorFromLength(_) {
            return w6[_ - 1];
          }
          isTypeMatrix(_) {
            return /^m/.test(_);
          }
          getTypeLength(_) {
            return "f" === _ ? 1 : parseInt(this.colorToVector(_).substr(1));
          }
          getTypeFromLength(_) {
            return 1 === _ ? "f" : "v" + _;
          }
          findNode(..._) {
            for (let I = 0; I < arguments.length; I++) {
              let R = _[I];
              if (R?.isNode) return R;
            }
          }
          resolve(..._) {
            for (let I = 0; I < arguments.length; I++) {
              let R = _[I];
              if (void 0 !== R) {
                if (R.isNode) return R;
                if (R.isTexture)
                  switch (R.mapping) {
                    case 301:
                    case 302:
                      return new wK(R);
                    case 306:
                      return new wZ(new wV(R));
                    default:
                      return new wV(R);
                  }
                else {
                  if (R.isVector2) return new wb(R);
                  if (R.isVector3) return new wS(R);
                  if (R.isVector4) return new wM(R);
                }
              }
            }
          }
          format(_, I, R) {
            switch (this.colorToVector(R + " <- " + I)) {
              case "f <- v2":
              case "f <- v3":
              case "f <- v4":
                return _ + ".x";
              case "f <- i":
              case "f <- b":
                return "float( " + _ + " )";
              case "v2 <- f":
                return "vec2( " + _ + " )";
              case "v2 <- v3":
              case "v2 <- v4":
                return _ + ".xy";
              case "v2 <- i":
              case "v2 <- b":
              case "v3 <- i":
              case "v3 <- b":
                return "vec2( float( " + _ + " ) )";
              case "v3 <- f":
                return "vec3( " + _ + " )";
              case "v3 <- v2":
                return "vec3( " + _ + ", 0.0 )";
              case "v3 <- v4":
                return _ + ".xyz";
              case "v4 <- f":
                return "vec4( " + _ + " )";
              case "v4 <- v2":
                return "vec4( " + _ + ", 0.0, 1.0 )";
              case "v4 <- v3":
                return "vec4( " + _ + ", 1.0 )";
              case "v4 <- i":
              case "v4 <- b":
                return "vec4( float( " + _ + " ) )";
              case "i <- f":
              case "i <- b":
                return "int( " + _ + " )";
              case "i <- v2":
              case "i <- v3":
              case "i <- v4":
                return "int( " + _ + ".x )";
              case "b <- f":
                return "( " + _ + " != 0.0 )";
              case "b <- v2":
                return "( " + _ + " != vec2( 0.0 ) )";
              case "b <- v3":
                return "( " + _ + " != vec3( 0.0 ) )";
              case "b <- v4":
                return "( " + _ + " != vec4( 0.0 ) )";
              case "b <- i":
                return "( " + _ + " != 0 )";
            }
            return _;
          }
          getTypeByFormat(_) {
            return w8[_] || _;
          }
          getFormatByType(_) {
            return w9[_] || _;
          }
          getUUID(_, I) {
            return (
              (I = void 0 === I || I) &&
                this.cache &&
                (_ = this.cache + "-" + _),
              _
            );
          }
          getElementByIndex(_) {
            return w5[_];
          }
          getIndexByElement(_) {
            return w5.indexOf(_);
          }
          isShader(_) {
            return this.shader === _;
          }
          setShader(_) {
            return (this.shader = _), this;
          }
          mergeDefines(_) {
            for (let I in _) this.defines[I] = _[I];
            return this.defines;
          }
          mergeUniform(_) {
            for (let I in _) this.uniforms[I] = _[I];
            return this.uniforms;
          }
          getTextureEncodingFromMap(_) {
            let I;
            return (
              _ ? _.isTexture && (I = _.encoding) : (I = 3e3),
              3e3 === I && this.context.gamma && (I = 3001),
              I
            );
          }
        },
        _e = class extends wx {
          constructor(_ = 0, I, R, B) {
            super("c"),
              (this.nodeType = "Color"),
              (this.value = _ instanceof wA ? _ : new wA(_ || 0, I, R, B));
          }
          setRGBA(_) {
            this.value.setRGBA(_.r, _.g, _.b, _.a);
          }
          generate(_, I, R, B, z, k) {
            (R = _.getUUID(R ?? this.getUUID())), (B = B ?? this.getType(_));
            let V = _.getNodeData(R),
              j = this.getReadonly() && void 0 !== this.generateReadonly;
            if (this.alpha) {
              let I = this.alpha.build(_, "f");
              _.addFragmentNodeCode(
                `accumAlpha += ( 1.0 - accumAlpha ) * ${I};`
              );
            }
            return j
              ? this.generateReadonly(_, I, R, B, z, k)
              : _.isShader("vertex")
              ? (V.vertex ||
                  (V.vertex = _.createVertexUniform(
                    B,
                    this,
                    z,
                    k,
                    this.getLabel()
                  )),
                _.format(V.vertex.name, B, I))
              : (V.fragment ||
                  (V.fragment = _.createFragmentUniform(
                    B,
                    this,
                    z,
                    k,
                    this.getLabel()
                  )),
                _.format(V.fragment.name, B, I));
          }
          generateReadonly(_, I, R, B, z, k) {
            return _.format(
              "vec3(" +
                this.value.r +
                ", " +
                this.value.g +
                ", " +
                this.value.b +
                ")",
              B,
              I
            );
          }
        },
        _t = class extends wx {
          constructor(_) {
            super("i"),
              (this.nodeType = "Int"),
              (this.value = Math.floor(_ ?? 0));
          }
          generateReadonly(_, I, R, B, z, k) {
            return _.format(this.value.toString(), B, I);
          }
        },
        _i = class extends wx {
          constructor(_) {
            super("b"), (this.nodeType = "Bool"), (this.value = _ ?? !1);
          }
          generateReadonly(_, I, R, B) {
            return _.format(this.value ? "true" : "false", B, I);
          }
        },
        _r = class extends wx {
          constructor(_ = 1, I) {
            super("f[]"),
              (this.nodeType = "FloatArray"),
              (this.size = _),
              (this.value = Array.isArray(I)
                ? I
                : "number" == typeof I
                ? Array(_).fill(I)
                : Array(_).fill(0));
          }
        },
        _s = class extends wx {},
        _a = class extends _s {
          constructor(_) {
            super("v3"), (this.image = _), (this._value = new rF());
          }
          get value() {
            return (
              (this._value.x = this.image.isVideo
                ? this.image.img.videoWidth ?? 0
                : this.image.img.width),
              (this._value.y = this.image.isVideo
                ? this.image.img.videoHeight ?? 0
                : this.image.img.height),
              this._value
            );
          }
        },
        _o = class extends _s {
          constructor(_, I, R = 1008) {
            super("t"), (this.image = _), (this.wrap = I), (this.minFilter = R);
          }
          get value() {
            return this.image.getTexture(this.wrap, this.minFilter);
          }
        },
        _c = class extends wx {
          constructor(_) {
            super("m3"),
              (this.nodeType = "Matrix3"),
              (this.value = _ ?? new ro());
          }
          generateReadonly(_, I, R, B, z, k) {
            return _.format(
              "mat3(" + this.value.elements.join(", ") + ")",
              B,
              I
            );
          }
          get elements() {
            return this.value.elements;
          }
          set elements(_) {
            this.value.fromArray(_);
          }
        },
        _d = class extends wx {
          constructor(_) {
            super("m4"),
              (this.nodeType = "Matrix4"),
              (this.value = _ ?? new sa());
          }
          generateReadonly(_, I, R, B, z, k) {
            return _.format(
              "mat4(" + this.value.elements.join(", ") + ")",
              B,
              I
            );
          }
          get elements() {
            return this.value.elements;
          }
          set elements(_) {
            this.value.fromArray(_);
          }
        };
      function JI(_, I, R) {
        _.setUvTransform(R[0], R[1], I[0], I[1], 0, 0, 0);
      }
      var _u = class extends _c {
          constructor(_, I) {
            super(new ro()),
              (this.repeat = _),
              (this.offset = I),
              JI(this.value, _, I);
          }
          updateMatrix() {
            JI(this.value, this.repeat, this.offset);
          }
        },
        _f = class extends wx {
          constructor(_ = 1, I) {
            super("v4[]"),
              (this.nodeType = "Vector4Array"),
              (this.size = _),
              (this.value = Array.isArray(I)
                ? I
                : I instanceof rM
                ? Array(_).fill(I)
                : Array(_).fill(new rM(0)));
          }
        },
        _m = class extends wy {
          constructor(_, I, R, B) {
            super("v3"),
              (this.nodeType = "Blend"),
              (this.a = _),
              (this.b = I),
              (this.alpha = R),
              (this.mode = B);
          }
          generate(_, I) {
            if (!_.isShader("fragment"))
              return (
                console.warn(
                  "BlendNode is not compatible with " + _.shader + " shader."
                ),
                _.format("vec3( 0.0 )", this.getType(_), I)
              );
            {
              let R = [];
              return (
                R.push(this.a.build(_, "c")),
                R.push(this.b.build(_, "c")),
                R.push(this.alpha.build(_, "f")),
                R.push(this.mode.build(_, "i")),
                _.format("spe_blend(" + R.join(",") + ")", this.getType(_), I)
              );
            }
          }
        },
        _g = class extends wy {
          constructor(_, I) {
            super("v3"),
              (this.nodeType = "CustomColor"),
              (this.color = _),
              (this.alpha = I),
              (this.calpha = `g${this.uuid
                .toString()
                .replace(/-/g, "")}_calpha`);
          }
          generate(_, I) {
            if (!_.isShader("fragment"))
              return (
                console.warn(
                  "CustomColorNode is not compatible with " +
                    _.shader +
                    " shader."
                ),
                _.format("vec3( 0.0 )", this.getType(_), I)
              );
            {
              let R = _.include(_g.Nodes.customColor);
              _.addFragmentVariable(this.calpha, "float");
              let B = [];
              return (
                B.push(this.color.build(_, "v3")),
                B.push(
                  this.mask ? `luminance(${this.mask.build(_, "v3")})` : "1.0"
                ),
                B.push(this.alpha.build(_, "f")),
                B.push(this.calpha),
                _.format(R + "(" + B.join(",") + ")", this.getType(_), I)
              );
            }
          }
        };
      _g.Nodes = {
        customColor:
          new wP(`vec3 customColor(vec3 color, float mask, float alpha, out float calpha) {
				float lalpha = alpha * mask;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;

				return color;
			}`),
      };
      var _v = class extends wy {
        constructor(_, I) {
          super("v3"),
            (this.nodeType = "CustomNormal"),
            (this.cnormal = _),
            (this.alpha = I),
            (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
        }
        generate(_, I) {
          if (!_.isShader("fragment"))
            return (
              console.warn(
                "CustomNormalNode is not compatible with " +
                  _.shader +
                  " shader."
              ),
              _.format("vec3( 0.0 )", this.getType(_), I)
            );
          {
            let R = _.include(_v.Nodes.customNormal);
            _.addFragmentVariable(this.calpha, "float");
            let B = [];
            return (
              B.push(this.cnormal.build(_, "v3")),
              B.push("normal"),
              B.push(
                this.mask
                  ? `luminance(${this.mask.flow(_, "v3").result})`
                  : "1.0"
              ),
              B.push(this.alpha.build(_, "f")),
              B.push(this.calpha),
              _.format(R + "(" + B.join(",") + ")", this.getType(_), I)
            );
          }
        }
      };
      _v.Nodes = {
        customNormal:
          new wP(`vec3 customNormal(vec3 cnormal, vec3 norm, float mask, float alpha, out float calpha) {
				vec3 normal = packNormalToRGB( norm ).rgb;
				normal *= step( vec3(0.5), cnormal );

				float lalpha = alpha * mask;
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;

				return normal;
			}`),
      };
      var _y = class extends wy {
        constructor(_, I, R, B, z, k, V, j, G, q, X, Q) {
          super("v3"),
            (this.nodeType = "CustomTexture"),
            (this.texture = _),
            (this.textureSize = I),
            (this.crop = R),
            (this.projection = B),
            (this.axis = z),
            (this.side = k),
            (this.size = V),
            (this.blending = j),
            (this.mat = G),
            (this.isMask = Q),
            (this.alpha = q),
            (this.mode = X),
            (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
        }
        generate(_, I) {
          _.require("position"),
            _.require("normal"),
            _.require("uv"),
            (_.requires.uv = [!0]),
            (_.extensions.shaderTextureLOD = !0),
            (_.extensions.derivatives = !0);
          let R = `g${this.uuid.toString().replace(/-/g, "")}`,
            B;
          switch (this.projection.value) {
            case 3:
              B = _.include(_y.Nodes.cylindrical);
              break;
            case 2:
              B = _.include(_y.Nodes.spherical);
              break;
            case 1:
              let z = [
                  "vec3(1.0, 0.0, 0.0)",
                  "vec3(0.0, 1.0, 0.0)",
                  "vec3(0.0, 0.0, 1.0)",
                ][this.axis.value],
                k = ["zy", "xz", "xy"][this.axis.value],
                V = new wP(`
		vec3 ${R}_planarTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {
				vec2 projected = (1. + (position.${k})) / 2.;
				vec2 uvs = ( mat * vec3( (projected * 2. - 1.) / (size * .5), 1. ) / 2. + 0.5 ).xy;
				writeUv = uvs;

				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				${
          2 === this.side.value
            ? ""
            : `lalpha *= step(0.0, ${
                1 === this.side.value ? "-1.0 * " : ""
              }dot(vObjectNormal, ${z}));`
        }

				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				
				lalpha *= mask;

				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}`);
              B = _.include(V);
              break;
            case 4:
              B = _.include(_y.Nodes.triplanar);
              break;
            default:
              B = _.include(_y.Nodes.uv);
          }
          _.addFragmentVariable(this.calpha, "float");
          let j = [];
          if (
            (j.push("normal"),
            j.push(this.texture.generate(_, "t")),
            j.push(this.textureSize.build(_, "v2")),
            j.push(this.crop.build(_, "f")),
            j.push(this.mat.build(_, "mat3")),
            j.push(this.size.build(_, "v2")),
            j.push(this.blending.build(_, "f")),
            j.push(this.isMask.build(_, "b")),
            j.push(
              this.mask ? `luminance(${this.mask.flow(_, "v3").result})` : "1.0"
            ),
            j.push(this.alpha.build(_, "f")),
            j.push(this.mode.build(_, "i")),
            j.push(this.calpha),
            4 === this.projection.value)
          ) {
            let I = `${R}_writeUvs`,
              B = I + "0",
              z = I + "1",
              k = I + "2",
              V = `${R}_triplanarWeights`;
            _.addFragmentVariable(B, "vec2"),
              _.addFragmentVariable(z, "vec2"),
              _.addFragmentVariable(k, "vec2"),
              _.addFragmentVariable(V, "vec3"),
              j.push(B),
              j.push(z),
              j.push(k),
              j.push(V);
          } else {
            let I = `${R}_writeUvs`;
            _.addFragmentVariable(I, "vec2"), j.push(I);
          }
          return _.format(B + "(" + j.join(",") + ")", this.getType(_), I);
        }
      };
      _y.Nodes = {
        cylindrical: new wP(`
vec3 cylindricalTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {
                vec3 posN = normalize(position);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float scaledHeight = position.y / (size.y * 0.5);
                float v =  (scaledHeight / 2.) + .5;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				writeUv = uvs;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;

				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}

				lalpha *= mask;
				
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}
`),
        spherical: new wP(`
vec3 sphericalTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {
                vec3 posN = normalize(vPosition);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float v = 0.5 + asin(posN.y) / 3.1415;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				writeUv = uvs;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;
				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}

				lalpha *= mask;

				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}
`),
        uv: new wP(`vec3 uvTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {
				vec2 uvs = ( mat * vec3( vUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				writeUv = uvs;

				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;

				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				
				lalpha *= mask;

				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}`),
        triplanar:
          new wP(`vec3 triplanarTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUvs0, out vec2 writeUvs1, out vec2 writeUvs2, out vec3 writeWeights) {
				vec3 p = position;
				vec2 uv0 = (1.0 + p.xy) / 2.0;     
				vec2 uv1 = (1.0 + p.zy) / 2.0;		
				vec2 uv2 = (1.0 + p.xz) / 2.0;		
	
				uv0 = (mat * vec3((uv0 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;
				uv1 = (mat * vec3((uv1 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;
				uv2 = (mat * vec3((uv2 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;

				// Range from 3 to 128 seems to be good
				float exponent = (1.0 - blending) * 125.0 + 3.0;

				vec3 n = vObjectNormal;
				vec3 weights = abs(normalize(n));
				weights = pow(weights, vec3(exponent));
				weights /= dot(weights, vec3(1.0));

				// Write out all sets of UVs that we generated
				writeUvs0 = uv0;
				writeUvs1 = uv1;
				writeUvs2 = uv2;
				writeWeights = weights;

				// Derivatives for LOD
				vec2 df0 = fwidth(uv0);
				vec2 df1 = fwidth(uv1);
				vec2 df2 = fwidth(uv2);
				if (df0.x > 0.5) df0.x = 0.0;
				if (df1.x > 0.5) df1.x = 0.0;
				if (df2.x > 0.5) df2.x = 0.0;

				#ifdef GL_EXT_shader_texture_lod
                	vec4 tmp = 
						texture2DLodEXT(tex, uv0, log2(max(df0.x, df0.y)*min(textureSize.x, textureSize.y))) * weights.z + 
						texture2DLodEXT(tex, uv1, log2(max(df1.x, df1.y)*min(textureSize.x, textureSize.y))) * weights.x + 
						texture2DLodEXT(tex, uv2, log2(max(df2.x, df2.y)*min(textureSize.x, textureSize.y))) * weights.y;
				#else
                	vec4 tmp = 
						textureLod(tex, uv0, log2(max(df0.x, df0.y)*min(textureSize.x, textureSize.y))) * weights.z + 
						textureLod(tex, uv1, log2(max(df1.x, df1.y)*min(textureSize.x, textureSize.y))) * weights.x + 
						textureLod(tex, uv2, log2(max(df2.x, df2.y)*min(textureSize.x, textureSize.y))) * weights.y;
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;

				// Apply cropping across all 3 planes
				if ( crop > 0.5 ) {
					if ( uv0.x < 0.0 || uv0.x > 1.0 || uv0.y < 0.0 || uv0.y > 1.0 )  {
						lalpha = 0.0;
					}
					if ( uv1.x < 0.0 || uv1.x > 1.0 || uv1.y < 0.0 || uv1.y > 1.0 )  {
						lalpha = 0.0;
					}
					if ( uv2.x < 0.0 || uv2.x > 1.0 || uv2.y < 0.0 || uv2.y > 1.0 )  {
						lalpha = 0.0;
					}
				}

				lalpha *= mask;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;//n * 0.5 + 0.5;
			}			
			`),
      };
      var _x = class extends wy {
        constructor(_, I, R, B, z, k, V, j, G, q, X, Q) {
          super("v3"),
            (this.nodeType = "Depth"),
            (this.gradientType = _),
            (this.smooth = I),
            (this.near = R),
            (this.far = B),
            (this.isVector = z),
            (this.isWorldSpace = k),
            (this.origin = V),
            (this.direction = j),
            (this.colors = G),
            (this.steps = q),
            (this.isMask = Q),
            (this.alpha = X),
            (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
        }
        generate(_, I) {
          let R = `g${this.uuid.toString().replace(/-/g, "")}`,
            B = new wP(
              `vec3 ${R}_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[${R}_MAX_COLORS], float steps[${R}_MAX_COLORS], bool isMask, float mask, float alpha, out float calpha) {
               vec4 color = colors[0];
               #ifdef ${R}_IS_VECTOR
                   #ifdef ${R}_LINEAR
                       #ifdef ${R}_WORLDSPACE
                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);
                       #else
                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);
                       #endif
                   #else
                       #ifdef ${R}_WORLDSPACE
                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);
                       #else
                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);
                       #endif
                   #endif
               #else
                   float dist = length(vWPosition - cameraPosition);
			       float depth = ( dist - near ) / ( far - near );
               #endif


              float p;
              #ifdef ${R}_SMOOTH
				for ( int i = 1; i < ${R}_MAX_COLORS; i++ ) {
						p = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}
              #else
                for ( int i = 1; i < ${R}_MAX_COLORS; i++ ) {
                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);
                   color = mix(color, colors[i], p);
                 }
              #endif

               float lalpha = alpha * color.a * mask;
               calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
			   accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));
			   
               return color.rgb;
			}`,
              [
                _x.Nodes.vectorLinearWorldSpaceDepth,
                _x.Nodes.vectorLinearObjectSpaceDepth,
                _x.Nodes.vectorSphericalObjectSpaceDepth,
                _x.Nodes.vectorSphericalWorldSpaceDepth,
              ]
            );
          if (!_.isShader("fragment"))
            return (
              console.warn(
                "DepthNode is not compatible with " + _.shader + " shader."
              ),
              _.format("vec3( 0.0 )", this.getType(_), I)
            );
          {
            _.define(`${R}_MAX_COLORS`, this.colors.value.length),
              this.smooth.value && _.define(`${R}_SMOOTH`),
              this.isVector.value > 0.5 && _.define(`${R}_IS_VECTOR`),
              0 === this.gradientType.value && _.define(`${R}_LINEAR`),
              this.isWorldSpace.value > 0.5 && _.define(`${R}_WORLDSPACE`),
              _.require("worldPosition"),
              _.addFragmentVariable(this.calpha, "float");
            let z = _.include(B),
              k = [];
            return (
              k.push(this.near.build(_, "f")),
              k.push(this.far.build(_, "f")),
              k.push(this.origin.build(_, "v3")),
              k.push(this.direction.build(_, "v3")),
              k.push(this.colors.build(_, "v4[]")),
              k.push(this.steps.build(_, "f[]")),
              k.push(this.isMask.build(_, "b")),
              k.push(
                this.mask
                  ? `luminance(${this.mask.flow(_, "v3").result})`
                  : "1.0"
              ),
              k.push(this.alpha.build(_, "f")),
              k.push(this.calpha),
              _.format(z + "(" + k.join(",") + ")", this.getType(_), I)
            );
          }
        }
      };
      _x.Nodes = {
        vectorLinearWorldSpaceDepth:
          new wP(`float vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`),
        vectorLinearObjectSpaceDepth:
          new wP(`float vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(position.x - origin.x) + n.y*(position.y - origin.y) + n.z*(position.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`),
        vectorSphericalWorldSpaceDepth:
          new wP(`float vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(vWPosition - origin);
               return ( dist - near ) / ( far - near );
            }`),
        vectorSphericalObjectSpaceDepth:
          new wP(`float vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(position - origin);
               return ( dist - near ) / ( far - near );
            }`),
      };
      var _b = class extends wy {
          constructor(_, I, R, B, z, k, V, j) {
            super("v3"),
              (this.nodeType = "Fresnel"),
              (this.color = _),
              (this.bias = I),
              (this.scale = R),
              (this.intensity = B),
              (this.factor = z),
              (this.isMask = j),
              (this.alpha = k),
              (this.mode = V),
              (this.calpha = `g${this.uuid
                .toString()
                .replace(/-/g, "")}_calpha`);
          }
          generate(_, I) {
            if (
              (_.require("vWorldViewDir"),
              _.require("worldNormal"),
              !_.isShader("fragment"))
            )
              return (
                console.warn(
                  "FresnelNode is not compatible with " + _.shader + " shader."
                ),
                _.format("vec3( 0.0 )", this.getType(_), I)
              );
            {
              _.addFragmentVariable(this.calpha, "float");
              let R =
                  new wP(`vec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, bool isMask, float mask, float alpha, int mode, out float calpha) {
					float fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );

					float lalpha = clamp(fresnel, 0.0, 1.0) * alpha * mask;
					calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
					accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

					return color;
				}`),
                B = _.include(R),
                z = [];
              return (
                z.push(this.color.build(_, "c")),
                z.push(this.bias.build(_, "f")),
                z.push(this.scale.build(_, "f")),
                z.push(this.intensity.build(_, "f")),
                z.push(this.factor.build(_, "f")),
                z.push(this.isMask.build(_, "b")),
                z.push(
                  this.mask
                    ? `luminance(${this.mask.flow(_, "v3").result})`
                    : "1.0"
                ),
                z.push(this.alpha.build(_, "f")),
                z.push(this.mode.build(_, "i")),
                z.push(this.calpha),
                _.format(B + "(" + z.join(",") + ")", this.getType(_), I)
              );
            }
          }
        },
        _w = class extends wy {
          constructor(_, I, R, B, z, k, V, j, G) {
            super("v3"),
              (this.nodeType = "Gradient"),
              (this.gradientType = _),
              (this.smooth = I),
              (this.colors = R),
              (this.steps = B),
              (this.offset = z),
              (this.morph = k),
              (this.angle = V),
              (this.isMask = G),
              (this.alpha = j),
              (this.calpha = `g${this.uuid
                .toString()
                .replace(/-/g, "")}_calpha`);
          }
          generate(_, I) {
            if (!_.isShader("fragment"))
              return (
                console.warn(
                  "GradientNode is not compatible with " + _.shader + " shader."
                ),
                _.format("vec3( 0.0 )", this.getType(_), I)
              );
            {
              _.define("GRAD_MAX", 10),
                _.require("uv"),
                (_.requires.uv = [!0]),
                _.addFragmentVariable(this.calpha, "float");
              let R = _.include(_w.Nodes.gradient),
                B = [];
              return (
                B.push(this.gradientType.build(_, "i")),
                B.push(this.smooth.build(_, "b")),
                B.push(this.colors.build(_, "v4[]")),
                B.push(this.steps.build(_, "f[]")),
                B.push(this.offset.build(_, "v2")),
                B.push(this.morph.build(_, "v2")),
                B.push(this.angle.build(_, "f")),
                B.push(this.isMask.build(_, "b")),
                B.push(
                  this.mask
                    ? `luminance(${this.mask.flow(_, "v3").result})`
                    : "1.0"
                ),
                B.push(this.alpha.build(_, "f")),
                B.push(this.calpha),
                _.format(R + "(" + B.join(",") + ")", this.getType(_), I)
              );
            }
          }
        };
      _w.Nodes = {
        gradient:
          new wP(`vec3 gradient(int gradientType, bool smoothed, vec4 colors[GRAD_MAX], float steps[GRAD_MAX], vec2 offset, vec2 morph, float angle, bool isMask, float mask, float alpha, out float calpha) {
				vec4 color = colors[0];
				vec2 m = morph / vUv.xy;
				vec2 rot = vec2( 0.5 + m.x, m.y );
				vec2 dt = vec2(
					cos( angle ) * rot.x - sin( angle ) * rot.y,
					sin( angle ) * rot.x + cos( angle ) * rot.y
				);
				vec2 pt = ( vUv - 0.5 + offset ) / 2.0 + dt / 2.0;
				float t = dot( pt, dt ) / dot( dt, dt );
				if ( gradientType == 1 ) {
					t = distance (
						( vUv + morph ) * 3.0,
						( vUv + offset ) + 1.0
					) + angle;
				} else if ( gradientType == 2 ) {
					float polar = atan(
						vUv.x + morph.x - 0.5 + offset.x,
						vUv.y + morph.y - 0.5 + offset.y
					) * -1.0;
					t = fract( ( angle / PI / -2.0 ) + 0.5 * ( polar / PI ) );
				}

				float p;
				if (smoothed) {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}

				} else {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], p);
					}
				}

				float lalpha = alpha * color.a * mask;
				calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));
				
				return color.xyz;
			}`),
      };
      var _S = class extends wy {
        constructor(_, I, R, B) {
          super("v3"),
            (this.nodeType = "Matcap"),
            (this.texture = _),
            (this.isMask = B),
            (this.alpha = I),
            (this.mode = R),
            (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
        }
        generate(_, I) {
          if (!_.isShader("fragment"))
            return (
              console.warn(
                "MatcapNode is not compatible with " + _.shader + " shader."
              ),
              _.format("vec3( 0.0 )", this.getType(_), I)
            );
          {
            _.addFragmentVariable(this.calpha, "float");
            let R = _.include(_S.Nodes.matcap);
            _.require("normal"), (_.requires.normal = !0);
            let B = [];
            return (
              B.push(this.texture.generate(_, "t")),
              B.push("normal"),
              B.push(this.isMask.build(_, "b")),
              B.push(
                this.mask
                  ? `luminance(${this.mask.flow(_, "v3").result})`
                  : "1.0"
              ),
              B.push(this.alpha.build(_, "f")),
              B.push(this.mode.build(_, "i")),
              B.push(this.calpha),
              _.format(R + "(" + B.join(",") + ")", this.getType(_), I)
            );
          }
        }
      };
      _S.Nodes = {
        matcap:
          new wP(`vec3 matcap(sampler2D matcapTex, vec3 normal, bool isMask, float mask, float alpha, int mode, out float calpha) {
					vec3 viewDir = normalize( vViewPosition );
					vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
					vec3 y = cross( viewDir, x );
					vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks
					vec4 matcapColor = texture2D( matcapTex, uv );

					float lalpha = alpha * mask;
					calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
					accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));
					
					return matcapColor.rgb;
            	}`),
      };
      var _M =
          (((_H = _M || {}).SIMPLEX = "simplex3d"),
          (_H.SIMPLEX_FRACTAL = "simplex3dFractal"),
          (_H.ASHIMA = "simplexAshima"),
          (_H.FBM = "fbm"),
          (_H.PERLIN = "perlin"),
          (_H.VORONOI = "voronoi"),
          _H),
        _C =
          ((t_ = new wP(`vec3 random3(vec3 c) {
			float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
			vec3 r;
			r.z = fract(512.0*j);
			j *= .125;
			r.x = fract(512.0*j);
			j *= .125;
			r.y = fract(512.0*j);
			return r-0.5;
		}`)),
          ((tS = new wP(
            `float simplex3d(vec3 p) {
			 vec3 s = floor(p + dot(p, vec3(F3)));
			 vec3 x = p - s + dot(s, vec3(G3));
			 
			 vec3 e = step(vec3(0.0), x - x.yzx);
			 vec3 i1 = e*(1.0 - e.zxy);
			 vec3 i2 = 1.0 - e.zxy*(1.0 - e);
				
			 vec3 x1 = x - i1 + G3;
			 vec3 x2 = x - i2 + 2.0*G3;
			 vec3 x3 = x - 1.0 + 3.0*G3;
			 
			 vec4 w, d;
			 
			 w.x = dot(x, x);
			 w.y = dot(x1, x1);
			 w.z = dot(x2, x2);
			 w.w = dot(x3, x3);
			 
			 w = max(0.6 - w, 0.0);
			 
			 d.x = dot(random3(s), x);
			 d.y = dot(random3(s + i1), x1);
			 d.z = dot(random3(s + i2), x2);
			 d.w = dot(random3(s + 1.0), x3);
			 
			 w *= w;
			 w *= w;
			 d *= w;
			 
			 return dot(d, vec4(52.0));
		}`,
            [t_]
          )).keywords.F3 = new wI("float F3 0.3333333")),
          (tS.keywords.G3 = new wI("float G3 0.1666667")),
          (tA = new wP(
            `float simplex3dFractal(vec3 m) {
			mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);
			mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);
			mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);
			return 0.5333333 * simplex3d(m * rot1)
				 + 0.2666667 * simplex3d(2.0 * m * rot2)
				 + 0.1333333 * simplex3d(4.0 * m * rot3)
				 + 0.0666667 * simplex3d(8.0 * m);
		}`,
            [tS]
          )),
          (tT = new wP(
            "vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}"
          )),
          (tP = new wP(
            "vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}"
          )),
          (tD = new wP(
            `float simplexAshima(vec3 v) {
		  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
		  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
		  vec3 i  = floor(v + dot(v, C.yyy) );
		  vec3 x0 =   v - i + dot(i, C.xxx) ;
		  vec3 g = step(x0.yzx, x0.xyz);
		  vec3 l = 1.0 - g;
		  vec3 i1 = min( g.xyz, l.zxy );
		  vec3 i2 = max( g.xyz, l.zxy );
		  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
		  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
		  vec3 x3 = x0 - 1. + 3.0 * C.xxx;
		  i = mod(i, 289.0 ); 
		  vec4 p = permute( permute( permute( 
					 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
				   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
				   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
		  float n_ = 1.0/7.0; // N=7
		  vec3  ns = n_ * D.wyz - D.xzx;
		  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)
		  vec4 x_ = floor(j * ns.z);
		  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
		  vec4 x = x_ *ns.x + ns.yyyy;
		  vec4 y = y_ *ns.x + ns.yyyy;
		  vec4 h = 1.0 - abs(x) - abs(y);
		  vec4 b0 = vec4( x.xy, y.xy );
		  vec4 b1 = vec4( x.zw, y.zw );
		  vec4 s0 = floor(b0)*2.0 + 1.0;
		  vec4 s1 = floor(b1)*2.0 + 1.0;
		  vec4 sh = -step(h, vec4(0.0));
		  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
		  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
		  vec3 p0 = vec3(a0.xy,h.x);
		  vec3 p1 = vec3(a0.zw,h.y);
		  vec3 p2 = vec3(a1.xy,h.z);
		  vec3 p3 = vec3(a1.zw,h.w);
		  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
		  p0 *= norm.x;
		  p1 *= norm.y;
		  p2 *= norm.z;
		  p3 *= norm.w;
		  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
		  m = m * m;
		  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
										dot(p2,x2), dot(p3,x3) ) );
		}`,
            [tT, tP]
          )),
          (tI = new wP(
            "vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}"
          )),
          (tR = new wP(
            "vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}",
            [tI]
          )),
          (tB = new wP(
            `float noise(vec3 p){
			vec3 a = floor(p);
			vec3 d = p - a;
			d = d * d * (3.0 - 2.0 * d);
			vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
			vec4 k1 = perm(b.xyxy);
			vec4 k2 = perm(k1.xyxy + b.zzww);
			vec4 c = k2 + a.zzzz;
			vec4 k3 = perm(c);
			vec4 k4 = perm(c + 1.0);
			vec4 o1 = fract(k3 * (1.0 / 41.0));
			vec4 o2 = fract(k4 * (1.0 / 41.0));
			vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
			vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
			return o4.y * d.y + o4.x * (1.0 - d.y);
		}`,
            [tR]
          )),
          ((tz = new wP(
            `float fbm(vec3 x) {
			float v = 0.0;
			float a = 0.5;
			vec3 shift = vec3(100);
			for (int i = 0; i < NUM_OCTAVES; ++i) {
				v += a * noise(x);
				x = x * 2.0 + shift;
				a *= 0.5;
			}
			return v;
		}`,
            [tB]
          )).keywords.NUM_OCTAVES = new wI("int NUM_OCTAVES 5")),
          (tF = new wP(
            "vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}"
          )),
          (tN = new wP(
            `float perlin(vec3 P){
		  vec3 Pi0 = floor(P);
		  vec3 Pi1 = Pi0 + vec3(1.0);
		  Pi0 = mod(Pi0, 289.0);
		  Pi1 = mod(Pi1, 289.0);
		  vec3 Pf0 = fract(P);
		  vec3 Pf1 = Pf0 - vec3(1.0);
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;
		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);
		  vec4 gx0 = ixy0 / 7.0;
		  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
		  gx0 = fract(gx0);
		  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		  vec4 sz0 = step(gz0, vec4(0.0));
		  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		  gy0 -= sz0 * (step(0.0, gy0) - 0.5);
		  vec4 gx1 = ixy1 / 7.0;
		  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
		  gx1 = fract(gx1);
		  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		  vec4 sz1 = step(gz1, vec4(0.0));
		  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		  gy1 -= sz1 * (step(0.0, gy1) - 0.5);
		  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
		  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;
		  float n000 = dot(g000, Pf0);
		  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		  float n111 = dot(g111, Pf1);
		  vec3 fade_xyz = fade(Pf0);
		  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		  return 2.2 * n_xyz;
		}`,
            [tT, tP, tF]
          )),
          (tk = new wP(`float hashwithoutsine13(vec3 p3)
		{
			p3  = fract(p3 * .1031);
			p3 += dot(p3, p3.yzx + 33.33);
			return fract((p3.x + p3.y) * p3.z);
		}`)),
          (tU = new wP(`vec3 hashwithoutsine33(vec3 p3)
		{
			p3 = fract(p3 * vec3(.1031, .1030, .0973));
			p3 += dot(p3, p3.yxz+33.33);
			return fract((p3.xxy + p3.yxx)*p3.zyx);
		}`)),
          (tV = new wP(`float metric(in vec3 p)
		{
			// L2 
			return length(p);

			// Chebyshev 
			// vec3 a = abs(p);
			// return max(a.x, max(a.y, a.z));
		}`)),
          (tj = new wP(`float smin( float a, float b, float k )
		{
			float h = smoothstep(0.0, 1.0, 0.5 + 0.5 * (b - a) / k);
			float correction = k * h * (1.0 - h);
			return mix(b, a, h) - correction;
		}`)),
          (tH = new wP(`float smax( float a, float b, float k )
		{
			float h = smoothstep(1.0, 0.0, 0.5 + 0.5 * (a - b) / k);
			float correction = k * h * (1.0 - h);
			return mix(a, b, h) + correction;
		}`)),
          (tW =
            new wP(`float remap(float value, float input_min, float input_max, float output_min, float output_max) {
			// Compute width of each interval
			float input_width = input_max - input_min;
			float output_width = output_max - output_min;
		
			// Convert input range into a 0-1 range 
			float scaled = (value - input_min) / input_width;
		
			// Convert the 0-1 range into a value in output range
			return output_min + (scaled * output_width);
		}`)),
          {
            simplex: tS,
            simplexFractal: tA,
            simplexAshima: tD,
            fbm: tz,
            perlin: tN,
            voronoi: new wP(
              `float voronoi(in vec3 x, in int style, in float smoothness, in float seed, in int quality) 
		{
			// Integer and fractional parts of this point's coordinates
			ivec3 p = ivec3(floor(x));
			vec3 f = fract(x);

			// Different variables that we will use to construct noise:
			//
			// f1: distance to the closest feature point
			// f2: distance to the second closest feature point
			// e: distance to the closest edge (cell boundary)
			//
			// We also compute "smooth" versions of all of the above quantites, essentially
			// replacing "hard" minimums with "smooth" minimums (described by IQ)
			float f1_smooth = 8.0;
			float f1 = 8.0;
			float f2_smooth = 8.0;
			float f2 = 8.0;
			float e_smooth = 8.0;
			float e = 8.0;

			// Variables stored from closest cell
			ivec3 mb;
			vec3 mr; 

			int steps = quality;
			
			for (int x = -steps; x <= steps; x++) 
			for (int y = -steps; y <= steps; y++)
			for (int z = -steps; z <= steps; z++)
			{
				ivec3 b = ivec3(x, y, z);
				vec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;
				float d = length(r);
				
				f1_smooth = smin(d, f1_smooth, smoothness);

				// Store un-smoothed distances too 
				if (d < f1) 
				{
					f2 = f1;
					f1 = d;

					mb = ivec3(x, y, z);
					mr = r;
				} 
				else if (d < f2) 
				{
					f2 = d;
				}
			}	
			
			float id = hashwithoutsine13(vec3(p + mb) + seed);

			// Second pass for edge distance  
			for (int x = -steps; x <= steps; x++) 
			for (int y = -steps; y <= steps; y++)
			for (int z = -steps; z <= steps; z++)
			{
				// Start search at the cell that contains the closest point to "x" (found in 1st pass)
				ivec3 b = mb + ivec3(x, y, z);
				vec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;
				float d1 = dot(0.5 * (mr + r), (r - mr)); 				// IQ normalizes "r - mr" but that breaks things for the smooth version?
				float d2 = dot(0.5 * (mr + r), normalize(r - mr));

				e_smooth = smin(d1, e_smooth, smoothness);

				e = min(e, d2);

				// Also compute a smooth version of F2 in this pass
				{
					ivec3 b = ivec3(x, y, z);
					if (b != mb) 
					{
						vec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;
						float d = length(r);

						f2_smooth = smin(d, f2_smooth, smoothness);
					}
				}
			}

			// Different visualization modes 
			if (style == 0) 
			{
				return f1_smooth;
			}
			if (style == 1) 
			{
				return f2_smooth;
			}
			if (style == 2) 
			{
				return f2_smooth - f1_smooth;
				
				// "Pebbles" also cool
				//return step(0.2, f2_smooth - f1_smooth);
			}
			if (style == 3) 
			{
				// This one is really good for rock / stone effects
				float a = f1; 
				float b = f2;
				float k = 3.0;
				float h = max(k - abs(a - b), 0.0) / k;
				float final = min(a, b) - h * h * k * (1.0 / 4.0);
				return final;
			}
			if (style == 4) 
			{
				// Some random adjustments to make this style stand out more 
				return exp(5.0 * e_smooth);
			}
			if (style == 5) 
			{
				return pow(f1_smooth, 3.0);
			}
			if (style == 6) 
			{				
				const float eps = 0.0125;

				// Thicker lines as the user increases the smoothness slider
				float thickness = smoothness * 0.25 + eps;

				// Blurrier lines as the user increases the smoothness slider
				float blur = pow(smoothness, 3.0) * 0.25 + eps;

				return smoothstep(
					thickness - thickness * blur, 
					thickness + thickness * blur, 
					e
				);
			}
			if (style == 7) 
			{
				return hashwithoutsine13(vec3(p + mb) + seed);
			}
		}
	`,
              [tk, tU, tV, tj, tH, tW]
            ),
          }),
        _T = class extends wy {
          constructor(
            _,
            I,
            R,
            B,
            z,
            k,
            V,
            j,
            G,
            q,
            X,
            Q,
            $,
            et,
            er,
            es,
            ea,
            en,
            eo
          ) {
            super("v3"),
              (this.nodeType = "Noise"),
              (this.scale = _),
              (this.size = I),
              (this.move = R),
              (this.fA = B),
              (this.fB = z),
              (this.distortion = k),
              (this.colorA = V),
              (this.colorB = j),
              (this.colorC = G),
              (this.colorD = q),
              (this.noiseType = Q),
              (this.voronoiStyle = et),
              (this.highCut = er),
              (this.lowCut = es),
              (this.smoothness = ea),
              (this.seed = en),
              (this.quality = eo),
              (this.isMask = $),
              (this.alpha = X),
              (this.calpha = `g${this.uuid
                .toString()
                .replace(/-/g, "")}_calpha`);
          }
          generate(_, I, R, B, z) {
            _.require("uv"),
              (_.requires.uv = [!0]),
              _.addFragmentVariable(this.calpha, "float");
            let k = Object.values(_M)[this.noiseType.value],
              V =
                "voronoi" == k
                  ? `
		float v = ${k}(st + move, voronoiStyle, smoothness, seed, quality);

		// Apply clipping to colors
		v = remap(v, lowCut, highCut, 0.0, 1.0);
		v = smax(v, 0.0, smoothness * 0.25);
		v = smin(v, 1.0, smoothness * 0.25);

		// Note that the voronoi mode only uses colors "A" and "C" from the UI 
		vec4 color = mix(colorA, colorC, v); 
		`
                  : `
		vec3 q = vec3(${k}(st),
					   ${k}(st + vec3(1.0)),
					   ${k}(st + vec3(1.0)));
		vec3 r = vec3(${k}(st + vec3(distortion, 1.0) * q + vec3(fA, 1.0) + move),
					  ${k}(st + vec3(distortion, 1.0) * q + vec3(fB, 1.0) + move), 
					  ${k}(st * q));
		float f = ${k}(st + r);
		vec4 color;
		color = mix(colorA, colorB, clamp((f * f) * 4.0, 0.0, 1.0));
		color = mix(color, colorC, clamp(length(q), 0.0, 1.0));
		color = mix(color, colorD, clamp(length(r.x), 0.0, 1.0));
		`,
              j = new wP(
                `vec3 ${k}customNoise(float scale, vec3 size, float move, vec2 fA, vec2 fB, vec2 distortion, vec4 colorA, vec4 colorB, vec4 colorC, vec4 colorD, int voronoiStyle, float highCut, float lowCut, float smoothness, float seed, int quality, bool isMask, float mask, float alpha, out float calpha) 
			{
                // Prevent scale of zero 
				scale = max(abs(scale), 0.001);

				vec3 st = position / size;
				st /= scale;

				${V}

				float lalpha = alpha * color.a * mask;
				calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return clamp(color, 0.0, 1.0).rgb;
			}`,
                [
                  _C.simplex,
                  _C.simplexFractal,
                  _C.simplexAshima,
                  _C.fbm,
                  _C.perlin,
                  _C.voronoi,
                ]
              ),
              G = _.include(j),
              q = [];
            return (
              q.push(this.scale.build(_, "f")),
              q.push(this.size.build(_, "v3")),
              q.push(this.move.build(_, "f")),
              q.push(this.fA.build(_, "v2")),
              q.push(this.fB.build(_, "v2")),
              q.push(this.distortion.build(_, "v2")),
              q.push(this.colorA.build(_, "v4")),
              q.push(this.colorB.build(_, "v4")),
              q.push(this.colorC.build(_, "v4")),
              q.push(this.colorD.build(_, "v4")),
              q.push(this.voronoiStyle.build(_, "i")),
              q.push(this.highCut.build(_, "f")),
              q.push(this.lowCut.build(_, "f")),
              q.push(this.smoothness.build(_, "f")),
              q.push(this.seed.build(_, "f")),
              q.push(this.quality.build(_, "i")),
              q.push(this.isMask.build(_, "b")),
              q.push(
                this.mask
                  ? `luminance(${this.mask.flow(_, "v3").result})`
                  : "1.0"
              ),
              q.push(this.alpha.build(_, "f")),
              q.push(this.calpha),
              _.format(G + "(" + q.join(",") + ")", this.getType(_), I)
            );
          }
        };
      _T.numOctaves = 5;
      var _D = class extends wy {
        constructor(_, I, R, B, z, k, V, j, G, q, X, Q, $, et, er, es) {
          super("v3"),
            (this.nodeType = "Outline"),
            (this.firstTime = !0),
            (this.outlineColor = _),
            (this.contourColor = I),
            (this.outlineWidth = R),
            (this.contourWidth = B),
            (this.contourThreshold = z),
            (this.outlineThreshold = k),
            (this.contourFrequency = V),
            (this.outlineSmoothing = j),
            (this.contourDirection = G),
            (this.positionalLines = q),
            (this.compensation = X),
            (this.resolution = Q),
            (this.normalMap = $),
            (this.depthMap = et),
            (this.pixelRatio = er),
            (this.alpha = es),
            (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
        }
        generate(_, I) {
          let R = `g${this.uuid.toString().replace(/-/g, "")}`;
          if (
            (_.require("vWorldViewDir"),
            _.require("worldNormal"),
            (_.extensions.derivatives = !0),
            this.compensation.value &&
              _.define("OUTLINE_COMPENSATION", `${R}_offset`),
            this.firstTime)
          ) {
            let I = this.outlineWidth.build(_, "f"),
              B = this.resolution.build(_, "v2"),
              z = this.compensation.build(_, "b"),
              k = this.pixelRatio.build(_, "f");
            _.addVertexParsVariable("randomColor", "attribute vec3"),
              _.addVertexParsVariable("extrudeNormal", "attribute vec3"),
              _.addVertexParsVariable(I, "uniform float"),
              _.addVertexParsVariable(B, "uniform vec2"),
              _.addVertexParsVariable(z, "uniform bool"),
              _.addVertexParsVariable(k, "uniform float"),
              _.addVertexParsVariable("vID", "flat out float"),
              _.addFragmentParsVariable("vID", "flat in float"),
              _.addVertexFinalCode(`
                vID = randomColor.r;
                vec2 ${R}_offset = vec2(0.0);
                if (${z}) {
                    vec4 ${R}_clipPosition = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));
                    // NOTE: For certain shapes, like spheres, we get incorrect extrusion when the
                    // normals face the camera directly. So we hackily fix this by offsetting the normal
                    // by a tiny amount.
                    vec3 ${R}_clipNormal = mat3(projectionMatrix) * (mat3(modelViewMatrix) * extrudeNormal) + 0.0000001;
                    ${R}_offset = normalize(${R}_clipNormal.xy) / ${B} * (${I} / 2.0) * ${R}_clipPosition.w * 2.0 * ${k};
                    ${R}_clipPosition.xy += ${R}_offset;
                    // TODO(MAX): To handle multiple outline layers, we only want to extrude
                    // if this offset is the biggest of all the potential offsets
                    gl_Position = ${R}_clipPosition;
                }
            `);
          }
          if (!_.isShader("fragment"))
            return (
              console.warn(
                "OutlineNode is not compatible with " + _.shader + " shader."
              ),
              ""
            );
          {
            _.require("uv"),
              (_.requires.uv = [!0]),
              _.addFragmentVariable(this.calpha, "float");
            let R = _.include(_D.Nodes.outline),
              B = [];
            return (
              B.push(this.outlineColor.build(_, "c")),
              B.push(this.contourColor.build(_, "c")),
              B.push(this.outlineWidth.build(_, "f")),
              B.push(this.contourWidth.build(_, "f")),
              B.push(this.contourThreshold.build(_, "f")),
              B.push(this.outlineThreshold.build(_, "f")),
              B.push(this.contourFrequency.build(_, "f")),
              B.push(this.outlineSmoothing.build(_, "f")),
              B.push(this.contourDirection.build(_, "v3")),
              B.push(this.positionalLines.build(_, "b")),
              B.push(this.resolution.build(_, "v2")),
              B.push(this.normalMap.getTexture(_, "t")),
              B.push(this.depthMap.getTexture(_, "t")),
              B.push(this.pixelRatio.build(_, "f")),
              B.push(this.compensation.build(_, "b")),
              B.push(
                this.mask
                  ? `luminance(${this.mask.flow(_, "v3").result})`
                  : "1.0"
              ),
              B.push(this.alpha.build(_, "f")),
              B.push(this.calpha),
              (this.firstTime = !this.firstTime),
              _.format(R + "(" + B.join(",") + ")", this.getType(_), I)
            );
          }
        }
      };
      _D.Nodes =
        ((tq = new wP(`
float sobelSample(sampler2D t, sampler2D d, vec2 uv, vec2 resolution, float outlineWidth, float pixelRatio)
{
    vec2 halton = haltonSequence[frameIndex];
    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
    float temporalAngle  = temporalOffset * PI2;

    vec2 texelSize = (vec2(1.0) / resolution);
    vec2 offsetSize = texelSize * outlineWidth * pixelRatio;

    vec2 uvSamples[9];
    vec4 normalSamples[9];

	uvSamples[0] = uv + vec2( -offsetSize.x, -offsetSize.y) + (vogelDiskSample(0, 9, temporalAngle) * texelSize);
	uvSamples[1] = uv + vec2(0.0, -offsetSize.y) + (vogelDiskSample(1, 9, temporalAngle) * texelSize);
	uvSamples[2] = uv + vec2(  offsetSize.x, -offsetSize.y) + (vogelDiskSample(2, 9, temporalAngle) * texelSize);
	uvSamples[3] = uv + vec2( -offsetSize.x, 0.0) + (vogelDiskSample(3, 9, temporalAngle) * texelSize);
	uvSamples[4] = uv;
	uvSamples[5] = uv + vec2(  offsetSize.x, 0.0) + (vogelDiskSample(5, 9, temporalAngle) * texelSize);
	uvSamples[6] = uv + vec2( -offsetSize.x, offsetSize.y) + (vogelDiskSample(6, 9, temporalAngle) * texelSize);
	uvSamples[7] = uv + vec2(0.0, offsetSize.y) + (vogelDiskSample(7, 9, temporalAngle) * texelSize);
	uvSamples[8] = uv + vec2(  offsetSize.x, offsetSize.y) + (vogelDiskSample(8, 9, temporalAngle) * texelSize);


    normalSamples[0] = texture2D(t, uvSamples[0]);
    normalSamples[1] = texture2D(t, uvSamples[1]);
    normalSamples[2] = texture2D(t, uvSamples[2]);
    normalSamples[3] = texture2D(t, uvSamples[3]);
    normalSamples[4] = texture2D(t, uvSamples[4]);
    normalSamples[5] = texture2D(t, uvSamples[5]);
    normalSamples[6] = texture2D(t, uvSamples[6]);
    normalSamples[7] = texture2D(t, uvSamples[7]);
    normalSamples[8] = texture2D(t, uvSamples[8]);

    float depthBias = 0.0001;
    // TODO(MAX): Can we somehow reduce the number of conditionals here with MATH?!
    if (normalSamples[0].a != vID && normalSamples[0].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[0]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[1].a != vID && normalSamples[1].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[1]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[2].a != vID && normalSamples[2].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[2]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[3].a != vID && normalSamples[3].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[3]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }


    if (normalSamples[4].a != vID && normalSamples[4].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[4]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[5].a != vID && normalSamples[5].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[5]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[6].a != vID && normalSamples[6].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[6]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[7].a != vID && normalSamples[7].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[7]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[8].a != vID && normalSamples[8].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[8]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    vec3 sobel_edge_h = normalSamples[2].rgb + (2.0*normalSamples[5].rgb) + normalSamples[8].rgb - (normalSamples[0].rgb + (2.0*normalSamples[3].rgb) + normalSamples[6].rgb);
  	vec3 sobel_edge_v = normalSamples[0].rgb + (2.0*normalSamples[1].rgb) + normalSamples[2].rgb - (normalSamples[6].rgb + (2.0*normalSamples[7].rgb) + normalSamples[8].rgb);

    float edgeNormal = sqrt(dot(sobel_edge_h, sobel_edge_h) + dot(sobel_edge_v, sobel_edge_v));
    return edgeNormal;
}
`)),
        {
          outline: new wP(
            `vec3 outline(vec3 outlineColor, vec3 contourColor, float outlineWidth, float contourWidth, float outlineThreshold, float contourThreshold, float outlineSmoothing, float contourFrequency, vec3 contourDirection, bool positionalLines, vec2 resolution, sampler2D normalMap, sampler2D depthMap, float pixelRatio, bool compensation, float mask, float alpha, out float calpha) {
                vec3 result = outlineColor;
                float resultAlpha = 0.0;

                vec3 N = normalize(vWNormal);
                vec2 nuv = (gl_FragCoord.xy / resolution);
                float sobelSample = compensation ? sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth / 2., pixelRatio) : sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth, pixelRatio);
                resultAlpha = smoothstep(outlineThreshold - outlineSmoothing, outlineThreshold + outlineSmoothing, sobelSample);

                //resultAlpha = 1.0;
                //result = vec3(sobelSample);

                float t = 1.0 - contourThreshold;
                if(positionalLines) {
                    vec3 NDir = position * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float f  = fract(NT * contourFrequency * 0.01);
                    float df = fwidth(NT * contourFrequency);

                    float g = smoothstep(df * (contourWidth * 0.01), df * (contourWidth * 0.01 * 2.0), f);
                    if (g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0;
                    }
                 }
                 else {
                    vec3 NDir = N * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float df = fwidth(NT * contourThreshold);
                    float f = sin(NT * 1.0 * contourFrequency);
                    float g = smoothstep(0.0, df * contourWidth, 1.0 - f);

                    if (df > (t * 0.5) && g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0 - g;
                    }
                 }

                 float lalpha = alpha * resultAlpha * mask;
                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				 
                 return result;
             }`,
            [tq]
          ),
        });
      var _O = class extends wy {
        constructor(_, I, R, B, z, k, V, j, G, q, X, Q, $, et, er, es, ea, en) {
          super("v3"),
            (this.nodeType = "Pattern"),
            (this.style = _),
            (this.projection = I),
            (this.axis = R),
            (this.blending = B),
            (this.offset = z),
            (this.colorA = k),
            (this.colorB = V),
            (this.frequency = j),
            (this.size = G),
            (this.variation = q),
            (this.smoothness = X),
            (this.zigzag = Q),
            (this.rotation = $),
            (this.vertical = et),
            (this.horizontal = er),
            (this.sides = es),
            (this.isMask = en),
            (this.alpha = ea),
            (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
        }
        generate(_, I) {
          if (!_.isShader("fragment"))
            return (
              console.warn(
                "PatterNode is not compatible with " + _.shader + " shader."
              ),
              _.format("vec3(0.0)", this.getType(_), I)
            );
          {
            let R;
            switch (
              (_.require("position"),
              _.require("uv"),
              (_.requires.uv = [!0]),
              _.require("normal"),
              (_.requires.normal = !0),
              _.addFragmentVariable(this.calpha, "float"),
              this.style.value)
            ) {
              case 0:
              default:
                R = "circle";
                break;
              case 1:
                R = "ring";
                break;
              case 2:
                R = "polygon";
                break;
              case 3:
                R = "xcross";
                break;
              case 4:
                R = "diamond";
                break;
              case 5:
                R = "checkerboard";
                break;
              case 6:
                R = "line";
                break;
              case 7:
                R = "wave";
            }
            let B = `g${this.uuid.toString().replace(/-/g, "")}`,
              z = new wP(`float hashwithoutsine12(vec2 p)
				{
					vec3 p3 = fract(vec3(p.xyx) * .1031);
					p3 += dot(p3, p3.yzx + 33.33);
					return fract((p3.x + p3.y) * p3.z);
				}`),
              k = new wP(`vec2 rotate_uv(in vec2 uv, float a, bool repeat) 
				{
					const float mid = 0.5;
					float radians = a * (PI / 180.0);
					vec2 rotated = vec2(
						cos(radians) * (uv.x - mid) + sin(radians) * (uv.y - mid) + mid,
						cos(radians) * (uv.y - mid) - sin(radians) * (uv.x - mid) + mid
					);
					return repeat ? fract(rotated): rotated;
				}`),
              V = "";
            if (4 === this.projection.value) {
              let _ =
                  2 === this.style.value
                    ? `${R}(uv0, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)`
                    : `${R}(uv0, frequency, size, variation, smoothness_remapped, zigzag, rotation)`,
                I =
                  2 === this.style.value
                    ? `${R}(uv1, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)`
                    : `${R}(uv1, frequency, size, variation, smoothness_remapped, zigzag, rotation)`,
                B =
                  2 === this.style.value
                    ? `${R}(uv2, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)`
                    : `${R}(uv2, frequency, size, variation, smoothness_remapped, zigzag, rotation)`;
              V = `
				vec3 p = position;
				float factor = 0.0125;
				vec2 uv0 = fract(p.xy * factor);
				vec2 uv1 = fract(p.zy * factor);
				vec2 uv2 = fract(p.xz * factor);
				
				uv0 = rotate_uv(uv0 + offset, rotation, true);
				uv1 = rotate_uv(uv1 + offset, rotation, true);
				uv2 = rotate_uv(uv2 + offset, rotation, true);
	
				float d0 = ${_};
				float d1 = ${I};
				float d2 = ${B};
				
				// Range from 3 to 128 seems to be good
				float exponent = (1.0 - blending) * 125.0 + 3.0;

				vec3 n = vObjectNormal;
				vec3 weights = abs(normalize(n));
				weights = pow(weights, vec3(exponent));
				weights /= dot(weights, vec3(1.0));
				d0 *= weights.z;
				d1 *= weights.x;
				d2 *= weights.y;
				float draw = d0 + d1 + d2;
	
				vec2 custom_uv = uv0 * weights.z + uv1 * weights.x + uv2 * weights.y;
				`;
            } else {
              let _ =
                  2 === this.style.value
                    ? `${R}(custom_uv, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)`
                    : `${R}(custom_uv, frequency, size, variation, smoothness_remapped, zigzag, rotation)`,
                I = "";
              0 === this.axis.value
                ? (I = `float radius = length(p);
					float theta = atan(p.y, p.z);
					float phi = acos(p.x / radius);`)
                : 1 === this.axis.value
                ? (I = `float radius = length(p);
					float theta = atan(p.x, p.z);
					float phi = acos(p.y / radius);`)
                : (this.axis.value,
                  (I = `float radius = length(p);
					float theta = atan(p.y, p.x);
					float phi = acos(p.z / radius);`));
              let B = "";
              switch (this.projection.value) {
                case 0:
                  B = "custom_uv = vUv.st;";
                  break;
                case 1:
                case 3:
                  break;
                case 2:
                  B = `
							vec3 p = position;
							${I}
							custom_uv = vec2(theta, phi);
							custom_uv /= PI;
							`;
              }
              V = `
				vec2 custom_uv;
				${B}
	
				custom_uv += offset;
				custom_uv = fract(custom_uv);
				custom_uv = rotate_uv(custom_uv, rotation, true);
	
				float draw = ${_};
				`;
            }
            let j = new wP(
                `vec3 ${B}_pattern(vec3 normal, float blending, int style, vec2 offset, vec4 colorA, vec4 colorB, vec2 frequency, float size, float variation, float smoothness, float zigzag, float rotation, vec2 vertical, vec2 horizontal, int sides, bool isMask, float mask, float alpha, out float calpha) {
					const float TWO_PI = PI * 2.0;
					float smoothness_remapped = pow(smoothness, 5.0);	

					${V}

					// Construct final output color
					vec4 color = mix(colorA, colorB, draw);
					color.a = clamp(color.a, 0.0, 1.0);

					// Apply cuts
					color.a *= 
						step(vertical.x, custom_uv.y) * 
						step(custom_uv.y, vertical.y);
					color.a *= 
						step(horizontal.x, abs(custom_uv.x)) * 
						step(abs(custom_uv.x), horizontal.y);

					// Accumulate alpha 
					float lalpha = alpha * clamp(color.a, 0.0, 1.0) * mask;
					calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
					accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

					return clamp(color, 0.0, 1.0).rgb;
				}`,
                [
                  k,
                  z,
                  _O.DrawFunctions.circle,
                  _O.DrawFunctions.ring,
                  _O.DrawFunctions.polygon,
                  _O.DrawFunctions.cross,
                  _O.DrawFunctions.diamond,
                  _O.DrawFunctions.checkerboard,
                  _O.DrawFunctions.line,
                  _O.DrawFunctions.wave,
                ]
              ),
              G = _.include(j),
              q = [];
            return (
              q.push("normal"),
              q.push(this.blending.build(_, "f")),
              q.push(this.style.build(_, "i")),
              q.push(this.offset.build(_, "v2")),
              q.push(this.colorA.build(_, "v4")),
              q.push(this.colorB.build(_, "v4")),
              q.push(this.frequency.build(_, "v2")),
              q.push(this.size.build(_, "f")),
              q.push(this.variation.build(_, "f")),
              q.push(this.smoothness.build(_, "f")),
              q.push(this.zigzag.build(_, "f")),
              q.push(this.rotation.build(_, "f")),
              q.push(this.vertical.build(_, "v2")),
              q.push(this.horizontal.build(_, "v2")),
              q.push(this.sides.build(_, "i")),
              q.push(this.isMask.build(_, "b")),
              q.push(
                this.mask
                  ? `luminance(${this.mask.flow(_, "v3").result})`
                  : "1.0"
              ),
              q.push(this.alpha.build(_, "f")),
              q.push(this.calpha),
              _.format(G + "(" + q.join(",") + ")", this.getType(_), I)
            );
          }
        }
      };
      _O.DrawFunctions =
        ((tX = new wP(`float hashwithoutsine12(vec2 p) {
				vec3 p3 = fract(vec3(p.xyx) * 0.1031);
				p3 += dot(p3, p3.yzx + 33.33);
				return fract((p3.x + p3.y) * p3.z);
			}`)),
        (tQ = new wP(
          `vec2 tile_and_center(in vec2 uv, in vec2 frequency, in float variation, in float zigzag, in float rotation) {
                // Create tiles in UV-space
                uv *= frequency;

                // Integer coords
                vec2 i = floor(uv);

                // Offset every other row based on zigzag param, then compute fractional coords
                float row_offset = mod(i.y, 2.0);
                uv.x += row_offset * zigzag;
                vec2 f = fract(uv);

				// Rotate the tile itself:
				// const float mid = 0.5;
				// f = vec2(
				// 	cos(rotation) * (f.x - mid) + sin(rotation) * (f.y - mid) + mid,
				// 	cos(rotation) * (f.y - mid) - sin(rotation) * (f.x - mid) + mid
				// );
				// f = fract(f);

                f = f * 2.0 - 1.0;

				// Recompute integer coords after shifting - then, random value per tile 
				i = floor(uv);
				float rand = (hashwithoutsine12(i) * 5.0 + 1.0);
				float jitter = mix(1.0, rand, variation);
				f *= jitter;

                return f;
            }`,
          [tX]
        )),
        (tZ = new wP(
          `float circle(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
                return smoothstep(
                    -smoothness, 
                     smoothness, 
                     length(f) - size
                );
            }`,
          [tQ]
        )),
        (tK = new wP(
          `float ring(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);

				float d = length(f);
                const float inner_width = 0.5;

                float outer = smoothstep(-smoothness, smoothness, d - size);
                float inner = smoothstep(-smoothness, smoothness, d - size * inner_width);
				return outer + (1.0 - inner);   
            }`,
          [tQ]
        )),
        (tJ = new wP(
          `float sdf_ngon(in vec2 p, in float r, in int n) {
                float an = (PI * 2.0) / float(n);
                float he = r * tan(0.5 * an);
                
                // Rotate to first sector
                p = -p.yx; 
                float bn = an * floor((atan(p.y, p.x) + 0.5 * an) / an);
                vec2  cs = vec2(cos(bn), sin(bn));
                p = mat2(cs.x, -cs.y, cs.y, cs.x)*p;
            
                // Side of polygon
                return length(p - vec2(r, clamp(p.y, -he, he))) * sign(p.x - r);
            }
            
            float polygon(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation, in int sides) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
                return smoothstep(-smoothness, smoothness, sdf_ngon(f, size, sides));
            }`,
          [tQ]
        )),
        (t$ = new wP(
          `float sdf_cross(in vec2 p, in vec2 b, float r ) {
                p = abs(p); 
				p = (p.y > p.x) ? p.yx : p.xy;
                vec2  q = p - b;
                float k = max(q.y, q.x);
                vec2  w = (k > 0.0) ? q : vec2(b.y - p.x, -k);
                return sign(k) * length(max(w, 0.0)) + r;
            }
            
            // Avoid namespace conflicts 
            float xcross(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
                return smoothstep(-smoothness, smoothness, sdf_cross(f, vec2(size, size * 0.25), smoothness));
            }`,
          [tQ]
        )),
        (t0 = new wP(
          `float ndot(vec2 a, vec2 b) { 
                return a.x*b.x - a.y*b.y; 
            }
            
            float sdf_diamond(in vec2 p, in vec2 b) {
                p = abs(p);
                float h = clamp(ndot(b - 2.0 * p, b) / dot(b, b), -1.0, 1.0);
                float d = length(p - 0.5 * b * vec2(1.0 - h, 1.0 + h));
                return d * sign(p.x * b.y + p.y * b.x - b.x * b.y);
            }

            float diamond(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
	            return smoothstep(-smoothness, smoothness, sdf_diamond(f, vec2(size)));
            }`,
          [tQ]
        )),
        (t2 =
          new wP(`float checkerboard(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                uv *= frequency;
                vec2 i = floor(uv);

                float offset = mod(i.y, 2.0);

                uv.x += offset + zigzag * offset;
                float x = floor(uv.x);
                
                return mod(x, 2.0);
            }`)),
        (t3 = new wP(
          `float line(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, 0.0, zigzag, rotation);
				
				// Different approach for variation param here
				float row = floor(uv * frequency).y;
				float rand = hashwithoutsine12(vec2(row));
				float s = mix(size, size * rand, variation);

				return smoothstep(
					s - smoothness, 
					s + smoothness, 
					abs(f.y)
				);
            }`,
          [tQ]
        )),
        {
          tileAndCenter: tQ,
          circle: tZ,
          ring: tK,
          polygon: tJ,
          cross: t$,
          diamond: t0,
          checkerboard: t2,
          line: t3,
          wave: new wP(`// Uses bisection 
            float udf_cos(in vec2 p, in float a, in float b, in float c, in float d) {
                // Convert all data to a primitive cosine wave
                p = c * (p - vec2(d, a));
                
                const float TWO_PI = PI * 2.0;

                // Reduce to principal half cycle
                p.x = mod(p.x, TWO_PI); 
                if (p.x > PI) {
                    p.x = TWO_PI - p.x;
                }
            
                // Find zero of derivative (minimize distance)
                float xa = 0.0;
                float xb = TWO_PI;

                // 24 bit precision
                for (int i = 0; i < 24; i++) {
                    float x = 0.5 * (xa + xb);
                    float y = x - p.x + b * c * sin(x) * (p.y - b * c * cos(x));
                    if (y < 0.0) xa = x; 
                    else xb = x;
                }
                float x = 0.5 * (xa + xb);
                
                // Compute distance    
                vec2 q = vec2(x, b * c * cos(x));
                return length(p - q) / c;
            }

            float wave(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                float repeat = frequency.x;
                uv *= repeat;
                vec2 i = floor(uv);
                float row_offset = mod(i.y, 2.0);
                uv.x += row_offset * zigzag;
                vec2 f = vec2(uv.x, fract(uv.y));

                // Generalized cosine: y(x) = a + b * cos(cx + d)
                const float amplitude = 0.125;
                float wave_frequency = frequency.y * 0.1;
                float distance_estimate = udf_cos(f, 0.50, amplitude, wave_frequency * (2.0 * PI), 0.0);

				// Different approach for variation param here
				float rand = hashwithoutsine12(vec2(i.y));
				float s = mix(size, size * rand, variation);

                return smoothstep(-smoothness, smoothness, distance_estimate - s * 0.5);
            }`),
        });
      var _I = class extends wy {
        constructor(_, I, R, B, z, k, V, j) {
          super("v3"),
            (this.nodeType = "Rainbow"),
            (this.filmThickness = _),
            (this.movement = I),
            (this.wavelengths = R),
            (this.noiseStrength = B),
            (this.noiseScale = z),
            (this.offset = k),
            (this.isMask = j),
            (this.alpha = V),
            (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
        }
        generate(_, I) {
          if (
            (_.require("vWorldViewDir"),
            _.require("worldNormal"),
            !_.isShader("fragment"))
          )
            return (
              console.warn(
                "RainbowNode is not compatible with " + _.shader + " shader."
              ),
              _.format("vec3( 0.0 )", this.getType(_), I)
            );
          {
            _.require("uv"),
              (_.requires.uv = [!0]),
              _.addFragmentVariable(this.calpha, "float");
            let R = _.include(_I.Nodes.rainbow),
              B = [];
            return (
              B.push(this.filmThickness.build(_, "f")),
              B.push(this.movement.build(_, "f")),
              B.push(this.wavelengths.build(_, "v3")),
              B.push(this.noiseStrength.build(_, "f")),
              B.push(this.noiseScale.build(_, "f")),
              B.push(this.offset.build(_, "v3")),
              B.push(this.isMask.build(_, "b")),
              B.push(
                this.mask
                  ? `luminance(${this.mask.flow(_, "v3").result})`
                  : "1.0"
              ),
              B.push(this.alpha.build(_, "f")),
              B.push(this.calpha),
              _.format(R + "(" + B.join(",") + ")", this.getType(_), I)
            );
          }
        }
      };
      _I.Nodes =
        ((t4 = new wP(
          `vec3 attenuation(vec3 wavelengths, float filmThickness, float movement, float noiseStrength, float noiseScale, vec3 offset) {
                 vec3 st = position / noiseScale;
				 vec3 q = vec3(simplex3d(st),
							  simplex3d(st + vec3(1.0)),
							  simplex3d(st + vec3(1.0)));

				 vec3 r = vec3(simplex3d(st + vec3(1.4, 1.3, 1.0) * q + vec3(1.7, 9.2, 1.0)),
							  simplex3d(st + vec3(2.0, 1.2, 1.0) * q + vec3(8.3, 2.8, 1.0)),
							  simplex3d(st * q));

                 float noise = simplex3d(st + r);

                 return .5 + .5 * cos((((filmThickness + (noise * noiseStrength)) / (vec3(wavelengths.r * 1.0, wavelengths.g * 0.8, wavelengths.b * 0.6) + 1.0)) * dot(normalize(vWorldViewDir + (offset * -0.001)), normalize(vWNormal))) + movement);
             }`,
          [_C.simplex]
        )),
        {
          rainbow: new wP(
            `vec3 rainbow(float filmThickness, float movement, vec3 wavelengths, float noiseStrength, float noiseScale, vec3 offset, bool isMask, float mask, float alpha, out float calpha) {
				vec3 res = clamp(attenuation(wavelengths, filmThickness, movement, noiseStrength, noiseScale, offset), 0.0, 2.0);

				float rainbowContribution = clamp(res.r + res.g + res.b, 0.0, 1.0);

				float lalpha = alpha * rainbowContribution * mask;
				calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return res;
             }`,
            [t4]
          ),
        });
      var _R = class extends wy {
        constructor(_, I, R, B, z, k, V, j, G, q) {
          super("v3"),
            (this.nodeType = "Toon"),
            (this.positioning = _),
            (this.colors = I),
            (this.steps = R),
            (this.source = B),
            (this.isWorldSpace = z),
            (this.noiseStrength = k),
            (this.noiseScale = V),
            (this.shadowColor = j),
            (this.offset = G),
            (this.alpha = q),
            (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
        }
        generate(_, I) {
          if (
            (_.require("worldNormal"),
            _.require("worldPosition"),
            !_.isShader("fragment"))
          )
            return (
              console.warn(
                "ToonNode is not compatible with " + _.shader + " shader."
              ),
              _.format("vec3( 0.0 )", this.getType(_), I)
            );
          {
            _.define("COLORS_MAX", 10),
              _.addFragmentVariable(this.calpha, "float");
            let R = _.include(_R.Nodes.toon),
              B = [];
            return (
              B.push(this.positioning.build(_, "i")),
              B.push(this.colors.build(_, "v4[]")),
              B.push(this.steps.build(_, "f[]")),
              B.push(this.source.build(_, "v3")),
              B.push(this.isWorldSpace.build(_, "b")),
              B.push(this.noiseStrength.build(_, "f")),
              B.push(this.noiseScale.build(_, "f")),
              B.push(this.shadowColor.build(_, "v4")),
              B.push(this.offset.build(_, "v3")),
              B.push(
                this.mask
                  ? `luminance(${this.mask.flow(_, "v3").result})`
                  : "1.0"
              ),
              B.push(this.alpha.build(_, "f")),
              B.push(this.calpha),
              _.format(R + "(" + B.join(",") + ")", this.getType(_), I)
            );
          }
        }
      };
      _R.Nodes =
        ((t5 = new wP(`float rand(float n) {
				return fract(sin(n) * 43758.5453123);
			}`)),
        (t6 = new wP(`float hash1(float p) { 
				p = fract(p * 0.011); 
				p *= p + 7.5; 
				p *= p + p; 
				return fract(p); 
			}`)),
        (t8 = new wP(
          `float valueNoise(vec3 x) {
				const vec3 step = vec3(110, 241, 171);
			
				vec3 i = floor(x);
				vec3 f = fract(x);
			 
				// For performance, compute the base input to a 1D hash from the integer part of the argument and the 
				// incremental change to the 1D based on the 3D -> 1D wrapping
				float n = dot(i, step);
			
				vec3 u = f * f * (3.0 - 2.0 * f);
				return mix(mix(mix( hash1(n + dot(step, vec3(0, 0, 0))), hash1(n + dot(step, vec3(1, 0, 0))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 0))), hash1(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
						   mix(mix( hash1(n + dot(step, vec3(0, 0, 1))), hash1(n + dot(step, vec3(1, 0, 1))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 1))), hash1(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
			}`,
          [t6]
        )),
        (t9 = new wP(`vec3 hash3(vec3 x) {
				x = vec3(dot(x,vec3(127.1, 311.7, 74.7)),
						 dot(x,vec3(269.5, 183.3, 246.1)),
						 dot(x,vec3(113.5, 271.9, 124.6)));
			
				return fract(sin(x)*43758.5453123);
			}`)),
        (t7 = new wP(
          `vec3 voronoiNoise(in vec3 x)
			{
				vec3 p = floor(x);
				vec3 f = fract(x);

				float id = 0.0;
				vec2 res = vec2(100.0);

				for(int k=-1; k<=1; k++)
				for(int j=-1; j<=1; j++)
				for(int i=-1; i<=1; i++)
				{
					vec3 b = vec3(float(i), float(j), float(k));

					// Comment out the "+ hash(p + b);" part below to get "square" cells
					vec3 r = vec3(b) - f + hash3(p + b);
					float d = dot(r, r);

					if (d < res.x)
					{
						id = dot(p + b, vec3(1.0, 57.0, 113.0));
						res = vec2(d, res.x);			
					}
					else if (d < res.y)
					{
						res.y = d;
					}
				}

				return vec3(sqrt(res), abs(id));
			}
			`,
          [t9]
        )),
        {
          toon: new wP(
            `vec3 toon(int positioning, vec4 colors[COLORS_MAX], float steps[COLORS_MAX], vec3 source, bool isWorldSpace, float noiseStrength, float noiseScale, vec4 shadowColor, vec3 offset, float mask, float alpha, out float calpha) {
				float t = 0.0;
				float shadow = 1.0;

				if (positioning == 0) {

					// Can't do this mode if lighting is "none"
					#if (defined(PHONG) || defined(LAMBERT) || defined(STANDARD))

						// Algorithm from Chapter 10 of Graphics Shaders
						const vec3 weights = vec3(0.2125, 0.7154, 0.0721);
						vec3 lpos;
						vec3 l;
						float dproduct;

						#if (NUM_POINT_LIGHTS > 0)

							#if defined(USE_SHADOWMAP) && (NUM_POINT_LIGHT_SHADOWS > 0)
								PointLightShadow pointLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_POINT_LIGHTS; i++) {
								// Light positions are in view-space for some reason?
								lpos = (inverse(viewMatrix) * vec4(pointLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								
								// TODO: we want to use "intensity" but it isn't available in the shader code
								//dproduct += dot(pointLights[UNROLLED_LOOP_INDEX].color, weights);

								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS)
									pointLightShadow = pointLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getPointShadow( 
											pointShadowMap[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowMapSize, 
											pointLightShadow.shadowBias, 
											pointLightShadow.shadowRadius,
											vPointShadowCoord[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowCameraNear, 
											pointLightShadow.shadowCameraFar);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_DIR_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_DIR_LIGHT_SHADOWS > 0)
								DirectionalLightShadow directionalLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_DIR_LIGHTS; i++) {
								// Use the direction vector for directional lights instead
								l = (inverse(viewMatrix) * vec4(directionalLights[UNROLLED_LOOP_INDEX].direction, 0.0)).xyz;
		
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS)
									directionalLightShadow = directionalLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow( 
										UNROLLED_LOOP_INDEX,
										directionalShadowMap[UNROLLED_LOOP_INDEX], 
										directionalLightShadow.shadowMapSize, 
										directionalLightShadow.shadowBias, 
										directionalLightShadow.shadowRadius, 
										vDirectionalShadowCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_SPOT_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_SPOT_LIGHT_SHADOWS > 0)
								SpotLightShadow spotLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_SPOT_LIGHTS; i++) {
								lpos = (inverse(viewMatrix) * vec4(spotLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS)
									spotLightShadow = spotLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow(
										UNROLLED_LOOP_INDEX,
										spotShadowMap[UNROLLED_LOOP_INDEX], 
										spotLightShadow.shadowMapSize, 
										spotLightShadow.shadowBias, 
										spotLightShadow.shadowRadius, 
										vSpotLightCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						t = clamp(t, 0.0, 1.0);
				
					#endif

				} else if (positioning == 1) {
					
					vec3 origin = mix(position, worldPosition, float(isWorldSpace));
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	

				} else {

					vec3 origin = worldPosition;
					vec3 source = cameraPosition - offset;
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	
					
				}

				if (noiseStrength > 0.0) {
					// Distort with noise
					vec3 st = position / noiseScale;
					
					// Voronoi "smooth" noise
					float noise = 1.0 - voronoiNoise(st).x;

					// Voronoi cellular noise
					//float noise = 1.0 - rand(voronoiNoise(st).z);

					// Position warp noise
					// vec3 offset = vec3(
					// 	simplex3d(st),
					// 	simplex3d(st + vec3(111.1, 143.89, 217.19)),
					// 	simplex3d(st + vec3(171.1, 247.89, 117.23))
					// );
					// st += offset;
					// float noise = valueNoise(st);

					t += noise * noiseStrength;
				}

				t = clamp(t, 0.0, 1.0);

				// Compute ramp color
				float p;
				vec4 color = colors[0];
				for (int i = 1; i < COLORS_MAX; i++) {
					p = clamp((t - steps[i-1]) / (steps[i] - steps[i-1]), 0.0, 1.0);
					color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
				}

				// Incorporate custom shadow color
				if (positioning == 0) {

					vec3 blendedShadow = mix(color.rgb, shadowColor.rgb, shadowColor.a);
					color.rgb = mix(blendedShadow, color.rgb, shadow);
				
				}

				// Accumulate alpha as usual
				float lalpha = alpha * color.a * mask;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;

				return color.xyz;

            }`,
            [_C.simplex, t5, t8, t7]
          ),
        });
      var _z = {
          textureBicubic: new wP(`float w0( float a ) {
            return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
        }
    
        float w1( float a ) {
            return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
        }
    
        float w2( float a ){
            return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
        }
    
        float w3( float a ) {
            return ( 1.0 / 6.0 ) * ( a * a * a );
        }
    
        // g0 and g1 are the two amplitude functions
        float g0( float a ) {
            return w0( a ) + w1( a );
        }
    
        float g1( float a ) {
            return w2( a ) + w3( a );
        }
    
        // h0 and h1 are the two offset functions
        float h0( float a ) {
            return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
        }
    
        float h1( float a ) {
            return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
        }
    
        vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
            uv = uv * texelSize.zw + 0.5;
    
            vec2 iuv = floor( uv );
            vec2 fuv = fract( uv );
    
            float g0x = g0( fuv.x );
            float g1x = g1( fuv.x );
            float h0x = h0( fuv.x );
            float h1x = h1( fuv.x );
            float h0y = h0( fuv.y );
            float h1y = h1( fuv.y );
    
            vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
            vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
            vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
            vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
    
            return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) + 
                   g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
        }

        vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
            vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
            vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
            vec2 fLodSizeInv = 1.0 / fLodSize;
            vec2 cLodSizeInv = 1.0 / cLodSize;
            vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
            vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
            return mix( fSample, cSample, fract( lod ) );
        }`),
        },
        _F = class extends wy {
          constructor(_, I, R, B, z, k, V, j) {
            super("v3"),
              (this.nodeType = "Transmission"),
              (this.thickness = _),
              (this.ior = I),
              (this.roughness = R),
              (this.transmissionSamplerSize = B),
              (this.transmissionSamplerMap = z),
              (this.transmissionDepthMap = k),
              (this.aspectRatio = V),
              (this.alpha = j),
              (this.calpha = `g${this.uuid
                .toString()
                .replace(/-/g, "")}_calpha`);
          }
          generate(_, I) {
            if (
              ((_.extensions.shaderTextureLOD = !0),
              (_.extensions.derivatives = !0),
              !_.isShader("fragment"))
            )
              return (
                console.warn(
                  "TransmissionNode is not compatible with " +
                    _.shader +
                    " shader."
                ),
                _.format("vec3( 0.0 )", this.getType(_), I)
              );
            {
              _.define("NUM_SAMPLES", 6),
                _.define("BLUR_SLOD", Math.pow(2, _j.transmissionLod.value)),
                _.require("worldPosition"),
                (_.requires.worldNormal = !0),
                (_.requires.modelMatrix = !0),
                (_.requires.projectionMatrix = !0),
                _.addFragmentVariable(this.calpha, "float");
              let R = _.include(_F.Nodes.transmission),
                B = [];
              return (
                B.push(this.thickness.build(_, "f")),
                B.push(this.ior.build(_, "f")),
                B.push(this.roughness.build(_, "f")),
                B.push(this.transmissionSamplerSize.build(_, "v2")),
                B.push(this.transmissionSamplerMap.getTexture(_, "t")),
                B.push(this.transmissionDepthMap.getTexture(_, "t")),
                B.push(this.aspectRatio.build(_, "v2")),
                B.push("normal"),
                B.push(
                  this.mask
                    ? `luminance(${this.mask.flow(_, "v3").result})`
                    : "1.0"
                ),
                B.push(this.alpha.build(_, "f")),
                B.push(this.calpha),
                _.format(R + "(" + B.join(",") + ")", this.getType(_), I)
              );
            }
          }
        };
      _F.Nodes =
        ((it =
          new wP(`vec3 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {
                // Slightly modified version of this:
                // https://www.shadertoy.com/view/ltScRG

				// Special case for blur == 0.0
				if (lod == 0.0) {
					#ifdef TEXTURE_LOD_EXT
					return texture2DLodEXT( sp, U, 0.0).rgb;
					#else
					return textureLod( sp, U, 0.0).rgb;
					#endif
				}
				
				vec2 texelSize = vec2(1.0) / resolution;
                vec2 halton = haltonSequence[frameIndex];
                float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
                float temporalAngle  = temporalOffset * PI2;
				vec3 res = vec3(0.0);
                vec2 uv = vec2(0.0);
                vec2 offset = vec2(0.0);
                vec2 vogelSample = vec2(0.0);
                for (int i = 0; i < NUM_SAMPLES; i++) {
                    vogelSample =  vogelDiskSample(i, NUM_SAMPLES, temporalAngle) * texelSize;
                    offset = vogelSample * scale * (lod * 10.0); // TODO: used to be hardcoded to 20
                    uv = U + offset;
                    float opaqueDepth = unpackRGBAToDepth(textureLod(dm, uv, lod));
                    if (opaqueDepth != 0.0 && opaqueDepth < gl_FragCoord.z) {
                        uv = unrefractedU;
                        lod = lod > 4.0 ? lod : lod / 2.0;
                    }
                    res += textureLod(sp, uv, lod).rgb;
                }
                return res / float(NUM_SAMPLES);
            }`)),
        (ii =
          new wP(`vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		        // Direction of refracted light.
		        vec3 refractionVector = refract( -v,  n, 1.0 / ior );
		        
				// Compute rotation-independant scaling of the model matrix.
		        vec3 modelScale;
		        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );

		        // The thickness is specified in local space
		        return normalize( refractionVector ) * thickness * modelScale;
	        }`)),
        (ir = new wP(`float applyIorToRoughness( float roughness, float ior ) {
				// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
				// an IOR of 1.5 results in the default amount of microfacet refraction.
				return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
			}`)),
        (is = new wP(
          `vec3 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {
				// Threejs exports do not pass a depth map to this shader, so we have to fallback to the "Threejs method of blurring" - see
				// also the code in convertTransmission.ts, which runs during export
				#ifdef IS_THREEJS_EXPORT
					float lod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness / 5.0, ior);
					return textureBicubic(transmissionSamplerMap, fragCoord.xy, lod).rgb;
				#else
					float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
					float lod = applyIorToRoughness(roughness, ior);
					return blur(transmissionSamplerMap, fragCoord, vec2(lod), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);
				#endif
			}`,
          [_z.textureBicubic, ir, it]
        )),
        (il = new wP(
          `vec3 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;

				// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
				vec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;

				vec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );
				vec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;
				unrefractedCoords += 1.0;
				unrefractedCoords /= 2.0;

				// Sample framebuffer to get pixel the refracted ray hits.
				return getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );
    		}`,
          [is, ii]
        )),
        {
          transmission: new wP(
            `vec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float mask, float alpha, out float calpha) {
                vec3 v = vec3(0.);
                if (isOrthographic) {
                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
                } else {
                    v = normalize(vWPosition - cameraPosition);
                }
                vec3 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );
                
				float lalpha = alpha * mask;
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * alpha;

				return transmission;
            }`,
            [il]
          ),
        });
      var _k = (((_W = _k || {}).NOISE = "noise"), (_W.MAP = "map"), _W),
        _V = class extends wy {
          constructor(_, I, R, B, z, k, V, j, G, q, X) {
            super("v3"),
              (this.displacementTypeIndex = new _t(0)),
              (this.nodeType = "VertexDisplacement"),
              (this.intensity = _),
              (this.movementOrTexture = I),
              "map" === Object.values(_k)[this.displacementTypeIndex.value] &&
                (this.mat = new _c(this.movementOrTexture.value.matrix)),
              (this.cropOrOffset = R),
              (this.scale = q),
              (this.noiseFunctionIndex = X),
              (this.voronoiStyle = B),
              (this.smoothness = z),
              (this.seed = k),
              (this.highCut = V),
              (this.lowCut = j),
              (this.quality = G);
          }
          generate(_, I) {
            if (!_.isShader("vertex"))
              return (
                console.warn(
                  "VertexDisplacementNode is not compatible with " +
                    _.shader +
                    " shader."
                ),
                _.format("vec3( 0.0 )", this.getType(_), I)
              );
            {
              _.define("USE_LAYER_DISPLACE");
              let R,
                B = [];
              switch (
                (B.push("displaced_position"),
                B.push("displaced_normal"),
                Object.values(_k)[this.displacementTypeIndex.value])
              ) {
                case "map":
                  (R = _.include(_V.Nodes.map)),
                    B.push(this.movementOrTexture.getTexture(_, "t")),
                    B.push("uv"),
                    B.push(this.cropOrOffset.build(_, "f")),
                    this.mat && B.push(this.mat.build(_, "mat3"));
                  break;
                case "noise": {
                  let I = Object.values(_M)[this.noiseFunctionIndex.value],
                    z = new wP(`vec3 orthogonal(vec3 v) {
							return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
						}`),
                    k =
                      "voronoi" == I
                        ? `
					float v = ${I}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1), voronoiStyle, smoothness, seed, quality);
					v = remap(v, lowCut, highCut, 0.0, 1.0);
					v = smax(v, 0.0, smoothness * 0.25);
					v = smin(v, 1.0, smoothness * 0.25);

					return p + n * v * intensity;
					`
                        : `
					return p + n * ${I}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1)) * intensity;
					`,
                    V = new wP(
                      `vec3 distorted(vec3 p, vec3 n, float scale, float intensity, vec3 offset, float neighbour_offset, float movement, int voronoiStyle, float smoothness, float seed, float highCut, float lowCut, int quality) {
							${k}
						}`,
                      [
                        _C.simplex,
                        _C.simplexFractal,
                        _C.simplexAshima,
                        _C.fbm,
                        _C.perlin,
                        _C.voronoi,
                      ]
                    ),
                    j = new wP(
                      `vec3 vertexDisplacementNoise(vec3 position, vec3 normal, float scale, vec3 offset, float movement, int voronoiStyle, float smoothness, float seed, float highCut, float lowCut, int quality, float intensity, out vec3 displaced_normal) {
							vec3 displaced_position = distorted(position, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);
							vec3 tangent1 = orthogonal(normal);
							vec3 tangent2 = normalize(cross(normal, tangent1));

                            // TODO(Max): The distance to the neighbors was originally scaled by 0.1.
                            // This caused some small oval/circular visual artifacts in the lighting.
                            // For now, simply using neighbors further away betters the problem,
                            // but we should figure out the underlying cause when we have some time.
                            // Maybe its related to how we calculate the tangent and bitangent?
							vec3 nearby1 = position + tangent1;
							vec3 nearby2 = position + tangent2;
							vec3 distorted1 = distorted(nearby1, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);
							vec3 distorted2 = distorted(nearby2, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);
							displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
							return displaced_position;
						}`,
                      [V, z]
                    );
                  (R = _.include(j)),
                    B.push(this.scale.build(_, "f")),
                    B.push(this.cropOrOffset.build(_, "v3")),
                    B.push(this.movementOrTexture.build(_, "f")),
                    B.push(this.voronoiStyle.build(_, "i")),
                    B.push(this.smoothness.build(_, "f")),
                    B.push(this.seed.build(_, "f")),
                    B.push(this.highCut.build(_, "f")),
                    B.push(this.lowCut.build(_, "f")),
                    B.push(this.quality.build(_, "i"));
                }
              }
              return (
                B.push(this.intensity.build(_, "f")),
                B.push("displaced_normal"),
                _.format(R + "(" + B.join(",") + ")", this.getType(_), I)
              );
            }
          }
        };
      _V.Nodes =
        ((ih = new wP(`vec3 orthogonal(vec3 v) {
				return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
			}`)),
        (ic =
          new wP(`float displacementMapTexture(sampler2D tex, float crop, vec2 uv, mat3 mat, vec2 offset) {
				vec2 uvs = (mat * vec3(uv * 2.0 - 1.0, 1.0) / 2.0 + 0.5).xy + offset;
				vec4 tmp = texture2D(tex, uvs);
				vec3 col = tmp.rgb;
				if (crop > 0.5) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						return 0.0;
					}
				}
				return col.r;
			}`)),
        {
          map: new wP(
            `vec3 vertexDisplacementMap(vec3 position, vec3 normal, sampler2D tex, vec2 uv, float crop, mat3 mat, float intensity, out vec3 displaced_normal) {
				vec3 displaced_position = position + normal * displacementMapTexture(tex, crop, uv, mat, vec2(0.0)) * intensity;
				vec3 tangent1 = normalize(orthogonal(normal));
				vec3 tangent2 = normalize(cross(normal, tangent1));
				vec3 nearby1 = position + tangent1 * 0.1;
				vec3 nearby2 = position + tangent2 * 0.1;
				vec3 distorted1 = nearby1 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				vec3 distorted2 = nearby2 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
				return displaced_position;
			}`,
            [ih, ic]
          ),
        });
      var _j = {
        normalRenderTarget: new wV(),
        normalRenderTargetDepth: new wV(),
        transmissionRenderTarget: new wV(),
        aspectRatio: new wb(),
        transmissionSize: new wb(2048, 2048),
        transmissionRenderTargetDepth: new wV(),
        aoRenderTarget: new wV(),
        aoEnabled: new _i(),
        pixelRatioNode: new wj(1),
        resolution: new wb(),
        penumbraSize: new _r(5, 0.5),
        frameIndex: new _t(0),
        transmissionLod: new _t(2),
      };
      for (let _ of Object.values(_j)) _.isRenderGlobal = !0;
      var _G,
        _H,
        _W,
        _q,
        _Y,
        _X,
        _Q,
        _Z = {
          skiaWasmUrl:
            "https://unpkg.com/@splinetool/ui-wasm@1.0.53/build/ui.wasm",
        },
        _K = class extends wm {
          constructor() {
            super("basic"),
              (this.nodeType = "Basic"),
              (this.color = new _e(5526619)),
              (this.shadingAlpha = new wj(1)),
              (this.shadingBlend = new _t(0)),
              (this.previousModelViewMatrix = new _d()),
              (this.previouseProjectionMatrix = new _d());
          }
          get category() {
            return "phong";
          }
          generate(_) {
            let I;
            if (_.isShader("vertex")) {
              let R = this.position
                ? this.position.analyzeAndFlow(_, "v3", { cache: "position" })
                : void 0;
              _.mergeUniform({ frameIndex: _j.frameIndex }),
                _.mergeUniform({ resolution: _j.resolution }),
                _.mergeUniform({
                  previousModelViewMatrix: this.previousModelViewMatrix,
                }),
                _.mergeUniform({
                  previousProjectionMatrix: this.previouseProjectionMatrix,
                }),
                _.mergeUniform(aA.merge([aX.fog])),
                _.addParsCode(
                  [
                    "varying vec3 vViewPosition;",
                    "varying vec3 vWPosition;",
                    "#include <fog_pars_vertex>",
                    "#include <normal_pars_vertex>",
                  ].join(`
`)
                );
              let B = [
                "#include <beginnormal_vertex>",
                `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
                "#include <normal_vertex>",
                `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`,
              ];
              R &&
                B.push(
                  R.code,
                  R.result ? "displaced_position = " + R.result + ";" : ""
                ),
                B.push(
                  "transformed = displaced_position;",
                  "transformedNormal = normalMatrix * displaced_normal;",
                  "#ifndef FLAT_SHADED",
                  "	vNormal = transformedNormal;",
                  "#endif"
                ),
                B.push(
                  "#include <project_vertex>",
                  "#include <fog_vertex>",
                  "#include <clipping_planes_vertex>",
                  "	vViewPosition = - mvPosition.xyz;",
                  "#include <worldpos_vertex>"
                ),
                B.push(
                  "vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"
                ),
                (I = B.join(`
`));
            } else {
              void 0 === this.color && (this.color = new _e(5526619)),
                this.color.analyze(_, { slot: "color" }),
                this.alpha && this.alpha.analyze(_),
                this.afterColor &&
                  this.afterColor.analyze(_, { slot: "afterColor" });
              let R = this.color.flow(_, "c", { slot: "color" }),
                B = this.alpha ? this.alpha.flow(_, "f") : void 0,
                z = this.alphaOverride
                  ? this.alphaOverride.flow(_, "f")
                  : void 0,
                k = this.afterColor
                  ? this.afterColor.flow(_, "c", { slot: "afterColor" })
                  : void 0;
              (_.requires.transparent = void 0 !== B),
                _.addParsCode(
                  [
                    "varying vec3 vWPosition;",
                    "#include <fog_pars_fragment>",
                    "#include <dithering_pars_fragment>",
                    "varying vec3 vViewPosition;",
                    "#include <normal_pars_fragment>",
                  ].join(`
`)
                );
              let V = ["#include <normal_fragment_begin>", R.code];
              B &&
                V.push(
                  B.code,
                  "#ifdef ALPHATEST",
                  " if ( " + B.result + " <= ALPHATEST ) discard;",
                  "#endif"
                ),
                k
                  ? V.push(
                      k.code,
                      `vec3 outgoingLight = ${R.result};`,
                      `vec3 finalColor = spe_blend(outgoingLight, ${k.result}, 1.0, SPE_BLENDING_NORMAL);`
                    )
                  : V.push(`vec3 finalColor = ${R.result};`);
              let j = "1.0";
              this.mask &&
                (this.mask.analyze(_),
                (j = `luminance(${this.mask.flow(_, "v3").result})`)),
                B
                  ? V.push(
                      `gl_FragColor = vec4( finalColor, accumAlpha * ${B.result} * ${j} );`
                    )
                  : V.push("gl_FragColor = vec4(" + R.result + ", 1.0 );"),
                z && V.push(`gl_FragColor.a *= ${z.result};`),
                V.push(
                  "#include <fog_fragment>",
                  "#include <dithering_fragment>"
                ),
                (I = V.join(`
`));
            }
            return I;
          }
        },
        _J = class extends wm {
          constructor() {
            super("lambert"),
              (this.nodeType = "Lambert"),
              (this.color = new _e(5526619)),
              (this.emissive = new _e(0)),
              (this.emissiveIntensity = new wj(1)),
              (this.previousModelViewMatrix = new _d()),
              (this.previouseProjectionMatrix = new _d()),
              (this.shadingAlpha = new wj(1)),
              (this.shadingBlend = new _t(0)),
              (this.occlusion = new _i(!0));
          }
          get category() {
            return "lambert";
          }
          build(_) {
            let I;
            if (
              (_.define("LAMBERT"),
              (_.requires.lights = !0),
              (_.extensions.derivatives = !0),
              _.isShader("vertex"))
            ) {
              let R = this.position
                ? this.position.analyzeAndFlow(_, "v3", { cache: "position" })
                : void 0;
              _.mergeUniform({ frameIndex: _j.frameIndex }),
                _.mergeUniform({ resolution: _j.resolution }),
                _.mergeUniform({
                  previousModelViewMatrix: this.previousModelViewMatrix,
                }),
                _.mergeUniform({
                  previousProjectionMatrix: this.previouseProjectionMatrix,
                }),
                _.mergeUniform(aA.merge([aX.fog, aX.lights])),
                _.addParsCode(
                  [
                    "varying vec3 vViewPosition;",
                    "varying vec3 vWPosition;",
                    "varying vec3 vLightFront;",
                    "varying vec3 vIndirectFront;",
                    "#ifndef DOUBLE_SIDED",
                    "   #define DOUBLE_SIDED",
                    "#endif",
                    "#ifdef DOUBLE_SIDED",
                    "	varying vec3 vLightBack;",
                    "	varying vec3 vIndirectBack;",
                    "#endif",
                    "#include <bsdfs>",
                    "#include <lights_pars_begin>",
                    "#include <color_pars_vertex>",
                    "#include <fog_pars_vertex>",
                    "#include <normal_pars_vertex>",
                    "#include <shadowmap_pars_vertex>",
                    "#include <clipping_planes_pars_vertex>",
                  ].join(`
`)
                );
              let B = [
                "#include <beginnormal_vertex>",
                `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
                "#include <normal_vertex>",
                `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`,
              ];
              R &&
                B.push(
                  R.code,
                  R.result ? "displaced_position = " + R.result + ";" : ""
                ),
                B.push(
                  "transformed = displaced_position;",
                  "transformedNormal = normalMatrix * displaced_normal;",
                  "#ifndef FLAT_SHADED",
                  "    vNormal = transformedNormal;",
                  "#endif"
                ),
                B.push(
                  "	#include <project_vertex>",
                  "	#include <clipping_planes_vertex>",
                  "	vViewPosition = - mvPosition.xyz;",
                  "	#include <worldpos_vertex>",
                  `
					vec3 diffuse = vec3( 1.0 );
					GeometricContext geometry;
					geometry.position = mvPosition.xyz;
					geometry.normal = normalize( transformedNormal );
					geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
				`
                ),
                B.push(
                  `
					GeometricContext backGeometry;
					backGeometry.position = geometry.position;
					backGeometry.normal = -geometry.normal;
					backGeometry.viewDir = geometry.viewDir;
					vLightFront = vec3( 0.0 );
					vIndirectFront = vec3( 0.0 );
					#ifdef DOUBLE_SIDED
						vLightBack = vec3( 0.0 );
						vIndirectBack = vec3( 0.0 );
					#endif
					IncidentLight directLight;
					float dotNL;
					vec3 directLightColor_Diffuse;
					vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
					vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
					#ifdef DOUBLE_SIDED
						vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
						vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
					#endif
					#if NUM_POINT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
							getPointLightInfo( pointLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_SPOT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
							getSpotLightInfo( spotLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_DIR_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
							getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_HEMI_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
							vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
							#ifdef DOUBLE_SIDED
								vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
							#endif
						}
						#pragma unroll_loop_end
					#endif
				`,
                  "	#include <shadowmap_vertex>",
                  "	#include <fog_vertex>"
                ),
                B.push(
                  "vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"
                ),
                (I = B.join(`
`));
            } else {
              _.mergeUniform({ penumbraSize: _j.penumbraSize }),
                _.mergeUniform({ frameIndex: _j.frameIndex }),
                _.mergeUniform({ aoMap: _j.aoRenderTarget }),
                _.mergeUniform({ aoEnabled: _j.aoEnabled }),
                void 0 === this.color && (this.color = new _e(5526619)),
                this.color.analyze(_, { slot: "color" }),
                this.shadingAlpha.analyze(_),
                this.shadingBlend.analyze(_),
                this.afterColor &&
                  this.afterColor.analyze(_, { slot: "afterColor" }),
                this.alpha && this.alpha.analyze(_);
              let R = this.color.flow(_, "c", { slot: "color" }),
                B = this.emissive.flow(_, "c", { slot: "emissive" }),
                z = this.emissiveIntensity.flow(_, "f", { slot: "emissive" }),
                k = this.occlusion.flow(_, "b", { slot: "occlusion" }),
                V = this.shadingAlpha.flow(_, "f"),
                j = this.shadingBlend.flow(_, "i"),
                G = this.afterColor
                  ? this.afterColor.flow(_, "c", { slot: "afterColor" })
                  : void 0,
                q = this.alpha ? this.alpha.flow(_, "f") : void 0,
                X = this.alphaOverride
                  ? this.alphaOverride.flow(_, "f")
                  : void 0;
              (_.requires.transparent = void 0 !== q),
                _.addParsCode(
                  [
                    "uniform float penumbraSize[5];",
                    "uniform sampler2D aoMap;",
                    "uniform bool aoEnabled;",
                    "varying vec3 vViewPosition;",
                    "varying vec3 vWPosition;",
                    "varying vec3 vLightFront;",
                    "varying vec3 vIndirectFront;",
                    "#ifndef DOUBLE_SIDED",
                    "   #define DOUBLE_SIDED",
                    "#endif",
                    "#include <normal_pars_fragment>",
                    "#ifdef DOUBLE_SIDED",
                    "	varying vec3 vLightBack;",
                    "	varying vec3 vIndirectBack;",
                    "#endif",
                    "#include <bsdfs>",
                    "#include <lights_pars_begin>",
                    "#include <fog_pars_fragment>",
                    "#include <shadowmap_pars_fragment>",
                    "#include <shadowmask_pars_fragment>",
                    "#include <clipping_planes_pars_fragment>",
                    "#include <dithering_pars_fragment>",
                  ].join(`
`)
                );
              let Q = [
                "#include <normal_fragment_begin>",
                `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx, viewdy));
				bool isFrontFacing = (dot(normal, faceNormal) >= 0.0);
				`,
                "#include <clipping_planes_fragment>",
              ];
              Q.push(
                R.code,
                "vec3 diffuseColor = " + R.result + ";",
                "ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );"
              ),
                q &&
                  Q.push(
                    q.code,
                    "#ifdef ALPHATEST",
                    "if ( " + q.result + " <= ALPHATEST ) discard;",
                    "#endif"
                  ),
                Q.push(
                  "#ifdef DOUBLE_SIDED",
                  "	reflectedLight.indirectDiffuse += ( isFrontFacing ) ? vIndirectFront : vIndirectBack;",
                  "#else",
                  "	reflectedLight.indirectDiffuse += vIndirectFront;",
                  "#endif",
                  "#include <lightmap_fragment>",
                  "reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );",
                  "#ifdef DOUBLE_SIDED",
                  "	reflectedLight.directDiffuse = ( isFrontFacing ) ? vLightFront : vLightBack;",
                  "#else",
                  "	reflectedLight.directDiffuse = vLightFront;",
                  "#endif",
                  "reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();"
                ),
                B &&
                  Q.push(
                    B.code,
                    "reflectedLight.directDiffuse += " +
                      B.result +
                      " * " +
                      z.result +
                      ";"
                  ),
                Q.push(
                  "vec3 ao = aoEnabled && " +
                    k.result +
                    " ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);",
                  "vec3 outgoingLight = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) ;"
                );
              let $ = "1.0";
              this.mask &&
                (this.mask.analyze(_),
                ($ = `luminance(${this.mask.flow(_, "v3").result})`)),
                Q.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${V.result} * ${$} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${V.result} * ${$}, ${j.result} );

					outgoingLight *= ao;
				}
				`),
                G &&
                  Q.push(
                    G.code,
                    `outgoingLight = spe_blend(outgoingLight, ${G.result}, 1.0, SPE_BLENDING_NORMAL);`
                  ),
                q
                  ? Q.push(
                      `gl_FragColor = vec4( outgoingLight, accumAlpha * ${q.result} );`
                    )
                  : Q.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),
                X && Q.push(`gl_FragColor.a *= ${X.result};`),
                Q.push(
                  "#include <encodings_fragment>",
                  "#include <fog_fragment>",
                  "#include <dithering_fragment>"
                ),
                (I = Q.join(`
`));
            }
            return I;
          }
        },
        _$ = {
          dHdxy:
            new wP(`vec2 dHdxy(sampler2D bumpMap, vec2 bumpMapUv, float bumpScale) {

            // Gradient of UVs w.r.t. X coordinate (in screen-space)
            vec2 dSTdx = dFdx(bumpMapUv);

            // Gradient of UVs w.r.t. Y coordinate (in screen-space)
            vec2 dSTdy = dFdy(bumpMapUv);
            
            // Forward differencing
            float Hll = bumpScale * luminance(texture(bumpMap, bumpMapUv).rgb);
            float dBx = bumpScale * luminance(texture(bumpMap, bumpMapUv + dSTdx).rgb) - Hll;
            float dBy = bumpScale * luminance(texture(bumpMap, bumpMapUv + dSTdy).rgb) - Hll;
            
            return vec2( dBx, dBy );
        }`),
          perturbNormalArb:
            new wP(`vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
            vec3 vSigmaX = dFdx( surf_pos.xyz );
            vec3 vSigmaY = dFdy( surf_pos.xyz );
            vec3 vN = surf_norm; // normalized
            
            vN = normalize(vN);

            vec3 R1 = cross( vSigmaY, vN );
            vec3 R2 = cross( vN, vSigmaX );

            R1 = normalize(R1);
            R2 = normalize(R2);
    
            float fDet = dot( vSigmaX, R1 ) * faceDirection;
    
            vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
            return normalize( abs( fDet ) * vN - vGrad );
        }`),
        },
        _1 = class extends wm {
          constructor() {
            super("phong"),
              (this.nodeType = "Phong"),
              (this.color = new _e(5526619)),
              (this.specular = new _e(1118481)),
              (this.shininess = new wj(30)),
              (this.previousModelViewMatrix = new _d()),
              (this.previouseProjectionMatrix = new _d()),
              (this.shadingAlpha = new wj(1)),
              (this.shadingBlend = new _t(0)),
              (this.occlusion = new _i(!0));
          }
          get category() {
            return "phong";
          }
          build(_) {
            let I;
            if (
              (_.define("PHONG"),
              (_.requires.lights = !0),
              (_.extensions.derivatives = !0),
              _.isShader("vertex"))
            ) {
              let R = this.position
                ? this.position.analyzeAndFlow(_, "v3", { cache: "position" })
                : void 0;
              _.mergeUniform({ frameIndex: _j.frameIndex }),
                _.mergeUniform({ resolution: _j.resolution }),
                _.mergeUniform({
                  previousModelViewMatrix: this.previousModelViewMatrix,
                }),
                _.mergeUniform({
                  previousProjectionMatrix: this.previouseProjectionMatrix,
                }),
                _.mergeUniform(aA.merge([aX.fog, aX.lights])),
                _.addParsCode(
                  [
                    "varying vec3 vViewPosition;",
                    "varying vec3 vWPosition;",
                    "#include <fog_pars_vertex>",
                    "#include <skinning_pars_vertex>",
                    "#include <normal_pars_vertex>",
                    "#include <shadowmap_pars_vertex>",
                    "#include <clipping_planes_pars_vertex>",
                  ].join(`
`)
                );
              let B = [
                "#include <beginnormal_vertex>",
                `
				#include <skinbase_vertex>
				#include <skinnormal_vertex>
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif


				vec3 displaced_position = position;
				vec3 displaced_normal = objectNormal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
                "#include <normal_vertex>",
                `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`,
              ];
              R &&
                B.push(
                  R.code,
                  R.result ? "displaced_position = " + R.result + ";" : ""
                ),
                B.push(
                  "transformed = displaced_position;",
                  "#include <skinning_vertex>",
                  "transformedNormal = normalMatrix * displaced_normal;",
                  "#ifndef FLAT_SHADED",
                  "    vNormal = transformedNormal;",
                  "#endif"
                ),
                B.push(
                  "	#include <project_vertex>",
                  "	#include <clipping_planes_vertex>",
                  "	vViewPosition = - mvPosition.xyz;",
                  "	#include <worldpos_vertex>",
                  "	#include <shadowmap_vertex>",
                  "	#include <fog_vertex>"
                ),
                B.push(
                  "vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"
                ),
                (I = B.join(`
`));
            } else {
              _.mergeUniform({ penumbraSize: _j.penumbraSize }),
                _.mergeUniform({ frameIndex: _j.frameIndex }),
                _.mergeUniform({ aoMap: _j.aoRenderTarget }),
                _.mergeUniform({ aoEnabled: _j.aoEnabled }),
                void 0 === this.color && (this.color = new _e(5526619)),
                this.color.analyze(_, { slot: "color" }),
                this.specular.analyze(_),
                this.shininess.analyze(_);
              let R = this.occlusion.flow(_, "b", { slot: "occlusion" });
              this.shadingAlpha.analyze(_),
                this.shadingBlend.analyze(_),
                this.afterColor &&
                  this.afterColor.analyze(_, { slot: "afterColor" }),
                this.alpha && this.alpha.analyze(_);
              let B = this.color.flow(_, "c", { slot: "color" }),
                z = this.specular.flow(_, "c"),
                k = this.shininess.flow(_, "f"),
                V = this.shadingAlpha.flow(_, "f"),
                j = this.shadingBlend.flow(_, "i"),
                G = this.afterColor
                  ? this.afterColor.flow(_, "c", { slot: "afterColor" })
                  : void 0,
                q = this.alpha ? this.alpha.flow(_, "f") : void 0,
                X = this.alphaOverride
                  ? this.alphaOverride.flow(_, "f")
                  : void 0;
              (_.requires.transparent = void 0 !== q),
                _.addParsCode(
                  [
                    "varying vec3 vWPosition;",
                    "uniform vec3 emissive;",
                    "uniform float penumbraSize[5];",
                    "uniform sampler2D aoMap;",
                    "uniform bool aoEnabled;",
                    "#include <normal_pars_fragment>",
                    "#include <fog_pars_fragment>",
                    "#include <bsdfs>",
                    "#include <lights_pars_begin>",
                    "#include <lights_phong_pars_fragment>",
                    "#include <shadowmap_pars_fragment>",
                    "#include <dithering_pars_fragment>",
                  ].join(`
`)
                );
              let Q = [
                "#include <normal_fragment_begin>",
                `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,
                "	BlinnPhongMaterial material;",
              ];
              if (this.bumpMap) {
                _.include(_$.dHdxy), _.include(_$.perturbNormalArb);
                let I = this.bumpMap.texture.flow(_, "t"),
                  R = this.bumpMap.flow(_, "v3"),
                  B = this.bumpMapIntensity
                    ? this.bumpMapIntensity.flow(_, "f").result
                    : "1.0",
                  z = "";
                (z =
                  4 === this.bumpMap.projection.value
                    ? `
					vec3 bumpNormal = vec3(0.0);
					{
						vec2 uv0 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs0;
						vec2 uv1 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs1;
						vec2 uv2 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs2;
						vec3 weights = g${this.bumpMap.uuid
              .toString()
              .replace(/-/g, "")}_triplanarWeights;

						vec2 grad0 = dHdxy(${I.result}, uv0, ${B});
						vec3 n0 = perturbNormalArb(-vViewPosition, normal, grad0, faceDirection);

						vec2 grad1 = dHdxy(${I.result}, uv1, ${B});
						vec3 n1 = perturbNormalArb(-vViewPosition, normal, grad1, faceDirection);

						vec2 grad2 = dHdxy(${I.result}, uv2, ${B});
						vec3 n2 = perturbNormalArb(-vViewPosition, normal, grad2, faceDirection);
						
						bumpNormal = n0 * weights.z + n1 * weights.x + n2 * weights.y;
						bumpNormal = normalize(bumpNormal);
					}

					normal = bumpNormal;
					`
                    : `
					vec2 bumpMapCachedUv = g${this.bumpMap.uuid
            .toString()
            .replace(/-/g, "")}_writeUvs;
					vec2 grad = dHdxy(${I.result}, bumpMapCachedUv, ${B});
					normal = perturbNormalArb( - vViewPosition, normal, grad, faceDirection );
					`),
                  Q.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates
					${R.result};
					${z}
					`);
              }
              Q.push(
                B.code,
                "	vec3 diffuseColor = " + B.result + ";",
                "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
                "	vec3 totalEmissiveRadiance = emissive;",
                z.code,
                "	vec3 specular = " + z.result + ";",
                k.code,
                "	float shininess = max( 0.0001, " + k.result + " );",
                "	float specularStrength = 1.0;"
              ),
                q &&
                  Q.push(
                    q.code,
                    "#ifdef ALPHATEST",
                    "if ( " + q.result + " <= ALPHATEST ) discard;",
                    "#endif"
                  ),
                Q.push("material.diffuseColor = diffuseColor;"),
                Q.push(
                  "material.specularColor = specular;",
                  "material.specularShininess = shininess;",
                  "material.specularStrength = specularStrength;",
                  "#include <lights_fragment_begin>",
                  "#include <lights_fragment_end>"
                ),
                Q.push(
                  "vec3 ao = aoEnabled && " +
                    R.result +
                    " ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);",
                  "vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse)) + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;"
                );
              let $ = "1.0";
              this.mask &&
                (this.mask.analyze(_),
                ($ = `luminance(${this.mask.flow(_, "v3").result})`)),
                Q.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${V.result} * ${$} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${V.result} * ${$}, ${j.result} );
					
					outgoingLight *= ao;
				}
				`),
                G &&
                  Q.push(
                    G.code,
                    `outgoingLight = spe_blend(outgoingLight, ${G.result}, 1.0, SPE_BLENDING_NORMAL);`
                  ),
                q
                  ? Q.push(
                      `gl_FragColor = vec4( outgoingLight, accumAlpha * ${q.result});`
                    )
                  : Q.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),
                X && Q.push(`gl_FragColor.a *= ${X.result};`),
                Q.push(
                  "#include <encodings_fragment>",
                  "#include <fog_fragment>",
                  "#include <dithering_fragment>"
                ),
                (I = Q.join(`
`));
            }
            return I;
          }
        },
        _3 = class extends wm {
          constructor() {
            super("standard"),
              (this.nodeType = "Standard"),
              (this.color = new _e(5526619)),
              (this.roughness = new wj(0.3)),
              (this.metalness = new wj(0)),
              (this.reflectivity = new wj(0.5)),
              (this.previousModelViewMatrix = new _d()),
              (this.previouseProjectionMatrix = new _d()),
              (this.shadingAlpha = new wj(1)),
              (this.shadingBlend = new _t(0)),
              (this.occlusion = new _i(!0));
          }
          get category() {
            return "physical";
          }
          build(_) {
            let I;
            if (
              (_.define("STANDARD"),
              (_.requires.lights = !0),
              (_.extensions.derivatives = !0),
              (_.extensions.shaderTextureLOD = !0),
              _.isShader("vertex"))
            ) {
              let R = this.position
                ? this.position.analyzeAndFlow(_, "v3", { cache: "position" })
                : void 0;
              _.mergeUniform({ frameIndex: _j.frameIndex }),
                _.mergeUniform({ resolution: _j.resolution }),
                _.mergeUniform({
                  previousModelViewMatrix: this.previousModelViewMatrix,
                }),
                _.mergeUniform({
                  previousProjectionMatrix: this.previouseProjectionMatrix,
                }),
                _.mergeUniform(aA.merge([aX.fog, aX.lights])),
                aX.LTC_1 &&
                  ((_.uniforms.ltc_1 = { value: void 0 }),
                  (_.uniforms.ltc_2 = { value: void 0 })),
                _.addParsCode(
                  [
                    "varying vec3 vViewPosition;",
                    "varying vec3 vWPosition;",
                    "#include <fog_pars_vertex>",
                    "#include <normal_pars_vertex>",
                    "#include <shadowmap_pars_vertex>",
                    "#include <clipping_planes_pars_vertex>",
                  ].join(`
`)
                );
              let B = [
                "#include <beginnormal_vertex>",
                `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
                "#include <normal_vertex>",
                `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`,
              ];
              R &&
                B.push(
                  R.code,
                  R.result ? "displaced_position = " + R.result + ";" : ""
                ),
                B.push(
                  "transformed = displaced_position;",
                  "transformedNormal = normalMatrix * displaced_normal;",
                  "#ifndef FLAT_SHADED",
                  "    vNormal = transformedNormal;",
                  "#endif"
                ),
                B.push(
                  "#include <project_vertex>",
                  "#include <fog_vertex>",
                  "#include <clipping_planes_vertex>",
                  "	vViewPosition = - mvPosition.xyz;",
                  "#include <worldpos_vertex>",
                  "#include <shadowmap_vertex>"
                ),
                B.push(
                  "vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"
                ),
                (I = B.join(`
`));
            } else {
              _.mergeUniform({ penumbraSize: _j.penumbraSize }),
                _.mergeUniform({ frameIndex: _j.frameIndex }),
                _.mergeUniform({ aoMap: _j.aoRenderTarget }),
                _.mergeUniform({ aoEnabled: _j.aoEnabled });
              let R = { gamma: !0 };
              void 0 === this.color && (this.color = new _e(5526619)),
                this.color.analyze(_, { slot: "color", context: R }),
                this.roughness.analyze(_),
                this.metalness.analyze(_);
              let B = this.occlusion.flow(_, "b", { slot: "occlusion" });
              this.shadingAlpha.analyze(_),
                this.shadingBlend.analyze(_),
                this.afterColor &&
                  this.afterColor.analyze(_, { slot: "afterColor" }),
                this.alpha && this.alpha.analyze(_),
                this.reflectivity && this.reflectivity.analyze(_);
              let z = this.color.flow(_, "c", { slot: "color", context: R }),
                k = this.roughness.flow(_, "f"),
                V = this.metalness.flow(_, "f"),
                j = this.shadingAlpha.flow(_, "f"),
                G = this.shadingBlend.flow(_, "i"),
                q = this.afterColor
                  ? this.afterColor.flow(_, "c", { slot: "afterColor" })
                  : void 0,
                X = this.alpha ? this.alpha.flow(_, "f") : void 0,
                Q = this.alphaOverride
                  ? this.alphaOverride.flow(_, "f")
                  : void 0,
                $ = this.reflectivity ? this.reflectivity.flow(_, "f") : void 0;
              (_.requires.transparent = void 0 !== X),
                _.addParsCode(
                  [
                    "varying vec3 vViewPosition;",
                    "varying vec3 vWPosition;",
                    "uniform float penumbraSize[5];",
                    "uniform sampler2D aoMap;",
                    "uniform bool aoEnabled;",
                    "#include <normal_pars_fragment>",
                    "#include <dithering_pars_fragment>",
                    "#include <fog_pars_fragment>",
                    "#include <bsdfs>",
                    "#include <lights_pars_begin>",
                    "#include <lights_physical_pars_fragment>",
                    "#include <shadowmap_pars_fragment>",
                  ].join(`
`)
                );
              let et = [
                "#include <clipping_planes_fragment>",
                "	#include <normal_fragment_begin>",
                `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,
                "	PhysicalMaterial material;",
                "	material.diffuseColor = vec3( 1.0 );",
              ];
              if (this.bumpMap) {
                _.include(_$.dHdxy), _.include(_$.perturbNormalArb);
                let I = this.bumpMap.texture.flow(_, "t"),
                  R = this.bumpMap.flow(_, "v3"),
                  B = this.bumpMapIntensity
                    ? this.bumpMapIntensity.flow(_, "f").result
                    : "1.0",
                  z = "";
                (z =
                  4 === this.bumpMap.projection.value
                    ? `
					vec3 bumpNormal = vec3(0.0);
					{
						vec2 uv0 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs0;
						vec2 uv1 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs1;
						vec2 uv2 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs2;
						vec3 weights = g${this.bumpMap.uuid
              .toString()
              .replace(/-/g, "")}_triplanarWeights;

						vec2 grad0 = dHdxy(${I.result}, uv0, ${B});
						vec3 n0 = perturbNormalArb(-vViewPosition, normal, grad0, faceDirection);

						vec2 grad1 = dHdxy(${I.result}, uv1, ${B});
						vec3 n1 = perturbNormalArb(-vViewPosition, normal, grad1, faceDirection);

						vec2 grad2 = dHdxy(${I.result}, uv2, ${B});
						vec3 n2 = perturbNormalArb(-vViewPosition, normal, grad2, faceDirection);
						
						bumpNormal = n0 * weights.z + n1 * weights.x + n2 * weights.y;
						bumpNormal = normalize(bumpNormal);
					}

					normal = bumpNormal;
					`
                    : `
					vec2 bumpMapCachedUv = g${this.bumpMap.uuid
            .toString()
            .replace(/-/g, "")}_writeUvs;
					vec2 grad = dHdxy(${I.result}, bumpMapCachedUv, ${B});
					normal = perturbNormalArb( - vViewPosition, normal, grad, faceDirection );
					`),
                  et.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates
					${R.result};
					${z}
					`);
              }
              if (
                (et.push(
                  z.code,
                  "	vec3 diffuseColor = " + z.result + ";",
                  "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
                  V.code,
                  "	float metalnessFactor = " + V.result + ";"
                ),
                this.roughnessMap)
              ) {
                let I = this.roughnessMap.texture.flow(_, "t"),
                  R = this.roughnessMap.flow(_, "v3"),
                  B = "";
                (B =
                  4 === this.roughnessMap.projection.value
                    ? `
					float roughnessChange = 1.0;
					{
						vec2 uv0 = g${this.roughnessMap.uuid.toString().replace(/-/g, "")}_writeUvs0;
						vec2 uv1 = g${this.roughnessMap.uuid.toString().replace(/-/g, "")}_writeUvs1;
						vec2 uv2 = g${this.roughnessMap.uuid.toString().replace(/-/g, "")}_writeUvs2;
						vec3 weights = g${this.roughnessMap.uuid
              .toString()
              .replace(/-/g, "")}_triplanarWeights;

						float r0 = luminance(texture(${I.result}, uv0).rgb) * roughnessScale;
						float r1 = luminance(texture(${I.result}, uv1).rgb) * roughnessScale;
						float r2 = luminance(texture(${I.result}, uv2).rgb) * roughnessScale;

						roughnessChange = (r0 * weights.z + r1 * weights.x + r2 * weights.y);
					}
					float roughnessFactor = roughnessChange * ${k.result};
					`
                    : `
					vec2 roughnessMapCachedUv = g${this.roughnessMap.uuid
            .toString()
            .replace(/-/g, "")}_writeUvs;

					vec4 vals = texture(${I.result},  roughnessMapCachedUv);
					float roughnessFactor = luminance(vals.rgb) * ${k.result};
					`),
                  et.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates
					${R.result};

					const float roughnessScale = 1.0;

					${B}
				`);
              } else
                et.push(k.code, "	float roughnessFactor = " + k.result + ";");
              X &&
                et.push(
                  X.code,
                  "#ifdef ALPHATEST",
                  "	if ( " + X.result + " <= ALPHATEST ) discard;",
                  "#endif"
                ),
                et.push(
                  "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
                  "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );"
                ),
                et.push(
                  "material.diffuseColor = diffuseColor * ( 1.0 - metalnessFactor );",
                  "material.roughness = max( roughnessFactor, 0.0525 );",
                  "material.roughness += geometryRoughness;",
                  "material.roughness = min( material.roughness, 1.0 );",
                  "material.roughness = clamp( roughnessFactor, 0.04, 1.0 );"
                ),
                $
                  ? et.push(
                      $.code,
                      "material.specularColor = mix( vec3( 0.16 * pow2( " +
                        $.result +
                        " ) ), diffuseColor, metalnessFactor );"
                    )
                  : et.push(
                      "material.specularColor = mix( vec3( 0.04 ), diffuseColor, metalnessFactor );"
                    ),
                et.push("#include <lights_fragment_begin>"),
                et.push("#include <lights_fragment_end>"),
                et.push(
                  "vec3 ao = aoEnabled && " +
                    B.result +
                    " ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);",
                  "vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse)) + reflectedLight.directSpecular + reflectedLight.indirectSpecular;"
                );
              let er = "1.0";
              this.mask &&
                (this.mask.analyze(_),
                (er = `luminance(${this.mask.flow(_, "v3").result})`)),
                et.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${j.result} * ${er} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${j.result} * ${er}, ${G.result} );
					
					outgoingLight *= ao;
				}
				`),
                q &&
                  et.push(
                    q.code,
                    `outgoingLight = spe_blend(outgoingLight, ${q.result}, 1.0, SPE_BLENDING_NORMAL);`
                  ),
                X
                  ? et.push(
                      `gl_FragColor = vec4( outgoingLight, accumAlpha * ${X.result} );`
                    )
                  : et.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),
                Q && et.push(`gl_FragColor.a *= ${Q.result};`),
                et.push(
                  "#include <encodings_fragment>",
                  "#include <fog_fragment>",
                  "#include <dithering_fragment>"
                ),
                (I = et.join(`
`));
            }
            return I;
          }
        },
        _4 = class extends wm {
          constructor() {
            super("toon"),
              (this.nodeType = "Toon"),
              (this.color = new _e(5526619)),
              (this.specular = new _e(1118481)),
              (this.shininess = new wj(30)),
              (this.previousModelViewMatrix = new _d()),
              (this.previouseProjectionMatrix = new _d()),
              (this.shadingAlpha = new wj(1)),
              (this.shadingBlend = new _t(0));
          }
          get category() {
            return "toon";
          }
          build(_) {
            let I;
            if (
              (_.define("TOON"),
              (_.requires.lights = !0),
              (_.extensions.derivatives = !0),
              _.isShader("vertex"))
            ) {
              let R = this.position
                ? this.position.analyzeAndFlow(_, "v3", { cache: "position" })
                : void 0;
              _.mergeUniform({ frameIndex: _j.frameIndex }),
                _.mergeUniform({ resolution: _j.resolution }),
                _.mergeUniform({
                  previousModelViewMatrix: this.previousModelViewMatrix,
                }),
                _.mergeUniform({
                  previousProjectionMatrix: this.previouseProjectionMatrix,
                }),
                _.mergeUniform(aA.merge([aX.fog, aX.lights])),
                _.addParsCode(
                  [
                    "varying vec3 vViewPosition;",
                    "varying vec3 vWPosition;",
                    "#include <fog_pars_vertex>",
                    "#include <normal_pars_vertex>",
                    "#include <shadowmap_pars_vertex>",
                    "#include <clipping_planes_pars_vertex>",
                  ].join(`
`)
                );
              let B = [
                "#include <beginnormal_vertex>",
                `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
                "#include <normal_vertex>",
                `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`,
              ];
              R &&
                B.push(
                  R.code,
                  R.result ? "displaced_position = " + R.result + ";" : ""
                ),
                B.push(
                  "transformed = displaced_position;",
                  "transformedNormal = normalMatrix * displaced_normal;",
                  "#ifndef FLAT_SHADED",
                  "    vNormal = transformedNormal;",
                  "#endif"
                ),
                B.push(
                  "	#include <project_vertex>",
                  "	#include <fog_vertex>",
                  "	#include <clipping_planes_vertex>",
                  "	vViewPosition = - mvPosition.xyz;",
                  "	#include <worldpos_vertex>",
                  "	#include <shadowmap_vertex>",
                  "	#include <fog_vertex>"
                ),
                B.push(
                  "vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"
                ),
                (I = B.join(`
`));
            } else {
              _.mergeUniform({ penumbraSize: _j.penumbraSize }),
                _.mergeUniform({ frameIndex: _j.frameIndex }),
                _.mergeUniform({ aoMap: _j.aoRenderTarget }),
                _.mergeUniform({ aoEnabled: _j.aoEnabled }),
                void 0 === this.color && (this.color = new _e(5526619)),
                this.color.analyze(_, { slot: "color" }),
                this.specular.analyze(_),
                this.shininess.analyze(_),
                this.shadingAlpha.analyze(_),
                this.shadingBlend.analyze(_),
                this.afterColor &&
                  this.afterColor.analyze(_, { slot: "afterColor" }),
                this.alpha && this.alpha.analyze(_);
              let R = this.color.flow(_, "c", { slot: "color" }),
                B = this.specular.flow(_, "c"),
                z = this.shininess.flow(_, "f"),
                k = this.shadingAlpha.flow(_, "f"),
                V = this.shadingBlend.flow(_, "i"),
                j = this.afterColor
                  ? this.afterColor.flow(_, "c", { slot: "afterColor" })
                  : void 0,
                G = this.alpha ? this.alpha.flow(_, "f") : void 0,
                q = this.alphaOverride
                  ? this.alphaOverride.flow(_, "f")
                  : void 0;
              (_.requires.transparent = void 0 !== G),
                _.addParsCode(
                  [
                    "uniform float penumbraSize[5];",
                    "uniform sampler2D aoMap;",
                    "uniform bool aoEnabled;",
                    "varying vec3 vWPosition;",
                    "#include <normal_pars_fragment>",
                    "#include <gradientmap_pars_fragment>",
                    "#include <fog_pars_fragment>",
                    "#include <bsdfs>",
                    "#include <lights_pars_begin>",
                    "#include <dithering_pars_fragment>",
                    `
					varying vec3 vViewPosition;
					struct ToonMaterial {
						vec3	diffuseColor;
						vec3	specularColor;
						float	specularShininess;
						float	specularStrength;
					};
					void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
			
						reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
						reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
					}
					void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
					}
					#define RE_Direct				RE_Direct_Toon
					#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
					#define Material_LightProbeLOD( material )	(0)
					`,
                    "#include <shadowmap_pars_fragment>",
                    "#include <bumpmap_pars_fragment>",
                    "#include <normalmap_pars_fragment>",
                  ].join(`
`)
                );
              let X = [
                "#include <normal_fragment_begin>",
                `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,
                "	ToonMaterial material;",
              ];
              if (this.bumpMap) {
                _.include(_$.dHdxy), _.include(_$.perturbNormalArb);
                let I = this.bumpMap.texture.flow(_, "t"),
                  R = this.bumpMap.flow(_, "v3"),
                  B = this.bumpMapIntensity
                    ? this.bumpMapIntensity.flow(_, "f").result
                    : "1.0",
                  z = "";
                (z =
                  4 === this.bumpMap.projection.value
                    ? `
					vec3 bumpNormal = vec3(0.0);
					{
						vec2 uv0 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs0;
						vec2 uv1 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs1;
						vec2 uv2 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs2;
						vec3 weights = g${this.bumpMap.uuid
              .toString()
              .replace(/-/g, "")}_triplanarWeights;

						vec2 grad0 = dHdxy(${I.result}, uv0, ${B});
						vec3 n0 = perturbNormalArb(-vViewPosition, normal, grad0, faceDirection);

						vec2 grad1 = dHdxy(${I.result}, uv1, ${B});
						vec3 n1 = perturbNormalArb(-vViewPosition, normal, grad1, faceDirection);

						vec2 grad2 = dHdxy(${I.result}, uv2, ${B});
						vec3 n2 = perturbNormalArb(-vViewPosition, normal, grad2, faceDirection);
						
						bumpNormal = n0 * weights.z + n1 * weights.x + n2 * weights.y;
						bumpNormal = normalize(bumpNormal);
					}

					normal = bumpNormal;
					`
                    : `
					vec2 bumpMapCachedUv = g${this.bumpMap.uuid
            .toString()
            .replace(/-/g, "")}_writeUvs;
					vec2 grad = dHdxy(${I.result}, bumpMapCachedUv, ${B});
					normal = perturbNormalArb( - vViewPosition, normal, grad, faceDirection );
					`),
                  X.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates
					${R.result};
					${z}
					`);
              }
              X.push(
                R.code,
                "	vec3 diffuseColor = " + R.result + ";",
                "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
                B.code,
                "	vec3 specular = " + B.result + ";",
                z.code,
                "	float shininess = max( 0.0001, " + z.result + " );",
                "	float specularStrength = 1.0;"
              ),
                G &&
                  X.push(
                    G.code,
                    "#ifdef ALPHATEST",
                    "if ( " + G.result + " <= ALPHATEST ) discard;",
                    "#endif"
                  ),
                X.push("material.diffuseColor = diffuseColor;"),
                X.push(
                  "material.specularColor = specular;",
                  "material.specularShininess = shininess;",
                  "material.specularStrength = specularStrength;",
                  "#include <lights_fragment_begin>",
                  "#include <lights_fragment_end>"
                ),
                X.push(
                  "vec3 ao = aoEnabled ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);",
                  "vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) * ao) + reflectedLight.directSpecular;"
                );
              let Q = "1.0";
              this.mask &&
                (this.mask.analyze(_),
                (Q = `luminance(${this.mask.flow(_, "v3").result})`)),
                X.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${k.result} * ${Q} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${k.result} * ${Q}, ${V.result} );
				}
				`),
                j &&
                  X.push(
                    j.code,
                    `outgoingLight = spe_blend(outgoingLight, ${j.result}, 1.0, SPE_BLENDING_NORMAL);`
                  ),
                G
                  ? X.push(
                      `gl_FragColor = vec4( outgoingLight, accumAlpha * ${G.result} );`
                    )
                  : X.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),
                q && X.push(`gl_FragColor.a *= ${q.result};`),
                X.push(
                  "#include <encodings_fragment>",
                  "#include <fog_fragment>",
                  "#include <dithering_fragment>"
                ),
                (I = X.join(`
`));
            }
            return I;
          }
        },
        _5 = class {
          constructor(_ = 1e4) {
            (this.timeout = _),
              (this.cache = new Map()),
              (this.head = {
                data: null,
                time: 0,
                src: null,
                next: null,
                prev: null,
              }),
              (this.tail = {
                data: null,
                time: 1 / 0,
                src: null,
                next: null,
                prev: null,
              }),
              (this.hasClean = !1),
              (this.head.next = this.tail),
              (this.tail.prev = this.head);
          }
          log(..._) {}
          remove(_) {
            let I = this.cache.get(_);
            I &&
              (this.dispose(_, I.data),
              this.cache.delete(_),
              (I.prev.next = I.next),
              (I.next.prev = I.prev));
          }
          scheduleCleanup() {
            this.hasClean ||
              (this.log("scheduled cleanup"),
              (this.hasClean = !0),
              setTimeout(() => {
                (this.hasClean = !1), this.log("cleaning");
                let _ = Date.now(),
                  I = this.head.next;
                for (; I.time < _ - this.timeout; )
                  this.dispose(I.src, I.data),
                    this.cache.delete(I.src),
                    ((I = I.next).prev = this.head),
                    (this.head.next = I);
                this.head.next !== this.tail
                  ? this.scheduleCleanup()
                  : this.log("no more cleanup");
              }, this.timeout + 1e3));
          }
          has(_) {
            return this.cache.get(_)?.data;
          }
          load(_) {
            let I = Date.now(),
              R = this.cache.get(_);
            return (
              void 0 === R
                ? ((R = {
                    data: this.create(_),
                    src: _,
                    time: I,
                    next: null,
                    prev: null,
                  }),
                  this.cache.set(_, R))
                : ((R.time = I),
                  (R.prev.next = R.next),
                  (R.next.prev = R.prev)),
              (R.prev = this.tail.prev),
              (R.next = this.tail),
              (this.tail.prev.next = R),
              (this.tail.prev = R),
              this.scheduleCleanup(),
              R.data
            );
          }
        },
        _6 = class extends _5 {
          create(_) {
            return URL.createObjectURL(new Blob([_]));
          }
          dispose(_, I) {
            URL.revokeObjectURL(I);
          }
        },
        _8 = class {
          constructor(_, I) {
            (this.data = _), (this.cache = I), (this.refCount = 0);
          }
          deref() {
            this.refCount,
              (this.refCount -= 1),
              0 === this.refCount && (this.cache.remove(this), this.dispose());
          }
          dispose() {
            this.refCount;
          }
        },
        _9 = class {
          constructor() {
            this.cache = new Map();
          }
          remove(_) {
            this.cache.delete(_.data);
          }
          load(_) {
            let I = this.cache.get(_);
            return (
              void 0 === I && ((I = this.create(_)), this.cache.set(_, I)),
              (I.refCount += 1),
              I
            );
          }
        },
        _7 = class extends _8 {
          constructor(_, I) {
            super(_, I.imageHolderCache),
              (this.data = _),
              (this.shared = I),
              (this.loaded = !1),
              (this.isVideo = !1),
              (this.isCanvas = !1),
              (this._cache = { 1e3: {}, 1001: {}, 1002: {} }),
              (this.isVideo = "video" === _.type),
              (this.isCanvas = "CANVAS" === _.nodeName),
              this.updateSrc(this.isCanvas ? _ : _.data);
          }
          async updateSrc(_) {
            if (typeof document > "u") return;
            this.disposeTextures(), (this.loaded = !1);
            let r = () => {
              for (let _ of ((this.loaded = !0), Object.values(this._cache)))
                for (let I of Object.values(_))
                  I && ((I.image = this.img), (I.needsUpdate = !0));
              this.shared.requestRender();
            };
            if (this.isCanvas) (this.img = _), (this.loaded = !0);
            else if (this.isVideo) {
              if (
                ((this.img = document.createElement("video")),
                (this.img.preload = "auto"),
                (this.img.playsInline = !0),
                (this.img.currentTime = 0.01),
                "string" != typeof _)
              ) {
                let R;
                var I = new FileReader();
                I.readAsDataURL(new Blob([_], { type: "video/mp4" })),
                  await new Promise((_) => {
                    I.onloadend = (I) => {
                      (R = I.target?.result), _(null);
                    };
                  }),
                  (this.img.src = R);
              } else this.img.src = _;
              this.img.onloadeddata = () => {
                r();
              };
            } else
              (this.img = new Image()),
                (this.img.src =
                  "string" == typeof _
                    ? _
                    : (_Q || (_Q = new _6()), _Q.load(_))),
                (this.img.onload = r);
          }
          getTexture(_, I = 1008) {
            let R = this._cache[_]?.[I];
            if (R) return R;
            {
              let R;
              return (
                this.isCanvas &&
                  (R = new oi(this.img, void 0, _, _, void 0, I)),
                (R = this.isVideo
                  ? new ot(this.img, void 0, _, _)
                  : new rA(this.img, void 0, _, _, void 0, I)),
                this.loaded && (R.needsUpdate = !0),
                void 0 === this._cache[_] && (this._cache[_] = {}),
                (this._cache[_][I] = R),
                R
              );
            }
          }
          setNeedsUpdate(_) {
            for (let I of Object.values(this._cache))
              for (let R of Object.values(I)) R && (R.needsUpdate = _);
          }
          disposeTextures() {
            for (let [_, I] of Object.entries(this._cache))
              for (let [R, B] of Object.entries(I))
                B?.dispose(), (this._cache[_][R] = void 0);
          }
          dispose() {
            super.dispose(), this.disposeTextures();
          }
        },
        Se = class extends _7 {},
        St = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 },
        Si = {};
      function nx(_, I, R, B, z, k, V) {
        var j = new Date(0);
        return j.setUTCFullYear(_, I, R), j.setUTCHours(B, z, k, V), j;
      }
      var Sr = {
        timezoneZ: /^(Z)$/,
        timezoneHH: /^([+-]\d{2})$/,
        timezoneHHMM: /^([+-]\d{2}):?(\d{2})$/,
      };
      function Fm(_, I, R) {
        if (!_ || (B = Sr.timezoneZ.exec(_))) return 0;
        if ((B = Sr.timezoneHH.exec(_)))
          return iR((k = parseInt(B[1], 10))) ? -(36e5 * k) : NaN;
        if ((B = Sr.timezoneHHMM.exec(_))) {
          k = parseInt(B[1], 10);
          var B,
            z,
            k,
            V = parseInt(B[2], 10);
          return iR(k, V)
            ? ((z = 36e5 * Math.abs(k) + 6e4 * V), k > 0 ? -z : z)
            : NaN;
        }
        if (
          (function (_) {
            if (Sn[_]) return !0;
            try {
              return (
                new Intl.DateTimeFormat(void 0, { timeZone: _ }),
                (Sn[_] = !0),
                !0
              );
            } catch {
              return !1;
            }
          })(_)
        ) {
          I = new Date(I || Date.now());
          var j = a_(
            R
              ? I
              : nx(
                  I.getFullYear(),
                  I.getMonth(),
                  I.getDate(),
                  I.getHours(),
                  I.getMinutes(),
                  I.getSeconds(),
                  I.getMilliseconds()
                ),
            _
          );
          return -(R
            ? j
            : (function (_, I, R) {
                var B = _.getTime() - I,
                  z = a_(new Date(B), R);
                if (I === z) return I;
                B -= z - I;
                var k = a_(new Date(B), R);
                return z === k ? z : Math.max(z, k);
              })(I, j, _));
        }
        return NaN;
      }
      function a_(_, I) {
        var R,
          B,
          z,
          k = (z = (function (_) {
            if (!Si[_]) {
              var I = new Intl.DateTimeFormat("en-US", {
                hour12: !1,
                timeZone: "America/New_York",
                year: "numeric",
                month: "numeric",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
              }).format(new Date("2014-06-25T04:00:00.123Z"));
              Si[_] =
                "06/25/2014, 00:00:00" === I ||
                "06/25/2014 00:00:00" === I
                  ? new Intl.DateTimeFormat("en-US", {
                      hour12: !1,
                      timeZone: _,
                      year: "numeric",
                      month: "numeric",
                      day: "2-digit",
                      hour: "2-digit",
                      minute: "2-digit",
                      second: "2-digit",
                    })
                  : new Intl.DateTimeFormat("en-US", {
                      hourCycle: "h23",
                      timeZone: _,
                      year: "numeric",
                      month: "numeric",
                      day: "2-digit",
                      hour: "2-digit",
                      minute: "2-digit",
                      second: "2-digit",
                    });
            }
            return Si[_];
          })(I)).formatToParts
            ? (function (_, I) {
                try {
                  for (
                    var R = _.formatToParts(I), B = [], z = 0;
                    z < R.length;
                    z++
                  ) {
                    var k = St[R[z].type];
                    k >= 0 && (B[k] = parseInt(R[z].value, 10));
                  }
                  return B;
                } catch (_) {
                  if (_ instanceof RangeError) return [NaN];
                  throw _;
                }
              })(z, _)
            : ((R = z.format(_).replace(/\u200E/g, "")),
              [
                (B = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(R))[3],
                B[1],
                B[2],
                B[4],
                B[5],
                B[6],
              ]),
          V = nx(k[0], k[1] - 1, k[2], k[3] % 24, k[4], k[5], 0).getTime(),
          j = _.getTime(),
          G = j % 1e3;
        return V - (j -= G >= 0 ? G : 1e3 + G);
      }
      function iR(_, I) {
        return -23 <= _ && _ <= 23 && (null == I || (0 <= I && I <= 59));
      }
      var Sn = {},
        Sd = pi(iV(), 1),
        Su = pi(ij(), 1),
        Sf = {
          dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
          datePattern: /^([0-9W+-]+)(.*)/,
          YY: /^(\d{2})$/,
          YYY: [/^([+-]\d{2})$/, /^([+-]\d{3})$/, /^([+-]\d{4})$/],
          YYYY: /^(\d{4})/,
          YYYYY: [/^([+-]\d{4})/, /^([+-]\d{5})/, /^([+-]\d{6})/],
          MM: /^-(\d{2})$/,
          DDD: /^-?(\d{3})$/,
          MMDD: /^-?(\d{2})-?(\d{2})$/,
          Www: /^-?W(\d{2})$/,
          WwwD: /^-?W(\d{2})-?(\d{1})$/,
          HH: /^(\d{2}([.,]\d*)?)$/,
          HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
          HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
          timeZone:
            /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/,
        };
      function hR(_, I, R) {
        (I = I || 0), (R = R || 0);
        var B = new Date(0);
        B.setUTCFullYear(_, 0, 4);
        var z = 7 * I + R + 1 - (B.getUTCDay() || 7);
        return B.setUTCDate(B.getUTCDate() + z), B;
      }
      var Sg = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        Sv = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function mR(_) {
        return _ % 400 == 0 || (_ % 4 == 0 && _ % 100 != 0);
      }
      function dR(_, I, R) {
        if (I < 0 || I > 11) return !1;
        if (null != R) {
          if (R < 1) return !1;
          var B = mR(_);
          if ((B && R > Sv[I]) || (!B && R > Sg[I])) return !1;
        }
        return !0;
      }
      function fR(_, I, R) {
        return !(I < 0 || I > 52 || (null != R && (R < 0 || R > 6)));
      }
      function c_(_, I, R) {
        return !(
          (null != _ && (_ < 0 || _ >= 25)) ||
          (null != I && (I < 0 || I >= 60)) ||
          (null != R && (R < 0 || R >= 60))
        );
      }
      function on(_, I) {
        return I.color(_);
      }
      function d_(_ = new Date(), I) {
        var R, B, z, k, V, j;
        let G,
          q,
          X = I.format,
          Q = _.getSeconds(),
          $ = _;
        I &&
          null !== I.timeZone &&
          ((R = new Date()),
          (B = I.timeZone),
          (z = (function (_, I) {
            if (arguments.length < 1)
              throw TypeError(
                "1 argument required, but only " + arguments.length + " present"
              );
            if (null === _) return new Date(NaN);
            var R = I || {},
              B =
                null == R.additionalDigits
                  ? 2
                  : (0, Sd.default)(R.additionalDigits);
            if (2 !== B && 1 !== B && 0 !== B)
              throw RangeError("additionalDigits must be 0, 1 or 2");
            if (
              _ instanceof Date ||
              ("object" == typeof _ &&
                "[object Date]" === Object.prototype.toString.call(_))
            )
              return new Date(_.getTime());
            if (
              "number" == typeof _ ||
              "[object Number]" === Object.prototype.toString.call(_)
            )
              return new Date(_);
            if (
              !(
                "string" == typeof _ ||
                "[object String]" === Object.prototype.toString.call(_)
              )
            )
              return new Date(NaN);
            var z = (function (_) {
                var I,
                  R = {},
                  B = Sf.dateTimePattern.exec(_);
                if (
                  (B
                    ? ((R.date = B[1]), (I = B[3]))
                    : (B = Sf.datePattern.exec(_))
                    ? ((R.date = B[1]), (I = B[2]))
                    : ((R.date = null), (I = _)),
                  I)
                ) {
                  var z = Sf.timeZone.exec(I);
                  z
                    ? ((R.time = I.replace(z[1], "")),
                      (R.timeZone = z[1].trim()))
                    : (R.time = I);
                }
                return R;
              })(_),
              k = (function (_, I) {
                var R,
                  B = Sf.YYY[I],
                  z = Sf.YYYYY[I];
                if ((R = Sf.YYYY.exec(_) || z.exec(_))) {
                  var k = R[1];
                  return {
                    year: parseInt(k, 10),
                    restDateString: _.slice(k.length),
                  };
                }
                if ((R = Sf.YY.exec(_) || B.exec(_))) {
                  var V = R[1];
                  return {
                    year: 100 * parseInt(V, 10),
                    restDateString: _.slice(V.length),
                  };
                }
                return { year: null };
              })(z.date, B),
              V = k.year,
              j = (function (_, I) {
                if (null === I) return null;
                if (0 === _.length)
                  return (B = new Date(0)).setUTCFullYear(I), B;
                if ((R = Sf.MM.exec(_)))
                  return (
                    (B = new Date(0)),
                    dR(I, (z = parseInt(R[1], 10) - 1))
                      ? (B.setUTCFullYear(I, z), B)
                      : new Date(NaN)
                  );
                if ((R = Sf.DDD.exec(_))) {
                  B = new Date(0);
                  var R,
                    B,
                    z,
                    k,
                    V = parseInt(R[1], 10);
                  return !(function (_, I) {
                    if (I < 1) return !1;
                    var R = mR(_);
                    return !((R && I > 366) || (!R && I > 365));
                  })(I, V)
                    ? new Date(NaN)
                    : (B.setUTCFullYear(I, 0, V), B);
                }
                if ((R = Sf.MMDD.exec(_))) {
                  (B = new Date(0)), (z = parseInt(R[1], 10) - 1);
                  var j = parseInt(R[2], 10);
                  return dR(I, z, j)
                    ? (B.setUTCFullYear(I, z, j), B)
                    : new Date(NaN);
                }
                if ((R = Sf.Www.exec(_)))
                  return fR(I, (k = parseInt(R[1], 10) - 1))
                    ? hR(I, k)
                    : new Date(NaN);
                if ((R = Sf.WwwD.exec(_))) {
                  k = parseInt(R[1], 10) - 1;
                  var G = parseInt(R[2], 10) - 1;
                  return fR(I, k, G) ? hR(I, k, G) : new Date(NaN);
                }
                return null;
              })(k.restDateString, V);
            if (isNaN(j) || !j) return new Date(NaN);
            var G,
              q = j.getTime(),
              X = 0;
            if (
              z.time &&
              isNaN(
                (X = (function (_) {
                  var I, R, B;
                  if ((I = Sf.HH.exec(_)))
                    return c_((R = parseFloat(I[1].replace(",", "."))))
                      ? (R % 24) * 36e5
                      : NaN;
                  if ((I = Sf.HHMM.exec(_)))
                    return c_(
                      (R = parseInt(I[1], 10)),
                      (B = parseFloat(I[2].replace(",", ".")))
                    )
                      ? (R % 24) * 36e5 + 6e4 * B
                      : NaN;
                  if ((I = Sf.HHMMSS.exec(_))) {
                    (R = parseInt(I[1], 10)), (B = parseInt(I[2], 10));
                    var z = parseFloat(I[3].replace(",", "."));
                    return c_(R, B, z)
                      ? (R % 24) * 36e5 + 6e4 * B + 1e3 * z
                      : NaN;
                  }
                  return null;
                })(z.time))
              )
            )
              return new Date(NaN);
            if (z.timeZone || R.timeZone) {
              if (isNaN((G = Fm(z.timeZone || R.timeZone, new Date(q + X)))))
                return new Date(NaN);
            } else
              (G = (0, Su.default)(new Date(q + X))),
                (G = (0, Su.default)(new Date(q + X + G)));
            return new Date(q + X + G);
          })(R, void 0)),
          (k = Fm(B, z, !0)),
          (V = new Date(z.getTime() - k)),
          (j = new Date(0)).setFullYear(
            V.getUTCFullYear(),
            V.getUTCMonth(),
            V.getUTCDate()
          ),
          j.setHours(
            V.getUTCHours(),
            V.getUTCMinutes(),
            V.getUTCSeconds(),
            V.getUTCMilliseconds()
          ),
          ($ = j));
        let et = $.getHours(),
          er = $.getMinutes(),
          es;
        "12ampm" === I.format12h24h && (es = et >= 12 ? "PM" : "AM");
        let ea = et;
        switch (
          ("24" !== I.format12h24h && 0 == (ea = et % 12) && (ea = 12), X)
        ) {
          case "HH:mm:ss":
            G = [ea, er, Q];
            break;
          case "HH:mm":
            G = [ea, er];
            break;
          case "HH":
            (G = [ea]), (es = void 0);
            break;
          case "mm":
            (G = [er]), (es = void 0);
            break;
          case "ss":
            (G = [Q]), (es = void 0);
            break;
          case "year":
            q = $.getFullYear();
            break;
          case "month":
            q = $.getMonth() + 1;
            break;
          case "dayOfYear":
            q = Math.floor(
              ($.getTime() - new Date($.getFullYear(), 0, 0).getTime()) / 864e5
            );
            break;
          case "dayOfMonth":
            q = $.getDate();
            break;
          case "secondOfDay":
            q = 3600 * et + 60 * er + Q;
            break;
          default:
            console.error("Unknown time format", X), (q = 0);
        }
        return void 0 !== G ? { textValue: G, suffix: es } : q;
      }
      function ao(_, I) {
        let { alpha: R, mode: B, isMask: z } = _,
          k =
            "string" == typeof R ? (Number(I.getVariable(R)) ?? 100) / 100 : R;
        return { type: _.type, alpha: k, mode: B, isMask: z };
      }
      var Sy = class extends wA {},
        Sx = {
          noise: ["noiseType"],
          texture: ["projection", "axis", "side"],
          video: ["projection", "axis", "side"],
          displace: ["noiseType"],
          light: ["roughnessMap", "bumpMap"],
          depth: ["smooth", "isWorldSpace", "gradientType", "isVector"],
          pattern: ["style", "projection", "axis"],
        },
        Sw = { depth: ["colors"] };
      function m_(_, I, R) {
        let B = R.uniforms[`f${R.id}_texture`];
        if (!B) return !1;
        if ("image" in _) {
          let R = _.image,
            z = I.image(R);
          B.image instanceof Se || B.image.deref(), (B.image = z);
        }
        if ("video" in _) {
          let R = _.video,
            z = I.video(R);
          B.image instanceof Se || B.image.deref(), (B.image = z);
        }
        if (
          ("wrapping" in _ && (B.wrap = _.wrapping),
          "minFilter" in _ && (B.minFilter = _.minFilter),
          "repeat" in _ || "offset" in _)
        ) {
          let I = R.uniforms[`f${R.id}_mat`];
          "repeat" in _ && (I.repeat = _.repeat),
            "offset" in _ && (I.offset = _.offset),
            I.updateMatrix();
        }
        return !1;
      }
      var Ql = (_, I, R) =>
          Math.max(
            0,
            Math.min(
              1,
              Number(
                I.getVariable("number" == typeof _ ? 100 * _ : _, R) ?? 100
              ) / 100
            )
          ) ?? 1,
        S_ = class {
          constructor(_, I, R, B, z) {
            for (let z in ((this.id = _),
            (this.uuid = I),
            (this.data = R),
            (this.uniforms = {}),
            B))
              this.uniforms[`f${this.id}_${z}`] = B[z];
            for (let _ in R) g_(_, this, R, z);
          }
          get type() {
            return this.data.type;
          }
          static create(_, I, R, B) {
            if ("light" === R.type) return SM.createLigherLayer(_, I, R, B);
            if ("texture" === R.type || "video" === R.type) {
              let z =
                  "texture" === R.type
                    ? B.canvas(R.texture.image) ?? B.image(R.texture.image)
                    : B.video(R.texture.video),
                k = new _o(z, R.texture.wrapping, R.texture.minFilter ?? 1008),
                V = new _a(z),
                j = new _u(R.texture.repeat, R.texture.offset),
                G = new wj(R.crop ? 1 : 0),
                q = new _t(R.projection ?? 0),
                X = new _t(["x", "y", "z"].indexOf(R.axis) ?? 0),
                Q = new _t(R.side ?? 0),
                $ = new wb(
                  R.size ? new rs(R.size[0], R.size[1]) : new rs(100, 100)
                ),
                et = new wj(R.blending ?? 0),
                er = new wj(Ql(R.alpha, B)),
                es = new _t(R.mode ?? 0),
                ea = new _i(R.isMask ?? !1),
                en = new _y(k, V, G, q, X, Q, $, et, j, er, es, ea),
                eo = new wk(en.calpha, "f");
              return new SS(
                _,
                I,
                R,
                {
                  texture: k,
                  textureSize: V,
                  crop: G,
                  projection: q,
                  axis: X,
                  side: Q,
                  size: $,
                  blending: et,
                  mat: j,
                  alpha: er,
                  mode: es,
                  isMask: ea,
                },
                en,
                es,
                eo,
                ea,
                B
              );
            }
            if ("matcap" === R.type) {
              let z = B.image(R.texture.image),
                k = new _o(z, R.texture.wrapping, R.texture.minFilter ?? 1008),
                V = new wj(Ql(R.alpha, B)),
                j = new _t(R.mode ?? 0),
                G = new _i(R.isMask ?? !1),
                q = new _S(k, V, j, G),
                X = new wk(q.calpha, "f");
              return new SS(
                _,
                I,
                R,
                { texture: k, alpha: V, mode: j, isMask: G },
                q,
                j,
                X,
                G,
                B
              );
            }
            if ("displace" !== R.type) {
              let z;
              return (
                (z = (function (_, I) {
                  switch (_.type) {
                    case "fresnel":
                      return (function (_, I) {
                        let {
                          bias: R,
                          scale: B,
                          intensity: z,
                          factor: k,
                          color: V,
                        } = _;
                        return {
                          ...ao(_, I),
                          color: on(V, I),
                          bias: R,
                          scale: B,
                          intensity: z,
                          factor: k,
                        };
                      })(_, I);
                    case "gradient":
                      return (function (_, I) {
                        let {
                          gradientType: R,
                          smooth: B,
                          colors: z,
                          steps: k,
                          angle: V,
                          offset: j,
                          morph: G,
                        } = _;
                        return {
                          ...ao(_, I),
                          gradientType: R,
                          smooth: B,
                          colors: z.map((_) => new rM(_[0], _[1], _[2], _[3])),
                          num: z.length,
                          steps: k,
                          offset: new rs(...j),
                          morph: new rs(...G),
                          angle: V,
                        };
                      })(_, I);
                    case "depth":
                      return (function (_, I) {
                        let {
                          gradientType: R,
                          near: B,
                          far: z,
                          isVector: k,
                          isWorldSpace: V,
                          origin: j,
                          direction: G,
                          colors: q,
                          steps: X,
                          smooth: Q,
                        } = _;
                        return {
                          ...ao(_, I),
                          gradientType: R,
                          near: B,
                          far: z,
                          isVector: k,
                          isWorldSpace: V,
                          origin: new rF(...j),
                          direction: G ? new rF(...G) : new rF(1, 0, 0),
                          colors: q.map((_) =>
                            void 0 !== _
                              ? new rM(_[0], _[1], _[2], _[3])
                              : new rM(0, 0, 0, 0)
                          ),
                          steps: X.slice(0, q.length),
                          smooth: Q,
                        };
                      })(_, I);
                    case "normal":
                      return (function (_, I) {
                        let { cnormal: R } = _;
                        return {
                          ...ao(_, I),
                          cnormal: new rF(R[0], R[1], R[2]),
                        };
                      })(_, I);
                    case "noise":
                      return {
                        ...ao(_, I),
                        scale: _.scale,
                        move: _.move,
                        fA: new rs(..._.fA),
                        fB: new rs(..._.fB),
                        size: new rF(..._.size),
                        distortion: new rs(..._.distortion),
                        colorA: on(_.colorA, I),
                        colorB: on(_.colorB, I),
                        colorC: on(_.colorC, I),
                        colorD: on(_.colorD, I),
                        noiseType: _.noiseType,
                        voronoiStyle: _.voronoiStyle,
                        highCut: _.highCut,
                        lowCut: _.lowCut,
                        smoothness: _.smoothness,
                        seed: _.seed,
                        quality: _.quality,
                      };
                    case "rainbow":
                      return {
                        ...ao(_, I),
                        filmThickness: _.filmThickness,
                        movement: _.movement,
                        wavelengths: new rF(..._.wavelengths),
                        noiseStrength: _.noiseStrength,
                        noiseScale: _.noiseScale,
                        offset: new rF(..._.offset),
                      };
                    case "toon":
                      return {
                        ...ao(_, I),
                        positioning: _.positioning,
                        colors: _.colors.map(
                          (_) => new rM(_[0], _[1], _[2], _[3])
                        ),
                        num: _.colors.length,
                        steps: _.steps,
                        source: new rF(..._.source),
                        isWorldSpace: _.isWorldSpace,
                        noiseStrength: _.noiseStrength,
                        noiseScale: _.noiseScale,
                        shadowColor: on(_.shadowColor, I),
                        offset: new rF(..._.offset),
                      };
                    case "outline":
                      return {
                        ...ao(_, I),
                        outlineColor: on(_.outlineColor, I),
                        contourColor: on(_.contourColor, I),
                        outlineWidth: _.outlineWidth,
                        contourWidth: _.contourWidth,
                        outlineThreshold: _.outlineThreshold,
                        contourThreshold: _.contourThreshold,
                        outlineSmoothing: _.outlineSmoothing,
                        contourFrequency: _.contourFrequency,
                        contourDirection: new rF(..._.contourDirection),
                        positionalLines: _.positionalLines,
                        compensation: _.compensation,
                      };
                    case "transmission":
                      return {
                        ...ao(_, I),
                        thickness: _.thickness,
                        ior: _.ior,
                        roughness: _.roughness,
                      };
                    case "color":
                      return { ...ao(_, I), color: on(_.color, I) };
                    case "pattern":
                      return {
                        ...ao(_, I),
                        style: _.style,
                        projection: _.projection,
                        axis: _.axis,
                        blending: _.blending,
                        offset: new rs(..._.offset),
                        colorA: on(_.colorA, I),
                        colorB: on(_.colorB, I),
                        frequency: new rs(..._.frequency),
                        size: _.size,
                        variation: _.variation,
                        smoothness: _.smoothness,
                        zigzag: _.zigzag,
                        rotation: _.rotation,
                        vertical: new rs(..._.vertical),
                        horizontal: new rs(..._.horizontal),
                        sides: _.sides,
                      };
                  }
                })(R, B)),
                (function (_, I, R, B, z) {
                  switch (_.type) {
                    case "color": {
                      let k = new _e(B.color ?? 5526619),
                        V = Cs(B),
                        j = new _g(k, V.alpha),
                        G = new wk(j.calpha, "f");
                      return new SS(
                        I,
                        R,
                        _,
                        { color: k, ...V },
                        j,
                        V.mode,
                        G,
                        V.isMask,
                        z
                      );
                    }
                    case "fresnel": {
                      let k = new _e(B.color ?? 16777215),
                        V = new wj(B.bias ?? 0.1),
                        j = new wj(B.scale ?? 1),
                        G = new wj(B.intensity ?? 2),
                        q = new wj(B.factor ?? 1),
                        X = Cs(B),
                        Q = new _b(k, V, j, G, q, X.alpha, X.mode, X.isMask),
                        $ = new wk(Q.calpha, "f");
                      return new SS(
                        I,
                        R,
                        _,
                        {
                          color: k,
                          bias: V,
                          scale: j,
                          intensity: G,
                          factor: q,
                          ...X,
                        },
                        Q,
                        X.mode,
                        $,
                        X.isMask,
                        z
                      );
                    }
                    case "rainbow": {
                      let k = new wj(B.filmThickness ?? 30),
                        V = new wj(B.movement ?? 0),
                        j = new wS(B.wavelengths ?? new rF(0, 0, 0)),
                        G = new wj(B.noiseStrength ?? 0),
                        q = new wj(B.noiseScale ?? 1),
                        X = new wS(B.offset ?? new rF(0, 0, 0)),
                        Q = Cs(B),
                        $ = new _I(k, V, j, G, q, X, Q.alpha, Q.isMask),
                        et = new wk($.calpha, "f");
                      return new SS(
                        I,
                        R,
                        _,
                        {
                          filmThickness: k,
                          movement: V,
                          wavelengths: j,
                          noiseStrength: G,
                          noiseScale: q,
                          offset: X,
                          ...Q,
                        },
                        $,
                        Q.mode,
                        et,
                        Q.isMask,
                        z
                      );
                    }
                    case "transmission": {
                      let k = new wj(B.thickness ?? 10),
                        V = new wj(B.ior ?? 1.5),
                        j = new wj(B.roughness ?? 0.5),
                        G = _j.transmissionSize,
                        q = _j.transmissionRenderTarget,
                        X = _j.transmissionRenderTargetDepth,
                        Q = window.innerWidth,
                        $ = window.innerHeight,
                        et = Q >= $ ? new wb($ / Q, 1) : new wb(1, Q / $),
                        er = Cs(B),
                        es = new _F(k, V, j, G, q, X, et, er.alpha),
                        ea = new wk(es.calpha, "f");
                      return new SS(
                        I,
                        R,
                        _,
                        {
                          thickness: k,
                          ior: V,
                          roughness: j,
                          aspectRatio: et,
                          ...er,
                        },
                        es,
                        er.mode,
                        ea,
                        er.isMask,
                        z
                      );
                    }
                    case "toon": {
                      let k,
                        V = new _t(B.positioning ?? 0),
                        j;
                      B.colors
                        ? (j = new _f(B.colors.length, B.colors))
                        : ((j = new _f(10, new rM(0, 0, 0, 1))).value[1] =
                            new rM(1, 1, 1, 1)),
                        B.steps
                          ? (k = new _r(B.steps.length, B.steps))
                          : ((k = new _r(10, 1)).value[0] = 0);
                      let G = new wS(B.source ?? new rF(0, 0, 0)),
                        q = new _i(B.isWorldSpace ?? !0),
                        X = new wj(B.noiseStrength ?? 0),
                        Q = new wj(B.noiseScale ?? 1),
                        $ = new wM(B.shadowColor),
                        et = new wS(B.offset ?? new rF(0, 0, 0)),
                        er = Cs(B),
                        es = new _R(V, j, k, G, q, X, Q, $, et, er.alpha),
                        ea = new wk(es.calpha, "f");
                      return new SS(
                        I,
                        R,
                        _,
                        {
                          positioning: V,
                          colors: j,
                          steps: k,
                          source: G,
                          isWorldSpace: q,
                          noiseStrength: X,
                          noiseScale: Q,
                          shadowColor: $,
                          offset: et,
                          ...er,
                        },
                        es,
                        er.mode,
                        ea,
                        er.isMask,
                        z
                      );
                    }
                    case "outline": {
                      let k = new _e(B.outlineColor ?? 16777215),
                        V = new _e(B.contourColor ?? 16777215),
                        j = new wj(B.outlineWidth ?? 0.1),
                        G = new wj(B.contourWidth ?? 0.1),
                        q = new wj(B.outlineThreshold ?? 0.1),
                        X = new wj(B.contourThreshold ?? 0.1),
                        Q = new wj(B.outlineSmoothing ?? 0.1),
                        $ = new wj(B.contourFrequency ?? 0.1),
                        et = new wS(B.contourDirection ?? new rF(0, 1, 0)),
                        er = new _i(B.positionalLines ?? !1),
                        es = new _i(B.compensation ?? !0),
                        ea = _j.normalRenderTarget,
                        en = _j.normalRenderTargetDepth,
                        eo = _j.pixelRatioNode,
                        el = _j.resolution,
                        eh = Cs(B),
                        ec = new _D(
                          k,
                          V,
                          j,
                          G,
                          q,
                          X,
                          Q,
                          $,
                          et,
                          er,
                          es,
                          el,
                          ea,
                          en,
                          eo,
                          eh.alpha
                        ),
                        ed = new wk(ec.calpha, "f");
                      return new SS(
                        I,
                        R,
                        _,
                        {
                          outlineColor: k,
                          contourColor: V,
                          outlineWidth: j,
                          contourWidth: G,
                          outlineThreshold: q,
                          contourThreshold: X,
                          outlineSmoothing: Q,
                          contourFrequency: $,
                          contourDirection: et,
                          positionalLines: er,
                          compensation: es,
                          ...eh,
                        },
                        ec,
                        eh.mode,
                        ed,
                        eh.isMask,
                        z
                      );
                    }
                    case "depth": {
                      let k,
                        V = new _t(B.gradientType ?? 0),
                        j = new _i(B.smooth ?? !1),
                        G = new wj(B.near ?? 50),
                        q = new wj(B.far ?? 200),
                        X = new wj(B.isVector ?? 1),
                        Q = new wj(B.isWorldSpace ?? 0),
                        $ = new wS(B.origin ?? new rF()),
                        et = new wS(B.direction ?? new rF()),
                        er;
                      B.colors
                        ? (er = new _f(B.colors.length, B.colors))
                        : ((er = new _f(2, new rM(0, 0, 0, 1))).value[1] =
                            new rM(1, 1, 1, 1)),
                        B.steps
                          ? (k = new _r(B.steps.length, B.steps))
                          : ((k = new _r(2, 1)).value[0] = 0);
                      let es = Cs(B),
                        ea = new _x(
                          V,
                          j,
                          G,
                          q,
                          X,
                          Q,
                          $,
                          et,
                          er,
                          k,
                          es.alpha,
                          es.isMask
                        ),
                        en = new wk(ea.calpha, "f");
                      return new SS(
                        I,
                        R,
                        _,
                        {
                          gradientType: V,
                          smooth: j,
                          near: G,
                          far: q,
                          isVector: X,
                          isWorldSpace: Q,
                          origin: $,
                          direction: et,
                          colors: er,
                          steps: k,
                          ...es,
                        },
                        ea,
                        es.mode,
                        en,
                        es.isMask,
                        z
                      );
                    }
                    case "noise": {
                      let k = new wj(B.scale ?? 1),
                        V = new wS(B.size ?? new rF(100, 100, 100)),
                        j = new wj(B.move ?? 1),
                        G = new wb(B.fA ?? new rs(1.7, 9.2)),
                        q = new wb(B.fB ?? new rs(8.3, 2.8)),
                        X = new wb(B.distortion ?? new rs(1, 1)),
                        Q = new wM(B.colorA),
                        $ = new wM(B.colorB),
                        et = new wM(B.colorC),
                        er = new wM(B.colorD),
                        es = new _t(B.noiseType ?? 0),
                        ea = new _t(B.voronoiStyle ?? 0),
                        en = new wj(B.highCut ?? 1),
                        eo = new wj(B.lowCut ?? 0),
                        el = new wj(B.smoothness ?? 0.5),
                        eh = new wj(B.seed ?? 0.5),
                        ec = new _t(B.quality ?? 1),
                        ed = Cs(B),
                        ep = new _T(
                          k,
                          V,
                          j,
                          G,
                          q,
                          X,
                          Q,
                          $,
                          et,
                          er,
                          ed.alpha,
                          es,
                          ed.isMask,
                          ea,
                          en,
                          eo,
                          el,
                          eh,
                          ec
                        ),
                        ef = new wk(ep.calpha, "f");
                      return new SS(
                        I,
                        R,
                        _,
                        {
                          scale: k,
                          size: V,
                          move: j,
                          fA: G,
                          fB: q,
                          distortion: X,
                          colorA: Q,
                          colorB: $,
                          colorC: et,
                          colorD: er,
                          noiseType: es,
                          ...ed,
                          voronoiStyle: ea,
                          highCut: en,
                          lowCut: eo,
                          smoothness: el,
                          seed: eh,
                          quality: ec,
                        },
                        ep,
                        ed.mode,
                        ef,
                        ed.isMask,
                        z
                      );
                    }
                    case "normal": {
                      let k = new wS(B.cnormal ?? new rF(1, 1, 1)),
                        V = Cs(B),
                        j = new _v(k, V.alpha),
                        G = new wk(j.calpha, "f");
                      return new SS(
                        I,
                        R,
                        _,
                        { cnormal: k, ...V },
                        j,
                        V.mode,
                        G,
                        V.isMask,
                        z
                      );
                    }
                    case "gradient": {
                      let k,
                        V = new _t(B.gradientType ?? 0),
                        j = new _i(B.smooth ?? !1),
                        G;
                      B.colors
                        ? (G = new _f(B.colors.length, B.colors))
                        : ((G = new _f(10, new rM(0, 0, 0, 1))).value[1] =
                            new rM(1, 1, 1, 1)),
                        B.steps
                          ? (k = new _r(B.steps.length, B.steps))
                          : ((k = new _r(10, 1)).value[0] = 0);
                      let q = new wb(B.offset ?? new rs(0, 0)),
                        X = new wb(B.morph ?? new rs(0, 0)),
                        Q = new wj(B.angle ?? 0),
                        $ = Cs(B),
                        et = new _w(V, j, G, k, q, X, Q, $.alpha, $.isMask),
                        er = new wk(et.calpha, "f");
                      return new SS(
                        I,
                        R,
                        _,
                        {
                          gradientType: V,
                          smooth: j,
                          colors: G,
                          steps: k,
                          offset: q,
                          morph: X,
                          angle: Q,
                          ...$,
                        },
                        et,
                        $.mode,
                        er,
                        $.isMask,
                        z
                      );
                    }
                    case "pattern": {
                      let k = new _t(B.style ?? 0),
                        V = new _t(B.projection ?? 0),
                        j = new _t(["x", "y", "z"].indexOf(B.axis) ?? 0),
                        G = new wj(B.blending ?? 0),
                        q = new wb(B.offset ?? new rs(0, 0)),
                        X = new wM(B.colorA),
                        Q = new wM(B.colorB),
                        $ = new wb(B.frequency ?? new rs(10, 10)),
                        et = new wj(B.size ?? 0.5),
                        er = new wj(B.variation ?? 0),
                        es = new wj(B.smoothness ?? 0.5),
                        ea = new wj(B.zigzag ?? 0),
                        en = new wj(B.rotation ?? 0),
                        eo = new wb(B.vertical ?? new rs(0, 1)),
                        el = new wb(B.horizontal ?? new rs(0, 1)),
                        eh = new _t(B.sides ?? 6),
                        ec = Cs(B),
                        ed = new _O(
                          k,
                          V,
                          j,
                          G,
                          q,
                          X,
                          Q,
                          $,
                          et,
                          er,
                          es,
                          ea,
                          en,
                          eo,
                          el,
                          eh,
                          ec.alpha,
                          ec.isMask
                        ),
                        ep = new wk(ed.calpha, "f");
                      return new SS(
                        I,
                        R,
                        _,
                        {
                          style: k,
                          projection: V,
                          axis: j,
                          blending: G,
                          offset: q,
                          colorA: X,
                          colorB: Q,
                          frequency: $,
                          size: et,
                          variation: er,
                          smoothness: es,
                          zigzag: ea,
                          rotation: en,
                          vertical: eo,
                          horizontal: el,
                          sides: eh,
                          ...ec,
                        },
                        ed,
                        ec.mode,
                        ep,
                        ec.isMask,
                        z
                      );
                    }
                    default: {
                      let k = new _e(1, 0, 0, 1),
                        V = Cs(B),
                        j = new _g(k, V.alpha),
                        G = new wk(j.calpha, "f");
                      return new SS(
                        I,
                        R,
                        _,
                        { color: k, ...V },
                        j,
                        V.mode,
                        G,
                        V.isMask,
                        z
                      );
                    }
                  }
                })(R, _, I, z, B)
              );
            }
            if ("noise" === R.displacementType) {
              let z = new wS(new rF(...R.offset)),
                k = new wj(R.scale ?? 10),
                V = new wj(R.intensity ?? 8),
                j = new wj(R.movement ?? 1),
                G = new _t(R.noiseType ?? 0),
                q = new _t(R.voronoiStyle ?? 0),
                X = new wj(R.smoothness ?? 0.5),
                Q = new wj(R.seed ?? 0),
                $ = new wj(R.highCut ?? 1),
                et = new wj(R.lowCut ?? 0),
                er = new _t(R.quality ?? 1),
                es = new _V(V, j, z, q, X, Q, $, et, er, k, G);
              return new SA(
                _,
                I,
                R,
                {
                  offset: z,
                  scale: k,
                  intensity: V,
                  movement: j,
                  noiseType: G,
                  voronoiStyle: q,
                  smoothness: X,
                  seed: Q,
                  highCut: $,
                  lowCut: et,
                  quality: er,
                },
                es,
                B
              );
            }
            throw Error();
          }
          updateByOp(_, I, R) {
            if (void 0 === _.path[0]) {
              if (0 === _.type)
                return "type" in _.props ||
                  "category" in _.props ||
                  "visible" in _.props
                  ? (R.scene.markNeedsUpdateRendererDirty(), !0)
                  : (function (_, I, R, B) {
                      let z = !1;
                      for (let [k, V] of Object.entries(_)) {
                        if ("bumpMap" === k || "roughnessMap" === k) {
                          z = !0;
                          continue;
                        }
                        if (!k || void 0 === V) continue;
                        if (g_(k, R, B, I)) {
                          "visible" === k && "light" === R.type && (z = !0);
                          continue;
                        }
                        R.visible = B.visible;
                        let _ = R.uniforms[`f${R.id}_${k}`];
                        if (_ && !(_ instanceof _s))
                          switch (
                            ((z =
                              z ||
                              (function (_, I, R) {
                                if ("isMask" === I) return !0;
                                let B = Sx[_.type],
                                  z = Sw[_.type];
                                if (void 0 !== z) {
                                  let B = _.color;
                                  if (z.includes(I)) {
                                    let _ = B[I]?.value?.length;
                                    if (void 0 !== _ && _ !== R.length)
                                      return !0;
                                  }
                                }
                                return void 0 !== B && B.includes(I);
                              })(R, k, V)),
                            _.constructor)
                          ) {
                            case _e:
                              if ("string" == typeof V) {
                                let R = I.getColor(V);
                                R && (_.value = R);
                                break;
                              }
                              _.value instanceof Sy
                                ? (_.value = new wA(V.r, V.g, V.b, V.a))
                                : _.setRGBA(V);
                              break;
                            case wM:
                              if ("string" == typeof V) {
                                let R = I.getColor(V);
                                R && (_.value = R);
                                break;
                              }
                              _.value instanceof Sy
                                ? (_.value = new wA(V.r, V.g, V.b, V.a))
                                : _.value.setRGBA(V.r, V.g, V.b, V.a);
                              break;
                            case wb:
                              _.value.setX(V[0]), _.value.setY(V[1]);
                              break;
                            case wS:
                              _.value.setX(V[0]),
                                _.value.setY(V[1]),
                                _.value.setZ(V[2]);
                              break;
                            case wV:
                              m_(V, I, R);
                              break;
                            case _f:
                              _.value = V.map((_) => new rM(..._));
                              break;
                            default:
                              _.value = V;
                          }
                      }
                      return z;
                    })(_.props, R.shared, this, I);
            } else if ("texture" === _.path[0])
              return (
                (!("texture" in I) && !("video" in I)) ||
                m_(_.props, R.shared, this)
              );
            return !1;
          }
          dispose() {
            let _;
            if (
              "texture" === (_ = this instanceof S_ ? this.type : this) ||
              "video" === _ ||
              "displace_map" === _ ||
              "matcap" === _
            ) {
              let _ = this.uniforms[`f${this.id}_texture`];
              if (!_) return !1;
              _.image instanceof Se || _.image.deref();
            }
          }
          hasValueByKey(_) {
            return void 0 !== this.uniforms[_];
          }
          hasValue(_) {
            return this.hasValueByKey(`f${this.id}_${_}`);
          }
          setValue(_, I) {
            let R = `f${this.id}_${_}`;
            this.hasValueByKey(R) &&
              void 0 !== I &&
              (this.uniforms[R].value = I);
          }
          getNode(_) {
            let I = `f${this.id}_${_}`;
            if (this.hasValueByKey(I)) return this.uniforms[I];
          }
          getValue(_) {
            let I = `f${this.id}_${_}`;
            if (this.hasValueByKey(I)) return this.uniforms[I].value;
          }
          getName(_) {
            let I = /f\d+_(.*)/.exec(_);
            if (I && I.length > 1) return I[1];
            console.log(`Layer.getName: error ${_}`);
          }
          getNames() {
            let _ = [];
            for (let I in this.uniforms) {
              let R = this.getName(I);
              R && _.push(R);
            }
            return _;
          }
        },
        SS = class extends S_ {
          constructor(_, I, R, B, z, k, V, j, G) {
            super(_, I, R, B, G),
              (this.params = B),
              (this.color = z),
              (this.mode = k),
              (this.alpha = V),
              (this.isMask = j);
          }
        },
        SA = class extends S_ {
          constructor(_, I, R, B, z, k) {
            super(_, I, R, B, k), (this.position = z);
          }
        },
        SM = class extends S_ {
          constructor(_, I, R, B, z, k) {
            super(_, I, R, z, k), (this.node = B);
          }
          static createLigherLayer(_, I, R, B) {
            let z,
              k = new wj(Ql(R.alpha, B)),
              V = new _t(R.mode),
              j = new wj(R.bumpMapIntensity),
              G = new wj(Ql(R.alphaOverride, B)),
              q;
            if (R.visible) {
              if ("lambert" === R.category) {
                z = new _J();
                let _ = new _e(B.color(R.emissive) ?? 0),
                  I = new _i(R.occlusion ?? !0);
                (q = { emissive: _, occlusion: I }),
                  (z.emissive = _),
                  (z.occlusion = I);
              } else if ("toon" === R.category) {
                z = new _4();
                let _ = new wj(R.shininess ?? 30),
                  I = new _e(B.color(R.specular) ?? 1118481);
                (q = { shininess: _, specular: I }),
                  (z.shininess = _),
                  (z.specular = I);
              } else if ("physical" === R.category) {
                z = new _3();
                let _ = new wj(R.roughness ?? 0.3),
                  I = new wj(R.metalness ?? 0),
                  B = new wj(R.reflectivity ?? 0.5),
                  k = new _i(R.occlusion ?? !0);
                (q = {
                  roughness: _,
                  metalness: I,
                  reflectivity: B,
                  occlusion: k,
                }),
                  (z.roughness = _),
                  (z.metalness = I),
                  (z.reflectivity = B),
                  (z.occlusion = k);
              } else {
                z = new _1();
                let _ = new wj(R.shininess ?? 30),
                  I = new _e(
                    void 0 !== R.specular
                      ? B.color(R.specular) ?? 1118481
                      : 1118481
                  ),
                  k = new _i(R.occlusion ?? !0);
                (q = { shininess: _, specular: I, occlusion: k }),
                  (z.shininess = _),
                  (z.specular = I),
                  (z.occlusion = k);
              }
            } else (z = new _K()), (q = {});
            return (
              (z.alpha = new wj(1)),
              (z.shadingAlpha = k),
              (z.shadingBlend = V),
              (z.bumpMapIntensity = j),
              (z.alphaOverride = G),
              (q.alpha = z.shadingAlpha),
              (q.mode = z.shadingBlend),
              (q.bumpMapIntensity = z.bumpMapIntensity),
              (q.alphaOverride = z.alphaOverride),
              new SM(_, I, R, z, q, B)
            );
          }
          get category() {
            return this.node.category;
          }
        };
      function Cs(_) {
        return {
          alpha: new wj(_.alpha ?? 1),
          mode: new _t(_.mode ?? 0),
          isMask: new _i(_.isMask ?? !1),
        };
      }
      function g_(_, I, R, B) {
        if ("displace" === R.type && ("intensity" === _ || "visible" === _)) {
          let _ = I.uniforms[`f${I.id}_intensity`];
          return _
            ? ((_.value = R.intensity * (R.visible ? 1 : 0)), _)
            : void 0;
        }
        if ("displace" !== R.type && ("alpha" === _ || "visible" === _)) {
          let z = I.uniforms[`f${I.id}_alpha`];
          if (!z) return;
          if (
            ((z.value = Ql(R.alpha, B) * (R.visible ? 1 : 0)),
            "outline" === R.type && "visible" === _)
          ) {
            let _ = I.uniforms[`f${I.id}_compensation`];
            _ && (_.value = R.compensation && R.visible);
          }
          return z;
        }
      }
      function eu(_, I) {
        let R = 0,
          B = _.layers.find((_) => "light" === _.data.type);
        if (B) {
          let _ = B.data,
            R = Number(I.getVariable(_.alphaOverride));
          if (
            ("string" == typeof _.alphaOverride ? R / 100 : _.alphaOverride) < 1
          )
            return !0;
        }
        for (let B of _.layers) {
          if ("displace" !== B.data.type && B.data.isMask) return !0;
          if (
            "displace" !== B.data.type &&
            "alpha" in B.data &&
            "light" !== B.data.type &&
            "fresnel" !== B.data.type &&
            "texture" !== B.data.type &&
            "matcap" !== B.data.type &&
            "rainbow" !== B.data.type &&
            "outline" !== B.data.type &&
            "pattern" !== B.data.type
          ) {
            let _ = B.data.visible ? B.data.alpha : 0;
            if (
              ("string" == typeof _ &&
                (_ = Math.max(
                  0,
                  Math.min(1, Number(I.getVariable(_) ?? 100) / 100)
                )),
              (1 === _ && "depth" === B.data.type) ||
                "gradient" === B.data.type)
            ) {
              for (let I of B.data.colors)
                if (I[3] < 1) {
                  _ = I[3];
                  break;
                }
            } else if (1 === _ && "noise" === B.data.type) {
              let R = Math.min(
                I.color(B.data.colorA).a,
                Math.min(
                  I.color(B.data.colorB).a,
                  Math.min(I.color(B.data.colorC).a, I.color(B.data.colorD).a)
                )
              );
              R < 1 && (_ = R);
            }
            R += (1 - R) * _;
          }
        }
        return R < 1;
      }
      var SC = class extends aT {
          constructor() {
            super(void 0),
              (this.flatShading = !1),
              (this.needsJitter = !0),
              (this.cacheKey = ""),
              (this.fog = !0),
              (this.dithering = !0),
              (this.vertexColors = !0),
              (this.transparent = !0);
          }
          customProgramCacheKey() {
            return this.cacheKey;
          }
        },
        ST = class extends SC {
          constructor(_, I, R, B) {
            super(),
              (this.flatShading = _),
              (this.side = I),
              (this.wireframe = R),
              (this.root = B);
          }
          updateAfterBuild() {
            let _ = this.root;
            (this.lights = _.lights),
              (this.vertexShader = _.vertexShader),
              (this.fragmentShader = _.fragmentShader),
              (this.defines = _.defines),
              (this.uniforms = _.uniforms),
              (this.extensions = _.extensions),
              (this.transparent = _.transparent),
              (this.cacheKey =
                _.customProgramCacheKey() +
                "flat" +
                this.flatShading +
                this.side);
          }
          onBeforeCompile(_, I) {
            this.root.onBeforeCompile(_);
          }
          get data() {
            return this.root.data;
          }
          get category() {
            return this.root.category;
          }
          get hasAO() {
            return this.root.hasAO;
          }
          getFlavor(_, I, R) {
            return this.root.getFlavor(_, I, R);
          }
          get layers() {
            return this.root.layers;
          }
          get fragment() {
            return this.root.fragment;
          }
          getLayersOfType(_) {
            return this.root.getLayersOfType(_);
          }
          getLayerByUuid(_) {
            return this.root.getLayerByUuid(_);
          }
          updateByOp(_, I, R) {
            this.root.updateByOp(_, I, R);
          }
          nodeMaterialDispose() {
            this.root.nodeMaterialDispose();
          }
        },
        SO = class extends SC {
          constructor(_, I, R = !0) {
            super(),
              (this.data = _),
              (this.allowVariableSaves = R),
              (this.layerIdGen = 0),
              (this.flavors = []),
              (this.masks = {}),
              (this.type = "NodeMaterial"),
              (this.updaters = []),
              this.reset0(_, I);
          }
          get nodeMaterial() {
            return this;
          }
          getFlavor(_, I, R) {
            let B = R ? 6 : (_ ? 3 : 0) + I;
            if (0 === B) return this;
            void 0 === this.flavors && (this.flavors = []), (B -= 1);
            let z = this.flavors[B];
            return (
              void 0 === z &&
                ((z = new ST(_, I, R, this)),
                (this.flavors[B] = z),
                (z.flatShading = _),
                (z.side = I),
                z.updateAfterBuild()),
              z
            );
          }
          get fragment() {
            return this.lightLayer.node;
          }
          get category() {
            return this.lightLayer.category;
          }
          get hasAO() {
            return this.lightLayer.getNode("occlusion")?.value ?? !1;
          }
          reset(_, I, R = !1) {
            (this.data !== _ || R) && this.reset0(_, I);
          }
          reset0(_, I) {
            this.data = _;
            let R = _.layers ?? gG.defaultTwoLayerData("phong").layers;
            try {
              this.layers = R.map((_) =>
                S_.create(this.layerIdGen++, _.id, _.data, I.shared)
              );
            } catch {
              this.layers = [];
            }
            this.layers.reverse(),
              (this.name = _.name ?? "Untitled Material"),
              this.onUpdate(I.shared),
              (this.transparent = eu(_, I.shared)),
              this.saveVariableLocations(I);
          }
          onVariableUpdate(_, I, R) {
            if ("alphaOverride" === _[0])
              (this.transparent = eu(this.data, R.shared)),
                this.lightLayer.setValue(
                  "alphaOverride",
                  Math.max(0, Math.min(Number(I) / 100, 1))
                );
            else if ("layer" === _[0]) {
              let B = _[1],
                z = _[2];
              if (B && z) {
                let _ = this.layers.find((_) => _.uuid === B);
                _?.hasValue(z) &&
                  ("alpha" === z
                    ? ((this.transparent = eu(this.data, R.shared)),
                      _.setValue(z, Math.max(0, Math.min(Number(I) / 100, 1))))
                    : _.setValue(z, I));
              }
            }
          }
          saveVariableLocations(_) {
            if (!this.allowVariableSaves) return;
            let I = this.data.layers.find((_) => "light" === _.data.type);
            I &&
              _.shared.getVariable(I.data.alphaOverride, [
                "material",
                this.uuid,
                "alphaOverride",
              ]),
              this.data.layers.forEach((I) => {
                "alpha" in I.data &&
                  "string" == typeof I.data.alpha &&
                  _.shared.getVariable(I.data.alpha, [
                    "material",
                    this.uuid,
                    "layer",
                    I.id,
                    "alpha",
                  ]);
              });
          }
          getLayersOfType(_) {
            return this.layers.filter((I) => I.type === _);
          }
          getLayerByUuid(_) {
            return this.layers.find((I) => I.uuid === _);
          }
          onUpdate(_) {
            for (let I of ((this.cacheKey = this.computeCacheKey()),
            (this.lightLayer = this.layers.find((_) => _ instanceof SM)),
            void 0 === this.lightLayer &&
              (this.lightLayer = new SM(
                0,
                "",
                { ...mq.defaultData("light", "phong"), visible: !1 },
                new _K(),
                {},
                _
              )),
            this.dispose(),
            this.flavors))
              I && I.dispose();
            this.applyTextureMaps(),
              this.applyMasks(),
              this.blendColors(),
              this.blendAfterColors(),
              this.blendPositions();
          }
          applyTextureMaps() {
            let _ = this.layers.find((_) => _ instanceof SM);
            if (!_) return;
            let I = _.data,
              R = I.bumpMap,
              B = I.roughnessMap;
            (_.node.bumpMap = void 0), (_.node.roughnessMap = void 0);
            for (let I = 0; I < this.layers.length; ++I) {
              let z = this.layers[I];
              z instanceof SS &&
                z.color instanceof _y &&
                (z.uuid === R && (_.node.bumpMap = z.color),
                z.uuid === B && (_.node.roughnessMap = z.color));
            }
          }
          updateByOp(_, I, R) {
            if (
              (void 0 !== I ? (this.data = I) : (I = this.data),
              (this.transparent = eu(I, R.shared)),
              "layers" === _.path[0])
            ) {
              this.data = I;
              let B = R.shared,
                z = _.path[1];
              if (void 0 === z) {
                if ((this.layers.reverse(), 4 === _.type)) {
                  let I = S_.create(this.layerIdGen++, _.id, _.data, R.shared);
                  this.layers.splice(_.localIndex, 0, I),
                    R.scene.markNeedsUpdateRendererDirty();
                } else if (5 === _.type)
                  this.layers.splice(_.localIndex, 1)[0].dispose(),
                    R.scene.markNeedsUpdateRendererDirty();
                else if (6 === _.type) {
                  let I = this.layers.findIndex((I) => I.uuid === _.id),
                    B = this.layers[I];
                  this.layers.splice(I, 1),
                    this.layers.splice(_.localIndex, 0, B),
                    R.scene.markNeedsUpdateRendererDirty();
                }
                this.layers.reverse(), this.onUpdate(R.shared);
              } else {
                0 === _.type &&
                  void 0 !== _.props.occlusion &&
                  R.scene.markNeedsUpdateRendererDirty();
                let k = this.layers.find((_) => _.uuid === z);
                if (k) {
                  let V = I.layers.data(z),
                    j;
                  if (
                    (0 === _.type &&
                      ("alpha" in _.props || "alphaOverride" in _.props) &&
                      (j =
                        "alpha" in _.props
                          ? {
                              ..._.props,
                              alpha: Ql(_.props.alpha, B, [
                                "material",
                                this.uuid,
                                "layer",
                                z,
                                "alpha",
                              ]),
                            }
                          : {
                              ..._.props,
                              alphaOverride: Ql(_.props.alphaOverride, B, [
                                "material",
                                this.uuid,
                                "alphaOverride",
                              ]),
                            }),
                    k.updateByOp(
                      {
                        ..._,
                        ...(j ? { props: j } : {}),
                        path: _.path.slice(2),
                      },
                      V,
                      R
                    ))
                  ) {
                    let _ = S_.create(this.layerIdGen++, z, V, B);
                    this.layers.splice(
                      this.layers.findIndex((_) => _.uuid === z),
                      1,
                      _
                    ),
                      this.onUpdate(R.shared);
                  }
                }
              }
            } else this.reset(I, R);
          }
          applyMasks() {
            for (let _ = 0; _ < this.layers.length; ++_) {
              let I = this.layers[_];
              I instanceof SS
                ? (I.color.mask = void 0)
                : I instanceof SM && (I.node.mask = void 0);
            }
            for (let _ = 0; _ < this.layers.length; ++_) {
              let I = this.layers[_];
              if (
                I instanceof SS &&
                I.isMask.value &&
                I.data.visible &&
                _ > 0
              ) {
                let R = _ - 1,
                  B = this.layers[R];
                B instanceof SM
                  ? (B.node.mask = new wH(I.color, I.alpha, wH.MUL))
                  : B instanceof SS &&
                    (B.isMask.value ||
                      (B.color.mask = new wH(I.color, I.alpha, wH.MUL)));
              }
            }
          }
          blendColors() {
            let _ = this.layers.findIndex((_) => _ instanceof SS),
              I = this.layers.findIndex((_) => _ instanceof SM);
            if (-1 !== _ && _ < I) {
              let R = this.layers[_].color;
              for (let B = _ + 1; B < I; ++B) {
                let _ = this.layers[B];
                if (_ instanceof SS) {
                  if (_.isMask.value) continue;
                  R = new _m(R, _.color, _.alpha, _.mode);
                }
              }
              this.fragment.color = R;
            } else this.fragment.color = void 0;
          }
          blendAfterColors() {
            let _ = new wk("outgoingLight", "f"),
              I = this.layers.findIndex((_) => _ instanceof SM);
            if (this.layers.length > I + 1) {
              for (let R = I + 1; R < this.layers.length; ++R) {
                let I = this.layers[R];
                if (I instanceof SS) {
                  if (I.isMask.value) continue;
                  _ = new _m(_, I.color, I.alpha, I.mode);
                }
              }
              this.fragment.afterColor = _;
            } else this.fragment.afterColor = void 0;
          }
          blendPositions() {
            let _ = this.layers.filter((_) => _ instanceof SA);
            if (_.length > 0) {
              let I = _[0].position;
              for (let R = 1; R < _.length; ++R)
                _[R] &&
                  ((I = new wH(I, _[R].position, wH.ADD)),
                  (I = new wH(I, new wj(0.5).setReadonly(!0), wH.MUL)));
              this.fragment.position = I;
            } else this.fragment.position = void 0;
          }
          getDefines() {
            return this.defines;
          }
          getUniforms() {
            return this.uniforms;
          }
          getVertexShader() {
            return this.vertexShader;
          }
          getFragmentShader() {
            return this.fragmentShader;
          }
          onBeforeCompile(_) {
            this.build(),
              (_.defines = this.defines),
              (_.uniforms = this.uniforms),
              (_.vertexShader = this.vertexShader),
              (_.fragmentShader = this.fragmentShader),
              (_.extensionDerivatives = !0 === this.extensions.derivatives),
              (_.extensionFragDepth = !0 === this.extensions.fragDepth),
              (_.extensionDrawBuffers = !0 === this.extensions.drawBuffers),
              (_.extensionShaderTextureLOD =
                !0 === this.extensions.shaderTextureLOD);
          }
          clampUniformsForPreview(_, I) {
            let i = (_, I, R) => Math.min(Math.max(_, I), R);
            for (let R of this.layers)
              if ("displace" === R.type) {
                let B = i(R.uniforms[`f${R.id}_intensity`].value, _, I);
                R.uniforms[`f${R.id}_intensity`].value = B;
              }
          }
          computeCacheKey() {
            let _ = "[";
            for (let { data: I } of this.data.layers)
              if ("light" === I.type)
                _ += `"${I.visible ? I.category.toUpperCase() : "Basic"}"`;
              else {
                let R = [
                    ...(Sx[I.type] ?? []).map((_) => I[_]),
                    ...(Sw[I.type] ?? []).map((_) => I[_]?.length ?? 0),
                  ],
                  B = "isMask" in I && I.isMask,
                  z = `"${I.type}-${I.visible}-${B}"`;
                R.length ? (_ += `[${z}, "${R.join('","')}"],`) : (_ += z);
              }
            return _.slice(0, -1) + "]";
          }
          updateFrame(_) {
            for (let I = 0; I < this.updaters.length; ++I)
              _.updateNode(this.updaters[I]);
          }
          build() {
            let _ = new w7();
            for (let I of ((_.needsJitter = this.needsJitter),
            (this.lights = this.lightLayer.data.visible),
            _.build(this.fragment, this.fragment),
            (this.vertexShader = _.getCode("vertex")),
            (this.fragmentShader = _.getCode("fragment")),
            (this.defines = _.defines),
            (this.uniforms = _.uniforms),
            (this.extensions = _.extensions),
            (this.updaters = _.updaters),
            this.flavors))
              I && I.updateAfterBuild();
            return this;
          }
          nodeMaterialDispose() {
            for (let _ of (this.layers.forEach((_) => _.dispose()),
            super.dispose(),
            this.flavors))
              _ && _.dispose();
          }
          assetsLoaded() {
            for (let _ of this.layers)
              if (_ instanceof SS) {
                let I = _.params.texture;
                if (I instanceof _o && !I.image.loaded) return !1;
              }
            return !0;
          }
          getHash() {
            return '{"fragment":' + this.fragment.getHash() + "}";
          }
        };
      Object.defineProperties(SC.prototype, {
        properties: {
          get: function () {
            return this.fragment.properties;
          },
        },
      });
      var SI,
        SR = class extends SO {
          constructor(_, I, R) {
            super(_, I, !1),
              (this.uuid = R),
              (this.allowVariableSaves = !0),
              this.saveVariableLocations(I);
          }
        },
        SB = pi(iH()),
        SL = new Map(),
        Sz = class {
          constructor({ src: _, volume: I, delay: R, loop: B }) {
            let z;
            (this._volume = 1),
              (this.delay = 0),
              (this._loop = 1),
              (this.loopsRemaining = 0),
              (this._status = "stopped"),
              (this.onEnd = () => {
                this.loopsRemaining === 1 / 0
                  ? this.replay()
                  : this.loopsRemaining > 1
                  ? (this.replay(), this.loopsRemaining--)
                  : ((this._status = "stopped"),
                    (this.loopsRemaining = this._loop));
              }),
              (z =
                "string" == typeof _
                  ? { src: _ }
                  : {
                      src: (function (_) {
                        if ("string" == typeof _) return _;
                        let I = SL.get(_);
                        return (
                          I ||
                            ((I = { url: URL.createObjectURL(new Blob([_])) }),
                            SL.set(_, I)),
                          I.url
                        );
                      })(_),
                      format: "wav",
                    }),
              (this.sound = new SB.Howl(z)),
              this.sound.on("end", this.onEnd),
              (this.src = _),
              void 0 !== I && (this.volume = I),
              void 0 !== R && (this.delay = R),
              void 0 !== B && (this.loop = B);
          }
          get status() {
            return this._status;
          }
          get volume() {
            return this._volume;
          }
          set volume(_) {
            (this._volume = _), this.sound.volume(_);
          }
          get loop() {
            return this._loop;
          }
          set loop(_) {
            (this._loop = _), (this.loopsRemaining = _);
          }
          replay() {
            this.clearDelay(),
              (this.delayTimerId = window.setTimeout(() => {
                this.sound.play(), this.clearDelay();
              }, this.delay));
          }
          fade(_, I = 1e3) {
            _
              ? (this.sound.volume(this._volume),
                this.clearFade(),
                (this.fadeTimerId = window.setTimeout(() => {
                  this.sound.fade(this._volume, 0, I), this.clearFade();
                }, _)))
              : this.sound.fade(this._volume, 0, I);
          }
          on(_, I, R) {
            this.sound.on(_, I, R);
          }
          off(_, I, R) {
            this.sound.off(_, I, R);
          }
          play() {
            "playing" === this._status ||
              this.sound.playing() ||
              ("paused" === this._status
                ? (0 === this.sound.seek() ? this.replay() : this.sound.play(),
                  (this._status = "playing"))
                : "stopped" === this._status &&
                  (this.replay(), (this._status = "playing")));
          }
          pause() {
            "playing" === this._status &&
              (this.sound.pause(),
              this.clearFade(),
              this.clearDelay(),
              (this._status = "paused"));
          }
          stop() {
            this.sound.stop(),
              (this.loopsRemaining = this._loop),
              this.clearFade(),
              this.clearDelay(),
              (this._status = "stopped");
          }
          clearFade() {
            this.fadeTimerId &&
              (clearTimeout(this.fadeTimerId), delete this.fadeTimerId);
          }
          clearDelay() {
            this.delayTimerId &&
              (clearTimeout(this.delayTimerId), delete this.delayTimerId);
          }
          dispose(_ = !1) {
            this.off(), this.stop(), this.clearFade(), this.clearDelay();
          }
        },
        SF = class {
          constructor() {
            (this.type = "ShapePath"),
              (this.color = new ry()),
              (this.subPaths = []),
              (this.currentPath = null);
          }
          moveTo(_, I) {
            return (
              (this.currentPath = new oM()),
              this.subPaths.push(this.currentPath),
              this.currentPath.moveTo(_, I),
              this
            );
          }
          lineTo(_, I) {
            return this.currentPath?.lineTo(_, I), this;
          }
          quadraticCurveTo(_, I, R, B) {
            return this.currentPath?.quadraticCurveTo(_, I, R, B), this;
          }
          bezierCurveTo(_, I, R, B, z, k) {
            return this.currentPath?.bezierCurveTo(_, I, R, B, z, k), this;
          }
          splineThru(_) {
            return this.currentPath?.splineThru(_), this;
          }
          toShapes() {
            let _ = {
                ORIGIN: 0,
                DESTINATION: 1,
                BETWEEN: 2,
                LEFT: 3,
                RIGHT: 4,
                BEHIND: 5,
                BEYOND: 6,
              },
              I = { loc: _.ORIGIN, t: 0 };
            function s(R, B, z) {
              let k = z.x - B.x,
                V = z.y - B.y,
                j = R.x - B.x,
                G = R.y - B.y,
                q = k * G - j * V;
              if (R.x === B.x && R.y === B.y) {
                (I.loc = _.ORIGIN), (I.t = 0);
                return;
              }
              if (R.x === z.x && R.y === z.y) {
                (I.loc = _.DESTINATION), (I.t = 1);
                return;
              }
              if (q < -Number.EPSILON) {
                I.loc = _.LEFT;
                return;
              }
              if (q > Number.EPSILON) {
                I.loc = _.RIGHT;
                return;
              }
              if (k * j < 0 || V * G < 0) {
                I.loc = _.BEHIND;
                return;
              }
              if (Math.sqrt(k * k + V * V) < Math.sqrt(j * j + G * G)) {
                I.loc = _.BEYOND;
                return;
              }
              (I.loc = _.BETWEEN), (I.t = 0 !== k ? j / k : G / V);
            }
            let R = 0,
              B = 999999999,
              z = -999999999,
              k = [];
            this.subPaths.forEach((_) => {
              let I = _.getPoints(),
                V = -999999999,
                j = 999999999,
                G = -999999999,
                q = 999999999;
              for (let _ = 0; _ < I.length; _++) {
                let R = I[_];
                R.y > V && (V = R.y),
                  R.y < j && (j = R.y),
                  R.x > G && (G = R.x),
                  R.x < q && (q = R.x);
              }
              z <= G && (z = G + 1),
                B >= q && (B = q - 1),
                I.length &&
                  k.push({
                    curves: _.curves,
                    points: I,
                    isCW: oz.isClockWise(I),
                    identifier: R++,
                    boundingBox: new lW(new rs(q, j), new rs(G, V)),
                  });
            });
            let V = k.map((R) =>
                (function (R, B, z, k, V) {
                  (null == V || "" === V) && (V = "nonzero");
                  let j = new rs();
                  R.boundingBox.getCenter(j);
                  let G = (function (R, B, z) {
                    let k = new rs();
                    B.getCenter(k);
                    let V = [];
                    return (
                      z.forEach((B) => {
                        B.boundingBox.containsPoint(k) &&
                          (function (R, B) {
                            let z = [],
                              k = [];
                            for (let V = 1; V < R.length; V++) {
                              let j = R[V - 1],
                                G = R[V];
                              for (let R = 1; R < B.length; R++) {
                                let V = (function (R, B, z, k) {
                                  let V = R.x,
                                    j = B.x,
                                    G = z.x,
                                    q = k.x,
                                    X = R.y,
                                    Q = B.y,
                                    $ = z.y,
                                    et = k.y,
                                    er = (q - G) * (X - $) - (et - $) * (V - G),
                                    es = (et - $) * (j - V) - (q - G) * (Q - X),
                                    ea = er / es,
                                    en =
                                      ((j - V) * (X - $) - (Q - X) * (V - G)) /
                                      es;
                                  if (
                                    (0 === es && 0 !== er) ||
                                    ea <= 0 ||
                                    ea >= 1 ||
                                    en < 0 ||
                                    en > 1
                                  )
                                    return null;
                                  if (0 === er && 0 === es) {
                                    for (let G = 0; G < 2; G++)
                                      if (
                                        (s(0 === G ? z : k, R, B),
                                        I.loc === _.ORIGIN)
                                      ) {
                                        let _ = 0 === G ? z : k;
                                        return { x: _.x, y: _.y, t: I.t };
                                      } else if (I.loc === _.BETWEEN)
                                        return {
                                          x: +(V + I.t * (j - V)).toPrecision(
                                            10
                                          ),
                                          y: +(X + I.t * (Q - X)).toPrecision(
                                            10
                                          ),
                                          t: I.t,
                                        };
                                    return null;
                                  }
                                  for (let V = 0; V < 2; V++)
                                    if (
                                      (s(0 === V ? z : k, R, B),
                                      I.loc === _.ORIGIN)
                                    ) {
                                      let _ = 0 === V ? z : k;
                                      return { x: _.x, y: _.y, t: I.t };
                                    }
                                  return {
                                    x: +(V + ea * (j - V)).toPrecision(10),
                                    y: +(X + ea * (Q - X)).toPrecision(10),
                                    t: ea,
                                  };
                                })(j, G, B[R - 1], B[R]);
                                null !== V &&
                                  void 0 ===
                                    z.find(
                                      (_) =>
                                        _.t <= V.t + Number.EPSILON &&
                                        _.t >= V.t - Number.EPSILON
                                    ) &&
                                  (z.push(V), k.push(new rs(V.x, V.y)));
                              }
                            }
                            return k;
                          })(R, B.points).forEach((_) => {
                            V.push({
                              identifier: B.identifier,
                              isCW: B.isCW,
                              point: _,
                            });
                          });
                      }),
                      V.sort((_, I) => _.point.x - I.point.x),
                      V
                    );
                  })([new rs(z, j.y), new rs(k, j.y)], R.boundingBox, B);
                  G.sort((_, I) => _.point.x - I.point.x);
                  let q = [],
                    X = [];
                  G.forEach((_) => {
                    _.identifier === R.identifier ? q.push(_) : X.push(_);
                  });
                  let Q = q[0].point.x,
                    $ = [],
                    et = 0;
                  for (; et < X.length && X[et].point.x < Q; )
                    $.length > 0 && $[$.length - 1] === X[et].identifier
                      ? $.pop()
                      : $.push(X[et].identifier),
                      et++;
                  if (($.push(R.identifier), "evenodd" === V)) {
                    let _ = $.length % 2 == 0,
                      I = $[$.length - 2];
                    return { identifier: R.identifier, isHole: _, for: I };
                  }
                  if ("nonzero" === V) {
                    let _ = !0,
                      I = null,
                      z = null;
                    for (let R = 0; R < $.length; R++) {
                      let k = $[R];
                      B[k] &&
                        (_
                          ? ((z = B[k].isCW), (_ = !1), (I = k))
                          : z !== B[k].isCW && ((z = B[k].isCW), (_ = !0)));
                    }
                    return { identifier: R.identifier, isHole: _, for: I };
                  }
                  console.warn(
                    'fill-rule: "' + V + '" is currently not implemented.'
                  );
                })(R, k, B, z, this.userData?.style.fillRule)
              ),
              j = [];
            return (
              k.forEach((_) => {
                let I = V[_.identifier];
                if (I && !I.isHole) {
                  let I = new oR();
                  (I.curves = _.curves),
                    V.filter(
                      (I) => I?.isHole && I.for === _.identifier
                    ).forEach((_) => {
                      if (_) {
                        let R = k[_.identifier],
                          B = new oM();
                        (B.curves = R.curves), I.holes.push(B);
                      }
                    }),
                    j.push(I);
                }
              }),
              j
            );
          }
        },
        SN = !1,
        Sk = new Promise((_) => {
          SI = _;
        }),
        SV = !1;
      async function QY(_) {
        return await (await fetch(_)).arrayBuffer();
      }
      var Sj = new (class {
        async load(_, I, R = () => {}) {
          let { load: B } = await Sk;
          B(_, (_, B) => {
            _ || !B ? R(_ ?? "Something went wrong") : I(B);
          });
        }
        async parse(_) {
          let { parse: I, Bidi: R } = await Sk;
          try {
            let B = I(_),
              z = new R();
            return (
              z.registerModifier("glyphIndex", null, (_) =>
                B.charToGlyphIndex(_.char)
              ),
              z.applyFeatures(B, B.defaultRenderOptions.features),
              { font: B, bidi: z }
            );
          } catch (_) {
            console.error(_);
          }
        }
      })();
      async function x_(_) {
        let I,
          R,
          B = !1;
        if (
          (_.url
            ? ((I = await QY(_.url)), (R = _.url), (B = _.url.startsWith("/")))
            : _.data &&
              (I = _.data.buffer.slice(
                _.data.byteOffset,
                _.data.byteOffset + _.data.byteLength
              )),
          I)
        ) {
          if (!SN)
            return { font: void 0, url: R, intercepted: B, arr: I, bidi: null };
          {
            let _ = await Sj.parse(I);
            if (_)
              return {
                font: _.font,
                url: R,
                intercepted: B,
                arr: I,
                bidi: _.bidi,
              };
          }
        }
      }
      var SH = class {
          constructor(_) {
            (this._arrayBuffer = new ArrayBuffer(1)),
              (this._isLoaded = !1),
              (this._intercepted = !1),
              (this._isUserFont = _.isUserFont ?? !1),
              (this._loadingPromise = x_(_).then((_) => {
                _ &&
                  ((this._arrayBuffer = _.arr),
                  (this._url = _.url),
                  (this.font = _.font),
                  (this._intercepted = _.intercepted),
                  (this._isLoaded = !0),
                  (this._bidi = _.bidi));
              }));
          }
          update(_) {
            (this._isLoaded = !1),
              (this._isUserFont = _.isUserFont ?? !1),
              (this._loadingPromise = x_(_).then((_) => {
                _ &&
                  ((this._arrayBuffer = _.arr),
                  (this._url = _.url),
                  (this.font = _.font),
                  (this._intercepted = _.intercepted),
                  (this._isLoaded = !0),
                  (this._bidi = _.bidi));
              }));
          }
          get url() {
            return this._url;
          }
          get intercepted() {
            return this._intercepted;
          }
          get isLoaded() {
            return this._isLoaded;
          }
          get loadingPromise() {
            return this._loadingPromise;
          }
          reverseLigaturesTable(_, I, R) {
            if (!this._bidi) return [];
            let B = this._bidi;
            B.getTextGlyphs(I);
            let z = B.tokenizer.tokens,
              k = [],
              V = 0,
              j = R.length === z.length;
            for (let B = 0; B < R.length; B++) {
              let G = R[B].index,
                q = String.fromCharCode(R[B].unicode),
                X = z[V];
              if (
                X.state.glyphIndex === G ||
                X.state.fina === G ||
                X.state.medi === G ||
                X.state.init === G ||
                j
              )
                k.push({
                  char: q,
                  index: G,
                  replacements: [X.state.glyphIndex],
                  replacementChars: [X.char],
                }),
                  V++;
              else {
                let R = X.char,
                  B = "",
                  z = [X.state.glyphIndex],
                  j = [],
                  Q = !1;
                for (; !Q; )
                  V++,
                    (R += B = I.charAt(V)),
                    z.push(_.charToGlyphIndex(B)),
                    1 === (j = _.stringToGlyphs(R)).length &&
                      j[0].index === G &&
                      (Q = !0),
                    V > I.length && (Q = !0);
                k.push({
                  char: q,
                  index: G,
                  replacements: z,
                  replacementChars: Array.from(R),
                }),
                  V++;
              }
            }
            return k;
          }
          generateShapes(_, I) {
            if (!this._isLoaded) return;
            let R = this.font,
              B = I.fontSize / this.unitsPerEm,
              z = I.fontSize * I.lineHeight,
              k = _.map((_) => this.getTextWidth(_, I)),
              V = I.width,
              j = this.getCharWidth(
                `
`,
                I
              ),
              G = 1 === I.horizontalAlign ? j : 0,
              q = this.computeSpaceWidthForLine(_, 0, I),
              X = this.getLineInitialOffsetX(
                k[0],
                V,
                I.horizontalAlign,
                _[0],
                j
              ),
              Q = this.getLineInitialOffsetY(
                z,
                _.length,
                I.height,
                B,
                I.verticalAlign
              ),
              $ = [],
              et = _.map((_) => []),
              er = _.map((_) => []),
              es;
            for (let ea = 0; ea < _.length; ea++) {
              let en = _[ea],
                eo = { features: { liga: !0 } },
                el = [];
              try {
                el = R.stringToGlyphs(en, eo);
              } catch (_) {
                console.warn(_);
              }
              X = this.getLineInitialOffsetX(
                k[ea],
                V,
                I.horizontalAlign,
                en,
                j
              );
              let eh = [];
              try {
                eh = this.reverseLigaturesTable(R, en, el);
              } catch (_) {
                console.warn(_);
              }
              q = this.computeSpaceWidthForLine(_, ea, I);
              for (let _ = 0; _ < el.length; _++) {
                let z = el[_],
                  k =
                    0 === z.index
                      ? `
`
                      : z.unicode
                      ? String.fromCharCode(z.unicode)
                      : void 0,
                  V = eh[_],
                  j = 0,
                  en = 0;
                0 === _ &&
                  2 === I.horizontalAlign &&
                  void 0 !== z.leftSideBearing &&
                  (en = -z.leftSideBearing * B),
                  es && (j = R.getKerningValue(z, es) * B),
                  (X += en + j);
                let eo = 0;
                if (
                  k ===
                  `
`
                )
                  eo = G;
                else if (" " === k) eo = q;
                else {
                  let _ = this.createPath(z, B, X, Q, I);
                  _ && ((eo = _.offsetX - (j + en)), $.push(_.path));
                }
                if (1 === V.replacements.length)
                  er[ea].push([X, Q]), et[ea].push(eo);
                else {
                  let _ = V.replacements.map(
                      (_) => (R.glyphs.get(_).advanceWidth ?? 0) * B
                    ),
                    I = _.reduce((_, I) => (_ += I), 0),
                    z = _.map((_) => _ / I),
                    k = X;
                  for (let _ = 0; _ < z.length; _++) {
                    let I = eo * z[_];
                    er[ea].push([k, Q]), et[ea].push(I), (k += I);
                  }
                }
                (X += eo), (es = z);
              }
              Q -= z;
            }
            let ea = [];
            for (let _ = 0, I = $.length; _ < I; _++)
              ea.push(...$[_].toShapes());
            return {
              shapes: ea,
              charWidths: et,
              lineWidths: k,
              charCoords: er,
            };
          }
          get isUserFont() {
            return this._isUserFont;
          }
          get arrayBuffer() {
            return this._arrayBuffer;
          }
          get ascender() {
            return this.font?.ascender ?? 0;
          }
          get descender() {
            return this.font?.descender ?? 0;
          }
          get familyName() {
            return this.font?.names.fontFamily ?? "";
          }
          get subfamilyName() {
            return this.font?.names.fontSubfamily ?? "";
          }
          get unitsPerEm() {
            return this.font?.unitsPerEm ?? 1;
          }
          getLineInitialOffsetX(_, I, R, B, z) {
            return (
              (3 === R || 2 === R) &&
                B.indexOf(`
`) >= 0 &&
                (_ -= z),
              3 === R ? 0.5 * I - 0.5 * _ : 2 === R ? I - _ : 0
            );
          }
          getLineInitialOffsetY(_, I, R, B, z) {
            let k = I * _,
              V = Math.abs(this.ascender - this.descender) * B,
              j = -this.ascender * B - (_ - V) / 2;
            return 3 === z
              ? -(R - k - j)
              : 2 === z
              ? -(0.5 * R - 0.5 * k - j)
              : j;
          }
          createPath(_, I, R, B, z) {
            let k = _.getPath(R, -B, z.fontSize, {
              kerning: !1,
              letterSpacing: z.letterSpacing,
            });
            if (!k) {
              console.error(
                'THREE.Font: character "' +
                  _ +
                  '" does not exists in font family ' +
                  this.familyName +
                  "."
              );
              return;
            }
            let V = new SF(),
              j = (_.advanceWidth ?? 1) * I;
            if (_)
              for (let _ of k.commands) {
                let I = V.currentPath?.currentPoint;
                if (!(I && "Z" !== _.type && I.x === _.x && -I.y === _.y))
                  switch (_.type) {
                    case "M":
                      V.moveTo(_.x, -_.y);
                      break;
                    case "L":
                      V.lineTo(_.x, -_.y);
                      break;
                    case "Q":
                      V.quadraticCurveTo(_.x1, -_.y1, _.x, -_.y);
                      break;
                    case "C":
                      V.bezierCurveTo(_.x1, -_.y1, _.x2, -_.y2, _.x, -_.y);
                  }
              }
            return (
              V.subPaths.forEach((_) => {
                let I = (function (_) {
                  if (_.length) {
                    let I = _[0];
                    if (I instanceof og) return I.v1;
                    if (I instanceof of || I instanceof ob) return I.v0;
                  }
                })(_.curves);
                void 0 !== I &&
                  _.currentPoint.distanceTo(I) > 0 &&
                  _.lineTo(I.x, I.y);
              }),
              { offsetX: j + z.fontSize * z.letterSpacing, path: V }
            );
          }
          getCharWidth(_, I) {
            return (
              this.font?.getAdvanceWidth(_, I.fontSize, {
                kerning: !0,
                letterSpacing: I.letterSpacing,
              }) ?? 0
            );
          }
          getTextWidth(_, I) {
            return (
              this.font?.getAdvanceWidth(_, I.fontSize, {
                kerning: !0,
                letterSpacing: I.letterSpacing,
              }) ?? 0
            );
          }
          computeSpaceWidthForLine(_, I, R) {
            let B = this.getCharWidth(" ", R),
              z = _[I];
            if (z) {
              let k = this.countSpaces(z.trimEnd());
              if (4 === R.horizontalAlign && I < _.length - 1 && k)
                return (R.width - (this.getTextWidth(z, R) - k * B)) / k;
            }
            return B;
          }
          countSpaces(_) {
            return (_.match(/ /g) || []).length;
          }
        },
        SW = class {
          constructor() {
            (this.objects = new Map()), (this.unreachable = new Set());
          }
          getCached(_) {
            return this.objects.get(_);
          }
          get size() {
            return this.objects.size;
          }
          get(_, I, R) {
            let B = this.objects.get(_);
            return (
              void 0 === B
                ? ((B = this.createObject(_, I, R)), this.objects.set(_, B))
                : (B.isShared = !0),
              B
            );
          }
          forceDelete(_) {
            let I = this.objects.get(_);
            I && (this.disposeObject(I), this.objects.delete(_));
          }
          mutateIfUnique(_, I) {
            let R = this.objects.get(_);
            if (R && !0 !== R.isShared)
              return this.objects.delete(_), this.objects.set(I, R), R;
          }
          startGc() {
            this.unreachable = new Set(this.objects.keys());
          }
          markAsReachable(_, I) {
            I === this.objects.get(_) && this.unreachable.delete(_);
          }
          endGc() {
            this.unreachable.forEach((_) => {
              this.disposeObject(this.objects.get(_)), this.objects.delete(_);
            }),
              this.unreachable.clear();
          }
          dispose() {
            this.objects.forEach((_) => {
              this.disposeObject(_);
            }),
              this.objects.clear();
          }
        },
        Sq = class extends SW {
          constructor(_) {
            super(), (this.flatShading = _);
          }
          disposeObject(_) {
            _.dispose();
          }
          createObject(_, I, R) {
            let B = Va(_, I, this.flatShading, R);
            return B.computeBoundingSphere(), B;
          }
        },
        SY = { markNeedsUpdateRendererDirty: () => {} },
        SX = class extends _9 {
          constructor(_) {
            super(), (this.shared = _);
          }
          create(_) {
            return new _7(_, this.shared);
          }
        },
        SQ = class {
          constructor(_, I = {}) {
            if (
              ((this.data = _),
              (this.geometryCache = new Sq(!0)),
              (this.geometryCache2 = new Sq(!1)),
              (this.imageHolderCache = new SX(this)),
              (this.thisContext = { scene: SY, shared: this }),
              (this.deletedMaterial = new SR(
                gG.defaultTwoLayerData("phong"),
                this.thisContext,
                ""
              )),
              (this.deletedImage = new Se(vO.emptyImage, this)),
              (this.deletedVideo = new Se(mG.defaultVideo, this)),
              (this.materials = {}),
              (this.images = {}),
              (this.canvases = {}),
              (this.videos = {}),
              (this.colors = {}),
              (this.audios = {}),
              (this.particles = {}),
              (this.fonts = {}),
              (this.variables = {}),
              (this.mouseProperty = null),
              (this.raycastProperty = null),
              (this.requestRender = () => {
                this._requestRender && this._requestRender();
              }),
              I.images)
            )
              for (let [_, R] of Object.entries(I.images)) this.addImage(_, R);
            if (I.videos)
              for (let [_, R] of Object.entries(I.videos)) this.addVideo(_, R);
            if (I.audios)
              for (let [_, R] of Object.entries(I.audios)) this.addAudio(_, R);
            if (I.particles)
              for (let [_, R] of Object.entries(I.particles))
                this.addParticle(_, R);
            this.reset(_);
          }
          setRequestRender(_) {
            this._requestRender = _;
          }
          setEntityOpContext(_) {
            this.entityOpContext = _;
          }
          reset(_, I = !1) {
            for (let { id: R, data: B } of (this.resetLib(_.lib), _.variables))
              this.addVariableHolder(R, B),
                I && this.updateVariableHolder(R, B);
            for (let [I, R] of Object.entries(_.images)) this.addImage(I, R);
            for (let [I, R] of Object.entries(_.videos)) this.addVideo(I, R);
            for (let [I, R] of Object.entries(_.colors)) this.addColor(I, R);
            for (let [I, R] of Object.entries(_.materials))
              this.addMaterial(I, R);
            for (let [I, R] of Object.entries(_.audios)) this.addAudio(I, R);
            for (let [I, R] of Object.entries(_.particles))
              this.addParticle(I, R);
            for (let [I, R] of Object.entries(_.fonts)) this.addFont(I, R);
          }
          addMaterial(_, I) {
            if (this.materials[_]) {
              let R = this.materials[_];
              R.reset(I, this.thisContext), R.dispose();
            } else {
              let R = new SR(I, this.thisContext, _);
              this.materials[_] = R;
            }
          }
          deleteMaterial(_) {
            this.materials[_] &&
              (this.materials[_].nodeMaterialDispose(),
              delete this.materials[_]);
          }
          getMaterial(_) {
            return this.materials[_];
          }
          getMaterialOrDeletedPlaceholder(_) {
            return this.materials[_] ?? this.deletedMaterial;
          }
          material(_) {
            return "string" == typeof _
              ? this.getMaterialOrDeletedPlaceholder(_)
              : null == _
              ? (console.error("material is undefined or null"),
                this.deletedMaterial)
              : new SO(_, this.thisContext);
          }
          getMaterials() {
            return this.materials;
          }
          addImage(_, I) {
            return this.images[_]
              ? (this.onColorOrImageUpdate && this.onColorOrImageUpdate(),
                this.images[_].updateSrc(I.data),
                !0)
              : ((this.images[_] = new Se(I, this)), !1);
          }
          deleteImage(_) {
            let I = this.images[_];
            I && (I.dispose(), delete this.images[_]);
          }
          getDefaultImage() {
            return this.images.image_0;
          }
          getImage(_) {
            return this.images[_] ?? this.deletedImage;
          }
          image(_) {
            return "string" == typeof _
              ? this.getImage(_)
              : this.imageHolderCache.load(_);
          }
          addCanvas(_, I) {
            return this.canvases[_]
              ? (this.onColorOrImageUpdate && this.onColorOrImageUpdate(),
                this.canvases[_].updateSrc(I),
                !0)
              : ((this.canvases[_] = new Se(I, this)), !1);
          }
          canvas(_) {
            return this.canvases[_];
          }
          addVideo(_, I) {
            return this.videos[_]
              ? (this.videos[_].updateSrc(I.data), !0)
              : ((this.videos[_] = new Se(I, this)), !1);
          }
          deleteVideo(_) {
            let I = this.videos[_];
            I && (I.dispose(), delete this.videos[_]);
          }
          getVideo(_) {
            return this.videos[_] ?? this.deletedVideo;
          }
          video(_) {
            return "string" == typeof _
              ? this.getVideo(_)
              : this.imageHolderCache.load(_);
          }
          addColor(_, I) {
            return this.colors[_]
              ? (this.onColorOrImageUpdate && this.onColorOrImageUpdate(),
                "a" in I
                  ? this.colors[_].setRGBA(I.r, I.g, I.b, I.a)
                  : this.colors[_].setRGBA(I.r, I.g, I.b, 1),
                !0)
              : ("a" in I
                  ? (this.colors[_] = new Sy(I.r, I.g, I.b, I.a))
                  : (this.colors[_] = new Sy(I.r, I.g, I.b, 1)),
                !1);
          }
          updateColor(_, I) {
            if (this.colors[_]) {
              this.onColorOrImageUpdate && this.onColorOrImageUpdate();
              let R = this.colors[_];
              return (
                (this.colors[_].r = I.r ?? R.r),
                (this.colors[_].g = I.g ?? R.g),
                (this.colors[_].b = I.b ?? R.b),
                (this.colors[_].a = I.a ?? R.a),
                !0
              );
            }
            return !1;
          }
          deleteColor(_) {
            this.colors[_] && delete this.colors[_];
          }
          getColor(_) {
            return this.colors[_];
          }
          color(_) {
            let I;
            if ("string" != typeof _)
              return "a" in _
                ? new wA(_.r, _.g, _.b, _.a)
                : new wA(_.r, _.g, _.b, 1);
            {
              let R = this.getColor(_);
              R
                ? (I = R)
                : (console.warn(
                    "Tried to create color layer params with a color key that does not exist in the assets manager"
                  ),
                  (I = new wA(0, 0, 0, 0)));
            }
            return I;
          }
          addAudio(_, I) {
            this.audios[_] = I;
          }
          getAudio(_) {
            let I = this.audios[_];
            if (I instanceof Sz) return I;
            {
              let R = new Sz({ src: I.data });
              return (this.audios[_] = R), R;
            }
          }
          addParticle(_, I) {
            this.particles[_] = I;
          }
          getParticle(_) {
            return this.particles[_];
          }
          deleteParticle(_) {
            this.particles[_] && delete this.particles[_];
          }
          deleteAudio(_) {
            let I = this.audios[_];
            I && (I instanceof Sz && I.dispose(), delete this.audios[_]);
          }
          addFont(_, I) {
            (this.fonts[_] = new SH(I)),
              this.fonts[_].loadingPromise.then(() => this.requestRender());
          }
          getFont(_) {
            return this.fonts[_];
          }
          deleteFont(_) {
            this.fonts[_] && delete this.fonts[_];
          }
          dispose() {
            Object.keys(this.materials).forEach((_) => this.deleteMaterial(_)),
              (this._requestRender = void 0),
              Object.values(this.audios).forEach((_) => {
                _ instanceof Sz && _.dispose();
              }),
              (this.audios = {}),
              (this.particles = {}),
              this.geometryCache.dispose(),
              this.geometryCache2.dispose();
          }
          addVariableHolder(_, I) {
            return void 0 === this.variables[_]
              ? ((this.variables[_] = { value: I.value, locations: [] }),
                "dynamicVariableType" in I &&
                  ((this.variables[_].dynamicVariablePlayState = "Playing"),
                  (this.variables[_].dynamicVariableToggleIsForward = void 0)),
                !0)
              : ((this.variables[_].value = I.value), !1);
          }
          resetDynamicVariablePlayState() {
            for (let _ in this.variables)
              void 0 !== this.variables[_].dynamicVariablePlayState &&
                ((this.variables[_].dynamicVariablePlayState = "Playing"),
                (this.variables[_].dynamicVariableToggleIsForward = void 0));
          }
          updateVariableHolder(_, I) {
            this.updateVariable(_, I.value);
          }
          updateVariable(_, I) {
            if (void 0 === this.variables[_]) return !1;
            this.variables[_].value = I;
            let R = I;
            for (; "string" == typeof R; ) R = this.variables[R].value;
            let B = this.entityOpContext.scene;
            for (let I = this.variables[_].locations.length - 1; I >= 0; I--) {
              let z = this.variables[_].locations[I];
              if ("material" === z[0]) {
                let _ = z[1],
                  I = R,
                  k = { scene: B, shared: this },
                  V = z.slice(2);
                B.traverseMaterial((R) => {
                  let B = R.root ?? R;
                  B.uuid === _ && B.onVariableUpdate(V, I, k);
                });
                let j = this.materials[_];
                j && j.onVariableUpdate(V, I, k);
              } else {
                let k = B.find(z[0]);
                if (void 0 === k) {
                  this.variables[_].locations.splice(I, 1);
                  continue;
                }
                if ("geometry" !== z[1] && "particles" !== z[1]) {
                  for (let _ = 1; _ < z.length - 1; _++) k = k[z[_]];
                  "rotation" === z[1]
                    ? (k[z[z.length - 1]] = R * rr.DEG2RAD)
                    : (k[z[z.length - 1]] = R);
                }
                if (
                  ("ParticleEmitter" === (k = B.find(z[0])).type &&
                    k.updateVariableState(R, z),
                  bG.is(k))
                ) {
                  if (
                    "position" === z[1] ||
                    "rotation" === z[1] ||
                    "scale" === z[1]
                  )
                    k.onVariableUpdate();
                  else if ("geometry" === z[1]) {
                    let _ = k;
                    k.component && (_ = k.component);
                    let I = _.dataPatched;
                    _.chooseGeoemtryCache(this).forceDelete(I.geometry),
                      _.createGeometryDelayed(this.entityOpContext),
                      _.onVariableUpdate(!0),
                      _.instances.forEach((_) => {
                        let I = _.dataPatched;
                        _.chooseGeoemtryCache(this).forceDelete(I.geometry),
                          _.createGeometryDelayed(this.entityOpContext),
                          _.onVariableUpdate(!0);
                      });
                  }
                }
              }
            }
            return this.requestRender(), !0;
          }
          deleteVariable(_) {
            this.variables[_] && delete this.variables[_];
          }
          getVariable(_, I) {
            if (Array.isArray(_)) {
              if ("mouse" === _[0]) return this.mouseProperty?.[_[1]] ?? 0;
              if ("raycast" === _[0]) return this.raycastProperty?.[_[1]] ?? 0;
              let I = this.entityOpContext.scene.find(_[0]);
              if ("width" === _[1] || "height" === _[1] || "depth" === _[1])
                return I.geometry.userData.parameters[_[1]];
              for (let R = 1; R < _.length; R++) I = I[_[R]];
              return "rotation" === _[1] && (I *= rr.RAD2DEG), I;
            }
            for (let _ in this.variables) {
              if (void 0 === I) break;
              let R = this.variables[_],
                B = R.locations?.findIndex((_) => pe.equal(_, I));
              void 0 !== B && -1 !== B && R.locations.splice(B, 1);
            }
            if ("string" != typeof _) return _;
            {
              let R = _,
                B = _;
              do {
                if (((B = R), void 0 === this.variables[R])) break;
                R = this.variables[R].value;
              } while ("string" == typeof R);
              return (
                I &&
                  void 0 !== this.variables[B] &&
                  this.variables[B].locations.push(I),
                R
              );
            }
          }
          getVariables() {
            return this.variables;
          }
          getDynamicVariablePlayState(_) {
            return this.variables[_]?.dynamicVariablePlayState;
          }
          setDynamicVariablePlayState(_, I) {
            void 0 !== this.variables[_] &&
              (this.variables[_].dynamicVariablePlayState = I);
          }
          getDynamicVariableToggleIsForward(_) {
            return this.variables[_]?.dynamicVariableToggleIsForward;
          }
          setDynamicVariableToggleIsForward(_, I) {
            void 0 !== this.variables[_] &&
              (this.variables[_].dynamicVariableToggleIsForward = I);
          }
          resetLib(_) {
            for (let [I, R] of Object.entries(_.images))
              this.addImage(I, R.asset);
            for (let [I, R] of Object.entries(_.audios))
              this.addAudio(I, R.asset);
            for (let [I, R] of Object.entries(_.particles))
              this.addParticle(I, R.asset);
            for (let [I, R] of Object.entries(_.colors))
              this.addColor(I, R.asset);
            for (let [I, R] of Object.entries(_.fonts))
              this.addFont(I, R.asset);
            for (let [I, R] of Object.entries(_.materials))
              this.addMaterial(I, R.asset);
            for (let [I, R] of Object.entries(_.videos))
              this.addVideo(I, R.asset);
            for (let [I, R] of Object.entries(_.variables))
              this.addVariableHolder(I, R.asset);
          }
          updateLibByOp(_, I) {
            "images" === _.path[0]
              ? 1 === _.path.length && 1 === _.type
                ? this.addImage(_.id, _.data.asset)
                : 1 === _.path.length && 2 === _.type && this.deleteImage(_.id)
              : "videos" === _.path[0]
              ? 1 === _.path.length && 1 === _.type
                ? this.addVideo(_.id, _.data.asset)
                : 1 === _.path.length && 2 === _.type && this.deleteVideo(_.id)
              : "audios" === _.path[0]
              ? 1 === _.path.length && 1 === _.type
                ? this.addAudio(_.id, _.data.asset)
                : 1 === _.path.length && 2 === _.type && this.deleteAudio(_.id)
              : "particles" === _.path[0]
              ? 1 === _.path.length && 1 === _.type
                ? this.addParticle(_.id, _.data.asset)
                : 1 === _.path.length &&
                  2 === _.type &&
                  this.deleteParticle(_.id)
              : "colors" === _.path[0]
              ? 1 === _.path.length && 1 === _.type
                ? this.addColor(_.id, _.data.asset)
                : 1 === _.path.length && 2 === _.type && this.deleteColor(_.id)
              : "materials" === _.path[0]
              ? 1 === _.path.length && 1 === _.type
                ? this.addMaterial(_.id, _.data.asset)
                : 1 === _.path.length &&
                  2 === _.type &&
                  this.deleteMaterial(_.id)
              : "fonts" === _.path[0]
              ? 1 === _.path.length && 1 === _.type
                ? this.addFont(_.id, _.data.asset)
                : 1 === _.path.length && 2 === _.type && this.deleteFont(_.id)
              : "variables" === _.path[0]
              ? 1 === _.path.length && 1 === _.type
                ? this.addVariableHolder(_.id, _.data.asset)
                : 1 === _.path.length &&
                  2 === _.type &&
                  this.deleteVariable(_.id)
              : "components" === _.path[0] && I.updateByLibOp(_, this);
          }
          updateByOp(_, I, R) {
            (this.data = I),
              "images" === _.path[0]
                ? 2 === _.path.length && 0 === _.type
                  ? _.props.data &&
                    this.getImage(_.path[1]).updateSrc(_.props.data)
                  : 1 === _.path.length && 1 === _.type
                  ? this.addImage(_.id, _.data)
                  : 1 === _.path.length &&
                    2 === _.type &&
                    this.deleteImage(_.id)
                : "videos" === _.path[0]
                ? 2 === _.path.length && 0 === _.type
                  ? _.props.data &&
                    this.getVideo(_.path[1]).updateSrc(_.props.data)
                  : 1 === _.path.length && 1 === _.type
                  ? this.addVideo(_.id, _.data)
                  : 1 === _.path.length &&
                    2 === _.type &&
                    this.deleteVideo(_.id)
                : "audios" === _.path[0]
                ? 2 === _.path.length && 0 === _.type
                  ? _.props.data &&
                    this.addAudio(_.path[1], I.audios[_.path[1]])
                  : 1 === _.path.length && 1 === _.type
                  ? this.addAudio(_.id, _.data)
                  : 1 === _.path.length &&
                    2 === _.type &&
                    this.deleteAudio(_.id)
                : "particles" === _.path[0]
                ? 2 === _.path.length && 0 === _.type
                  ? _.props.data &&
                    this.addParticle(_.path[1], I.particles[_.path[1]])
                  : 1 === _.path.length && 1 === _.type
                  ? this.addParticle(_.id, _.data)
                  : 1 === _.path.length &&
                    2 === _.type &&
                    this.deleteParticle(_.id)
                : "colors" === _.path[0]
                ? 2 === _.path.length && 0 === _.type
                  ? this.updateColor(_.path[1], _.props)
                  : 1 === _.path.length && 1 === _.type
                  ? this.addColor(_.id, _.data)
                  : 1 === _.path.length &&
                    2 === _.type &&
                    this.deleteColor(_.id)
                : "materials" === _.path[0]
                ? 1 === _.path.length && 1 === _.type
                  ? this.addMaterial(_.id, _.data)
                  : 1 === _.path.length && 2 === _.type
                  ? this.deleteMaterial(_.id)
                  : _.path.length > 1 &&
                    this.getMaterial(_.path[1]).updateByOp(
                      u9.drop(_, 2),
                      I.materials[_.path[1]],
                      { shared: this, scene: R }
                    )
                : "fonts" === _.path[0]
                ? 2 === _.path.length && 0 === _.type
                  ? this.updateFont(_.path[1], _, R)
                  : 1 === _.path.length && 1 === _.type
                  ? this.addFont(_.id, _.data)
                  : 1 === _.path.length && 2 === _.type && this.deleteFont(_.id)
                : "variables" === _.path[0]
                ? 2 === _.path.length && 0 === _.type && "value" in _.props
                  ? this.updateVariable(_.path[1], _.props.value)
                  : 1 === _.path.length && 4 === _.type
                  ? this.addVariableHolder(_.id, _.data)
                  : 1 === _.path.length &&
                    5 === _.type &&
                    this.deleteVariable(_.id)
                : "lib" === _.path[0] && this.updateLibByOp(u9.drop(_, 1), R);
          }
          updateFont(_, I, R) {
            if (I.props.url) {
              let B = this.getFont(_),
                z = { ...this.data.fonts[_], url: I.props.url };
              B.update(z),
                B.loadingPromise.then(() => this.requestRender()),
                R.updateFont(_, this);
            }
          }
        };
      new SQ(vN.emptyData());
      var SZ = class extends wp {
          updateByPatchedOp(_, I, R) {
            if (
              (super.updateByPatchedOp(_, I, R),
              null !==
                (function (_, I) {
                  let R = [];
                  if (I.length !== _.length) return null;
                  for (var B = 0; B < _.length; ) {
                    if ("*" === I[B]) R.push(_[B]);
                    else if (_[B] !== I[B]) return null;
                    B += 1;
                  }
                  return R;
                })(_.path, ["materials"]) &&
                0 === _.type &&
                Array.isArray(this.material))
            )
              for (let [I, B] of Object.entries(_.props)) {
                let _ = R.shared.material(B);
                this.material[Number(I)] = _;
              }
            else if (Rt(_.path, ["material"]) && this.material instanceof SC)
              "material" in I &&
                "string" != typeof I.material &&
                this.material.updateByOp(u9.drop(_, 1), I.material, R);
            else if (
              Rt(_.path, ["materials", "*"]) &&
              Array.isArray(this.material)
            ) {
              let B = _.path[1];
              if ("materials" in I && B < this.material.length) {
                let z = I.materials[B];
                "string" != typeof z &&
                  this.material[B].updateByOp(u9.drop(_, 2), z, R);
              }
            }
          }
          get needsAO() {
            return (
              void 0 !== this.material &&
              (Array.isArray(this.material) ? this.material[0] : this.material)
                .hasAO
            );
          }
          updateState(_, I) {
            super.updateState(_, I),
              void 0 !== _.castShadow && (this.castShadow = _.castShadow),
              void 0 !== _.receiveShadow &&
                (this.receiveShadow = _.receiveShadow);
            let R = this.dataPatched;
            if (
              (_.geometry?.type !== "NonParametricGeometry" &&
                "material" in _ &&
                void 0 !== _.material &&
                (this.disposeMaterial(),
                (this.material = I.shared
                  .material(_.material)
                  .getFlavor(R.flatShading, R.side, R.wireframe)),
                I.scene.markNeedsUpdateRendererDirty()),
              (_.geometry?.type === "NonParametricGeometry" ||
                "materials" in _) &&
                ("materials" in _ && void 0 !== _.materials
                  ? (this.disposeMaterial(),
                    (this.material = _.materials.map((_) =>
                      I.shared
                        .material(_)
                        .getFlavor(R.flatShading, R.side, R.wireframe)
                    )),
                    I.scene.markNeedsUpdateRendererDirty())
                  : "material" in _ &&
                    void 0 !== _.material &&
                    (this.disposeMaterial(),
                    (this.material = [
                      I.shared
                        .material(_.material)
                        .getFlavor(R.flatShading, R.side, R.wireframe),
                    ]),
                    I.scene.markNeedsUpdateRendererDirty())),
              void 0 !== _.flatShading ||
                void 0 !== _.wireframe ||
                void 0 !== _.side)
            ) {
              if (Array.isArray(this.material))
                for (let _ = 0; _ < this.material.length; _++)
                  this.material[_] = this.material[_].getFlavor(
                    R.flatShading,
                    R.side,
                    R.wireframe
                  );
              else
                this.material = this.material.getFlavor(
                  R.flatShading,
                  R.side,
                  R.wireframe
                );
            }
          }
          disposeMaterial() {
            this.material &&
              vv(this.material).forEach((_) => {
                _ instanceof SC && (_ instanceof SR || _.nodeMaterialDispose());
              });
          }
          dispose() {
            this.disposeMaterial(), super.dispose();
          }
        },
        SK = new rF(),
        SJ = new rM(),
        S$ = new rM(),
        S0 = new rF(),
        S1 = new sa(),
        S2 = class extends SZ {
          constructor(_, I, R) {
            super(_, I),
              (this.data = I),
              (this.isSkinnedMesh = !1),
              (this.localGeometry = void 0),
              I.bindMode &&
                I.bindMatrix &&
                ((this.bindMode = I.bindMode),
                (this.bindMatrix = new sa().fromArray(I.bindMatrix)),
                (this.bindMatrixInverse = new sa()));
          }
          chooseGeoemtryCache(_) {
            return _.geometryCache;
          }
          markGeometryAsReachable(_) {
            this.geometryCreateDeleyed instanceof ai &&
              this.chooseGeoemtryCache(_).markAsReachable(
                this.dataPatched.geometry,
                this.geometryCreateDeleyed
              );
          }
          get geometry() {
            if (void 0 !== this.localGeometry) return this.localGeometry;
            if (this.geometryCreateDeleyed instanceof SQ) {
              let _ = this.geometryCreateDeleyed,
                I = this.chooseGeoemtryCache(_);
              this.geometryCreateDeleyed = I.get(
                this.dataPatched.geometry,
                _,
                this
              );
            }
            return this.geometryCreateDeleyed;
          }
          set geometry(_) {
            this.localGeometry = _;
          }
          get is2DAndNoDepth() {
            let _ = this.dataPatched.geometry;
            return gY.is2DParametricMesh(_.type) && 0 === _.depth;
          }
          get is2DType() {
            return gY.is2DParametricMesh(this.geometry.userData.type);
          }
          get isNonParametric() {
            return "NonParametricGeometry" === this.geometry.userData.type;
          }
          updateByPatchedOp(_, I, R) {
            super.updateByPatchedOp(_, I, R),
              Rt(_.path, ["geometry"]) &&
                this.updateByPatchedOpGeometry(u9.drop(_, 1), I.geometry, R);
          }
          removeInteractionGeometry(_) {
            this.localGeometry?.dispose(), (this.localGeometry = void 0);
          }
          updateGeometryInteractions(_, I) {
            this.invalidateDownstreamBooleanData();
            let R = this.data.geometry.type;
            if ("NonParametricGeometry" === R || "SubdivGeometry" === R) {
              let R, B, z;
              if (void 0 === this.localGeometry) {
                let R = { ...this.data.geometry, ..._ };
                this.localGeometry = Va(R, I, this.data.flatShading, this);
              }
              _.scaleBaked
                ? ([R, B, z] = _.scaleBaked)
                : ({ width: R, height: B, depth: z } = _);
              let k = this.localGeometry.userData;
              void 0 !== k.sxPrev &&
                Mm(
                  this.localGeometry.attributes,
                  R / k.sxPrev,
                  B / k.syPrev,
                  z / k.szPrev
                ),
                (k.sxPrev = R),
                (k.syPrev = B),
                (k.szPrev = z);
            } else {
              let R = { ...this.data.geometry, ..._ };
              this.localGeometry?.dispose(),
                (this.localGeometry = Va(R, I, this.data.flatShading, this));
            }
          }
          refreshAttachedCloners(_) {
            for (let I of this.attachedSurfaceCloners)
              _.scene.addPendingUpdateCloner(I.object);
          }
          refreshAttachedPaths(_) {
            for (let I of this.attachedPaths)
              _.scene.addPendingCommand(() => I.updateShape());
          }
          createGeometryDelayed(_) {
            (this.geometryCreateDeleyed = _.shared),
              this.refreshAttachedCloners(_),
              this.refreshAttachedPaths(_);
          }
          updateByPatchedOpGeometry(_, I, R) {
            let B = !1;
            0 === _.type &&
              0 === _.path.length &&
              Object.keys(_.props).includes("scaleBaked") &&
              this.geometryCreateDeleyed instanceof b8 &&
              this.chooseGeoemtryCache(R.shared).mutateIfUnique(
                this.geometryCreateDeleyed.data,
                I
              ) === this.geometryCreateDeleyed &&
              ((B = !0),
              this.geometryCreateDeleyed.mutateDirectlyScaleBaked(
                I,
                _.props.scaleBaked
              ),
              this.refreshAttachedCloners(R),
              this.refreshAttachedPaths(R)),
              B ||
                (R.scene?.markGeometryCacheDirty(),
                this.createGeometryDelayed(R)),
              this.resetBBoxNeedsUpdate(),
              this.invalidateDownstreamBooleanData();
          }
          updateGeometryOnStateUpdate(_, I) {
            this.createGeometryDelayed(I);
          }
          updateState(_, I) {
            void 0 !== _.geometry &&
              this.updateGeometryOnStateUpdate(_.geometry, I),
              super.updateState(_, I);
          }
          updateGeometryGroupsIfNeeded() {
            Array.isArray(this.material) &&
              0 === this.geometry.groups.length &&
              this.geometry.addGroup(
                0,
                Math.max(
                  this.geometry.getIndex()?.count ?? 0,
                  this.geometry.getAttribute("position").count
                ),
                0
              );
          }
          updateEntityBoxSize(_, I) {
            let R = this.geometry.userData.parameters;
            this.is2DType
              ? _.set(0, 0, 0.5 * R.depth)
              : this.isNonParametric
              ? (_.setScalar(0),
                this.geometry.boundingSphere &&
                  _.copy(this.geometry.boundingSphere.center),
                I.set(R.width, R.height, R.depth ?? 0).multiplyScalar(0.5))
              : _.setScalar(0),
              I.set(R.width, R.height, R.depth ?? 0).multiplyScalar(0.5);
          }
          updateMatrixWorld(_) {
            super.updateMatrixWorld(_),
              "attached" === this.bindMode
                ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
                : "detached" === this.bindMode &&
                  this.bindMatrixInverse.copy(this.bindMatrix).invert();
          }
          bind(_, I) {
            (this.skeleton = _),
              (this.isSkinnedMesh = !0),
              void 0 === I &&
                (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                (I = this.matrixWorld)),
              this.bindMatrix.copy(I),
              this.bindMatrixInverse.copy(I).invert();
          }
          pose() {
            this.skeleton.pose();
          }
          normalizeSkinWeights(_) {
            let I = new rM(),
              R = this.geometry.attributes.skinWeight;
            for (let _ = 0, B = R.count; _ < B; _++) {
              I.fromBufferAttribute(R, _);
              let B = 1 / I.manhattanLength();
              B !== 1 / 0 ? I.multiplyScalar(B) : I.set(1, 0, 0, 0),
                R.setXYZW(_, I.x, I.y, I.z, I.w);
            }
          }
          boneTransform(_, I) {
            let R = this.skeleton;
            if (void 0 === R) return;
            let B = this.geometry;
            SJ.fromBufferAttribute(B.attributes.skinIndex, _),
              S$.fromBufferAttribute(B.attributes.skinWeight, _),
              SK.copy(I).applyMatrix4(this.bindMatrix),
              I.set(0, 0, 0);
            for (let _ = 0; _ < 4; _++) {
              let B = S$.getComponent(_);
              if (0 !== B) {
                let z = SJ.getComponent(_);
                S1.multiplyMatrices(R.bones[z].matrixWorld, R.boneInverses[z]),
                  I.addScaledVector(S0.copy(SK).applyMatrix4(S1), B);
              }
            }
            return I.applyMatrix4(this.bindMatrixInverse);
          }
        };
      function ff(_) {
        if (Array.isArray(_.material)) {
          for (let I of _.material)
            if (0 === I.getLayersOfType("outline").length) return;
        } else if (
          !(_.material instanceof SC) ||
          0 === _.material.getLayersOfType("outline").length
        )
          return;
        _ instanceof S2 && _.is2DAndNoDepth
          ? (function (_) {
              if (
                _.geometry.attributes.extrudeNormals ||
                !_.geometry.attributes.position
              )
                return;
              let I = _.geometry.attributes.position.array,
                R = new Float32Array(I.length),
                B = new rF();
              for (let _ = 0; _ < I.length; _ += 3)
                B.set(I[_], I[_ + 1], I[_ + 2]).normalize(),
                  (R[_] = B.x),
                  (R[_ + 1] = B.y),
                  (R[_ + 2] = B.z);
              _.geometry.setAttribute("extrudeNormal", new s4(R, 3));
            })(_)
          : (function (_) {
              if (
                _.geometry.attributes.extrudeNormal ||
                !_.geometry.attributes.position ||
                !_.geometry.attributes.normal
              )
                return;
              let I = new Map(),
                R = _.geometry.attributes,
                B = R.position.array,
                z = R.normal.array,
                k = new Float32Array(B.length);
              for (let _ = 0; _ < B.length; _ += 3) {
                let R = `${B[_]}_${B[_ + 1]}_${B[_ + 2]}`,
                  k = new rF(z[_], z[_ + 1], z[_ + 2]);
                I.has(R)
                  ? I.get(R)?.normals.push(k)
                  : I.set(R, { normals: [k], result: new rF() });
              }
              I.forEach((_, I) => {
                for (let I of _.normals) _.result.add(I);
                _.result.divideScalar(_.normals.length);
              });
              for (let _ = 0; _ < B.length; _ += 3) {
                let R = `${B[_]}_${B[_ + 1]}_${B[_ + 2]}`,
                  z = I.get(R)?.result;
                z && ((k[_] = z.x), (k[_ + 1] = z.y), (k[_ + 2] = z.z));
              }
              _.geometry.setAttribute("extrudeNormal", new s4(k, 3));
            })(_);
      }
      function pf(_) {
        if (!_.geometry.attributes.position) return;
        let I = _.geometry.attributes.position.array,
          R = new Float32Array(I.length),
          B = parseInt(_.uuid.replace(/\D/g, "")),
          z = [
            rr.seededRandom(B),
            rr.seededRandom(B + 1e4),
            rr.seededRandom(B + 2e4),
          ];
        for (let _ = 0; _ < I.length; _++) R[_] = z[_ % 3];
        _.geometry.setAttribute("randomColor", new s0(R, 3));
      }
      var S3 = new rU(),
        S4 = new rF(),
        S5 = class extends S2 {
          constructor(_, I, R) {
            super(_, I, R),
              (this.data = I),
              (this.hiddenMatrixOld = new sa()),
              (this.smoothShading = !0),
              (this.skipReactionUpdate = !1);
          }
          chooseGeoemtryCache(_) {
            return this.dataPatched.flatShading
              ? _.geometryCache
              : _.geometryCache2;
          }
          get subdivPointerNew() {
            return void 0 !== this.localGeometry
              ? this.subdivPointer
              : this.geometry.ensureSubdivPointer();
          }
          get originalGeometryNew() {
            return void 0 !== this.localGeometry
              ? this.originalGeometry
              : this.geometry.originalGeometry;
          }
          get phongAngle() {
            return this.data.geometry.phongAngle ?? 45;
          }
          updateEntityBoxSize(_, I) {
            let R = this.geometry.userData.parameters;
            _.copy(this.originalGeometryNew.boundingSphere.center),
              I.set(R.width, R.height, R.depth ?? 0).multiplyScalar(0.5);
          }
          createGeometryByControls(_) {
            if (!0 === this.skipReactionUpdate) return;
            let I = this.localGeometry?.uuid,
              {
                originalGeometry: R,
                subdividedGeometry: B,
                subdivPointer: z,
              } = b8.build(
                _,
                this.subdivPointer,
                this.smoothShading,
                this.hasNonUniformScale ? this.shearScale : void 0
              );
            (this.subdivPointer = z),
              void 0 !== R &&
                (this.originalGeometry?.dispose(), (this.originalGeometry = R)),
              void 0 !== B &&
                (this.subdividedGeometry?.dispose(),
                (this.subdividedGeometry = B ?? void 0)),
              (this.localGeometry =
                this.subdividedGeometry ?? this.originalGeometry),
              ff(this),
              pf(this),
              this.calcBoundingBox(),
              I && (this.localGeometry.uuid = I);
          }
          updateState(_, I) {
            if ((super.updateState(_, I), void 0 !== _.flatShading)) {
              let R = this.material;
              (this.material = Array.isArray(R)
                ? R.map((_) => _.getFlavor(!1, _.side, _.wireframe))
                : R.getFlavor(!1, R.side, R.wireframe)),
                (this.smoothShading = !_.flatShading),
                this.createGeometryDelayed(I);
            }
          }
          updateMesh(_ = !1) {
            b8.buildLevel(
              this.subdivPointer,
              !0,
              this.smoothShading ? this.phongAngle : -1,
              this.originalGeometry,
              _ && this.hasNonUniformScale ? this.shearScaleInv : void 0
            ),
              this.subdividedGeometry &&
                b8.buildLevel(
                  this.subdivPointer,
                  !1,
                  this.smoothShading ? this.phongAngle : -1,
                  this.subdividedGeometry,
                  _ && this.hasNonUniformScale ? this.shearScaleInv : void 0
                );
          }
          updateTopology() {
            this.originalGeometry.dispose(),
              (this.originalGeometry = b8.buildLevel(
                this.subdivPointer,
                !0,
                this.smoothShading ? this.phongAngle : -1
              )),
              this.subdividedGeometry &&
                (this.subdividedGeometry.dispose(),
                (this.subdividedGeometry = b8.buildLevel(
                  this.subdivPointer,
                  !1,
                  this.smoothShading ? this.phongAngle : -1
                ))),
              (this.localGeometry =
                this.subdividedGeometry ?? this.originalGeometry);
          }
          raycast(_, I) {
            let R = this.localGeometry;
            (this.localGeometry = this.originalGeometryNew),
              wp.prototype.raycast.call(this, _, I),
              (this.localGeometry = R);
          }
          activateSVDCompensation() {
            this.hasNonUniformScale &&
              (this.matrix.copy(this.matrixWorldRigid),
              this.hiddenMatrixOld.copy(this.hiddenMatrix),
              this.hiddenMatrix.copy(this.parent.matrixWorld).invert());
          }
          deactivateSVDCompensation() {
            this.hasNonUniformScale &&
              (this.updateMatrix(),
              (this.hasNonUniformScale = void 0),
              this.hiddenMatrix.copy(this.hiddenMatrixOld));
          }
          calcBoundingBox() {
            let _ = this.originalGeometry;
            null === _.boundingSphere &&
              ((_.boundingSphere = new r5()),
              this.subdividedGeometry &&
                (this.subdividedGeometry.boundingSphere = _.boundingSphere));
            let I = _.attributes.position,
              R = _.boundingSphere.center;
            S3.setFromBufferAttribute(I),
              S3.getCenter(R),
              (_.boundingSphere.radius = R.distanceTo(S3.max)),
              isNaN(_.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                ),
              S3.getSize(S4),
              this.hasNonUniformScale && S4.divide(this.scale);
            let B = { width: S4.x, height: S4.y, depth: S4.z };
            return (this.geometry.userData.parameters = B), B;
          }
          updateBoundingSphere(_) {
            let I = this.originalGeometry;
            S3.min.set(_[0], _[2], _[4]),
              S3.max.set(_[1], _[3], _[5]),
              this.hasNonUniformScale &&
                (S3.min.applyMatrix4(this.shearScaleInv),
                S3.max.applyMatrix4(this.shearScaleInv)),
              null === I.boundingSphere && (I.boundingSphere = new r5());
            let R = I.boundingSphere.center;
            S3.getCenter(R), (I.boundingSphere.radius = R.distanceTo(S3.max));
          }
          freeSubdivPointer() {
            this.subdivPointer &&
              (b8.freeSubdivPointer(this.subdivPointer),
              (this.subdivPointer = 0)),
              (this.localGeometry = void 0),
              this.originalGeometry?.dispose(),
              this.subdividedGeometry?.dispose();
          }
          dispose() {
            super.dispose(), this.freeSubdivPointer();
          }
          updateByPatchedOpGeometry(_, I, R) {
            super.updateByPatchedOpGeometry(_, I, R),
              this.localGeometry && this.createGeometryByControls(I);
          }
        },
        S6 = {
          x: [1, 0, 0],
          "-x": [-1, 0, 0],
          y: [0, 1, 0],
          "-y": [0, -1, 0],
          z: [0, 0, 1],
          "-z": [0, 0, -1],
        },
        S8 = { polygon_center: 0, edge: 1, vertex: 2 },
        Gm = (_, I) => (R, B) => I && 0 !== R && 0 !== _ ? (_ * B) / 100 : 0,
        xt = (_, I) => {
          let R = Math.abs(I),
            B = -1 * R;
          return ((_ - -1) * (R - B)) / 2 + B;
        },
        S9 = new rF(),
        S7 = new rF(),
        Ae = new rF(),
        Ai = new rF();
      function mf(_, I) {
        let R = Ae.fromArray(_),
          B = Ai.fromArray(I);
        S7.copy(B).sub(R);
        let z = S7.length();
        return (
          S7.normalize().multiplyScalar(0.5 * z), S9.copy(R).add(S7).toArray()
        );
      }
      var Ar = new sX(),
        As = new rF(),
        Aa = new rF(),
        An = new rF(),
        w_ = (_) => 0.5 * (1 - Math.cos(_ * Math.PI)),
        Ao = class {
          constructor() {
            this.perlin = Array(4096);
          }
          noise(_, I = 0, R = 0) {
            if (null == this.perlin) {
              this.perlin = Array(4096);
              for (let _ = 0; _ < 4096; _++) this.perlin[_] = Math.random();
            }
            _ < 0 && (_ = -_), I < 0 && (I = -I), R < 0 && (R = -R);
            let B = Math.floor(_),
              z = Math.floor(I),
              k = Math.floor(R),
              V = _ - B,
              j = I - z,
              G = R - k,
              q,
              X,
              Q = 0,
              $ = 0.5,
              et,
              er,
              es;
            for (let _ = 0; _ < 4; _++) {
              let _ = B + (z << 4) + (k << 8);
              (q = w_(V)),
                (X = w_(j)),
                (et = this.perlin[4095 & _]),
                (et += q * (this.perlin[(_ + 1) & 4095] - et)),
                (er = this.perlin[(_ + 16) & 4095]),
                (er += q * (this.perlin[(_ + 16 + 1) & 4095] - er)),
                (et += X * (er - et)),
                (_ += 256),
                (er = this.perlin[4095 & _]),
                (er += q * (this.perlin[(_ + 1) & 4095] - er)),
                (es = this.perlin[(_ + 16) & 4095]),
                (es += q * (this.perlin[(_ + 16 + 1) & 4095] - es)),
                (er += X * (es - er)),
                (et += w_(G) * (er - et)),
                (Q += et * $),
                ($ *= 0.5),
                (B <<= 1),
                (z <<= 1),
                (j *= 2),
                (k <<= 1),
                (G *= 2),
                (V *= 2) >= 1 && (B++, V--),
                j >= 1 && (z++, j--),
                G >= 1 && (k++, G--);
            }
            return Q;
          }
          noiseSeed(_) {
            let I, R;
            let B = {
              setSeed(_) {
                R = I = (_ ?? 4294967296 * Math.random()) >>> 0;
              },
              getSeed: () => I,
              rand: () =>
                (R = (1664525 * R + 1013904223) % 4294967296) / 4294967296,
            };
            B.setSeed(_), (this.perlin = Array(4096));
            for (let _ = 0; _ < 4096; _++) this.perlin[_] = B.rand();
          }
        },
        Al = new rF(),
        Ac = new sa(),
        Au = new ss();
      function __(_) {
        let I = !1;
        return (
          _.scene.objects.traverse((_, R) => {
            "Mesh" === R.type && "TextGeometry" === R.geometry.type && (I = !0);
          }),
          I
        );
      }
      var Ap,
        Af,
        Am,
        Ag,
        Ay,
        Ax = class extends S2 {
          constructor(_, I, R) {
            super(_, I, R), (this.data = I);
          }
          get textGeometry() {
            return this.geometry;
          }
          get charWidths() {
            return this.textGeometry.charWidths;
          }
          get charCoords() {
            return this.textGeometry.charCoords;
          }
          get wrappedText() {
            return this.textGeometry.wrappedText;
          }
          get font() {
            return this.textGeometry.font;
          }
          get initialOffsetY() {
            let _ = this.dataPatched;
            return (
              this.font?.getLineInitialOffsetY(
                this.lineHeight,
                this.wrappedText.length,
                _.geometry.height,
                this.fontScale,
                _.geometry.verticalAlign
              ) ?? 0
            );
          }
          get fontScale() {
            let _ = this.dataPatched;
            return this.font ? _.geometry.fontSize / this.font.unitsPerEm : 1;
          }
          get AD() {
            return Math.abs(this.ascender - this.descender);
          }
          get ascender() {
            return (this.font?.ascender ?? 1) * this.fontScale;
          }
          get descender() {
            return (this.font?.descender ?? 1) * this.fontScale;
          }
          get lineHeight() {
            let _ = this.dataPatched;
            return _.geometry.fontSize * _.geometry.lineHeight;
          }
          raycast(_, I) {
            let { matrixWorld: R } = this;
            if (
              !(
                isNaN(_.ray.origin.x) ||
                0 === this.scale.x ||
                0 === this.scale.y ||
                0 === this.scale.z
              ) &&
              (Ac.copy(R).invert(),
              Au.copy(_.ray).applyMatrix4(Ac),
              Au.intersectBox(this.singleBBox, Al))
            ) {
              let B = Al.applyMatrix4(R),
                z = _.ray.origin.distanceTo(B);
              I.push({ distance: z, point: B.clone(), object: this });
            }
          }
        },
        Ab = new rF(),
        Aw = new rF();
      bQ.then((_) => {
        (Am = [
          (Af = _).get_face_center,
          Af.get_edge_midpoint,
          Af.get_vertex_position,
        ]),
          (Ag = [Af.get_face_normal, Af.get_edge_normal, Af.get_vertex_normal]),
          (Ay = [Af.face_count, Af.edge_count, Af.vertex_count]);
      });
      var A_ = new sa(),
        AS = new sa(),
        AA = new rF(),
        AM = new rF(),
        AC = new rF(),
        AT = new rF(),
        AP = new rF(),
        AD = new rF(),
        AO = new Ao(),
        AI = class extends Td(sL) {
          constructor(_, I) {
            super(),
              (this.parameters = I),
              (this.objectForSample = void 0),
              (this._pendingMediaLoad = !1),
              (this.object = _);
          }
          resetOnMove() {
            this.removeFromParent(), (this.parent = null);
          }
          expandClones(_) {
            if (null === this.parent) this.updateState(this.parameters, _);
            else for (let _ of this.children) _ instanceof yj && _.expand();
          }
          invalidateTransform(_) {
            (this.matrixWorldNeedsUpdate = !0),
              this.traverse((I) => {
                I instanceof yj &&
                  I.object === _ &&
                  (I.matrixWorldNeedsUpdate = !0);
              });
          }
          onObjUpdateMatrix() {
            "toObject" !== this.parameters.type &&
              (this.matrixWorldNeedsUpdate = !0);
          }
          update() {
            switch ((this._updateCount(), this.parameters.type)) {
              case "radial":
                this._updateRadial(this.parameters);
                break;
              case "linear":
                this._updateLinear(this.parameters);
                break;
              case "grid":
                this._updateGrid(this.parameters);
                break;
              case "toObject":
                this._updateToObject(this.parameters);
            }
            for (let _ of this.children)
              _.updateMatrix(),
                _.hasNonUniformScale &&
                  (_.updateMatrixWorld(), _.updateMatrixWorldSVD());
          }
          _updateCount(_) {
            let I;
            if (
              ((I =
                void 0 !== _
                  ? _
                  : "grid" === this.parameters.type
                  ? Math.round(this.parameters.grid.count[0]) *
                    Math.round(this.parameters.grid.count[1]) *
                    Math.round(this.parameters.grid.count[2])
                  : this.parameters.count),
              "toObject" !== this.parameters.type ||
                this.parameters.toObject.object ||
                (I = 0),
              "toObject" === this.parameters.type && this.objectForSample)
            ) {
              for (let _ = 0, I = this.children.length; _ < I; ++_)
                this.remove(this.children[0]);
              let _ = this.children;
              if (_.length === I) return;
              if (_.length < I)
                for (let R = 0, B = I - _.length; R < B; ++R) {
                  let _ = new yj(this.object);
                  _.expand(), this.add(_);
                }
              else
                for (let R = 0, B = _.length - I; R < B; ++R) this.remove(_[R]);
            } else {
              if (this.children.length === I) return;
              if (this.children.length < I)
                for (let _ = 0, R = I - this.children.length; _ < R; ++_) {
                  let _ = new yj(this.object);
                  _.expand(), this.add(_);
                }
              else
                for (let _ = 0, R = this.children.length - I; _ < R; ++_)
                  this.remove(this.children[0]);
            }
          }
          _updateRadial(_) {
            let I = _.radial,
              R = I.start * rr.DEG2RAD,
              B = R - I.end * rr.DEG2RAD,
              z = new sg(I.rotation[0], I.rotation[1], I.rotation[2]),
              k;
            switch (I.axis) {
              case "z":
                k = new rF(0, 0, 1);
                break;
              case "y":
                k = new rF(0, 1, 0);
                break;
              default:
                k = new rF(1, 0, 0);
            }
            let V =
                _.randomnessObject ??
                mI.defaultData([1, 1, 1]).randomnessObject,
              j = "perlin" === V.noiseType;
            AO.noiseSeed(V.seed);
            let G = T0((0, y_.default)(V.seed)),
              q = Gm(V.strength, this.parameters.randomness);
            for (let [X, Q] of this.children.entries()) {
              let $ = X * (V.freqScale / 10) + V.movement,
                et = j ? AO.noise($) : G($, $),
                er = X + 1;
              (Q.scale.x = I.scale[0] + q(er, xt(et, V.scale[0])) || 1e-4),
                (Q.scale.y = I.scale[1] + q(er, xt(et, V.scale[1])) || 1e-4),
                (Q.scale.z = I.scale[2] + q(er, xt(et, V.scale[2])) || 1e-4),
                Q.position.setScalar(0);
              let es = (B / _.count) * X - R;
              switch (I.axis) {
                case "x":
                  Q.rotation.set(0, es, 0);
                  break;
                case "y":
                  Q.rotation.set(0, 0, es);
                  break;
                case "z":
                  Q.rotation.set(es, 0, 0);
              }
              Q.translateOnAxis(k, I.radius),
                (Q.position.x += I.position[0] + q(er, xt(et, V.position[0]))),
                (Q.position.y += I.position[1] + q(er, xt(et, V.position[1]))),
                (Q.position.z += I.position[2] + q(er, xt(et, V.position[2])));
              let ea = q(er, xt(et, V.rotation[0])),
                en = q(er, xt(et, V.rotation[1])),
                eo = q(er, xt(et, V.rotation[2]));
              !0 === I.alignment
                ? ((Q.rotation.x += z.x + ea),
                  (Q.rotation.y += z.y + en),
                  (Q.rotation.z += z.z + eo))
                : Q.rotation.set(z.x + ea, z.y + en, z.z + eo);
            }
          }
          _updateLinear(_) {
            if ("linear" !== _.type) throw Error();
            let I = _.linear,
              R = new sg(I.rotation[0], I.rotation[1], I.rotation[2]),
              B =
                _.randomnessObject ??
                mI.defaultData([1, 1, 1]).randomnessObject,
              z = "perlin" === B.noiseType;
            AO.noiseSeed(B.seed);
            let k = T0((0, y_.default)(B.seed)),
              V = Gm(B.strength, this.parameters.randomness);
            for (let [_, j] of this.children.entries()) {
              let G = _ * (B.freqScale / 10) + B.movement,
                q = z ? AO.noise(G) : k(G, G),
                X = _ + 1,
                Q = V(X, xt(q, B.rotation[0])),
                $ = V(X, xt(q, B.rotation[1])),
                et = V(X, xt(q, B.rotation[2]));
              (j.scale.x =
                1 + (I.scale[0] - 1) * _ + V(X, xt(q, B.scale[0])) || 1e-4),
                (j.scale.y =
                  1 + (I.scale[1] - 1) * _ + V(X, xt(q, B.scale[1])) || 1e-4),
                (j.scale.z =
                  1 + (I.scale[2] - 1) * _ + V(X, xt(q, B.scale[2])) || 1e-4),
                (j.rotation.x = R.x * _ + Q),
                (j.rotation.y = R.y * _ + $),
                (j.rotation.z = R.z * _ + et),
                (j.position.x = I.position[0] * _ + V(X, xt(q, B.position[0]))),
                (j.position.y = I.position[1] * _ + V(X, xt(q, B.position[1]))),
                (j.position.z = I.position[2] * _ + V(X, xt(q, B.position[2])));
            }
          }
          _updateGrid(_) {
            let I = 0,
              R = _.grid,
              B =
                _.randomnessObject ??
                mI.defaultData([1, 1, 1]).randomnessObject,
              z = Gm(B.strength, this.parameters.randomness),
              k = "perlin" === B.noiseType;
            AO.noiseSeed(B.seed);
            let V = (function (_ = Math.random) {
              let I = OO(_),
                R = new Float64Array(I).map((_) => yD[(_ % 12) * 3]),
                B = new Float64Array(I).map((_) => yD[(_ % 12) * 3 + 1]),
                z = new Float64Array(I).map((_) => yD[(_ % 12) * 3 + 2]);
              return function (_, k, V) {
                let j,
                  G,
                  q,
                  X,
                  Q = (_ + k + V) * yM,
                  $ = mm(_ + Q),
                  et = mm(k + Q),
                  er = mm(V + Q),
                  es = ($ + et + er) * yT,
                  ea = _ - ($ - es),
                  en = k - (et - es),
                  eo = V - (er - es),
                  el,
                  eh,
                  ec,
                  ed,
                  ep,
                  ef;
                ea >= en
                  ? en >= eo
                    ? ((el = 1),
                      (eh = 0),
                      (ec = 0),
                      (ed = 1),
                      (ep = 1),
                      (ef = 0))
                    : (ea >= eo
                        ? ((el = 1), (eh = 0), (ec = 0))
                        : ((el = 0), (eh = 0), (ec = 1)),
                      (ed = 1),
                      (ep = 0),
                      (ef = 1))
                  : en < eo
                  ? ((el = 0), (eh = 0), (ec = 1), (ed = 0), (ep = 1), (ef = 1))
                  : ea < eo
                  ? ((el = 0), (eh = 1), (ec = 0), (ed = 0), (ep = 1), (ef = 1))
                  : ((el = 0),
                    (eh = 1),
                    (ec = 0),
                    (ed = 1),
                    (ep = 1),
                    (ef = 0));
                let em = ea - el + yT,
                  ey = en - eh + yT,
                  ex = eo - ec + yT,
                  eb = ea - ed + 2 * yT,
                  ew = en - ep + 2 * yT,
                  e_ = eo - ef + 2 * yT,
                  eS = ea - 1 + 3 * yT,
                  eA = en - 1 + 3 * yT,
                  eC = eo - 1 + 3 * yT,
                  eT = 255 & $,
                  eP = 255 & et,
                  eI = 255 & er,
                  eR = 0.6 - ea * ea - en * en - eo * eo;
                if (eR < 0) j = 0;
                else {
                  let _ = eT + I[eP + I[eI]];
                  (eR *= eR),
                    (j = eR * eR * (R[_] * ea + B[_] * en + z[_] * eo));
                }
                let eB = 0.6 - em * em - ey * ey - ex * ex;
                if (eB < 0) G = 0;
                else {
                  let _ = eT + el + I[eP + eh + I[eI + ec]];
                  (eB *= eB),
                    (G = eB * eB * (R[_] * em + B[_] * ey + z[_] * ex));
                }
                let ez = 0.6 - eb * eb - ew * ew - e_ * e_;
                if (ez < 0) q = 0;
                else {
                  let _ = eT + ed + I[eP + ep + I[eI + ef]];
                  (ez *= ez),
                    (q = ez * ez * (R[_] * eb + B[_] * ew + z[_] * e_));
                }
                let eF = 0.6 - eS * eS - eA * eA - eC * eC;
                if (eF < 0) X = 0;
                else {
                  let _ = eT + 1 + I[eP + 1 + I[eI + 1]];
                  (eF *= eF),
                    (X = eF * eF * (R[_] * eS + B[_] * eA + z[_] * eC));
                }
                return 32 * (j + G + q + X);
              };
            })((0, y_.default)(B.seed));
            if (!0 === R.useCenter) {
              let _ = {
                  x: R.count[0] % 2 == 0 ? 2 : 1,
                  y: R.count[1] % 2 == 0 ? 2 : 1,
                  z: R.count[2] % 2 == 0 ? 2 : 1,
                },
                j = new rF(
                  R.size[0] * (R.count[0] - _.x) * 0.5,
                  R.size[1] * (R.count[1] - _.y) * 0.5,
                  R.size[2] * (R.count[2] - _.z) * 0.5
                );
              for (let _ = 0; _ < R.count[0]; _++)
                for (let G = 0; G < R.count[1]; G++)
                  for (let q = 0; q < R.count[2]; q++) {
                    let X = [
                        (_ + 1) * (B.freqScale / 10) + B.movement,
                        (G + 1) * (B.freqScale / 10) + B.movement,
                        (q + 1) * (B.freqScale / 10) + B.movement,
                      ],
                      Q = k ? AO.noise(...X) : V(...X),
                      $ = this.children[I++];
                    ($.scale.x = 1 + z(I, xt(Q, B.scale[0])) || 1e-4),
                      ($.scale.y = 1 + z(I, xt(Q, B.scale[1])) || 1e-4),
                      ($.scale.z = 1 + z(I, xt(Q, B.scale[2])) || 1e-4);
                    let et = z(I, xt(Q, B.rotation[0])),
                      er = z(I, xt(Q, B.rotation[1])),
                      es = z(I, xt(Q, B.rotation[2]));
                    $.rotation.set(et, er, es),
                      ($.position.x =
                        R.size[0] * _ - j.x + z(I, xt(Q, B.position[0]))),
                      ($.position.y =
                        R.size[1] * G - j.y + z(I, xt(Q, B.position[1]))),
                      ($.position.z =
                        R.size[2] * q - j.z + z(I, xt(Q, B.position[2])));
                  }
            } else
              for (let _ = 0; _ < R.count[0]; _++)
                for (let j = 0; j < R.count[1]; j++)
                  for (let G = 0; G < R.count[2]; G++) {
                    let q = [
                        (_ + 1) * (B.freqScale / 10) + B.movement,
                        (j + 1) * (B.freqScale / 10) + B.movement,
                        (G + 1) * (B.freqScale / 10) + B.movement,
                      ],
                      X = k ? AO.noise(...q) : V(...q),
                      Q = this.children[I++];
                    (Q.scale.x = 1 + z(I, xt(X, B.scale[0])) || 1e-4),
                      (Q.scale.y = 1 + z(I, xt(X, B.scale[1])) || 1e-4),
                      (Q.scale.z = 1 + z(I, xt(X, B.scale[2])) || 1e-4);
                    let $ = z(I, xt(X, B.rotation[0])),
                      et = z(I, xt(X, B.rotation[1])),
                      er = z(I, xt(X, B.rotation[2]));
                    Q.rotation.set($, et, er),
                      (Q.position.x =
                        R.size[0] * _ + z(I, xt(X, B.position[0]))),
                      (Q.position.y =
                        -R.size[1] * j + z(I, xt(X, B.position[1]))),
                      (Q.position.z =
                        -R.size[2] * G + z(I, xt(X, B.position[2])));
                  }
          }
          _updateToObject(_) {
            if ("toObject" !== _.type) throw Error();
            let { toObject: I } = _,
              R = new sg(I.rotation[0], I.rotation[1], I.rotation[2]),
              B =
                _.randomnessObject ??
                mI.defaultData([1, 1, 1]).randomnessObject,
              z = "perlin" === B.noiseType;
            AO.noiseSeed(B.seed);
            let k = T0((0, y_.default)(B.seed)),
              V = Gm(B.strength, this.parameters.randomness);
            if (!I.object) {
              for (let [, _] of this.children.entries())
                _.position.set(0, 0, 0),
                  _.scale.setScalar(1),
                  _.rotation.set(0, 0, 0);
              this.objectForSample = void 0;
              return;
            }
            if (!this.objectForSample) return;
            if (this.objectForSample instanceof Ax) {
              if (
                this.objectForSample.font?.isLoaded &&
                void 0 !== this.objectForSample.geometry.attributes.position
              )
                this._pendingMediaLoad = !1;
              else {
                this._pendingMediaLoad = !0;
                return;
              }
            }
            if (
              void 0 === this.objectForSample.geometry &&
              this.objectForSample.isAncestorOf(this.object.uuid)
            ) {
              console.warn(
                `Oh no! The object "${this.object.name}" (${this.object.uuid}) seem to be a child/descendant of the object it's being cloned to. Please re-parent it so that they are siblings instead.`
              );
              return;
            }
            let j = this.getSubdivData(),
              G = [],
              h = (_) => {
                let I = _.length;
                return [
                  _.map((_) => _[0]).reduce((_, I) => _ + I, 0) / I,
                  _.map((_) => _[1]).reduce((_, I) => _ + I, 0) / I,
                  _.map((_) => _[2]).reduce((_, I) => _ + I, 0) / I,
                ];
              },
              d = (_) => Math.round(1e6 * _) / 1e6;
            j.forEach((_) => {
              let I = j.filter(
                (I) =>
                  d(_.pos[0]) === d(I.pos[0]) &&
                  d(_.pos[1]) === d(I.pos[1]) &&
                  d(_.pos[2]) === d(I.pos[2])
              );
              I.length > 1
                ? G.push({ pos: _.pos, norm: h(I.map((_) => _.norm)) })
                : G.push(_);
            });
            let q = (function (_) {
              let I = [],
                R = {};
              for (var B = 0, z = _.length; B < z; B++) {
                var k = JSON.stringify(
                  _[B].pos.map((_) => Math.round(1e4 * _) / 1e4)
                );
                R[k] || (I.push(_[B]), (R[k] = !0));
              }
              return I;
            })(G);
            if (q.length > 0) {
              let _ = Math.round((q.length * I.count) / 100);
              this._updateCount(_);
            } else {
              let _ = this.objectForSample.geometry.getAttribute("position");
              if (!_ || isNaN(_.count) || 0 === _.count) {
                console.warn(
                  `Oh no! The object "${this.object.name}" (${this.object.uuid}) cannot be cloned on the surface of "${this.objectForSample.name}" (${this.objectForSample.uuid}) because the latter does not have a valid geometry.`
                );
                return;
              }
            }
            this.objectForSample.updateMatrixWorld();
            let X = new yB(this.objectForSample).build(),
              Q = S6[I.axis],
              $ = this.children;
            for (let [_, j] of (X.setRandomGenerator(
              (0, y_.default)(this.object.uuid + I.seed)
            ),
            $.entries())) {
              let G = _ * (B.freqScale / 10) + B.movement,
                $ = z ? AO.noise(G) : k(G, G),
                et = _ + 1,
                er = V(et, xt($, B.rotation[0])),
                es = V(et, xt($, B.rotation[1])),
                ea = V(et, xt($, B.rotation[2]));
              "random" === I.spreadType
                ? X.sample(AC, AT)
                : (q.length &&
                    (AC.fromArray(q[_].pos), AT.fromArray(q[_].norm)),
                  this.objectForSample instanceof S5 &&
                    AC.applyMatrix4(
                      A_.copy(this.objectForSample.matrixWorld).invert()
                    )),
                AC.applyMatrix4(this.object.hiddenMatrix.clone().invert()),
                j.position.copy(AC),
                AA.fromArray(Q);
              let en =
                  "normal" === I.align ? AT : this.object.getWorldDirection(AD),
                eo = AM.fromArray(I.position);
              (AM.x += V(et, xt($, B.position[0]))),
                (AM.y += V(et, xt($, B.position[1]))),
                (AM.z += V(et, xt($, B.position[2])));
              let el = Math.acos(en.dot(AA)),
                eh = AP.crossVectors(AA, en).normalize(),
                ec = AS.makeRotationAxis(eh, el),
                ed = en.clone().cross(this.object.up).normalize(),
                ep = ed.clone().cross(en).normalize(),
                ef = new sa().makeBasis(ed, en, ep),
                em = new rF(AA.y, AA.z, AA.x).normalize(),
                ey = em.clone().cross(AA).normalize(),
                ex = new sa().makeBasis(em, AA, ey).invert(),
                eb = new sa().multiplyMatrices(ef, ex);
              j.rotation.setFromRotationMatrix(eb),
                eo.applyMatrix4(ec),
                j.position.add(eo),
                (j.rotation.x = j.rotation.x + R.x + er),
                (j.rotation.y = j.rotation.y + R.y + es),
                (j.rotation.z = j.rotation.z + R.z + ea),
                j.scale.setScalar(1),
                (j.scale.x =
                  j.scale.x + I.scale[0] + V(et, xt($, B.scale[0])) || 1e-4),
                (j.scale.y =
                  j.scale.y + I.scale[1] + V(et, xt($, B.scale[1])) || 1e-4),
                (j.scale.z =
                  j.scale.z + I.scale[2] + V(et, xt($, B.scale[2])) || 1e-4),
                j.scale.multiply(this.object.scale),
                (j.hiddenMatrix = this.object.hiddenMatrix);
            }
          }
          getSubdivData() {
            if (!this.objectForSample) return [];
            let _ = this.parameters.toObject.spreadType;
            if ("random" === _) return [];
            if (!(this.objectForSample instanceof S5))
              return (
                this.objectForSample.geometry.index
                  ? (function (_) {
                      let I = [];
                      for (let R = 0; R <= _.index.count; R++)
                        if (
                          (As.fromArray(_.index.array, 3 * R),
                          Ar.setFromAttributeAndIndices(
                            _.attributes.position,
                            As.x,
                            As.y,
                            As.z
                          ),
                          Ar.getNormal(Aa),
                          Ar.getMidpoint(An),
                          !(isNaN(An.x) || isNaN(An.y) || isNaN(An.z)))
                        ) {
                          let { a: _, b: R, c: B } = Ar,
                            z = _.toArray(),
                            k = R.toArray(),
                            V = B.toArray(),
                            j = _.distanceTo(R),
                            G = R.distanceTo(B),
                            q = B.distanceTo(_),
                            X = mf(z, k),
                            Q = mf(k, V),
                            $ = mf(V, z),
                            et = [j, G, q],
                            er = Math.max(...et),
                            es =
                              et.filter((_) => Math.round(_) === Math.round(er))
                                .length > 1,
                            ea = [],
                            en = Ar.getMidpoint(An).toArray();
                          er !== j || es || ((ea = [Q, $, $]), (en = X)),
                            er !== G || es || ((ea = [X, $, $]), (en = Q)),
                            er !== q || es || ((ea = [X, Q, Q]), (en = $)),
                            es && (ea = [X, Q, $]),
                            I.push({
                              vertices: [z, k, V],
                              faceCenters: ea,
                              midpoint: en,
                              norm: Ar.getNormal(Aa).toArray(),
                            });
                        }
                      return I;
                    })(this.objectForSample.geometry)
                  : (function (_) {
                      let I = [],
                        { position: R } = _.attributes;
                      for (let _ = 0; _ < R.count; _++) {
                        Ar.setFromAttributeAndIndices(
                          R,
                          3 * _,
                          3 * _ + 1,
                          3 * _ + 2
                        ),
                          Ar.getNormal(Aa),
                          Ar.getMidpoint(An);
                        let B = Ar.a.toArray(),
                          z = Ar.b.toArray(),
                          k = Ar.c.toArray();
                        I.push({
                          vertices: [B, z, k],
                          faceCenters: [mf(B, z), mf(z, k), mf(k, B)],
                          midpoint: An.toArray(),
                          norm: Aa.toArray(),
                        });
                      }
                      return I;
                    })(this.objectForSample.geometry)
              )
                .map((I, R) =>
                  "polygon_center" === _
                    ? { pos: I.midpoint, norm: I.norm }
                    : "vertex" === _
                    ? [
                        { pos: I.vertices[0], norm: I.norm },
                        { pos: I.vertices[1], norm: I.norm },
                        { pos: I.vertices[2], norm: I.norm },
                      ]
                    : "edge" === _
                    ? [
                        { pos: I.faceCenters[0], norm: I.norm },
                        { pos: I.faceCenters[1], norm: I.norm },
                        { pos: I.faceCenters[2], norm: I.norm },
                      ]
                    : []
                )
                .flat();
            {
              let I = this.objectForSample,
                R = S8[_],
                B = Ay[R],
                z = Am[R],
                k = Ag[R],
                V = [],
                j = B(I.subdivPointerNew);
              for (let _ = 0; _ <= j - 1; _++) {
                let R = z(I.subdivPointerNew, _),
                  B = k(I.subdivPointerNew, _);
                Ab.fromArray(R).applyMatrix4(I.matrixWorld),
                  Aw.fromArray(B),
                  V.push({ pos: Ab.toArray(), norm: Aw.toArray() });
              }
              return V;
            }
          }
          updateState(_, I) {
            if (
              ((this.parameters = Ea(_)), "toObject" !== this.parameters.type)
            )
              (null === this.parent || this.parent !== this.object) &&
                (this.removeFromParent(),
                this.object.parent?.add(this),
                (this.matrix = this.object.matrix),
                (this.hiddenMatrix = this.object.hiddenMatrix),
                (this.matrixWorldNeedsUpdate = !0),
                (this.matrixAutoUpdate = !1));
            else if (
              null === this.parent ||
              this.parent.uuid !== this.parameters.toObject.object
            ) {
              this.removeFromParent();
              let _ = I.find(this.parameters.toObject.object);
              _ instanceof wp
                ? (this.objectForSample = _)
                : (this.objectForSample = void 0),
                (this.matrix = new sa()),
                (this.hiddenMatrix = new sa()),
                (this.matrixWorldNeedsUpdate = !0),
                (this.matrixAutoUpdate = !1),
                _ && _.add(this);
            }
            this.update();
          }
          get pendingMediaLoad() {
            return this._pendingMediaLoad;
          }
        },
        Qo = (_) => {
          var I;
          return (
            ((I = class extends _ {}).geometryHelper = new aS(30, 30, 30)), I
          );
        },
        AR = new ss(),
        Az = new r5(),
        AF = new sa(),
        Ko = (_, I, R, B, z = !1) => {
          let k = _.matrixWorld;
          if (
            (null === I.boundingSphere && I.computeBoundingSphere(),
            Az.copy(I.boundingSphere),
            Az.applyMatrix4(k),
            !1 === R.ray.intersectsSphere(Az) ||
              (AF.copy(k).invert(),
              AR.copy(R.ray).applyMatrix4(AF),
              null !== I.boundingBox && !1 === AR.intersectsBox(I.boundingBox)))
          )
            return;
          let V,
            j = I.index,
            G = I.attributes.position,
            q = I.drawRange,
            X;
          if (!1 === z) {
            let I = Math.max(0, q.start),
              z = Math.min(j.count, q.start + q.count);
            for (X = I; X < z; X += 3)
              if (
                (V = (function (_, I, R, B, z, k, V) {
                  let j = new rF(),
                    G = new rF(),
                    q = new rF(),
                    X = new rF(),
                    Q = new rF();
                  if (
                    (j.fromBufferAttribute(B, z),
                    G.fromBufferAttribute(B, k),
                    q.fromBufferAttribute(B, V),
                    null === R.intersectTriangle(j, G, q, !1, X))
                  )
                    return null;
                  Q.copy(X), Q.applyMatrix4(_.matrixWorld);
                  let $ = I.ray.origin.distanceTo(Q);
                  return $ < I.near || $ > I.far
                    ? null
                    : {
                        faceIndex: 1,
                        distance: $,
                        point: Q.clone(),
                        object: _,
                      };
                })(_, R, AR, G, j.getX(X), j.getX(X + 1), j.getX(X + 2)))
              ) {
                (V.faceIndex = Math.floor(X / 3)), B.push(V);
                return;
              }
          } else {
            let z = I.attributes.position,
              k = new rF(),
              V = new rF(),
              j = new rF(),
              G = new rF(),
              X = 1 / ((_.scale.x + _.scale.y + _.scale.z) / 3),
              Q = X * X,
              $ = Math.max(0, q.start),
              et = Math.min(z.count, q.start + q.count);
            for (let I = $, q = et - 1; I < q; I += 2) {
              if (
                (k.fromBufferAttribute(z, I),
                V.fromBufferAttribute(z, I + 1),
                AR.distanceSqToSegment(k, V, G, j) > Q)
              )
                continue;
              G.applyMatrix4(_.matrixWorld);
              let q = R.ray.origin.distanceTo(G);
              q < R.near ||
                q > R.far ||
                B.push({
                  distance: q,
                  point: j.clone().applyMatrix4(_.matrixWorld),
                  object: _,
                });
            }
          }
        },
        Ak = new rF(),
        AV = new aP(),
        Aj = class extends n7 {
          constructor(_) {
            let I = new ai(),
              R = new n$({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
              B = [],
              z = [],
              k = {},
              V = new ry(15711266),
              j = new ry(15711266),
              G = new ry(2857471);
            function h(_, I, R) {
              d(_, R), d(I, R);
            }
            function d(_, I) {
              B.push(0, 0, 0),
                z.push(I.r, I.g, I.b),
                void 0 === k[_] && (k[_] = []),
                k[_].push(B.length / 3 - 1);
            }
            h("n1", "n2", V),
              h("n2", "n4", V),
              h("n4", "n3", V),
              h("n3", "n1", V),
              h("f1", "f2", V),
              h("f2", "f4", V),
              h("f4", "f3", V),
              h("f3", "f1", V),
              h("n1", "f1", V),
              h("n2", "f2", V),
              h("n3", "f3", V),
              h("n4", "f4", V),
              h("p", "n1", j),
              h("p", "n2", j),
              h("p", "n3", j),
              h("p", "n4", j),
              h("u1", "u2", G),
              h("u2", "u3", G),
              h("u3", "u1", G),
              I.setAttribute("position", new s4(B, 3)),
              I.setAttribute("color", new s4(z, 3)),
              super(I, R),
              (this.type = "CameraHelper"),
              (this.camera = _),
              this.camera.updateProjectionMatrix &&
                this.camera.updateProjectionMatrix(),
              (this.matrix = _.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.pointMap = k),
              this.update();
          }
          update() {
            let _ = this.geometry,
              I = this.pointMap;
            (AV.projectionMatrixInverse.elements = [
              0.5112609807824982, -0, -0, -0, -0, 0.41421356237309503, -0, -0,
              -0, -0, -0, -0.099999, -0, -0, -1.0000000000000002, 0.100001,
            ]),
              co("n1", I, _, AV, -1, -1, 0.8),
              co("n2", I, _, AV, 1, -1, 0.8),
              co("n3", I, _, AV, -1, 1, 0.8),
              co("n4", I, _, AV, 1, 1, 0.8),
              co("f1", I, _, AV, -1, -1, 0.8),
              co("f2", I, _, AV, 1, -1, 0.8),
              co("f3", I, _, AV, -1, 1, 0.8),
              co("f4", I, _, AV, 1, 1, 0.8),
              co("u1", I, _, AV, 0.35, 1.1, 0.8),
              co("u2", I, _, AV, -0.35, 1.1, 0.8),
              co("u3", I, _, AV, 0, 1.55, 0.8),
              (_.getAttribute("position").needsUpdate = !0);
          }
          dispose() {
            this.geometry.dispose(), this.material.dispose();
          }
        };
      function co(_, I, R, B, z, k, V) {
        Ak.set(z, k, V).unproject(B);
        let j = I[_];
        if (void 0 !== j) {
          let _ = R.getAttribute("position");
          for (let I = 0, R = j.length; I < R; I++)
            _.setXYZ(j[I], Ak.x, Ak.y, Ak.z);
        }
      }
      var AH = class extends Qo(Aj) {
        constructor(_) {
          super(_),
            (this.object = _),
            (this.object = _),
            (this.name = `CombinedCameraHelper: ${_.uuid}`);
        }
        updateMatrixWorld(_) {
          super.updateMatrixWorld(_), this.updateTarget();
        }
        updateTarget() {
          let _ = this.object.getTarget();
          this.updateWorldMatrix(!0, !1), this.worldToLocal(_);
        }
        raycast(_, I) {
          Ko(this.object, this.geometry, _, I, !0);
        }
      };
      (CS || (CS = {})).is = (_) => "objectHelper" in _;
      var Is = (_, I) =>
          class extends Cd(_) {
            constructor() {
              super(...arguments),
                (this.objectHelper = new I(this)),
                (this.gizmos = {});
            }
            get geometryHelper() {
              return I.geometryHelper;
            }
            raycast(_, I) {
              this.objectHelper.raycast(_, I);
            }
            showGizmos() {
              for (let _ in this.gizmos) {
                let I = this.gizmos[_];
                I instanceof l5 && (I.visible = !0);
              }
            }
            updateEntityBoxSize(_, I) {
              this.objectHelper.visible && this.geometryHelper instanceof aS
                ? (_.setScalar(0),
                  I.set(
                    this.geometryHelper.parameters.width,
                    this.geometryHelper.parameters.height,
                    this.geometryHelper.parameters.height
                  ).multiplyScalar(0.5))
                : super.updateEntityBoxSize(_, I);
            }
            hideGizmos() {
              for (let _ in this.gizmos) {
                let I = this.gizmos[_];
                I instanceof l5 && (I.visible = !1);
              }
            }
          },
        AW = new rF(),
        Aq = new rF(),
        AY = new rz(),
        AX = new rF(),
        AQ = new rF(),
        AZ = new rF(),
        AK = class extends Is(aP, AH) {
          constructor(_ = "", I = { ...vn.defaultData, name: "" }) {
            super(),
              (this._cameraType = "OrthographicCamera"),
              (this.targetOffset = mO.DefaultTargetOffset),
              (this.isUpVectorFlipped = !1),
              (this.angleOffsetFromUp = 0),
              (this.wasMovedByUser = !1),
              (this.wasMovedBySwitchCameraAction = !1),
              this.super_Entity(_, I),
              (this.previousProjectionMatrix = new sa()),
              (this.matrixAutoUpdate = !0),
              (this.width = window.innerWidth),
              (this.height = window.innerHeight);
            let R = this.width,
              B = this.height;
            (this.orthoCamera = new aK(
              -0.5 * R,
              0.5 * R,
              0.5 * B,
              -0.5 * B,
              -5e4,
              1e4
            )),
              (this.perspCamera = new aI(45, R / B, 50, 1e4)),
              (this.left = this.orthoCamera.left),
              (this.right = this.orthoCamera.right),
              (this.top = this.orthoCamera.top),
              (this.bottom = this.orthoCamera.bottom),
              (this.far = this.orthoCamera.far),
              (this.view = this.orthoCamera.view),
              (this.aspect = this.perspCamera.aspect),
              (this.focus = this.perspCamera.focus),
              (this.filmGauge = this.perspCamera.filmGauge),
              (this.filmOffset = this.perspCamera.filmOffset),
              this.objectHelper.update();
          }
          get isPerspectiveCamera() {
            return "PerspectiveCamera" === this.cameraType;
          }
          get isOrthographicCamera() {
            return !this.isPerspectiveCamera;
          }
          get cameraType() {
            return this._cameraType;
          }
          set fov(_) {
            this.perspCamera.fov = _;
          }
          get fov() {
            return this.perspCamera.fov;
          }
          setNear(_, I) {
            "PerspectiveCamera" === _
              ? (this.perspCamera.near = I)
              : (this.orthoCamera.near = I);
          }
          setZoom(_, I) {
            I >= 0 &&
              ("PerspectiveCamera" === _
                ? (this.perspCamera.zoom = I)
                : (this.orthoCamera.zoom = I));
          }
          set cameraType(_) {
            "PerspectiveCamera" === _
              ? this.toPerspective()
              : "OrthographicCamera" === _ && this.toOrthographic();
          }
          get near() {
            return "PerspectiveCamera" === this._cameraType
              ? this.perspCamera.near
              : this.orthoCamera.near;
          }
          set near(_) {
            "PerspectiveCamera" === this._cameraType
              ? (this.perspCamera.near = _)
              : (this.orthoCamera.near = _);
          }
          get zoom() {
            return "PerspectiveCamera" === this._cameraType
              ? this.perspCamera.zoom
              : this.orthoCamera.zoom;
          }
          set zoom(_) {
            _ >= 0 &&
              ("PerspectiveCamera" === this._cameraType
                ? (this.perspCamera.zoom = _)
                : (this.orthoCamera.zoom = _));
          }
          lookAt(_, I, R) {
            "number" == typeof _ && (_ = new rF(_, I, R)),
              super.lookAt(_),
              this.getWorldPosition(AW),
              (this.targetOffset = AW.distanceTo(_));
          }
          getTarget(_ = new rF()) {
            return (
              this.getWorldDirection(Aq),
              this.getWorldPosition(AW),
              Aq.multiplyScalar(this.targetOffset),
              _.copy(AW).add(Aq),
              _
            );
          }
          getDistanceToTarget() {
            let _ = this.getTarget();
            return this.getWorldPosition(AW), AW.distanceTo(_);
          }
          updateUp() {
            this.getWorldQuaternion(AY),
              AX.set(0, 0, 1).applyQuaternion(AY),
              AQ.copy(sL.DEFAULT_UP),
              this.isUpVectorFlipped && AQ.negate(),
              AQ.applyQuaternion(AY),
              AZ.copy(sL.DEFAULT_UP).projectOnPlane(AX),
              (this.angleOffsetFromUp = AZ.angleTo(AQ)),
              (this.angleOffsetFromUp *= AZ.cross(AQ).dot(AX) >= 0 ? 1 : -1);
          }
          updateTransformState(_, I) {
            let R = super.updateTransformState(_, I);
            return (
              void 0 !== _.isUpVectorFlipped &&
                (this.isUpVectorFlipped = _.isUpVectorFlipped),
              this.updateUp(),
              R
            );
          }
          getViewFrontToObject(_) {
            let I = _.getWorldPosition(new rF()),
              R = _.getWorldDirection(new rF()).multiplyScalar(
                this.targetOffset
              );
            return { position: I.clone().add(R), target: I };
          }
          getViewToTarget(_) {
            let I = this.getWorldDirection(new rF()).multiplyScalar(
              this.targetOffset
            );
            return { position: _.clone().sub(I), target: _ };
          }
          getViewToObject(_) {
            let I = new rF();
            return _.getWorldPosition(I), this.getViewToTarget(I);
          }
          setViewplaneSize(_, I, R = !1) {
            if (((this.aspect = _ / I), R)) {
              let R = _ > I ? this.aspect : 1,
                B = _ > I ? 1 : this.aspect;
              (this.left = -395 * R),
                (this.right = 395 * R),
                (this.top = 395 * (1 / B)),
                (this.bottom = -395 * (1 / B));
            } else
              (this.left = -(0.5 * _)),
                (this.right = 0.5 * _),
                (this.top = 0.5 * I),
                (this.bottom = -(0.5 * I));
            this.updateProjectionMatrix();
          }
          copyViewPlaneSize(_) {
            (this.aspect = _.aspect),
              (this.left = _.left),
              (this.right = _.right),
              (this.top = _.top),
              (this.bottom = _.bottom),
              this.updateProjectionMatrix();
          }
          toOrthographic() {
            (this.orthoCamera.left = this.left),
              (this.orthoCamera.right = this.right),
              (this.orthoCamera.top = this.top),
              (this.orthoCamera.bottom = this.bottom),
              (this.orthoCamera.view = this.view),
              (this.orthoCamera.far = this.far),
              this.orthoCamera.updateProjectionMatrix(),
              (this.projectionMatrix = this.orthoCamera.projectionMatrix),
              (this.projectionMatrixInverse =
                this.orthoCamera.projectionMatrixInverse),
              (this._cameraType = "OrthographicCamera"),
              this.objectHelper && this.objectHelper.update();
          }
          toPerspective() {
            (this.perspCamera.aspect = this.aspect),
              (this.perspCamera.fov = this.fov),
              (this.perspCamera.view = this.view),
              (this.perspCamera.far = this.far),
              this.perspCamera.updateProjectionMatrix(),
              (this.projectionMatrix = this.perspCamera.projectionMatrix),
              (this.projectionMatrixInverse =
                this.perspCamera.projectionMatrixInverse),
              (this._cameraType = "PerspectiveCamera"),
              this.objectHelper && this.objectHelper.update();
          }
          setFocalLength(_) {
            this.perspCamera.setFocalLength(_), this.toPerspective();
          }
          getFocalLength() {
            return this.perspCamera.getFocalLength();
          }
          getEffectiveFOV() {
            return this.perspCamera.getEffectiveFOV();
          }
          getFilmWidth() {
            return this.perspCamera.getFilmWidth();
          }
          getFilmHeight() {
            return this.perspCamera.getFilmHeight();
          }
          setViewOffset(_, I, R, B, z, k) {
            "PerspectiveCamera" === this._cameraType
              ? this.perspCamera.setViewOffset(_, I, R, B, z, k)
              : this.orthoCamera.setViewOffset(_, I, R, B, z, k);
          }
          clearViewOffset() {
            "PerspectiveCamera" === this._cameraType
              ? (this.perspCamera.clearViewOffset(), this.toPerspective())
              : (this.orthoCamera.clearViewOffset(), this.toOrthographic());
          }
          copyHistory() {
            this.previousProjectionMatrix &&
              this.previousProjectionMatrix.copy(this.projectionMatrix);
          }
          updateProjectionMatrix() {
            "PerspectiveCamera" === this._cameraType
              ? this.toPerspective()
              : "OrthographicCamera" === this._cameraType &&
                this.toOrthographic();
          }
          updateMatrixWorld(_) {
            super.updateMatrixWorld(_),
              this.matrixWorldInverse.copy(this.matrixWorld).invert();
          }
          updateWorldMatrix(_, I) {
            super.updateWorldMatrix(_, I),
              this.matrixWorldInverse.copy(this.matrixWorld).invert();
          }
          copy(_, I) {
            return (
              super.copy(_, I),
              (this.parent = _.parent),
              this.orthoCamera.copy(_.orthoCamera),
              this.perspCamera.copy(_.perspCamera),
              (this.left = _.left),
              (this.right = _.right),
              (this.top = _.top),
              (this.bottom = _.bottom),
              (this.far = _.far),
              (this.view = null === _.view ? null : Object.assign({}, _.view)),
              (this._cameraType = _._cameraType),
              (this.aspect = _.aspect),
              (this.fov = _.fov),
              (this.focus = _.focus),
              (this.filmGauge = _.filmGauge),
              (this.filmOffset = _.filmOffset),
              (this.targetOffset = _.targetOffset),
              this.updateProjectionMatrix(),
              this
            );
          }
          toCameraState(_ = []) {
            return ua(
              {
                type: this.cameraType,
                far: this.far,
                orthographic: {
                  near: this.orthoCamera.near,
                  zoom: this.orthoCamera.zoom,
                },
                perspective: {
                  near: this.perspCamera.near,
                  fov: this.perspCamera.fov,
                  zoom: this.perspCamera.zoom,
                },
                up: this.up.toArray(),
                targetOffset: this.targetOffset,
                isUpVectorFlipped: this.isUpVectorFlipped,
              },
              _
            );
          }
          updateCameraSubtype(_, I) {
            let R =
              "perspective" === _ ? "PerspectiveCamera" : "OrthographicCamera";
            void 0 !== I.zoom && this.setZoom(R, I.zoom),
              void 0 !== I.near && this.setNear(R, I.near),
              void 0 !== I.fov &&
                "PerspectiveCamera" === R &&
                (this.fov = I.fov);
          }
          updateState(_, I) {
            this.updateCameraState(_, I);
          }
          updateCameraState(_, I) {
            this.updateState_Entity(_, I),
              void 0 !== _.far && (this.far = _.far),
              void 0 !== _.orthographic &&
                this.updateCameraSubtype("orthographic", _.orthographic),
              void 0 !== _.perspective &&
                this.updateCameraSubtype("perspective", _.perspective),
              void 0 !== _.type && (this.cameraType = _.type),
              void 0 !== _.up && this.up.fromArray(_.up),
              void 0 !== _.targetOffset && (this.targetOffset = _.targetOffset),
              void 0 !== _.isUpVectorFlipped &&
                (this.isUpVectorFlipped = _.isUpVectorFlipped),
              this.updateProjectionMatrix();
          }
          updateByPatchedOp(_, I, R) {
            super.updateByPatchedOp(_, I, R),
              1 === _.path.length &&
                0 === _.type &&
                this.updateCameraSubtype(_.path[0], _.props);
          }
          toState(_) {
            return {
              ...super.toState(_),
              ...this.toCameraState(_),
              type: this.cameraType,
            };
          }
        },
        AJ = new sa(),
        A$ = new sa();
      function I_(_) {
        let I = !1;
        return (
          _.scene.objects.traverse((_, R) => {
            R.geometry?.type === "BooleanGeometry" && (I = !0);
          }),
          I
        );
      }
      var A1 = class extends SZ {
        constructor(_, I, R) {
          super(_, I),
            (this.data = I),
            (this.meshSetAddresses = []),
            (this.needsTransformForDownstream = !1),
            (this.geometry = new ai()),
            (this.onAfterRender = (_, I, R, B, z, k) => {
              super.onAfterRender(_, I, R, B, z, k), this.recomputeBoolean();
            }),
            (this.geometry.userData.parameters = {
              width: 0,
              height: 0,
              depth: 0,
            });
        }
        get booleanOp() {
          return this.data.geometry.operation;
        }
        get phongAngle() {
          return this.data.geometry.phongAngle ?? 45;
        }
        get isLOD() {
          return this.recomputeBoolean(), !1;
        }
        updateByPatchedOp(_, I, R) {
          super.updateByPatchedOp(_, I, R),
            1 === _.path.length &&
              "geometry" === _.path[0] &&
              0 === _.type &&
              void 0 !== _.props.operation &&
              (this.freeBooleanPointer(), this.resetBBoxNeedsUpdate());
        }
        freeBooleanPointer() {
          super.freeBooleanPointer(), this.geometry.dispose();
        }
        recomputeBoolean(_, I = !0) {
          if (-1 !== this.booleanMeshSetAddress && !_) return;
          for (let R = 0; R < this.children.length; R++) {
            let B = this.children[R];
            B instanceof A1 &&
              !0 === B.dataPatched.visible &&
              B.recomputeBoolean(!0 === _, I);
          }
          this.meshSetAddresses = [];
          for (let R = 0; R < this.children.length; R++) {
            let B = this.children[R];
            if (
              B instanceof wp &&
              !0 === B.dataPatched.visible &&
              B.geometry.attributes.position?.count > 0 &&
              B.geometry.drawRange.count > 0 &&
              0 !== B.booleanMeshSetAddress
            ) {
              AJ.multiplyMatrices(B.hiddenMatrix, B.matrix);
              try {
                if (-1 === B.booleanMeshSetAddress) {
                  if (
                    ((B.geometry.index ?? B.geometry.getAttribute("position"))
                      .count /
                      3 <
                      15e5 &&
                      (B.booleanMeshSetAddress = wa.getMeshSet(
                        B.geometry,
                        !0 === _,
                        I
                      )),
                    -1 === B.booleanMeshSetAddress)
                  )
                    return;
                  wa.transformMeshSet(B.booleanMeshSetAddress, AJ),
                    B.booleanMatrixInvOld.copy(AJ).invert(),
                    (B.booleanWasTransformed = !1);
                } else
                  B instanceof A1 && !0 === B.needsTransformForDownstream
                    ? (wa.transformMeshSet(B.booleanMeshSetAddress, AJ),
                      (B.needsTransformForDownstream = !1))
                    : !0 === B.booleanWasTransformed &&
                      (wa.transformMeshSet(
                        B.booleanMeshSetAddress,
                        A$.multiplyMatrices(AJ, B.booleanMatrixInvOld)
                      ),
                      B.booleanMatrixInvOld.copy(AJ).invert(),
                      (B.booleanWasTransformed = !1));
              } catch (_) {
                console.error(_),
                  (B.booleanMeshSetAddress = 0),
                  (B.geometry.userData.booleanOperationDidFail = !0);
                continue;
              }
              !1 === wa.hasOpenEdges(B.booleanMeshSetAddress) ||
              (R === this.children.length - 1 && 2 === this.booleanOp)
                ? (this.meshSetAddresses.push(B.booleanMeshSetAddress),
                  (B.geometry.userData.booleanOperationDidFail = !1))
                : (B.geometry.userData.booleanOperationDidFail = "openEdges");
            }
          }
          if (0 === this.meshSetAddresses.length) {
            this.geometry.setAttribute("position", new s4([], 0)),
              this.geometry.setDrawRange(0, 0);
            return;
          }
          if (!0 === _)
            return wa.calcBooleanTopological(
              this.meshSetAddresses,
              this.booleanOp
            );
          let R = this.geometry;
          R.dispose(),
            (this.geometry = new ai()),
            (this.geometry.userData = R.userData),
            (this.geometry.boundingSphere = R.boundingSphere);
          try {
            this.booleanMeshSetAddress = wa.calcBoolean(
              this.meshSetAddresses,
              this.booleanOp,
              this.geometry,
              this.phongAngle
            );
          } catch (_) {
            (this.booleanMeshSetAddress = 0),
              (this.geometry.userData.booleanOperationDidFail = !0),
              console.error(_);
          }
          this.booleanMatrixInvOld.copy(this.matrix).invert(),
            (this.needsTransformForDownstream = !0),
            ff(this),
            pf(this);
        }
        dispose() {
          super.dispose(), this.geometry.dispose();
        }
      };
      (CA || (CA = {})).is = function (_) {
        return bG.is(_) && _ instanceof le;
      };
      var bf = (_, I) =>
          class extends Is(_, I) {
            updateState_Light(_, I) {
              this.updateState_Entity(_, I),
                void 0 !== _.color && (this.color = I.shared.color(_.color)),
                void 0 !== _.intensity && (this.intensity = _.intensity),
                void 0 !== _.depth &&
                  ((this.shadow.camera.far = _.depth),
                  (this.shadow.needsUpdate = !0)),
                void 0 !== _.shadows && (this.castShadow = _.shadows);
            }
          },
        mn = (_) => _ instanceof wp,
        Rn = (_) => null !== _ && _ instanceof A1,
        YR = (_) => _ instanceof AK,
        XR = (_) => CA.is(_),
        Wm = (_) => CS.is(_),
        A2 = class extends Qo(l6) {
          constructor(_, I = 15) {
            super(I),
              (this.object = _),
              this.object.updateMatrixWorld(),
              (this.name = `EmptyObjectHelper: ${_.uuid}`),
              (this.matrix = _.matrixWorld),
              (this.matrixAutoUpdate = !1),
              this.object.isBone && (this.visible = !1);
          }
          raycast(_, I) {
            Ko(this.object, A2.geometryHelper, _, I);
          }
          update() {}
        },
        A3 = class extends Is(nT, A2) {
          constructor(_, I) {
            super(), this.super_Entity(_, I), this.objectHelper.update();
          }
          updateState(_, I) {
            this.updateState_Entity(_, I),
              "buffer" in _ &&
                1 === Object.keys(_).length &&
                I.scene.reloadSplats();
          }
        },
        A4 = class extends Is(nT, A2) {
          constructor(_, I, R) {
            super(),
              this.super_Entity(_, I),
              (this.context = R),
              this.objectHelper.update();
          }
          updateState(_, I) {
            this.updateState_Entity(_, I);
          }
        },
        A5 =
          "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",
        A6 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;
#if PASS == 1
uniform vec4 kernel64[32];
#else
uniform vec4 kernel16[8];
#endif
varying vec2 vUv;void main(){
#ifdef FOREGROUND
vec2 CoCNearFar=texture2D(cocBuffer,vUv).rg;float CoC=CoCNearFar.r*scale;
#else
float CoC=texture2D(cocBuffer,vUv).g*scale;
#endif
if(CoC==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{
#ifdef FOREGROUND
vec2 step=texelSize*max(CoC,CoCNearFar.g*scale);
#else
vec2 step=texelSize*CoC;
#endif
#if PASS == 1
vec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;
#else
vec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;
#endif
}}`,
        A8 = class extends aT {
          constructor(_ = !1, I = !1) {
            super({
              name: "BokehMaterial",
              defines: { PASS: _ ? "2" : "1" },
              uniforms: {
                kernel64: new lk(null),
                kernel16: new lk(null),
                inputBuffer: new lk(null),
                cocBuffer: new lk(null),
                texelSize: new lk(new rs()),
                scale: new lk(1),
              },
              blending: 0,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader: A6,
              vertexShader: A5,
            }),
              (this.toneMapped = !1),
              I && (this.defines.FOREGROUND = "1"),
              this.generateKernel();
          }
          set inputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          setInputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          set cocBuffer(_) {
            this.uniforms.cocBuffer.value = _;
          }
          setCoCBuffer(_) {
            this.uniforms.cocBuffer.value = _;
          }
          get scale() {
            return this.uniforms.scale.value;
          }
          set scale(_) {
            this.uniforms.scale.value = _;
          }
          getScale(_) {
            return (this.uniforms.scale.value = _);
          }
          setScale(_) {
            this.uniforms.scale.value = _;
          }
          generateKernel() {
            let _ = new Float32Array(128),
              I = new Float32Array(32),
              R = 0,
              B = 0;
            for (let z = 0; z < 80; ++z) {
              let k = 2.39996323 * z,
                V = Math.sqrt(z) / Math.sqrt(80),
                j = V * Math.cos(k),
                G = V * Math.sin(k);
              z % 5 == 0
                ? ((I[B++] = j), (I[B++] = G))
                : ((_[R++] = j), (_[R++] = G));
            }
            let z = [],
              k = [];
            for (let I = 0; I < 128; )
              z.push(new rM(_[I++], _[I++], _[I++], _[I++]));
            for (let _ = 0; _ < 32; )
              k.push(new rM(I[_++], I[_++], I[_++], I[_++]));
            (this.uniforms.kernel64.value = z),
              (this.uniforms.kernel16.value = k);
          }
          setTexelSize(_, I) {
            this.uniforms.texelSize.value.set(_, I);
          }
          setSize(_, I) {
            this.uniforms.texelSize.value.set(1 / _, 1 / I);
          }
        };
      function F_(_, I, R) {
        return Math.min(Math.max((_ + I) / (I - R), 0), 1);
      }
      var A9 = `#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}void main(){float depth=readDepth(vUv);
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);
#else
float linearDepth=depth;
#endif
float signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}`,
        A7 = class extends aT {
          constructor(_) {
            super({
              name: "CircleOfConfusionMaterial",
              defines: { DEPTH_PACKING: "0" },
              uniforms: {
                depthBuffer: new lk(null),
                focusDistance: new lk(0),
                focusRange: new lk(0),
                cameraNear: new lk(0.3),
                cameraFar: new lk(1e3),
              },
              blending: 0,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader: A9,
              vertexShader: A5,
            }),
              (this.toneMapped = !1),
              (this.uniforms.focalLength = this.uniforms.focusRange),
              this.adoptCameraSettings(_);
          }
          get near() {
            return this.uniforms.cameraNear.value;
          }
          get far() {
            return this.uniforms.cameraFar.value;
          }
          set depthBuffer(_) {
            this.uniforms.depthBuffer.value = _;
          }
          set depthPacking(_) {
            (this.defines.DEPTH_PACKING = _.toFixed(0)),
              (this.needsUpdate = !0);
          }
          setDepthBuffer(_, I = 3200) {
            (this.depthBuffer = _), (this.depthPacking = I);
          }
          get focusDistance() {
            return this.uniforms.focusDistance.value;
          }
          set focusDistance(_) {
            this.uniforms.focusDistance.value = _;
          }
          get worldFocusDistance() {
            var _;
            return -(this.focusDistance * ((_ = this.near) - this.far) - _);
          }
          set worldFocusDistance(_) {
            this.focusDistance = F_(-_, this.near, this.far);
          }
          getFocusDistance(_) {
            this.uniforms.focusDistance.value = _;
          }
          setFocusDistance(_) {
            this.uniforms.focusDistance.value = _;
          }
          get focalLength() {
            return this.focusRange;
          }
          set focalLength(_) {
            this.focusRange = _;
          }
          get focusRange() {
            return this.uniforms.focusRange.value;
          }
          set focusRange(_) {
            this.uniforms.focusRange.value = _;
          }
          get worldFocusRange() {
            var _;
            return -(this.focusRange * ((_ = this.near) - this.far) - _);
          }
          set worldFocusRange(_) {
            this.focusRange = F_(-_, this.near, this.far);
          }
          getFocalLength(_) {
            return this.focusRange;
          }
          setFocalLength(_) {
            this.focusRange = _;
          }
          adoptCameraSettings(_) {
            _ &&
              ((this.uniforms.cameraNear.value = _.near),
              (this.uniforms.cameraFar.value = _.far),
              _ instanceof aI
                ? (this.defines.PERSPECTIVE_CAMERA = "1")
                : delete this.defines.PERSPECTIVE_CAMERA,
              (this.needsUpdate = !0));
          }
        },
        Me = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <encodings_fragment>
#include <dithering_fragment>
}`,
        Mt = class extends aT {
          constructor(_ = new rs()) {
            super({
              name: "KawaseBlurMaterial",
              uniforms: {
                inputBuffer: new lk(null),
                texelSize: new lk(new rs()),
                halfTexelSize: new lk(new rs()),
                kernel: new lk(0),
                scale: new lk(1),
              },
              blending: 0,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader: Me,
              vertexShader:
                "uniform vec2 texelSize;uniform vec2 halfTexelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize*vec2(kernel)+halfTexelSize)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}",
            }),
              (this.toneMapped = !1),
              this.setTexelSize(_.x, _.y);
          }
          set inputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          setInputBuffer(_) {
            this.inputBuffer = _;
          }
          get scale() {
            return this.uniforms.scale.value;
          }
          set scale(_) {
            this.uniforms.scale.value = _;
          }
          getScale() {
            return this.uniforms.scale.value;
          }
          setScale(_) {
            this.uniforms.scale.value = _;
          }
          getKernel() {
            return null;
          }
          get kernel() {
            return this.uniforms.kernel.value;
          }
          set kernel(_) {
            this.uniforms.kernel.value = _;
          }
          setKernel(_) {
            this.kernel = _;
          }
          setTexelSize(_, I) {
            this.uniforms.texelSize.value.set(_, I),
              this.uniforms.halfTexelSize.value.set(_, I).multiplyScalar(0.5);
          }
          setSize(_, I) {
            let R = this.uniforms;
            R.texelSize.value.set(1 / _, 1 / I),
              R.halfTexelSize.value.copy(R.texelSize.value).multiplyScalar(0.5);
          }
        },
        Ms = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <encodings_fragment>
}`,
        Ma = class extends aT {
          constructor() {
            super({
              name: "CopyMaterial",
              uniforms: { inputBuffer: new lk(null), opacity: new lk(1) },
              blending: 0,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader: Ms,
              vertexShader: A5,
            }),
              (this.toneMapped = !1);
          }
          set inputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          setInputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          getOpacity(_) {
            return this.uniforms.opacity.value;
          }
          setOpacity(_) {
            this.uniforms.opacity.value = _;
          }
        },
        Mn = `varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
#if EDGE_DETECTION_MODE == 1
#include <common>
#endif
#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}
#elif PREDICATION_MODE == 2
uniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}
#endif
#if PREDICATION_MODE != 0
vec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}
#endif
#if EDGE_DETECTION_MODE != 0
uniform sampler2D inputBuffer;
#endif
void main(){
#if EDGE_DETECTION_MODE == 0
const vec2 threshold=vec2(DEPTH_THRESHOLD);
#elif PREDICATION_MODE != 0
vec2 threshold=calculatePredicatedThreshold();
#else
const vec2 threshold=vec2(EDGE_THRESHOLD);
#endif
#if EDGE_DETECTION_MODE == 0
vec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 1
float l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 2
vec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#endif
}`,
        Ml = `uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);
#if EDGE_DETECTION_MODE != 0
vUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);
#endif
gl_Position=vec4(position.xy,1.0,1.0);}`,
        Mc = { COLOR: 2 },
        Md = class extends aT {
          constructor(_ = new rs(), I = Mc.COLOR) {
            super({
              name: "EdgeDetectionMaterial",
              defines: {
                THREE_REVISION: "149".replace(/\D+/g, ""),
                LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
                EDGE_THRESHOLD: "0.1",
                DEPTH_THRESHOLD: "0.01",
                PREDICATION_MODE: "0",
                PREDICATION_THRESHOLD: "0.01",
                PREDICATION_SCALE: "2.0",
                PREDICATION_STRENGTH: "1.0",
                DEPTH_PACKING: "0",
              },
              uniforms: {
                inputBuffer: new lk(null),
                depthBuffer: new lk(null),
                predicationBuffer: new lk(null),
                texelSize: new lk(_),
              },
              blending: 0,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader: Mn,
              vertexShader: Ml,
            }),
              (this.toneMapped = !1),
              (this.edgeDetectionMode = I);
          }
          set depthBuffer(_) {
            this.uniforms.depthBuffer.value = _;
          }
          set depthPacking(_) {
            (this.defines.DEPTH_PACKING = _.toFixed(0)),
              (this.needsUpdate = !0);
          }
          setDepthBuffer(_, I = 3200) {
            (this.depthBuffer = _), (this.depthPacking = I);
          }
          get edgeDetectionMode() {
            return Number(this.defines.EDGE_DETECTION_MODE);
          }
          set edgeDetectionMode(_) {
            (this.defines.EDGE_DETECTION_MODE = _.toFixed(0)),
              (this.needsUpdate = !0);
          }
          getEdgeDetectionMode() {
            return this.edgeDetectionMode;
          }
          setEdgeDetectionMode(_) {
            this.edgeDetectionMode = _;
          }
          get localContrastAdaptationFactor() {
            return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR);
          }
          set localContrastAdaptationFactor(_) {
            (this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = _.toFixed("6")),
              (this.needsUpdate = !0);
          }
          getLocalContrastAdaptationFactor() {
            return this.localContrastAdaptationFactor;
          }
          setLocalContrastAdaptationFactor(_) {
            this.localContrastAdaptationFactor = _;
          }
          get edgeDetectionThreshold() {
            return Number(this.defines.EDGE_THRESHOLD);
          }
          set edgeDetectionThreshold(_) {
            (this.defines.EDGE_THRESHOLD = _.toFixed("6")),
              (this.defines.DEPTH_THRESHOLD = (0.1 * _).toFixed("6")),
              (this.needsUpdate = !0);
          }
          getEdgeDetectionThreshold() {
            return this.edgeDetectionThreshold;
          }
          setEdgeDetectionThreshold(_) {
            this.edgeDetectionThreshold = _;
          }
          get predicationMode() {
            return Number(this.defines.PREDICATION_MODE);
          }
          set predicationMode(_) {
            (this.defines.PREDICATION_MODE = _.toFixed(0)),
              (this.needsUpdate = !0);
          }
          getPredicationMode() {
            return this.predicationMode;
          }
          setPredicationMode(_) {
            this.predicationMode = _;
          }
          set predicationBuffer(_) {
            this.uniforms.predicationBuffer.value = _;
          }
          setPredicationBuffer(_) {
            this.uniforms.predicationBuffer.value = _;
          }
          get predicationThreshold() {
            return Number(this.defines.PREDICATION_THRESHOLD);
          }
          set predicationThreshold(_) {
            (this.defines.PREDICATION_THRESHOLD = _.toFixed("6")),
              (this.needsUpdate = !0);
          }
          getPredicationThreshold() {
            return this.predicationThreshold;
          }
          setPredicationThreshold(_) {
            this.predicationThreshold = _;
          }
          get predicationScale() {
            return Number(this.defines.PREDICATION_SCALE);
          }
          set predicationScale(_) {
            (this.defines.PREDICATION_SCALE = _.toFixed("6")),
              (this.needsUpdate = !0);
          }
          getPredicationScale() {
            return this.predicationScale;
          }
          setPredicationScale(_) {
            this.predicationScale = _;
          }
          get predicationStrength() {
            return Number(this.defines.PREDICATION_STRENGTH);
          }
          set predicationStrength(_) {
            (this.defines.PREDICATION_STRENGTH = _.toFixed("6")),
              (this.needsUpdate = !0);
          }
          getPredicationStrength() {
            return this.predicationStrength;
          }
          setPredicationStrength(_) {
            this.predicationStrength = _;
          }
          setSize(_, I) {
            this.uniforms.texelSize.value.set(1 / _, 1 / I);
          }
        },
        Mu = `#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if THREE_REVISION >= 137
vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <encodings_fragment>
#endif
#include <dithering_fragment>
}`,
        Mp = {
          FRAGMENT_HEAD: "FRAGMENT_HEAD",
          FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
          FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
          VERTEX_HEAD: "VERTEX_HEAD",
          VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT",
        },
        Mf = class extends aT {
          constructor(_, I, R, B, z = !1) {
            super({
              name: "EffectMaterial",
              defines: {
                THREE_REVISION: "149".replace(/\D+/g, ""),
                DEPTH_PACKING: "0",
                ENCODE_OUTPUT: "1",
              },
              uniforms: {
                inputBuffer: new lk(null),
                depthBuffer: new lk(null),
                resolution: new lk(new rs()),
                texelSize: new lk(new rs()),
                cameraNear: new lk(0.3),
                cameraFar: new lk(1e3),
                aspect: new lk(1),
                time: new lk(0),
              },
              blending: 0,
              depthWrite: !1,
              depthTest: !1,
              dithering: z,
            }),
              (this.toneMapped = !1),
              _ && this.setShaderParts(_),
              I && this.setDefines(I),
              R && this.setUniforms(R),
              this.adoptCameraSettings(B);
          }
          set inputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          setInputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          get depthBuffer() {
            return this.uniforms.depthBuffer.value;
          }
          set depthBuffer(_) {
            this.uniforms.depthBuffer.value = _;
          }
          get depthPacking() {
            return Number(this.defines.DEPTH_PACKING);
          }
          set depthPacking(_) {
            (this.defines.DEPTH_PACKING = _.toFixed(0)),
              (this.needsUpdate = !0);
          }
          setDepthBuffer(_, I = 3200) {
            (this.depthBuffer = _), (this.depthPacking = I);
          }
          setShaderParts(_) {
            return (
              (this.fragmentShader = Mu.replace(
                Mp.FRAGMENT_HEAD,
                _.get(Mp.FRAGMENT_HEAD)
              )
                .replace(Mp.FRAGMENT_MAIN_UV, _.get(Mp.FRAGMENT_MAIN_UV))
                .replace(
                  Mp.FRAGMENT_MAIN_IMAGE,
                  _.get(Mp.FRAGMENT_MAIN_IMAGE)
                )),
              (this.vertexShader =
                "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}"
                  .replace(Mp.VERTEX_HEAD, _.get(Mp.VERTEX_HEAD))
                  .replace(
                    Mp.VERTEX_MAIN_SUPPORT,
                    _.get(Mp.VERTEX_MAIN_SUPPORT)
                  )),
              (this.needsUpdate = !0),
              this
            );
          }
          setDefines(_) {
            for (let I of _.entries()) this.defines[I[0]] = I[1];
            return (this.needsUpdate = !0), this;
          }
          setUniforms(_) {
            for (let I of _.entries()) this.uniforms[I[0]] = I[1];
            return this;
          }
          setExtensions(_) {
            for (let I of ((this.extensions = {}), _)) this.extensions[I] = !0;
            return this;
          }
          get encodeOutput() {
            return void 0 !== this.defines.ENCODE_OUTPUT;
          }
          set encodeOutput(_) {
            this.encodeOutput !== _ &&
              (_
                ? (this.defines.ENCODE_OUTPUT = "1")
                : delete this.defines.ENCODE_OUTPUT,
              (this.needsUpdate = !0));
          }
          isOutputEncodingEnabled(_) {
            return this.encodeOutput;
          }
          setOutputEncodingEnabled(_) {
            this.encodeOutput = _;
          }
          get time() {
            return this.uniforms.time.value;
          }
          set time(_) {
            this.uniforms.time.value = _;
          }
          setDeltaTime(_) {
            this.uniforms.time.value += _;
          }
          adoptCameraSettings(_) {
            _ &&
              ((this.uniforms.cameraNear.value = _.near),
              (this.uniforms.cameraFar.value = _.far),
              _ instanceof aI
                ? (this.defines.PERSPECTIVE_CAMERA = "1")
                : delete this.defines.PERSPECTIVE_CAMERA,
              (this.needsUpdate = !0));
          }
          setSize(_, I) {
            let R = this.uniforms;
            R.resolution.value.set(_, I),
              R.texelSize.value.set(1 / _, 1 / I),
              (R.aspect.value = _ / I);
          }
          static get Section() {
            return Mp;
          }
        },
        Mg = `#include <common>
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);l*=low*high;
#elif defined(THRESHOLD)
l=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=vec4(texel.rgb*l,l);
#else
gl_FragColor=vec4(l);
#endif
}`,
        My = class extends aT {
          constructor(_ = !1, I = null) {
            super({
              name: "LuminanceMaterial",
              defines: { THREE_REVISION: "149".replace(/\D+/g, "") },
              uniforms: {
                inputBuffer: new lk(null),
                threshold: new lk(0),
                smoothing: new lk(1),
                range: new lk(null),
              },
              blending: 0,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader: Mg,
              vertexShader: A5,
            }),
              (this.toneMapped = !1),
              (this.colorOutput = _),
              (this.luminanceRange = I);
          }
          set inputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          setInputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          get threshold() {
            return this.uniforms.threshold.value;
          }
          set threshold(_) {
            this.smoothing > 0 || _ > 0
              ? (this.defines.THRESHOLD = "1")
              : delete this.defines.THRESHOLD,
              (this.uniforms.threshold.value = _);
          }
          getThreshold() {
            return this.threshold;
          }
          setThreshold(_) {
            this.threshold = _;
          }
          get smoothing() {
            return this.uniforms.smoothing.value;
          }
          set smoothing(_) {
            this.threshold > 0 || _ > 0
              ? (this.defines.THRESHOLD = "1")
              : delete this.defines.THRESHOLD,
              (this.uniforms.smoothing.value = _);
          }
          getSmoothingFactor() {
            return this.smoothing;
          }
          setSmoothingFactor(_) {
            this.smoothing = _;
          }
          get useThreshold() {
            return this.threshold > 0 || this.smoothing > 0;
          }
          set useThreshold(_) {}
          get colorOutput() {
            return void 0 !== this.defines.COLOR;
          }
          set colorOutput(_) {
            _ ? (this.defines.COLOR = "1") : delete this.defines.COLOR,
              (this.needsUpdate = !0);
          }
          isColorOutputEnabled(_) {
            return this.colorOutput;
          }
          setColorOutputEnabled(_) {
            this.colorOutput = _;
          }
          get useRange() {
            return null !== this.luminanceRange;
          }
          set useRange(_) {
            this.luminanceRange = null;
          }
          get luminanceRange() {
            return this.uniforms.range.value;
          }
          set luminanceRange(_) {
            null !== _ ? (this.defines.RANGE = "1") : delete this.defines.RANGE,
              (this.uniforms.range.value = _),
              (this.needsUpdate = !0);
          }
          getLuminanceRange() {
            return this.luminanceRange;
          }
          setLuminanceRange(_) {
            this.luminanceRange = _;
          }
        },
        Mx = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef MASK_PRECISION_HIGH
uniform mediump sampler2D maskTexture;
#else
uniform lowp sampler2D maskTexture;
#endif
#if MASK_FUNCTION != 0
uniform float strength;
#endif
varying vec2 vUv;void main(){
#if COLOR_CHANNEL == 0
float mask=texture2D(maskTexture,vUv).r;
#elif COLOR_CHANNEL == 1
float mask=texture2D(maskTexture,vUv).g;
#elif COLOR_CHANNEL == 2
float mask=texture2D(maskTexture,vUv).b;
#else
float mask=texture2D(maskTexture,vUv).a;
#endif
#if MASK_FUNCTION == 0
#ifdef INVERTED
mask=step(mask,0.0);
#else
mask=1.0-step(mask,0.0);
#endif
#else
mask=clamp(mask*strength,0.0,1.0);
#ifdef INVERTED
mask=1.0-mask;
#endif
#endif
#if MASK_FUNCTION == 2
gl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);
#else
gl_FragColor=mask*texture2D(inputBuffer,vUv);
#endif
}`,
        Mb = class extends aT {
          constructor(_ = null) {
            super({
              name: "MaskMaterial",
              uniforms: {
                maskTexture: new lk(_),
                inputBuffer: new lk(null),
                strength: new lk(1),
              },
              blending: 0,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader: Mx,
              vertexShader: A5,
            }),
              (this.toneMapped = !1),
              this.setColorChannel(0),
              this.setMaskFunction(0);
          }
          set inputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          setInputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          set maskTexture(_) {
            (this.uniforms.maskTexture.value = _),
              delete this.defines.MASK_PRECISION_HIGH,
              1009 !== _.type && (this.defines.MASK_PRECISION_HIGH = "1"),
              (this.needsUpdate = !0);
          }
          setMaskTexture(_) {
            this.maskTexture = _;
          }
          set colorChannel(_) {
            (this.defines.COLOR_CHANNEL = _.toFixed(0)),
              (this.needsUpdate = !0);
          }
          setColorChannel(_) {
            this.colorChannel = _;
          }
          set maskFunction(_) {
            (this.defines.MASK_FUNCTION = _.toFixed(0)),
              (this.needsUpdate = !0);
          }
          setMaskFunction(_) {
            this.maskFunction = _;
          }
          get inverted() {
            return void 0 !== this.defines.INVERTED;
          }
          set inverted(_) {
            this.inverted && !_
              ? delete this.defines.INVERTED
              : _ && (this.defines.INVERTED = "1"),
              (this.needsUpdate = !0);
          }
          isInverted() {
            return this.inverted;
          }
          setInverted(_) {
            this.inverted = _;
          }
          get strength() {
            return this.uniforms.strength.value;
          }
          set strength(_) {
            this.uniforms.strength.value = _;
          }
          getStrength() {
            return this.strength;
          }
          setStrength(_) {
            this.strength = _;
          }
        },
        Mw = `#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)
#if __VERSION__ < 300
#define round(v) floor(v + 0.5)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);
#endif
}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);
#endif
}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){
#if !defined(DISABLE_DIAG_DETECTION)
weights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){
#endif
vec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);
#if !defined(DISABLE_DIAG_DETECTION)
}else{e.r=0.0;}
#endif
}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}`,
        M_ = class extends aT {
          constructor(_ = new rs(), I = new rs()) {
            super({
              name: "SMAAWeightsMaterial",
              defines: {
                MAX_SEARCH_STEPS_INT: "16",
                MAX_SEARCH_STEPS_FLOAT: "16.0",
                MAX_SEARCH_STEPS_DIAG_INT: "8",
                MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
                CORNER_ROUNDING: "25",
                CORNER_ROUNDING_NORM: "0.25",
                AREATEX_MAX_DISTANCE: "16.0",
                AREATEX_MAX_DISTANCE_DIAG: "20.0",
                AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
                AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
                SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
                SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)",
              },
              uniforms: {
                inputBuffer: new lk(null),
                searchTexture: new lk(null),
                areaTexture: new lk(null),
                resolution: new lk(I),
                texelSize: new lk(_),
              },
              blending: 0,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader: Mw,
              vertexShader:
                "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}",
            }),
              (this.toneMapped = !1);
          }
          set inputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          setInputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          get searchTexture() {
            return this.uniforms.searchTexture.value;
          }
          set searchTexture(_) {
            this.uniforms.searchTexture.value = _;
          }
          get areaTexture() {
            return this.uniforms.areaTexture.value;
          }
          set areaTexture(_) {
            this.uniforms.areaTexture.value = _;
          }
          setLookupTextures(_, I) {
            (this.searchTexture = _), (this.areaTexture = I);
          }
          get orthogonalSearchSteps() {
            return Number(this.defines.MAX_SEARCH_STEPS_INT);
          }
          set orthogonalSearchSteps(_) {
            let I = Math.min(Math.max(_, 0), 112);
            (this.defines.MAX_SEARCH_STEPS_INT = I.toFixed("0")),
              (this.defines.MAX_SEARCH_STEPS_FLOAT = I.toFixed("1")),
              (this.needsUpdate = !0);
          }
          setOrthogonalSearchSteps(_) {
            this.orthogonalSearchSteps = _;
          }
          get diagonalSearchSteps() {
            return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT);
          }
          set diagonalSearchSteps(_) {
            let I = Math.min(Math.max(_, 0), 20);
            (this.defines.MAX_SEARCH_STEPS_DIAG_INT = I.toFixed("0")),
              (this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = I.toFixed("1")),
              (this.needsUpdate = !0);
          }
          setDiagonalSearchSteps(_) {
            this.diagonalSearchSteps = _;
          }
          get diagonalDetection() {
            return void 0 === this.defines.DISABLE_DIAG_DETECTION;
          }
          set diagonalDetection(_) {
            _
              ? delete this.defines.DISABLE_DIAG_DETECTION
              : (this.defines.DISABLE_DIAG_DETECTION = "1"),
              (this.needsUpdate = !0);
          }
          isDiagonalDetectionEnabled() {
            return this.diagonalDetection;
          }
          setDiagonalDetectionEnabled(_) {
            this.diagonalDetection = _;
          }
          get cornerRounding() {
            return Number(this.defines.CORNER_ROUNDING);
          }
          set cornerRounding(_) {
            let I = Math.min(Math.max(_, 0), 100);
            (this.defines.CORNER_ROUNDING = I.toFixed("4")),
              (this.defines.CORNER_ROUNDING_NORM = (I / 100).toFixed("4")),
              (this.needsUpdate = !0);
          }
          setCornerRounding(_) {
            this.cornerRounding = _;
          }
          get cornerDetection() {
            return void 0 === this.defines.DISABLE_CORNER_DETECTION;
          }
          set cornerDetection(_) {
            _
              ? delete this.defines.DISABLE_CORNER_DETECTION
              : (this.defines.DISABLE_CORNER_DETECTION = "1"),
              (this.needsUpdate = !0);
          }
          isCornerRoundingEnabled() {
            return this.cornerDetection;
          }
          setCornerRoundingEnabled(_) {
            this.cornerDetection = _;
          }
          setSize(_, I) {
            let R = this.uniforms;
            R.texelSize.value.set(1 / _, 1 / I), R.resolution.value.set(_, I);
          }
        },
        MS = new aP(),
        MA = null,
        MC = class {
          constructor(_ = "Pass", I = new nz(), R = MS) {
            (this.name = _),
              (this.renderer = null),
              (this.scene = I),
              (this.camera = R),
              (this.screen = null),
              (this.rtt = !0),
              (this.needsSwap = !0),
              (this.needsDepthTexture = !1),
              (this.enabled = !0);
          }
          get renderToScreen() {
            return !this.rtt;
          }
          set renderToScreen(_) {
            if (this.rtt === _) {
              let I = this.getFullscreenMaterial();
              null !== I && (I.needsUpdate = !0), (this.rtt = !_);
            }
          }
          setRenderer(_) {
            this.renderer = _;
          }
          isEnabled() {
            return this.enabled;
          }
          setEnabled(_) {
            this.enabled = _;
          }
          get fullscreenMaterial() {
            return null !== this.screen ? this.screen.material : null;
          }
          set fullscreenMaterial(_) {
            let I = this.screen;
            null !== I
              ? (I.material = _)
              : (((I = new aw(
                  (function () {
                    if (null === MA) {
                      let _ = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
                        I = new Float32Array([0, 0, 2, 0, 0, 2]);
                      void 0 !== (MA = new ai()).setAttribute
                        ? (MA.setAttribute("position", new s0(_, 3)),
                          MA.setAttribute("uv", new s0(I, 2)))
                        : (MA.addAttribute("position", new s0(_, 3)),
                          MA.addAttribute("uv", new s0(I, 2)));
                    }
                    return MA;
                  })(),
                  _
                )).frustumCulled = !1),
                null === this.scene && (this.scene = new nz()),
                this.scene.add(I),
                (this.screen = I));
          }
          getFullscreenMaterial() {
            return this.fullscreenMaterial;
          }
          setFullscreenMaterial(_) {
            this.fullscreenMaterial = _;
          }
          getDepthTexture() {
            return null;
          }
          setDepthTexture(_, I = 3200) {}
          render(_, I, R, B, z) {
            throw Error("Render method not implemented!");
          }
          setSize(_, I) {}
          initialize(_, I, R) {}
          dispose() {
            for (let _ of Object.keys(this)) {
              let I = this[_];
              if (null !== I && "function" == typeof I.dispose) {
                if (I instanceof nz || I === this.renderer) continue;
                this[_].dispose();
              }
            }
          }
        },
        MT = class extends MC {
          constructor(_, I = !0) {
            super("CopyPass"),
              (this.fullscreenMaterial = new Ma()),
              (this.needsSwap = !1),
              (this.renderTarget = _),
              void 0 === _ &&
                ((this.renderTarget = new rT(1, 1, {
                  minFilter: 1006,
                  magFilter: 1006,
                  stencilBuffer: !1,
                  depthBuffer: !1,
                })),
                (this.renderTarget.texture.name = "CopyPass.Target")),
              (this.autoResize = I);
          }
          get resize() {
            return this.autoResize;
          }
          set resize(_) {
            this.autoResize = _;
          }
          get texture() {
            return this.renderTarget.texture;
          }
          getTexture() {
            return this.renderTarget.texture;
          }
          setAutoResizeEnabled(_) {
            this.autoResize = _;
          }
          render(_, I, R, B, z) {
            (this.fullscreenMaterial.inputBuffer = I.texture),
              _.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
              _.render(this.scene, this.camera);
          }
          setSize(_, I) {
            this.autoResize && this.renderTarget.setSize(_, I);
          }
          initialize(_, I, R) {
            void 0 !== R &&
              ((this.renderTarget.texture.type = R),
              1009 !== R
                ? (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                    "1")
                : 3001 === _.outputEncoding &&
                  (this.renderTarget.texture.encoding = 3001));
          }
        },
        MP = class extends MC {
          constructor() {
            super("ClearMaskPass", null, null), (this.needsSwap = !1);
          }
          render(_, I, R, B, z) {
            let k = _.state.buffers.stencil;
            k.setLocked(!1), k.setTest(!1);
          }
        },
        MD = new ry(),
        MO = class extends MC {
          constructor(_ = !0, I = !0, R = !1) {
            super("ClearPass", null, null),
              (this.needsSwap = !1),
              (this.color = _),
              (this.depth = I),
              (this.stencil = R),
              (this.overrideClearColor = null),
              (this.overrideClearAlpha = -1);
          }
          setClearFlags(_, I, R) {
            (this.color = _), (this.depth = I), (this.stencil = R);
          }
          getOverrideClearColor() {
            return this.overrideClearColor;
          }
          setOverrideClearColor(_) {
            this.overrideClearColor = _;
          }
          getOverrideClearAlpha() {
            return this.overrideClearAlpha;
          }
          setOverrideClearAlpha(_) {
            this.overrideClearAlpha = _;
          }
          render(_, I, R, B, z) {
            let k = this.overrideClearColor,
              V = this.overrideClearAlpha,
              j = _.getClearAlpha(),
              G = null !== k,
              q = V >= 0;
            G
              ? (MD.copy(_.getClearColor(MD)), _.setClearColor(k, q ? V : j))
              : q && _.setClearAlpha(V),
              _.setRenderTarget(this.renderToScreen ? null : I),
              _.clear(this.color, this.depth, this.stencil),
              G ? _.setClearColor(MD, j) : q && _.setClearAlpha(j);
          }
        },
        MI = class extends i8 {
          constructor(_, I = -1, R = -1, B = 1) {
            super(),
              (this.resizable = _),
              (this.base = new rs(1, 1)),
              (this.preferred = new rs(I, R)),
              (this.target = this.preferred),
              (this.s = B);
          }
          get width() {
            let { base: _, preferred: I, scale: R } = this;
            return -1 !== I.width
              ? I.width
              : -1 !== I.height
              ? Math.round(I.height * (_.width / Math.max(_.height, 1)))
              : Math.round(_.width * R);
          }
          set width(_) {
            this.preferredWidth = _;
          }
          get height() {
            let { base: _, preferred: I, scale: R } = this;
            return -1 !== I.height
              ? I.height
              : -1 !== I.width
              ? Math.round(
                  I.width / Math.max(_.width / Math.max(_.height, 1), 1)
                )
              : Math.round(_.height * R);
          }
          set height(_) {
            this.preferredHeight = _;
          }
          getWidth() {
            return this.width;
          }
          getHeight() {
            return this.height;
          }
          get scale() {
            return this.s;
          }
          set scale(_) {
            this.s !== _ &&
              ((this.s = _),
              this.preferred.setScalar(-1),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(this.base.width, this.base.height));
          }
          getScale() {
            return this.scale;
          }
          setScale(_) {
            this.scale = _;
          }
          get baseWidth() {
            return this.base.width;
          }
          set baseWidth(_) {
            this.base.width !== _ &&
              ((this.base.width = _),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(this.base.width, this.base.height));
          }
          getBaseWidth() {
            return this.base.width;
          }
          setBaseWidth(_) {
            this.base.width !== _ &&
              ((this.base.width = _),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(this.base.width, this.base.height));
          }
          get baseHeight() {
            return this.base.height;
          }
          set baseHeight(_) {
            this.base.height !== _ &&
              ((this.base.height = _),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(this.base.width, this.base.height));
          }
          getBaseHeight() {
            return this.baseHeight;
          }
          setBaseHeight(_) {
            this.baseHeight = _;
          }
          setBaseSize(_, I) {
            (this.base.width !== _ || this.base.height !== I) &&
              (this.base.set(_, I),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(this.base.width, this.base.height));
          }
          get preferredWidth() {
            return this.preferred.width;
          }
          set preferredWidth(_) {
            this.preferred.width !== _ &&
              ((this.preferred.width = _),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(this.base.width, this.base.height));
          }
          getPreferredWidth() {
            return this.preferredWidth;
          }
          setPreferredWidth(_) {
            this.preferredWidth = _;
          }
          get preferredHeight() {
            return this.preferred.height;
          }
          set preferredHeight(_) {
            this.preferred.height !== _ &&
              ((this.preferred.height = _),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(this.base.width, this.base.height));
          }
          getPreferredHeight() {
            return this.preferredHeight;
          }
          setPreferredHeight(_) {
            this.preferredHeight = _;
          }
          setPreferredSize(_, I) {
            (this.preferred.width !== _ || this.preferred.height !== I) &&
              (this.preferred.set(_, I),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(this.base.width, this.base.height));
          }
          copy(_) {
            this.base.set(_.getBaseWidth(), _.getBaseHeight()),
              this.preferred.set(_.getPreferredWidth(), _.getPreferredHeight()),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(this.base.width, this.base.height);
          }
          static get AUTO_SIZE() {
            return -1;
          }
        },
        MR = !1,
        ML = class {
          constructor(_ = null) {
            (this.originalMaterials = new Map()),
              (this.material = null),
              (this.materials = null),
              (this.materialsBackSide = null),
              (this.materialsDoubleSide = null),
              (this.materialsFlatShaded = null),
              (this.materialsFlatShadedBackSide = null),
              (this.materialsFlatShadedDoubleSide = null),
              this.setMaterial(_),
              (this.meshCount = 0),
              (this.replaceMaterial = (_) => {
                if (_.isMesh) {
                  let I;
                  if (_.material.flatShading)
                    switch (_.material.side) {
                      case 2:
                        I = this.materialsFlatShadedDoubleSide;
                        break;
                      case 1:
                        I = this.materialsFlatShadedBackSide;
                        break;
                      default:
                        I = this.materialsFlatShaded;
                    }
                  else
                    switch (_.material.side) {
                      case 2:
                        I = this.materialsDoubleSide;
                        break;
                      case 1:
                        I = this.materialsBackSide;
                        break;
                      default:
                        I = this.materials;
                    }
                  this.originalMaterials.set(_, _.material),
                    _.isSkinnedMesh
                      ? (_.material = I[2])
                      : _.isInstancedMesh
                      ? (_.material = I[1])
                      : (_.material = I[0]),
                    ++this.meshCount;
                }
              });
          }
          setMaterial(_) {
            if ((this.disposeMaterials(), (this.material = _), null !== _)) {
              let I = (this.materials = [_.clone(), _.clone(), _.clone()]);
              for (let R of I)
                (R.uniforms = Object.assign({}, _.uniforms)), (R.side = 0);
              (I[2].skinning = !0),
                (this.materialsBackSide = I.map((I) => {
                  let R = I.clone();
                  return (
                    (R.uniforms = Object.assign({}, _.uniforms)),
                    (R.side = 1),
                    R
                  );
                })),
                (this.materialsDoubleSide = I.map((I) => {
                  let R = I.clone();
                  return (
                    (R.uniforms = Object.assign({}, _.uniforms)),
                    (R.side = 2),
                    R
                  );
                })),
                (this.materialsFlatShaded = I.map((I) => {
                  let R = I.clone();
                  return (
                    (R.uniforms = Object.assign({}, _.uniforms)),
                    (R.flatShading = !0),
                    R
                  );
                })),
                (this.materialsFlatShadedBackSide = I.map((I) => {
                  let R = I.clone();
                  return (
                    (R.uniforms = Object.assign({}, _.uniforms)),
                    (R.flatShading = !0),
                    (R.side = 1),
                    R
                  );
                })),
                (this.materialsFlatShadedDoubleSide = I.map((I) => {
                  let R = I.clone();
                  return (
                    (R.uniforms = Object.assign({}, _.uniforms)),
                    (R.flatShading = !0),
                    (R.side = 2),
                    R
                  );
                }));
            }
          }
          render(_, I, R) {
            let B = _.shadowMap.enabled;
            if (((_.shadowMap.enabled = !1), MR)) {
              let B = this.originalMaterials;
              for (let z of ((this.meshCount = 0),
              I.traverse(this.replaceMaterial),
              _.render(I, R),
              B))
                z[0].material = z[1];
              this.meshCount !== B.size && B.clear();
            } else {
              let B = I.overrideMaterial;
              (I.overrideMaterial = this.material),
                _.render(I, R),
                (I.overrideMaterial = B);
            }
            _.shadowMap.enabled = B;
          }
          disposeMaterials() {
            if (null !== this.material)
              for (let _ of this.materials
                .concat(this.materialsBackSide)
                .concat(this.materialsDoubleSide)
                .concat(this.materialsFlatShaded)
                .concat(this.materialsFlatShadedBackSide)
                .concat(this.materialsFlatShadedDoubleSide))
                _.dispose();
          }
          dispose() {
            this.originalMaterials.clear(), this.disposeMaterials();
          }
          static get workaroundEnabled() {
            return MR;
          }
          static set workaroundEnabled(_) {
            MR = _;
          }
        },
        Mz = class extends MC {
          constructor(_, I, R = null) {
            super("RenderPass", _, I),
              (this.needsSwap = !1),
              (this.clearPass = new MO()),
              (this.overrideMaterialManager = null === R ? null : new ML(R)),
              (this.ignoreBackground = !1),
              (this.skipShadowMapUpdate = !1),
              (this.selection = null);
          }
          get renderToScreen() {
            return super.renderToScreen;
          }
          set renderToScreen(_) {
            (super.renderToScreen = _), (this.clearPass.renderToScreen = _);
          }
          get overrideMaterial() {
            let _ = this.overrideMaterialManager;
            return null !== _ ? _.material : null;
          }
          set overrideMaterial(_) {
            let I = this.overrideMaterialManager;
            null !== _
              ? null !== I
                ? I.setMaterial(_)
                : (this.overrideMaterialManager = new ML(_))
              : null !== I &&
                (I.dispose(), (this.overrideMaterialManager = null));
          }
          getOverrideMaterial() {
            return this.overrideMaterial;
          }
          setOverrideMaterial(_) {
            this.overrideMaterial = _;
          }
          get clear() {
            return this.clearPass.enabled;
          }
          set clear(_) {
            this.clearPass.enabled = _;
          }
          getSelection() {
            return this.selection;
          }
          setSelection(_) {
            this.selection = _;
          }
          isBackgroundDisabled() {
            return this.ignoreBackground;
          }
          setBackgroundDisabled(_) {
            this.ignoreBackground = _;
          }
          isShadowMapDisabled() {
            return this.skipShadowMapUpdate;
          }
          setShadowMapDisabled(_) {
            this.skipShadowMapUpdate = _;
          }
          getClearPass() {
            return this.clearPass;
          }
          render(_, I, R, B, z) {
            let k = this.scene,
              V = this.camera,
              j = this.selection,
              G = V.layers.mask,
              q = k.background,
              X = _.shadowMap.autoUpdate,
              Q = this.renderToScreen ? null : I;
            null !== j && V.layers.set(j.getLayer()),
              this.skipShadowMapUpdate && (_.shadowMap.autoUpdate = !1),
              (this.ignoreBackground ||
                null !== this.clearPass.overrideClearColor) &&
                (k.background = null),
              this.clearPass.enabled && this.clearPass.render(_, I),
              _.setRenderTarget(Q),
              null !== this.overrideMaterialManager
                ? this.overrideMaterialManager.render(_, k, V)
                : _.render(k, V),
              (V.layers.mask = G),
              (k.background = q),
              (_.shadowMap.autoUpdate = X);
          }
        },
        MF = class extends MC {
          constructor(
            _,
            I,
            {
              resolutionScale: R = 1,
              width: B = MI.AUTO_SIZE,
              height: z = MI.AUTO_SIZE,
              renderTarget: k,
            } = {}
          ) {
            super("DepthPass"),
              (this.needsSwap = !1),
              (this.renderPass = new Mz(_, I, new n_({ depthPacking: 3201 })));
            let V = this.renderPass;
            (V.skipShadowMapUpdate = !0), (V.ignoreBackground = !0);
            let j = V.getClearPass();
            (j.overrideClearColor = new ry(16777215)),
              (j.overrideClearAlpha = 1),
              (this.renderTarget = k),
              void 0 === this.renderTarget &&
                ((this.renderTarget = new rT(1, 1, {
                  minFilter: 1003,
                  magFilter: 1003,
                  stencilBuffer: !1,
                })),
                (this.renderTarget.texture.name = "DepthPass.Target"));
            let G = (this.resolution = new MI(this, B, z, R));
            G.addEventListener("change", (_) =>
              this.setSize(G.baseWidth, G.baseHeight)
            );
          }
          get texture() {
            return this.renderTarget.texture;
          }
          getTexture() {
            return this.renderTarget.texture;
          }
          getResolution() {
            return this.resolution;
          }
          getResolutionScale() {
            return this.resolution.scale;
          }
          setResolutionScale(_) {
            this.resolution.scale = _;
          }
          render(_, I, R, B, z) {
            let k = this.renderToScreen ? null : this.renderTarget;
            this.renderPass.render(_, k);
          }
          setSize(_, I) {
            let R = this.resolution;
            R.setBaseSize(_, I), this.renderTarget.setSize(R.width, R.height);
          }
        };
      new Float32Array([
        255 / 256 / 16777216,
        255 / 256 / 65536,
        255 / 256 / 256,
        255 / 256,
      ]);
      var MN = {
          SKIP: 0,
          ADD: 1,
          ALPHA: 2,
          AVERAGE: 3,
          COLOR_BURN: 4,
          COLOR_DODGE: 5,
          DARKEN: 6,
          DIFFERENCE: 7,
          EXCLUSION: 8,
          LIGHTEN: 9,
          MULTIPLY: 10,
          DIVIDE: 11,
          NEGATION: 12,
          NORMAL: 13,
          OVERLAY: 14,
          REFLECT: 15,
          SCREEN: 16,
          SOFT_LIGHT: 17,
          SUBTRACT: 18,
        },
        Mk = new Map([
          [MN.SKIP, null],
          [
            MN.ADD,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x+y,1.0)*opacity+x*(1.0-opacity);}",
          ],
          [
            MN.ALPHA,
            "vec3 blend(const in vec3 x,const in vec3 y,const in float opacity){return y*opacity+x*(1.0-opacity);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){float a=min(y.a,opacity);return vec4(blend(x.rgb,y.rgb,a),max(x.a,a));}",
          ],
          [
            MN.AVERAGE,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y)*0.5*opacity+x*(1.0-opacity);}",
          ],
          [
            MN.COLOR_BURN,
            "float blend(const in float x,const in float y){return(y==0.0)?y:max(1.0-(1.0-x)/y,0.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
          ],
          [
            MN.COLOR_DODGE,
            "float blend(const in float x,const in float y){return(y==1.0)?y:min(x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
          ],
          [
            MN.DARKEN,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x,y)*opacity+x*(1.0-opacity);}",
          ],
          [
            MN.DIFFERENCE,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return abs(x-y)*opacity+x*(1.0-opacity);}",
          ],
          [
            MN.EXCLUSION,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y-2.0*x*y)*opacity+x*(1.0-opacity);}",
          ],
          [
            MN.LIGHTEN,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x,y)*opacity+x*(1.0-opacity);}",
          ],
          [
            MN.MULTIPLY,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return x*y*opacity+x*(1.0-opacity);}",
          ],
          [
            MN.DIVIDE,
            "float blend(const in float x,const in float y){return(y>0.0)?min(x/y,1.0):1.0;}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
          ],
          [
            MN.NEGATION,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-abs(1.0-x-y))*opacity+x*(1.0-opacity);}",
          ],
          [
            MN.NORMAL,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y*opacity+x*(1.0-opacity);}",
          ],
          [
            MN.OVERLAY,
            "float blend(const in float x,const in float y){return(x<0.5)?(2.0*x*y):(1.0-2.0*(1.0-x)*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
          ],
          [
            MN.REFLECT,
            "float blend(const in float x,const in float y){return(y==1.0)?y:min(x*x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
          ],
          [
            MN.SCREEN,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-(1.0-x)*(1.0-y))*opacity+x*(1.0-opacity);}",
          ],
          [
            MN.SOFT_LIGHT,
            "float blend(const in float x,const in float y){return(y<0.5)?(2.0*x*y+x*x*(1.0-2.0*y)):(sqrt(x)*(2.0*y-1.0)+2.0*x*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
          ],
          [
            MN.SUBTRACT,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x+y-1.0,0.0)*opacity+x*(1.0-opacity);}",
          ],
        ]),
        MV = class extends i8 {
          constructor(_, I = 1) {
            super(), (this.f = _), (this.opacity = new lk(I));
          }
          getOpacity() {
            return this.opacity.value;
          }
          setOpacity(_) {
            this.opacity.value = _;
          }
          get blendFunction() {
            return this.f;
          }
          set blendFunction(_) {
            (this.f = _), this.dispatchEvent({ type: "change" });
          }
          getBlendFunction() {
            return this.blendFunction;
          }
          setBlendFunction(_) {
            this.blendFunction = _;
          }
          getShaderCode() {
            return Mk.get(this.blendFunction);
          }
        },
        Mj = { NONE: 0, DEPTH: 1, CONVOLUTION: 2 },
        MG = class extends i8 {
          constructor(
            _,
            I,
            {
              attributes: R = Mj.NONE,
              blendFunction: B = MN.SCREEN,
              defines: z = new Map(),
              uniforms: k = new Map(),
              extensions: V = null,
              vertexShader: j = null,
            } = {}
          ) {
            super(),
              (this.name = _),
              (this.renderer = null),
              (this.attributes = R),
              (this.fragmentShader = I),
              (this.vertexShader = j),
              (this.defines = z),
              (this.uniforms = k),
              (this.extensions = V),
              (this.blendMode = new MV(B)),
              this.blendMode.addEventListener("change", (_) =>
                this.setChanged()
              );
          }
          getName() {
            return this.name;
          }
          setRenderer(_) {
            this.renderer = _;
          }
          getDefines() {
            return this.defines;
          }
          getUniforms() {
            return this.uniforms;
          }
          getExtensions() {
            return this.extensions;
          }
          getBlendMode() {
            return this.blendMode;
          }
          getAttributes() {
            return this.attributes;
          }
          setAttributes(_) {
            (this.attributes = _), this.setChanged();
          }
          getFragmentShader() {
            return this.fragmentShader;
          }
          setFragmentShader(_) {
            (this.fragmentShader = _), this.setChanged();
          }
          getVertexShader() {
            return this.vertexShader;
          }
          setVertexShader(_) {
            (this.vertexShader = _), this.setChanged();
          }
          setChanged() {
            this.dispatchEvent({ type: "change" });
          }
          setDepthTexture(_, I = 3200) {}
          update(_, I, R) {}
          setSize(_, I) {}
          initialize(_, I, R) {}
          dispose() {
            for (let _ of Object.keys(this)) {
              let I = this[_];
              if (null !== I && "function" == typeof I.dispose) {
                if (I instanceof nz || I === this.renderer) continue;
                this[_].dispose();
              }
            }
          }
        };
      function JR(_, I, R) {
        for (let B of I) {
          let I = "$1" + _ + B.charAt(0).toUpperCase() + B.slice(1),
            z = RegExp("([^\\.])(\\b" + B + "\\b)", "g");
          for (let _ of R.entries())
            null !== _[1] && R.set(_[0], _[1].replace(z, I));
        }
      }
      var MH = class extends MC {
          constructor(_, ...I) {
            super("EffectPass"),
              (this.fullscreenMaterial = new Mf(null, null, null, _)),
              (this.effects = I.sort((_, I) => I.attributes - _.attributes)),
              (this.skipRendering = !1),
              (this.uniformCount = 0),
              (this.varyingCount = 0),
              (this.minTime = 1),
              (this.maxTime = Number.POSITIVE_INFINITY);
          }
          get encodeOutput() {
            return this.fullscreenMaterial.encodeOutput;
          }
          set encodeOutput(_) {
            this.fullscreenMaterial.encodeOutput = _;
          }
          get dithering() {
            return this.fullscreenMaterial.dithering;
          }
          set dithering(_) {
            let I = this.fullscreenMaterial;
            (I.dithering = _), (I.needsUpdate = !0);
          }
          verifyResources() {
            let _ = this.renderer.capabilities,
              I = Math.min(_.maxFragmentUniforms, _.maxVertexUniforms);
            this.uniformCount > I &&
              console.warn(
                "The current rendering context doesn't support more than " +
                  I +
                  " uniforms, but " +
                  this.uniformCount +
                  " were defined"
              ),
              (I = _.maxVaryings),
              this.varyingCount > I &&
                console.warn(
                  "The current rendering context doesn't support more than " +
                    I +
                    " varyings, but " +
                    this.varyingCount +
                    " were defined"
                );
          }
          updateMaterial() {
            let _ = Mf.Section,
              I = new Map([
                [_.FRAGMENT_HEAD, ""],
                [_.FRAGMENT_MAIN_UV, ""],
                [_.FRAGMENT_MAIN_IMAGE, ""],
                [_.VERTEX_HEAD, ""],
                [_.VERTEX_MAIN_SUPPORT, ""],
              ]),
              R = new Map(),
              B = new Map(),
              z = new Map(),
              k = new Set(),
              V = 0,
              j = 0,
              G = 0,
              q = !1,
              X = !1;
            for (let _ of this.effects)
              if (_.blendMode.blendFunction === MN.SKIP)
                G |= _.getAttributes() & Mj.DEPTH;
              else if ((G & _.getAttributes() & Mj.CONVOLUTION) != 0)
                console.error("Convolution effects cannot be merged", _);
              else {
                G |= _.getAttributes();
                let Q = (function (_, I, R, B, z, k, V) {
                  let j = new Map([
                      ["fragment", I.getFragmentShader()],
                      ["vertex", I.getVertexShader()],
                    ]),
                    G =
                      void 0 !== j.get("fragment") &&
                      /mainImage/.test(j.get("fragment")),
                    q =
                      void 0 !== j.get("fragment") &&
                      /mainUv/.test(j.get("fragment")),
                    X = [],
                    Q = [],
                    $ = !1,
                    et = !1;
                  if (void 0 === j.get("fragment"))
                    console.error("Missing fragment shader", I);
                  else if (q && (V & Mj.CONVOLUTION) != 0)
                    console.error(
                      "Effects that transform UV coordinates are incompatible with convolution effects",
                      I
                    );
                  else if (G || q) {
                    let er = /(?:\w+\s+(\w+)\([\w\s,]*\)\s*{[^}]+})/g,
                      es = Mf.Section;
                    if (q) {
                      let I = `	${_}MainUv(UV);
`;
                      R.set(
                        es.FRAGMENT_MAIN_UV,
                        R.get(es.FRAGMENT_MAIN_UV) + I
                      ),
                        ($ = !0);
                    }
                    if (
                      null !== j.get("vertex") &&
                      /mainSupport/.test(j.get("vertex"))
                    ) {
                      let I = `	${_}MainSupport(`;
                      (I += /mainSupport *\([\w\s]*?uv\s*?\)/.test(
                        j.get("vertex")
                      )
                        ? `vUv);
`
                        : `);
`),
                        R.set(
                          es.VERTEX_MAIN_SUPPORT,
                          R.get(es.VERTEX_MAIN_SUPPORT) + I
                        ),
                        (X = X.concat(
                          [
                            ...j
                              .get("vertex")
                              .matchAll(/(?:varying\s+\w+\s+(\w*))/g),
                          ].map((_) => _[1])
                        )),
                        (Q = Q.concat(X).concat(
                          [...j.get("vertex").matchAll(er)].map((_) => _[1])
                        ));
                    }
                    (Q = (Q = (Q = Q.concat(
                      [...j.get("fragment").matchAll(er)].map((_) => _[1])
                    )).concat(
                      [...I.defines.keys()].map((_) =>
                        _.replace(/\([\w\s,]*\)/g, "")
                      )
                    )).concat([...I.uniforms.keys()])),
                      I.uniforms.forEach((I, R) =>
                        k.set(_ + R.charAt(0).toUpperCase() + R.slice(1), I)
                      ),
                      I.defines.forEach((I, R) =>
                        z.set(_ + R.charAt(0).toUpperCase() + R.slice(1), I)
                      ),
                      JR(_, Q, z),
                      JR(_, Q, j);
                    let ea = I.blendMode;
                    if ((B.set(ea.blendFunction, ea), G)) {
                      let I = `${_}MainImage(color0, UV, `;
                      (V & Mj.DEPTH) != 0 &&
                        /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/.test(
                          j.get("fragment")
                        ) &&
                        ((I += "depth, "), (et = !0)),
                        (I += `color1);
	`);
                      let B = _ + "BlendOpacity";
                      k.set(B, ea.opacity),
                        (I += `color0 = blend${ea.blendFunction}(color0, color1, ${B});

	`),
                        R.set(
                          es.FRAGMENT_MAIN_IMAGE,
                          R.get(es.FRAGMENT_MAIN_IMAGE) + I
                        ),
                        (I = `uniform float ${B};

`),
                        R.set(es.FRAGMENT_HEAD, R.get(es.FRAGMENT_HEAD) + I);
                    }
                    R.set(
                      es.FRAGMENT_HEAD,
                      R.get(es.FRAGMENT_HEAD) +
                        j.get("fragment") +
                        `
`
                    ),
                      null !== j.get("vertex") &&
                        R.set(
                          es.VERTEX_HEAD,
                          R.get(es.VERTEX_HEAD) +
                            j.get("vertex") +
                            `
`
                        );
                  } else
                    console.error(
                      "The fragment shader contains neither a mainImage nor a mainUv function",
                      I
                    );
                  return { varyings: X, transformedUv: $, readDepth: et };
                })("e" + V++, _, I, R, B, z, G);
                if (
                  ((j += Q.varyings.length),
                  (q = q || Q.transformedUv),
                  (X = X || Q.readDepth),
                  null !== _.extensions)
                )
                  for (let I of _.extensions) k.add(I);
              }
            let Q = /\bblend\b/g;
            for (let B of R.values()) {
              let R = B.getShaderCode().replace(Q, `blend${B.blendFunction}`);
              I.set(
                _.FRAGMENT_HEAD,
                I.get(_.FRAGMENT_HEAD) +
                  R +
                  `
`
              );
            }
            if ((G & Mj.DEPTH) != 0) {
              if (X) {
                let R = `float depth = readDepth(UV);

	`;
                I.set(_.FRAGMENT_MAIN_IMAGE, R + I.get(_.FRAGMENT_MAIN_IMAGE));
              }
              this.needsDepthTexture = null === this.getDepthTexture();
            } else this.needsDepthTexture = !1;
            if (q) {
              let R = `vec2 transformedUv = vUv;
`;
              I.set(_.FRAGMENT_MAIN_UV, R + I.get(_.FRAGMENT_MAIN_UV)),
                B.set("UV", "transformedUv");
            } else B.set("UV", "vUv");
            I.forEach((_, I, R) =>
              R.set(
                I,
                _.trim().replace(
                  /^#/,
                  `
#`
                )
              )
            ),
              (this.uniformCount = z.size),
              (this.varyingCount = j),
              (this.skipRendering = 0 === V),
              (this.needsSwap = !this.skipRendering),
              this.fullscreenMaterial
                .setShaderParts(I)
                .setExtensions(k)
                .setUniforms(z)
                .setDefines(B);
          }
          recompile() {
            this.updateMaterial(), this.verifyResources();
          }
          getDepthTexture() {
            return this.fullscreenMaterial.depthBuffer;
          }
          setDepthTexture(_, I = 3200) {
            for (let R of ((this.fullscreenMaterial.depthBuffer = _),
            (this.fullscreenMaterial.depthPacking = I),
            this.effects))
              R.setDepthTexture(_, I);
          }
          render(_, I, R, B, z) {
            for (let R of this.effects) R.update(_, I, B);
            if (!this.skipRendering || this.renderToScreen) {
              let z = this.fullscreenMaterial;
              (z.inputBuffer = I.texture),
                (z.time += B),
                _.setRenderTarget(this.renderToScreen ? null : R),
                _.render(this.scene, this.camera);
            }
          }
          setSize(_, I) {
            for (let R of (this.fullscreenMaterial.setSize(_, I), this.effects))
              R.setSize(_, I);
          }
          initialize(_, I, R) {
            for (let B of ((this.renderer = _), this.effects))
              B.initialize(_, I, R),
                B.addEventListener("change", (_) => this.handleEvent(_));
            this.updateMaterial(),
              this.verifyResources(),
              void 0 !== R &&
                1009 !== R &&
                (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                  "1");
          }
          dispose() {
            for (let _ of (super.dispose(), this.effects)) _.dispose();
          }
          handleEvent(_) {
            "change" === _.type && this.recompile();
          }
        },
        MW = [
          new Float32Array([0, 0]),
          new Float32Array([0, 1, 1]),
          new Float32Array([0, 1, 1, 2]),
          new Float32Array([0, 1, 2, 2, 3]),
          new Float32Array([0, 1, 2, 3, 4, 4, 5]),
          new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10]),
        ],
        Mq = class extends MC {
          constructor({
            resolutionScale: _ = 0.5,
            width: I = MI.AUTO_SIZE,
            height: R = MI.AUTO_SIZE,
            kernelSize: B = MK.LARGE,
          } = {}) {
            super("KawaseBlurPass"),
              (this.renderTargetA = new rT(1, 1, {
                minFilter: 1006,
                magFilter: 1006,
                stencilBuffer: !1,
                depthBuffer: !1,
              })),
              (this.renderTargetA.texture.name = "Blur.Target.A"),
              (this.renderTargetB = this.renderTargetA.clone()),
              (this.renderTargetB.texture.name = "Blur.Target.B");
            let z = (this.resolution = new MI(this, I, R, _));
            z.addEventListener("change", (_) =>
              this.setSize(z.baseWidth, z.baseHeight)
            ),
              (this.blurMaterial = new Mt()),
              (this.ditheredBlurMaterial = new Mt()),
              (this.ditheredBlurMaterial.uniforms.scale =
                this.blurMaterial.uniforms.scale),
              (this.ditheredBlurMaterial.dithering = !0),
              (this.dithering = !1),
              (this.kernelSize = B);
          }
          getResolution() {
            return this.resolution;
          }
          get width() {
            return this.resolution.width;
          }
          set width(_) {
            this.resolution.preferredWidth = _;
          }
          get height() {
            return this.resolution.height;
          }
          set height(_) {
            this.resolution.preferredHeight = _;
          }
          get scale() {
            return this.blurMaterial.scale;
          }
          set scale(_) {
            this.blurMaterial.scale = _;
          }
          getScale() {
            return this.blurMaterial.scale;
          }
          setScale(_) {
            this.blurMaterial.scale = _;
          }
          getKernelSize() {
            return this.kernelSize;
          }
          setKernelSize(_) {
            this.kernelSize = _;
          }
          getResolutionScale() {
            return this.resolution.scale;
          }
          setResolutionScale(_) {
            this.resolution.scale = _;
          }
          render(_, I, R, B, z) {
            let k = this.scene,
              V = this.camera,
              j = this.renderTargetA,
              G = this.renderTargetB,
              q = MW[this.kernelSize],
              X = this.blurMaterial,
              Q = I,
              $,
              et;
            for (
              this.fullscreenMaterial = X, $ = 0, et = q.length - 1;
              $ < et;
              ++$
            ) {
              let I = (1 & $) == 0 ? j : G;
              (X.kernel = q[$]),
                (X.inputBuffer = Q.texture),
                _.setRenderTarget(I),
                _.render(k, V),
                (Q = I);
            }
            this.dithering &&
              ((X = this.ditheredBlurMaterial), (this.fullscreenMaterial = X)),
              (X.kernel = q[$]),
              (X.inputBuffer = Q.texture),
              _.setRenderTarget(this.renderToScreen ? null : R),
              _.render(k, V);
          }
          setSize(_, I) {
            let R = this.resolution;
            R.setBaseSize(_, I);
            let B = R.width,
              z = R.height;
            this.renderTargetA.setSize(B, z),
              this.renderTargetB.setSize(B, z),
              this.blurMaterial.setSize(B, z),
              this.ditheredBlurMaterial.setSize(B, z);
          }
          initialize(_, I, R) {
            void 0 !== R &&
              ((this.renderTargetA.texture.type = R),
              (this.renderTargetB.texture.type = R),
              1009 !== R
                ? ((this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1"),
                  (this.ditheredBlurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                    "1"))
                : 3001 === _.outputEncoding &&
                  ((this.renderTargetA.texture.encoding = 3001),
                  (this.renderTargetB.texture.encoding = 3001)));
          }
          static get AUTO_SIZE() {
            return MI.AUTO_SIZE;
          }
        },
        MY = class extends MC {
          constructor({
            width: _ = MI.AUTO_SIZE,
            height: I = MI.AUTO_SIZE,
            renderTarget: R,
            luminanceRange: B,
            colorOutput: z,
          } = {}) {
            super("LuminancePass"),
              (this.fullscreenMaterial = new My(z, B)),
              (this.needsSwap = !1),
              (this.renderTarget = R),
              void 0 === this.renderTarget &&
                ((this.renderTarget = new rT(1, 1, {
                  minFilter: 1006,
                  magFilter: 1006,
                  stencilBuffer: !1,
                  depthBuffer: !1,
                })),
                (this.renderTarget.texture.name = "LuminancePass.Target"),
                (this.renderTarget.texture.generateMipmaps = !1));
            let k = (this.resolution = new MI(this, _, I));
            k.addEventListener("change", (_) =>
              this.setSize(k.baseWidth, k.baseHeight)
            );
          }
          get texture() {
            return this.renderTarget.texture;
          }
          getTexture() {
            return this.renderTarget.texture;
          }
          getResolution() {
            return this.resolution;
          }
          render(_, I, R, B, z) {
            (this.fullscreenMaterial.inputBuffer = I.texture),
              _.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
              _.render(this.scene, this.camera);
          }
          setSize(_, I) {
            let R = this.resolution;
            R.setBaseSize(_, I), this.renderTarget.setSize(R.width, R.height);
          }
          initialize(_, I, R) {
            void 0 !== R &&
              1009 !== R &&
              (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                "1");
          }
        },
        MX = class extends MC {
          constructor(_, I) {
            super("MaskPass", _, I),
              (this.needsSwap = !1),
              (this.clearPass = new MO(!1, !1, !0)),
              (this.inverse = !1);
          }
          get inverted() {
            return this.inverse;
          }
          set inverted(_) {
            this.inverse = _;
          }
          get clear() {
            return this.clearPass.enabled;
          }
          set clear(_) {
            this.clearPass.enabled = _;
          }
          getClearPass() {
            return this.clearPass;
          }
          isInverted() {
            return this.inverted;
          }
          setInverted(_) {
            this.inverted = _;
          }
          render(_, I, R, B, z) {
            let k = _.getContext(),
              V = _.state.buffers,
              j = this.scene,
              G = this.camera,
              q = this.clearPass,
              X = this.inverted ? 0 : 1,
              Q = 1 - X;
            V.color.setMask(!1),
              V.depth.setMask(!1),
              V.color.setLocked(!0),
              V.depth.setLocked(!0),
              V.stencil.setTest(!0),
              V.stencil.setOp(k.REPLACE, k.REPLACE, k.REPLACE),
              V.stencil.setFunc(k.ALWAYS, X, 4294967295),
              V.stencil.setClear(Q),
              V.stencil.setLocked(!0),
              this.clearPass.enabled &&
                (this.renderToScreen
                  ? q.render(_, null)
                  : (q.render(_, I), q.render(_, R))),
              this.renderToScreen
                ? _.setRenderTarget(null)
                : (_.setRenderTarget(I), _.render(j, G), _.setRenderTarget(R)),
              _.render(j, G),
              V.color.setLocked(!1),
              V.depth.setLocked(!1),
              V.stencil.setLocked(!1),
              V.stencil.setFunc(k.EQUAL, 1, 4294967295),
              V.stencil.setOp(k.KEEP, k.KEEP, k.KEEP),
              V.stencil.setLocked(!0);
          }
        },
        MQ = class extends MC {
          constructor(_, I = "inputBuffer") {
            super("ShaderPass"),
              (this.fullscreenMaterial = _),
              (this.inputBufferUniform = null),
              this.setInput(I);
          }
          setInput(_) {
            if (
              ((this.inputBufferUniform = null),
              null !== this.fullscreenMaterial)
            ) {
              let I = this.fullscreenMaterial.uniforms;
              void 0 !== I &&
                void 0 !== I[_] &&
                (this.inputBufferUniform = I[_]);
            }
          }
          render(_, I, R, B, z) {
            null !== this.inputBufferUniform &&
              null !== I &&
              (this.inputBufferUniform.value = I.texture),
              _.setRenderTarget(this.renderToScreen ? null : R),
              _.render(this.scene, this.camera);
          }
          initialize(_, I, R) {
            void 0 !== R &&
              1009 !== R &&
              (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                "1");
          }
        },
        MZ = class {
          constructor() {
            (this.previousTime = 0),
              (this.currentTime = 0),
              (this.delta = 0),
              (this.fixedDelta = 1e3 / 60),
              (this.elapsed = 0),
              (this.timescale = 1),
              (this.fixedDeltaEnabled = !1),
              (this.autoReset = !1);
          }
          setFixedDeltaEnabled(_) {
            return (this.fixedDeltaEnabled = _), this;
          }
          isAutoResetEnabled(_) {
            return this.autoReset;
          }
          setAutoResetEnabled(_) {
            return (
              "u" > typeof document &&
                void 0 !== document.hidden &&
                (_
                  ? document.addEventListener("visibilitychange", this)
                  : document.removeEventListener("visibilitychange", this),
                (this.autoReset = _)),
              this
            );
          }
          getDelta() {
            return 0.001 * this.delta;
          }
          getFixedDelta() {
            return 0.001 * this.fixedDelta;
          }
          setFixedDelta(_) {
            return (this.fixedDelta = 1e3 * _), this;
          }
          getElapsed() {
            return 0.001 * this.elapsed;
          }
          getTimescale() {
            return this.timescale;
          }
          setTimescale(_) {
            return (this.timescale = _), this;
          }
          update(_) {
            return (
              this.fixedDeltaEnabled
                ? (this.delta = this.fixedDelta)
                : ((this.previousTime = this.currentTime),
                  (this.currentTime = void 0 !== _ ? _ : performance.now()),
                  (this.delta = this.currentTime - this.previousTime)),
              (this.delta *= this.timescale),
              (this.elapsed += this.delta),
              this
            );
          }
          reset() {
            return (
              (this.delta = 0),
              (this.elapsed = 0),
              (this.currentTime = performance.now()),
              this
            );
          }
          handleEvent(_) {
            document.hidden || (this.currentTime = performance.now());
          }
          dispose() {
            this.setAutoResetEnabled(!1);
          }
        },
        MK = { MEDIUM: 2, LARGE: 3, HUGE: 5 },
        MJ = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=clamp(texture2D(map,uv)*intensity,0.0,1.0);}`,
        M$ = class extends MG {
          constructor({
            blendFunction: _ = MN.SCREEN,
            luminanceThreshold: I = 0.9,
            luminanceSmoothing: R = 0.025,
            resolutionScale: B = 0.5,
            intensity: z = 1,
            width: k = MI.AUTO_SIZE,
            height: V = MI.AUTO_SIZE,
            kernelSize: j = MK.LARGE,
          } = {}) {
            super("BloomEffect", MJ, {
              blendFunction: _,
              uniforms: new Map([
                ["map", new lk(null)],
                ["intensity", new lk(z)],
              ]),
            }),
              (this.renderTarget = new rT(1, 1, {
                minFilter: 1006,
                magFilter: 1006,
                stencilBuffer: !1,
                depthBuffer: !1,
              })),
              (this.renderTarget.texture.name = "Bloom.Target"),
              (this.renderTarget.texture.generateMipmaps = !1),
              (this.uniforms.get("map").value = this.renderTarget.texture),
              (this.luminancePass = new MY({
                renderTarget: this.renderTarget,
                colorOutput: !0,
              })),
              (this.luminanceMaterial.threshold = I),
              (this.luminanceMaterial.smoothingFactor = R),
              (this.blurPass = new Mq({
                resolutionScale: B,
                width: k,
                height: V,
                kernelSize: j,
              }));
            let G = this.blurPass.getResolution();
            G.addEventListener("change", (_) =>
              this.setSize(G.baseWidth, G.baseHeight)
            );
          }
          get texture() {
            return this.renderTarget.texture;
          }
          getTexture() {
            return this.renderTarget.texture;
          }
          get resolution() {
            return this.blurPass.resolution;
          }
          getResolution() {
            return this.blurPass.resolution;
          }
          getBlurPass() {
            return this.blurPass;
          }
          getLuminancePass() {
            return this.luminancePass;
          }
          get luminanceMaterial() {
            return this.luminancePass.fullscreenMaterial;
          }
          getLuminanceMaterial() {
            return this.luminancePass.fullscreenMaterial;
          }
          get width() {
            return this.resolution.width;
          }
          set width(_) {
            this.resolution.preferredWidth = _;
          }
          get height() {
            return this.resolution.height;
          }
          set height(_) {
            this.resolution.preferredHeight = _;
          }
          get dithering() {
            return this.blurPass.dithering;
          }
          set dithering(_) {
            this.blurPass.dithering = _;
          }
          get kernelSize() {
            return this.blurPass.kernelSize;
          }
          set kernelSize(_) {
            this.blurPass.kernelSize = _;
          }
          get distinction() {
            return console.warn(this.name, "distinction was removed"), 1;
          }
          set distinction(_) {
            console.warn(this.name, "distinction was removed");
          }
          get intensity() {
            return this.uniforms.get("intensity").value;
          }
          set intensity(_) {
            this.uniforms.get("intensity").value = _;
          }
          getIntensity() {
            return this.intensity;
          }
          setIntensity(_) {
            this.intensity = _;
          }
          getResolutionScale() {
            return this.resolution.scale;
          }
          setResolutionScale(_) {
            this.resolution.scale = _;
          }
          update(_, I, R) {
            let B = this.renderTarget;
            this.luminancePass.enabled
              ? (this.luminancePass.render(_, I, B),
                this.blurPass.render(_, B, B))
              : this.blurPass.render(_, I, B);
          }
          setSize(_, I) {
            let R = this.resolution;
            R.setBaseSize(_, I),
              this.renderTarget.setSize(R.width, R.height),
              this.luminancePass.resolution.copy(R);
          }
          initialize(_, I, R) {
            this.blurPass.initialize(_, I, R),
              void 0 !== R &&
                ((this.renderTarget.texture.type = R),
                3001 === _.outputEncoding &&
                  (this.renderTarget.texture.encoding = 3001));
          }
        },
        M0 = class extends MG {
          constructor({
            blendFunction: _ = MN.NORMAL,
            brightness: I = 0,
            contrast: R = 0,
          } = {}) {
            super(
              "BrightnessContrastEffect",
              "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(min(color+vec3(0.5),1.0),inputColor.a);}",
              {
                blendFunction: _,
                uniforms: new Map([
                  ["brightness", new lk(I)],
                  ["contrast", new lk(R)],
                ]),
              }
            );
          }
          get brightness() {
            return this.uniforms.get("brightness").value;
          }
          set brightness(_) {
            this.uniforms.get("brightness").value = _;
          }
          getBrightness(_) {
            return this.brightness;
          }
          setBrightness(_) {
            this.brightness = _;
          }
          get contrast() {
            return this.uniforms.get("contrast").value;
          }
          set contrast(_) {
            this.uniforms.get("contrast").value = _;
          }
          getContrast(_) {
            return this.contrast;
          }
          setContrast(_) {
            this.contrast = _;
          }
        },
        M1 = class extends MG {
          constructor(_ = MN.NORMAL) {
            super(
              "ColorAverageEffect",
              "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(vec3(average(inputColor.rgb)),inputColor.a);}",
              { blendFunction: _ }
            );
          }
        },
        M4 = class extends MG {
          constructor({
            blendFunction: _ = MN.NORMAL,
            offset: I = new rs(0.001, 5e-4),
          } = {}) {
            super(
              "ChromaticAberrationEffect",
              "varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 ra=texture2D(inputBuffer,vUvR).ra;vec2 ba=texture2D(inputBuffer,vUvB).ba;outputColor=vec4(ra.x,inputColor.g,ba.x,max(max(ra.y,ba.y),inputColor.a));}",
              {
                vertexShader:
                  "uniform vec2 offset;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vec2 shift=offset*vec2(1.0,aspect);vUvR=uv+shift;vUvB=uv-shift;}",
                blendFunction: _,
                attributes: Mj.CONVOLUTION,
                uniforms: new Map([["offset", new lk(I)]]),
              }
            );
          }
          get offset() {
            return this.uniforms.get("offset").value;
          }
          set offset(_) {
            this.uniforms.get("offset").value = _;
          }
          getOffset() {
            return this.offset;
          }
          setOffset(_) {
            this.offset = _;
          }
        },
        M5 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;
#else
uniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;
#endif
uniform lowp sampler2D nearCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);float CoCNear=texture2D(nearCoCBuffer,uv).r;CoCNear=min(CoCNear*scale,1.0);vec4 result=inputColor*(1.0-colorFar.a)+colorFar;result=mix(result,colorNear,CoCNear);outputColor=result;}`,
        M6 = class extends MG {
          constructor(
            _,
            {
              blendFunction: I = MN.NORMAL,
              worldFocusDistance: R,
              worldFocusRange: B,
              focusDistance: z = 0,
              focalLength: k = 0.1,
              focusRange: V = k,
              bokehScale: j = 1,
              width: G = MI.AUTO_SIZE,
              height: q = MI.AUTO_SIZE,
            } = {}
          ) {
            super("DepthOfFieldEffect", M5, {
              blendFunction: I,
              attributes: Mj.DEPTH,
              uniforms: new Map([
                ["nearColorBuffer", new lk(null)],
                ["farColorBuffer", new lk(null)],
                ["nearCoCBuffer", new lk(null)],
                ["scale", new lk(1)],
              ]),
            }),
              (this.camera = _),
              (this.renderTarget = new rT(1, 1, {
                minFilter: 1006,
                magFilter: 1006,
                stencilBuffer: !1,
                depthBuffer: !1,
              })),
              (this.renderTarget.texture.name = "DoF.Intermediate"),
              (this.renderTarget.texture.generateMipmaps = !1),
              (this.renderTargetMasked = this.renderTarget.clone()),
              (this.renderTargetMasked.texture.name = "DoF.Masked.Far"),
              (this.renderTargetNear = this.renderTarget.clone()),
              (this.renderTargetNear.texture.name = "DoF.Bokeh.Near"),
              (this.uniforms.get("nearColorBuffer").value =
                this.renderTargetNear.texture),
              (this.renderTargetFar = this.renderTarget.clone()),
              (this.renderTargetFar.texture.name = "DoF.Bokeh.Far"),
              (this.uniforms.get("farColorBuffer").value =
                this.renderTargetFar.texture),
              (this.renderTargetCoC = this.renderTarget.clone()),
              (this.renderTargetCoC.texture.name = "DoF.CoC"),
              (this.renderTargetCoCBlurred = this.renderTargetCoC.clone()),
              (this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred"),
              (this.uniforms.get("nearCoCBuffer").value =
                this.renderTargetCoCBlurred.texture),
              (this.cocPass = new MQ(new A7(_)));
            let X = this.cocMaterial;
            (X.focusDistance = z),
              (X.focusRange = V),
              void 0 !== R && (X.worldFocusDistance = R),
              void 0 !== B && (X.worldFocusRange = B),
              (this.blurPass = new Mq({
                kernelSize: MK.MEDIUM,
                width: G,
                height: q,
              }));
            let Q = this.blurPass.getResolution();
            Q.addEventListener("change", (_) =>
              this.setSize(Q.getBaseWidth(), Q.getBaseHeight())
            ),
              (this.maskPass = new MQ(new Mb(this.renderTargetCoC.texture)));
            let $ = this.maskPass.fullscreenMaterial;
            ($.maskFunction = 1),
              ($.colorChannel = 1),
              (this.bokehNearBasePass = new MQ(new A8(!1, !0))),
              (this.bokehNearBasePass.fullscreenMaterial.cocBuffer =
                this.renderTargetCoCBlurred.texture),
              (this.bokehNearFillPass = new MQ(new A8(!0, !0))),
              (this.bokehNearFillPass.fullscreenMaterial.cocBuffer =
                this.renderTargetCoCBlurred.texture),
              (this.bokehFarBasePass = new MQ(new A8(!1, !1))),
              (this.bokehFarBasePass.fullscreenMaterial.cocBuffer =
                this.renderTargetCoC.texture),
              (this.bokehFarFillPass = new MQ(new A8(!0, !1))),
              (this.bokehFarFillPass.fullscreenMaterial.cocBuffer =
                this.renderTargetCoC.texture),
              (this.target = null),
              (this.bokehScale = j);
          }
          get cocTexture() {
            return this.renderTargetCoC.texture;
          }
          get cocMaterial() {
            return this.cocPass.fullscreenMaterial;
          }
          get circleOfConfusionMaterial() {
            return this.cocMaterial;
          }
          getCircleOfConfusionMaterial() {
            return this.circleOfConfusionMaterial;
          }
          getBlurPass() {
            return this.blurPass;
          }
          get resolution() {
            return this.blurPass.getResolution();
          }
          getResolution() {
            return this.blurPass.getResolution();
          }
          get bokehScale() {
            return this.uniforms.get("scale").value;
          }
          set bokehScale(_) {
            for (let I of [
              this.bokehNearBasePass,
              this.bokehNearFillPass,
              this.bokehFarBasePass,
              this.bokehFarFillPass,
            ])
              I.fullscreenMaterial.setScale(_);
            this.maskPass.fullscreenMaterial.setStrength(_),
              (this.uniforms.get("scale").value = _);
          }
          getBokehScale() {
            return this.bokehScale;
          }
          setBokehScale(_) {
            this.bokehScale = _;
          }
          getTarget() {
            return this.target;
          }
          setTarget(_) {
            this.target = _;
          }
          calculateFocusDistance(_) {
            let I = this.camera;
            return F_(-I.position.distanceTo(_), I.near, I.far);
          }
          setDepthTexture(_, I = 3200) {
            (this.circleOfConfusionMaterial.depthBuffer = _),
              (this.circleOfConfusionMaterial.depthPacking = I);
          }
          update(_, I, R) {
            let B = this.renderTarget,
              z = this.renderTargetCoC,
              k = this.renderTargetCoCBlurred,
              V = this.renderTargetMasked;
            if (null !== this.target) {
              let _ = this.calculateFocusDistance(this.target);
              this.circleOfConfusionMaterial.focusDistance = _;
            }
            this.cocPass.render(_, null, z),
              this.blurPass.render(_, z, k),
              this.maskPass.render(_, I, V),
              this.bokehFarBasePass.render(_, V, B),
              this.bokehFarFillPass.render(_, B, this.renderTargetFar),
              this.bokehNearBasePass.render(_, I, B),
              this.bokehNearFillPass.render(_, B, this.renderTargetNear);
          }
          setSize(_, I) {
            let R = this.resolution;
            R.setBaseSize(_, I);
            let B = R.width,
              z = R.height,
              k = [
                this.cocPass,
                this.blurPass,
                this.maskPass,
                this.bokehNearBasePass,
                this.bokehNearFillPass,
                this.bokehFarBasePass,
                this.bokehFarFillPass,
              ];
            k.push(this.renderTargetCoC, this.renderTargetMasked),
              k.forEach((R) => R.setSize(_, I)),
              (k = [
                this.renderTarget,
                this.renderTargetNear,
                this.renderTargetFar,
                this.renderTargetCoCBlurred,
              ]).forEach((_) => _.setSize(B, z)),
              [
                this.bokehNearBasePass,
                this.bokehNearFillPass,
                this.bokehFarBasePass,
                this.bokehFarFillPass,
              ].forEach((_) => _.fullscreenMaterial.setSize(B, z));
          }
          initialize(_, I, R) {
            [
              this.cocPass,
              this.maskPass,
              this.bokehNearBasePass,
              this.bokehNearFillPass,
              this.bokehFarBasePass,
              this.bokehFarFillPass,
            ].forEach((B) => B.initialize(_, I, R)),
              this.blurPass.initialize(_, I, 1009),
              void 0 !== R &&
                ((this.renderTarget.texture.type = R),
                (this.renderTargetNear.texture.type = R),
                (this.renderTargetFar.texture.type = R),
                (this.renderTargetMasked.texture.type = R),
                3001 === _.outputEncoding &&
                  ((this.renderTarget.texture.encoding = 3001),
                  (this.renderTargetNear.texture.encoding = 3001),
                  (this.renderTargetFar.texture.encoding = 3001),
                  (this.renderTargetMasked.texture.encoding = 3001)));
          }
        };
      new rF(), new sa();
      var M8 = class extends MG {
        constructor({
          blendFunction: _ = MN.NORMAL,
          hue: I = 0,
          saturation: R = 0,
        } = {}) {
          super(
            "HueSaturationEffect",
            "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}",
            {
              blendFunction: _,
              uniforms: new Map([
                ["hue", new lk(new rF())],
                ["saturation", new lk(R)],
              ]),
            }
          ),
            (this.hue = I);
        }
        get saturation() {
          return this.uniforms.get("saturation").value;
        }
        set saturation(_) {
          this.uniforms.get("saturation").value = _;
        }
        getSaturation() {
          return this.saturation;
        }
        setSaturation(_) {
          this.saturation = _;
        }
        get hue() {
          return Math.acos((3 * this.uniforms.get("hue").value.x - 1) / 2);
        }
        set hue(_) {
          let I = Math.sin(_),
            R = Math.cos(_);
          this.uniforms
            .get("hue")
            .value.set(
              (2 * R + 1) / 3,
              (-Math.sqrt(3) * I - R + 1) / 3,
              (Math.sqrt(3) * I - R + 1) / 3
            );
        }
        getHue() {
          return this.hue;
        }
        setHue(_) {
          this.hue = _;
        }
      };
      new ry();
      var M9 = `void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*time));
#ifdef PREMULTIPLY
outputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);
#else
outputColor=vec4(noise,inputColor.a);
#endif
}`,
        Ee = class extends MG {
          constructor({
            blendFunction: _ = MN.SCREEN,
            premultiply: I = !1,
          } = {}) {
            super("NoiseEffect", M9, { blendFunction: _ }),
              (this.premultiply = I);
          }
          get premultiply() {
            return this.defines.has("PREMULTIPLY");
          }
          set premultiply(_) {
            this.premultiply !== _ &&
              (_
                ? this.defines.set("PREMULTIPLY", "1")
                : this.defines.delete("PREMULTIPLY"),
              this.setChanged());
          }
          isPremultiplied() {
            return this.premultiply;
          }
          setPremultiplied(_) {
            this.premultiply = _;
          }
        },
        Et = class extends MG {
          constructor(_ = 30) {
            super(
              "PixelationEffect",
              "uniform bool active;uniform vec2 d;void mainUv(inout vec2 uv){if(active){uv=vec2(d.x*(floor(uv.x/d.x)+0.5),d.y*(floor(uv.y/d.y)+0.5));}}",
              {
                uniforms: new Map([
                  ["active", new lk(!1)],
                  ["d", new lk(new rs())],
                ]),
              }
            ),
              (this.resolution = new rs()),
              (this.d = 0),
              (this.granularity = _);
          }
          get granularity() {
            return this.d;
          }
          set granularity(_) {
            let I = Math.floor(_);
            I % 2 > 0 && (I += 1),
              (this.d = I),
              (this.uniforms.get("active").value = I > 0),
              this.setSize(this.resolution.width, this.resolution.height);
          }
          getGranularity() {
            return this.granularity;
          }
          setGranularity(_) {
            this.granularity = _;
          }
          setSize(_, I) {
            this.resolution.set(_, I),
              this.uniforms
                .get("d")
                .value.setScalar(this.d)
                .divide(this.resolution);
          }
        };
      new rF(), new rF();
      var Ei =
          "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC",
        Er =
          "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC",
        En = { LOW: 0, MEDIUM: 1, HIGH: 2, ULTRA: 3 },
        Eo = class extends MG {
          constructor({
            preset: _ = En.MEDIUM,
            edgeDetectionMode: I = Mc.COLOR,
            predicationMode: R = 0,
          } = {}) {
            let B, z;
            super(
              "SMAAEffect",
              "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}",
              {
                vertexShader:
                  "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}",
                blendFunction: MN.NORMAL,
                attributes: Mj.CONVOLUTION | Mj.DEPTH,
                uniforms: new Map([["weightMap", new lk(null)]]),
              }
            ),
              arguments.length > 1 &&
                ((B = arguments[0]),
                (z = arguments[1]),
                arguments.length > 2 && (_ = arguments[2]),
                arguments.length > 3 && (I = arguments[3])),
              (this.renderTargetEdges = new rT(1, 1, {
                minFilter: 1006,
                stencilBuffer: !1,
                depthBuffer: !1,
              })),
              (this.renderTargetEdges.texture.name = "SMAA.Edges"),
              (this.renderTargetWeights = this.renderTargetEdges.clone()),
              (this.renderTargetWeights.texture.name = "SMAA.Weights"),
              (this.uniforms.get("weightMap").value =
                this.renderTargetWeights.texture),
              (this.clearPass = new MO(!0, !1, !1)),
              (this.clearPass.overrideClearColor = new ry(0)),
              (this.clearPass.overrideClearAlpha = 1),
              (this.edgeDetectionPass = new MQ(new Md())),
              (this.edgeDetectionMaterial.edgeDetectionMode = I),
              (this.edgeDetectionMaterial.predicationMode = R),
              (this.weightsPass = new MQ(new M_()));
            let k = new o2();
            (k.onLoad = () => {
              let _ = new rA(B);
              (_.name = "SMAA.Search"),
                (_.magFilter = 1003),
                (_.minFilter = 1003),
                (_.generateMipmaps = !1),
                (_.needsUpdate = !0),
                (_.flipY = !0),
                (this.weightsMaterial.searchTexture = _);
              let I = new rA(z);
              (I.name = "SMAA.Area"),
                (I.magFilter = 1006),
                (I.minFilter = 1006),
                (I.generateMipmaps = !1),
                (I.needsUpdate = !0),
                (I.flipY = !1),
                (this.weightsMaterial.areaTexture = I),
                this.dispatchEvent({ type: "load" });
            }),
              k.itemStart("search"),
              k.itemStart("area"),
              void 0 !== B && void 0 !== z
                ? (k.itemEnd("search"), k.itemEnd("area"))
                : "u" > typeof Image &&
                  ((B = new Image()),
                  (z = new Image()),
                  B.addEventListener("load", () => k.itemEnd("search")),
                  z.addEventListener("load", () => k.itemEnd("area")),
                  (B.src = Ei),
                  (z.src = Er)),
              this.applyPreset(_);
          }
          get edgesTexture() {
            return this.renderTargetEdges.texture;
          }
          getEdgesTexture() {
            return this.edgesTexture;
          }
          get weightsTexture() {
            return this.renderTargetWeights.texture;
          }
          getWeightsTexture() {
            return this.weightsTexture;
          }
          get edgeDetectionMaterial() {
            return this.edgeDetectionPass.fullscreenMaterial;
          }
          get colorEdgesMaterial() {
            return this.edgeDetectionMaterial;
          }
          getEdgeDetectionMaterial() {
            return this.edgeDetectionMaterial;
          }
          get weightsMaterial() {
            return this.weightsPass.fullscreenMaterial;
          }
          getWeightsMaterial() {
            return this.weightsMaterial;
          }
          setEdgeDetectionThreshold(_) {
            this.edgeDetectionMaterial.edgeDetectionThreshold = _;
          }
          setOrthogonalSearchSteps(_) {
            this.weightsMaterial.orthogonalSearchSteps = _;
          }
          applyPreset(_) {
            let I = this.edgeDetectionMaterial,
              R = this.weightsMaterial;
            switch (_) {
              case En.LOW:
                (I.edgeDetectionThreshold = 0.15),
                  (R.orthogonalSearchSteps = 4),
                  (R.diagonalDetection = !1),
                  (R.cornerDetection = !1);
                break;
              case En.MEDIUM:
                (I.edgeDetectionThreshold = 0.1),
                  (R.orthogonalSearchSteps = 8),
                  (R.diagonalDetection = !1),
                  (R.cornerDetection = !1);
                break;
              case En.HIGH:
                (I.edgeDetectionThreshold = 0.1),
                  (R.orthogonalSearchSteps = 16),
                  (R.diagonalSearchSteps = 8),
                  (R.cornerRounding = 25),
                  (R.diagonalDetection = !0),
                  (R.cornerDetection = !0);
                break;
              case En.ULTRA:
                (I.edgeDetectionThreshold = 0.05),
                  (R.orthogonalSearchSteps = 32),
                  (R.diagonalSearchSteps = 16),
                  (R.cornerRounding = 25),
                  (R.diagonalDetection = !0),
                  (R.cornerDetection = !0);
            }
          }
          setDepthTexture(_, I = 3200) {
            (this.edgeDetectionMaterial.depthBuffer = _),
              (this.edgeDetectionMaterial.depthPacking = I);
          }
          update(_, I, R) {
            this.clearPass.render(_, this.renderTargetEdges),
              this.edgeDetectionPass.render(_, I, this.renderTargetEdges),
              this.weightsPass.render(
                _,
                this.renderTargetEdges,
                this.renderTargetWeights
              );
          }
          setSize(_, I) {
            this.edgeDetectionMaterial.setSize(_, I),
              this.weightsMaterial.setSize(_, I),
              this.renderTargetEdges.setSize(_, I),
              this.renderTargetWeights.setSize(_, I);
          }
          dispose() {
            let { searchTexture: _, areaTexture: I } = this.weightsMaterial;
            null !== _ && null !== I && (_.dispose(), I.dispose()),
              super.dispose();
          }
          static get searchImageDataURL() {
            return Ei;
          }
          static get areaImageDataURL() {
            return Er;
          }
        },
        Eh = `uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;
#if VIGNETTE_TECHNIQUE == 0
float d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));
#else
vec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));
#endif
outputColor=vec4(color,inputColor.a);}`,
        Ec = { DEFAULT: 0, ESKIL: 1 },
        Ed = class extends MG {
          constructor({
            blendFunction: _ = MN.NORMAL,
            technique: I = Ec.DEFAULT,
            eskil: R = !1,
            offset: B = 0.5,
            darkness: z = 0.5,
          } = {}) {
            super("VignetteEffect", Eh, {
              blendFunction: _,
              defines: new Map([["VIGNETTE_TECHNIQUE", I.toFixed(0)]]),
              uniforms: new Map([
                ["offset", new lk(B)],
                ["darkness", new lk(z)],
              ]),
            });
          }
          get technique() {
            return Number(this.defines.get("VIGNETTE_TECHNIQUE"));
          }
          set technique(_) {
            this.technique !== _ &&
              (this.defines.set("VIGNETTE_TECHNIQUE", _.toFixed(0)),
              this.setChanged());
          }
          get eskil() {
            return this.technique === Ec.ESKIL;
          }
          set eskil(_) {
            this.technique = _ ? Ec.ESKIL : Ec.DEFAULT;
          }
          getTechnique() {
            return this.technique;
          }
          setTechnique(_) {
            this.technique = _;
          }
          get offset() {
            return this.uniforms.get("offset").value;
          }
          set offset(_) {
            this.uniforms.get("offset").value = _;
          }
          getOffset() {
            return this.offset;
          }
          setOffset(_) {
            this.offset = _;
          }
          get darkness() {
            return this.uniforms.get("darkness").value;
          }
          set darkness(_) {
            this.uniforms.get("darkness").value = _;
          }
          getDarkness() {
            return this.darkness;
          }
          setDarkness(_) {
            this.darkness = _;
          }
        };
      function gn(_, I, R, B) {
        var z;
        return (z = _ + (I - _) * 0.75) + (R + (B - R) * 0.75 - z) * 0.875;
      }
      new Float32Array(3),
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array([0, 0, 0]),
        new Float32Array([1, 0, 0]),
        new Float32Array([1, 1, 0]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([1, 0, 0]),
        new Float32Array([1, 0, 1]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([0, 0, 1]),
        new Float32Array([1, 0, 1]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([0, 1, 0]),
        new Float32Array([1, 1, 0]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([0, 1, 0]),
        new Float32Array([0, 1, 1]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([0, 0, 1]),
        new Float32Array([0, 1, 1]),
        new Float32Array([1, 1, 1]),
        new Float32Array(2),
        new Float32Array(2),
        new Float32Array([0, -0.25, 0.25, -0.125, 0.125, -0.375, 0.375]),
        new Float32Array([0, 0]),
        new Float32Array([0.25, -0.25]),
        new Float32Array([-0.25, 0.25]),
        new Float32Array([0.125, -0.125]),
        new Float32Array([-0.125, 0.125]),
        new Uint8Array([0, 0]),
        new Uint8Array([3, 0]),
        new Uint8Array([0, 3]),
        new Uint8Array([3, 3]),
        new Uint8Array([1, 0]),
        new Uint8Array([4, 0]),
        new Uint8Array([1, 3]),
        new Uint8Array([4, 3]),
        new Uint8Array([0, 1]),
        new Uint8Array([3, 1]),
        new Uint8Array([0, 4]),
        new Uint8Array([3, 4]),
        new Uint8Array([1, 1]),
        new Uint8Array([4, 1]),
        new Uint8Array([1, 4]),
        new Uint8Array([4, 4]),
        new Uint8Array([0, 0]),
        new Uint8Array([1, 0]),
        new Uint8Array([0, 2]),
        new Uint8Array([1, 2]),
        new Uint8Array([2, 0]),
        new Uint8Array([3, 0]),
        new Uint8Array([2, 2]),
        new Uint8Array([3, 2]),
        new Uint8Array([0, 1]),
        new Uint8Array([1, 1]),
        new Uint8Array([0, 3]),
        new Uint8Array([1, 3]),
        new Uint8Array([2, 1]),
        new Uint8Array([3, 1]),
        new Uint8Array([2, 3]),
        new Uint8Array([3, 3]),
        gn(0, 0, 0, 0),
        new Float32Array([0, 0, 0, 0]),
        gn(0, 0, 0, 1),
        new Float32Array([0, 0, 0, 1]),
        gn(0, 0, 1, 0),
        new Float32Array([0, 0, 1, 0]),
        gn(0, 0, 1, 1),
        new Float32Array([0, 0, 1, 1]),
        gn(0, 1, 0, 0),
        new Float32Array([0, 1, 0, 0]),
        gn(0, 1, 0, 1),
        new Float32Array([0, 1, 0, 1]),
        gn(0, 1, 1, 0),
        new Float32Array([0, 1, 1, 0]),
        gn(0, 1, 1, 1),
        new Float32Array([0, 1, 1, 1]),
        gn(1, 0, 0, 0),
        new Float32Array([1, 0, 0, 0]),
        gn(1, 0, 0, 1),
        new Float32Array([1, 0, 0, 1]),
        gn(1, 0, 1, 0),
        new Float32Array([1, 0, 1, 0]),
        gn(1, 0, 1, 1),
        new Float32Array([1, 0, 1, 1]),
        gn(1, 1, 0, 0),
        new Float32Array([1, 1, 0, 0]),
        gn(1, 1, 0, 1),
        new Float32Array([1, 1, 0, 1]),
        gn(1, 1, 1, 0),
        new Float32Array([1, 1, 1, 0]),
        gn(1, 1, 1, 1),
        new Float32Array([1, 1, 1, 1]);
      var Eu = class {
          constructor(_, I) {
            (this.enabled = !1),
              (this.effect = new _(I)),
              Object.defineProperty(this, "opacity", {
                enumerable: !0,
                set(_) {
                  this.effect.blendMode.opacity.value = _;
                },
                get() {
                  return this.effect.blendMode.opacity.value;
                },
              }),
              Object.defineProperty(this, "blendFunction", {
                enumerable: !0,
                set(_) {
                  this.effect.blendMode.setBlendFunction(Number(_));
                },
                get() {
                  return this.effect.blendMode.blendFunction;
                },
              }),
              (this.blendFunction = MN.NORMAL);
          }
        },
        Ep = class extends Eu {
          constructor() {
            super(M$), (this.blendFunction = MN.SCREEN);
          }
          set intensity(_) {
            this.effect.intensity = _;
          }
          get intensity() {
            return this.effect.intensity;
          }
          set luminanceThreshold(_) {
            this.effect.luminanceMaterial.threshold = _;
          }
          get luminanceThreshold() {
            return this.effect.luminanceMaterial.threshold;
          }
          set luminanceSmoothing(_) {
            this.effect.luminanceMaterial.smoothing = _;
          }
          get luminanceSmoothing() {
            return this.effect.luminanceMaterial.smoothing;
          }
          set blurScale(_) {
            this.effect.blurPass.scale = _;
          }
          get blurScale() {
            return this.effect.blurPass.scale;
          }
          set kernelSize(_) {
            this.effect.blurPass.kernelSize = _;
          }
          get kernelSize() {
            return this.effect.blurPass.kernelSize;
          }
        },
        Ef = class extends Eu {
          constructor() {
            super(M0);
          }
          set contrast(_) {
            this.effect.uniforms.get("contrast").value = _;
          }
          get contrast() {
            return this.effect.uniforms.get("contrast").value;
          }
          set brightness(_) {
            this.effect.uniforms.get("brightness").value = _;
          }
          get brightness() {
            return this.effect.uniforms.get("brightness").value;
          }
        },
        Em = class extends Eu {
          constructor() {
            super(M4), (this.effect.offset = new rs(0.01, 0.01));
          }
          set offset(_) {
            this.effect.offset.set(_[0] / 1e3, _[1] / 1e3);
          }
          get offset() {
            return [1e3 * this.effect.offset.x, 1e3 * this.effect.offset.y];
          }
        },
        Ev = class extends Eu {
          constructor() {
            super(M1);
          }
        },
        Ey = class extends Eu {
          constructor() {
            super(M8), (this._hue = 0);
          }
          set hue(_) {
            (this._hue = _), this.effect.setHue(_);
          }
          get hue() {
            return this._hue;
          }
          set saturation(_) {
            this.effect.uniforms.get("saturation").value = _;
          }
          get saturation() {
            return this.effect.uniforms.get("saturation").value;
          }
        },
        Ex = class extends Eu {
          constructor() {
            super(Ee), (this.blendFunction = MN.OVERLAY);
          }
        },
        Eb = class extends Eu {
          constructor() {
            super(Ed);
          }
          get eskil() {
            return this.effect.eskil;
          }
          set eskil(_) {
            this.effect.eskil = _;
          }
          get darkness() {
            return this.effect.uniforms.get("darkness").value;
          }
          set darkness(_) {
            this.effect.uniforms.get("darkness").value = _;
          }
          get offset() {
            return this.effect.uniforms.get("offset").value;
          }
          set offset(_) {
            this.effect.uniforms.get("offset").value = _;
          }
        },
        Ew = class extends Eu {
          constructor(_) {
            super(M6, _);
          }
          set focalLength(_) {
            this.effect.circleOfConfusionMaterial.uniforms.focalLength.value =
              _;
          }
          get focalLength() {
            return this.effect.circleOfConfusionMaterial.uniforms.focalLength
              .value;
          }
          set focusDistance(_) {
            this.effect.circleOfConfusionMaterial.uniforms.focusDistance.value =
              _;
          }
          get focusDistance() {
            return this.effect.circleOfConfusionMaterial.uniforms.focusDistance
              .value;
          }
          get bokehScale() {
            return this.effect.bokehScale;
          }
          set bokehScale(_) {
            this.effect.bokehScale = _;
          }
        },
        E_ = class extends Eu {
          constructor() {
            super(Et);
          }
          get granularity() {
            return this.effect.getGranularity();
          }
          set granularity(_) {
            this.effect.setGranularity(_);
          }
        },
        ES = `#define GLSLIFY 1
varying vec2 vUv;varying vec2 vTexCoords[9];uniform vec2 resolution;void main(){vUv=position.xy*0.5+0.5;vec2 texelSize=vec2(1.0)/resolution;vTexCoords[0]=vUv+vec2(-texelSize.x,-texelSize.y);vTexCoords[1]=vUv+vec2(0.0,-texelSize.y);vTexCoords[2]=vUv+vec2(texelSize.x,-texelSize.y);vTexCoords[3]=vUv+vec2(-texelSize.x,0.0);vTexCoords[4]=vUv+vec2(0.0,0.0);vTexCoords[5]=vUv+vec2(texelSize.x,0.0);vTexCoords[6]=vUv+vec2(-texelSize.x,texelSize.y);vTexCoords[7]=vUv+vec2(0.0,texelSize.y);vTexCoords[8]=vUv+vec2(texelSize.x,texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}`,
        EA = `#define GLSLIFY 1
#include <common>
varying vec2 vUv;varying vec2 vTexCoords[9];uniform sampler2D inputBuffer;uniform sampler2D historyBuffer;uniform sampler2D velocityBuffer;uniform sampler2D depthBuffer;uniform vec2 resolution;
#define USE_YCOCG
#define USE_CATMULL_ROM
const float feedback_min=0.5;const float feedback_max=0.95;vec3 RGB_YCoCg(vec3 c){return vec3(c.x/4.0+c.y/2.0+c.z/4.0,c.x/2.0-c.z/2.0,-c.x/4.0+c.y/2.0-c.z/4.0);}vec3 YCoCg_RGB(vec3 c){return clamp(vec3(c.x+c.y-c.z,c.x+c.z,c.x-c.y-c.z),vec3(0.0),vec3(1.0));}vec4 sample_color(sampler2D tex,vec2 uv){
#ifdef USE_YCOCG
vec4 c=texture(tex,uv);return vec4(RGB_YCoCg(c.rgb),c.a);
#else
return texture(tex,uv);
#endif
}vec4 sample_catmull_rom(sampler2D tex,vec2 uv,vec2 texSize){vec2 samplePos=uv*texSize;vec2 texPos1=floor(samplePos-0.5)+0.5;vec2 f=samplePos-texPos1;vec2 w0=f*(-0.5+f*(1.0-0.5*f));vec2 w1=1.0+f*f*(-2.5+1.5*f);vec2 w2=f*(0.5+f*(2.0-1.5*f));vec2 w3=f*f*(-0.5+0.5*f);vec2 w12=w1+w2;vec2 offset12=w2/(w1+w2);vec2 texPos0=texPos1-1.0;vec2 texPos3=texPos1+2.0;vec2 texPos12=texPos1+offset12;texPos0/=texSize;texPos3/=texSize;texPos12/=texSize;vec4 result=vec4(0.0);result+=texture2D(tex,vec2(texPos12.x,texPos0.y))*w12.x*w0.y;result+=texture2D(tex,vec2(texPos0.x,texPos12.y))*w0.x*w12.y;result+=texture2D(tex,vec2(texPos12.x,texPos12.y))*w12.x*w12.y;result+=texture2D(tex,vec2(texPos3.x,texPos12.y))*w3.x*w12.y;result+=texture2D(tex,vec2(texPos12.x,texPos3.y))*w12.x*w3.y;return result;}vec3 choose_motion_vector(){
#ifdef CHOOSE_LONGEST_MOTION_VECTOR
float longest=-1.0;vec3 v_choose=vec3(-1.0);for(int i=0;i<9;i++){vec3 v=texture2D(velocityBuffer,vTexCoords[i]).rgb;float l=length(v.xy);if(l>longest){longest=l;v_choose=v;}}return v_choose;
#else
float closest_depth=1000.0;vec2 closest_uv_offset=vec2(0.0);for(int i=0;i<9;i++){float neighbor_depth=texture2D(depthBuffer,vTexCoords[i]).r;if(neighbor_depth<closest_depth){closest_uv_offset=vTexCoords[i];closest_depth=neighbor_depth;}}return texture2D(velocityBuffer,closest_uv_offset).rgb;
#endif
}vec4 clipAabb(vec3 aabb_min,vec3 aabb_max,vec4 avg,vec4 input_texel){const float FLT_EPS=0.00000001;vec3 p_clip=0.5*(aabb_max+aabb_min);vec3 e_clip=0.5*(aabb_max-aabb_min)+FLT_EPS;vec4 v_clip=input_texel-vec4(p_clip,avg.w);vec3 v_unit=v_clip.xyz/e_clip;vec3 a_unit=abs(v_unit);float ma_unit=max(a_unit.x,max(a_unit.y,a_unit.z));if(ma_unit>1.0){return vec4(p_clip,avg.w)+v_clip/ma_unit;}else{return input_texel;}}vec3 clip_aabb_variance(in vec3 cOld,in vec3 cNew,in vec3 centre,in vec3 halfSize){if(all(lessThanEqual(abs(cOld-centre),halfSize))){return cOld;}vec3 dir=(cNew-cOld);vec3 near=centre-sign(dir)*halfSize;vec3 tAll=(near-cOld)/dir;float t=0.0001;for(int i=0;i<3;i++){if(tAll[i]>=0.0&&tAll[i]<t){t=tAll[i];}}if(t>=0.0001){return cOld;}return cOld+dir*t;}void main(){vec3 v=choose_motion_vector();vec2 velocity=v.rg;vec2 previousPixelPos=vUv-velocity;vec4 currentColor=sample_color(inputBuffer,vUv);
#ifdef USE_CATMULL_ROM
vec4 previousColor=sample_catmull_rom(historyBuffer,previousPixelPos,resolution);
#else
vec4 previousColor=sample_color(historyBuffer,previousPixelPos);
#endif
#ifdef USE_YCOCG
previousColor=vec4(RGB_YCoCg(previousColor.rgb),previousColor.a);
#endif
vec4 ctl=sample_color(inputBuffer,vTexCoords[0]);vec4 ctc=sample_color(inputBuffer,vTexCoords[1]);vec4 ctr=sample_color(inputBuffer,vTexCoords[2]);vec4 cml=sample_color(inputBuffer,vTexCoords[3]);vec4 cmc=sample_color(inputBuffer,vTexCoords[4]);vec4 cmr=sample_color(inputBuffer,vTexCoords[5]);vec4 cbl=sample_color(inputBuffer,vTexCoords[6]);vec4 cbc=sample_color(inputBuffer,vTexCoords[7]);vec4 cbr=sample_color(inputBuffer,vTexCoords[8]);vec4 cmin=min(ctl,min(ctc,min(ctr,min(cml,min(cmc,min(cmr,min(cbl,min(cbc,cbr))))))));vec4 cmax=max(ctl,max(ctc,max(ctr,max(cml,max(cmc,max(cmr,max(cbl,max(cbc,cbr))))))));vec4 cavg=(ctl+ctc+ctr+cml+cmc+cmr+cbl+cbc+cbr)/9.0;vec4 cmin5=min(ctc,min(cml,min(cmc,min(cmr,cbc))));vec4 cmax5=max(ctc,max(cml,max(cmc,max(cmr,cbc))));vec4 cavg5=(ctc+cml+cmc+cmr+cbc)/5.0;cmin=0.5*(cmin+cmin5);cmax=0.5*(cmax+cmax5);cavg=0.5*(cavg+cavg5);
#ifdef USE_YCOCG
vec2 chroma_extent=vec2(0.25*0.5*(cmax.r-cmin.r));vec2 chroma_center=currentColor.gb;cmin.yz=chroma_center-chroma_extent;cmax.yz=chroma_center+chroma_extent;cavg.yz=chroma_center;
#endif
vec4 previousColorClipped=clamp(previousColor,cmin,cmax);
#ifdef LUMINANCE_DIFFERENCES
#ifdef USE_YCOCG
float lum0=currentColor.r;float lum1=previousColorClipped.r;
#else
float lum0=luminance(currentColor.rgb);float lum1=luminance(previousColorClipped.rgb);
#endif
float unbiased_diff=abs(lum0-lum1)/max(lum0,max(lum1,0.2));float unbiased_weight=1.0-unbiased_diff;float unbiased_weight_sqr=unbiased_weight*unbiased_weight;float k_feedback=mix(feedback_min,feedback_max,unbiased_weight_sqr);vec4 result=mix(currentColor,previousColorClipped,vec4(k_feedback));
#else
const float alpha=0.1;vec4 result=mix(currentColor,previousColorClipped,1.0-alpha);
#endif
#ifdef USE_YCOCG
gl_FragColor=vec4(YCoCg_RGB(result.rgb).rgb,result.a);
#else
gl_FragColor=result;
#endif
}`,
        EE = `#define GLSLIFY 1
varying vec2 vUv;void main(){gl_Position=vec4(position.xy,1.0,1.0);vUv=position.xy*0.5+0.5;}`,
        EC = `#define GLSLIFY 1
layout(location=1)out vec4 gVelocity;varying vec2 vUv;uniform sampler2D inputBuffer;void main(){gl_FragColor=texture2D(inputBuffer,vUv);gVelocity=vec4(0.0);}`,
        ET = class extends aT {
          constructor() {
            super({
              name: "PassthroughMaterial",
              uniforms: { inputBuffer: new lk(null) },
              blending: 0,
              depthWrite: !1,
              depthTest: !1,
              vertexShader: EE,
              fragmentShader: EC,
            });
          }
          set inputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
        },
        ED = class extends MC {
          constructor() {
            super("TAAResolvePass"),
              (this.MRTCompatible = !0),
              (this.needsSwap = !1),
              (this.passThroughMaterial = new ET()),
              (this.resolutionVector = new rs()),
              (this.resolveMaterial = new aT({
                name: "TAAResolveMaterial",
                uniforms: {
                  inputBuffer: new lk(null),
                  historyBuffer: new lk(null),
                  velocityBuffer: new lk(null),
                  depthBuffer: new lk(null),
                  resolution: new lk(new rs()),
                },
                blending: 0,
                depthWrite: !1,
                depthTest: !1,
                vertexShader: ES,
                fragmentShader: EA,
              })),
              (this.historyRenderTarget = new rT(1024, 1024, {
                minFilter: 1006,
                stencilBuffer: !1,
                depthBuffer: !1,
              })),
              (this.historyRenderTarget.texture.name = "TAA.History"),
              (this.resultRenderTarget = new rT(1024, 1024, {
                minFilter: 1006,
                stencilBuffer: !1,
                depthBuffer: !1,
              })),
              (this.resultRenderTarget.texture.name = "TAA.Output");
          }
          setSize(_, I) {
            this.historyRenderTarget.setSize(_, I),
              this.resultRenderTarget.setSize(_, I);
          }
          render(_, I) {
            (this.fullscreenMaterial = this.resolveMaterial),
              (this.resolveMaterial.uniforms.inputBuffer.value = I.texture[0]),
              (this.resolveMaterial.uniforms.velocityBuffer.value =
                I.texture[1]),
              (this.resolveMaterial.uniforms.depthBuffer.value =
                I.depthTexture),
              (this.resolveMaterial.uniforms.historyBuffer.value =
                this.historyRenderTarget.texture),
              this.resolveMaterial.uniforms.resolution.value.set(
                I.width,
                I.height
              ),
              _.setRenderTarget(this.resultRenderTarget),
              _.render(this.scene, this.camera),
              (this.fullscreenMaterial = this.passThroughMaterial),
              (this.passThroughMaterial.inputBuffer =
                this.resultRenderTarget.texture),
              _.setRenderTarget(this.historyRenderTarget),
              _.render(this.scene, this.camera);
            let R = this.renderToScreen ? null : I;
            (this.fullscreenMaterial = this.passThroughMaterial),
              (this.passThroughMaterial.inputBuffer =
                this.resultRenderTarget.texture),
              _.setRenderTarget(R),
              _.render(this.scene, this.camera);
          }
          dispose() {
            this.resultRenderTarget.dispose(),
              this.historyRenderTarget.dispose(),
              this.resolveMaterial.dispose(),
              this.passThroughMaterial.dispose();
          }
        },
        EO = class extends MC {
          constructor(_, I, R) {
            super("TransmissionPass", void 0, I),
              (this.MRTCompatible = !0),
              (this.depthPass = new MF(_, I, {
                renderTarget: R.transmissionDepthTarget,
              })),
              (this.passThroughMaterial = new ET()),
              (this.splineScene = _),
              (this.needsSwap = !1);
          }
          updatePasses(_) {
            (this.passThroughMaterial = new ET()),
              (this.depthPass = new MF(this.splineScene, this.camera, {
                renderTarget: _.transmissionDepthTarget,
              }));
          }
          setCamera(_) {
            this.camera = _;
          }
          setScene(_) {
            this.splineScene = _;
          }
          render(_, I, R) {
            let B = this.camera.layers.mask;
            _.setRenderTarget(_.transmissionRenderTarget),
              (this.fullscreenMaterial = this.passThroughMaterial),
              (this.passThroughMaterial.inputBuffer = I.texture[0]),
              _.clear(),
              _.render(this.scene, this.camera),
              this.camera.layers.disable(3),
              this.depthPass.render(_, I, R),
              (_.shadowMap.needsUpdate = !1),
              (_.shadowMap.autoUpdate = !1);
            let z = this.renderToScreen ? null : I;
            this.camera.layers.set(3),
              _.setRenderTarget(z),
              _.render(this.splineScene, this.camera),
              (this.camera.layers.mask = B);
          }
        },
        EI = new nz(),
        ER = new aT({
          transparent: !0,
          vertexShader: `
        void main() {
            gl_Position = vec4(0.0);
        }
    `,
          fragmentShader: `
        layout(location = 1) out vec4 gVelocity;

        void main() {
            gl_FragColor = vec4(0.0);
			gVelocity = vec4(0.0);
        }
    `,
        }),
        EB = class extends MC {
          constructor(_, I, R) {
            super("OpaquePass", I ?? EI, R),
              (this.MRTCompatible = !0),
              (this.hasTransmissionPass = !1),
              (this.clear = !0),
              (this.clearColorOnly = !1),
              (this.clearDepth = !1),
              (this.needsSwap = !1),
              (this.originalMaterials = new Map()),
              (this.MRTCompatible = _);
          }
          set splatViewer(_) {
            this._splatViewer = _;
          }
          get splatViewer() {
            return this._splatViewer;
          }
          setCamera(_) {
            this.camera = _;
          }
          setScene(_) {
            this.scene = _ ?? EI;
          }
          getScene() {
            return this.scene;
          }
          render(_, I) {
            this.camera.layers.enable(3),
              this.hasTransmissionPass &&
                (this.originalMaterials.clear(),
                this.scene.traverse((_) => {
                  _.layers.isEnabled(3) &&
                    _ instanceof wp &&
                    (this.originalMaterials.set(_.id, _.material),
                    (_.material = ER));
                }),
                (_.shadowMap.needsUpdate = !0),
                (_.shadowMap.autoUpdate = !0)),
              this.camera.layers.enable(8);
            let R = this.renderToScreen ? null : I;
            if (
              (_.setRenderTarget(R),
              this.clearColorOnly && _.clear(!0, !1, !0),
              this.clear && _.clear(),
              this._splatViewer?.splatRenderingInitialized === !0)
            ) {
              let I = _.autoClear;
              (_.autoClear = !1),
                _.render(this.scene, this.camera),
                this._splatViewer.update(),
                _.render(this._splatViewer.splatMesh, this.camera),
                (_.autoClear = I);
            } else _.render(this.scene, this.camera);
            this.clearDepth && _.clear(!1, !0, !1),
              this.hasTransmissionPass &&
                this.originalMaterials.forEach((_, I) => {
                  let R = this.scene.getObjectById(I);
                  R && (R.material = _);
                });
          }
        },
        EL = class {
          constructor(
            _,
            {
              depthBuffer: I = !0,
              stencilBuffer: R = !1,
              multisampling: B = 0,
              frameBufferType: z = 0,
            } = {}
          ) {
            (this.renderer = _),
              (this.helperStartIndex = 0),
              (this.copyPass = new MT()),
              (this.depthTexture = null),
              (this.timer = new MZ()),
              (this._width = 1),
              (this._height = 1),
              (this.passes = []),
              (this.helperPasses = []),
              (this.autoRenderToScreen = !0),
              (this.inputBuffer = this.createBuffer(
                I,
                R,
                z,
                B,
                !0,
                "input buffer mrt"
              )),
              (this.inputBufferSingle = this.createBuffer(
                I,
                R,
                z,
                B,
                !1,
                " input buffer single"
              )),
              this.inputBufferSingle.texture.dispose(),
              this.inputBufferSingle.depthTexture.dispose(),
              (this.inputBufferSingle.texture = this.inputBuffer.texture[0]),
              (this.inputBufferSingle.depthTexture =
                this.inputBuffer.depthTexture),
              (this.outputBuffer = this.inputBuffer.clone()),
              (this.outputBuffer.name = "output buffer mrt"),
              (this.outputBufferSingle = this.createBuffer(
                I,
                R,
                z,
                B,
                !1,
                "output buffer single"
              )),
              this.outputBufferSingle.texture.dispose(),
              this.outputBufferSingle.depthTexture.dispose(),
              (this.outputBufferSingle.texture = this.outputBuffer.texture[0]),
              (this.outputBufferSingle.depthTexture =
                this.outputBuffer.depthTexture),
              this.setRenderer(_);
          }
          get multisampling() {
            return this.inputBuffer.samples || 0;
          }
          set multisampling(_) {
            let I = this.inputBuffer,
              R = this.multisampling;
            R > 0 && _ > 0
              ? ((this.inputBuffer.samples = _),
                (this.outputBuffer.samples = _),
                this.inputBuffer.dispose(),
                this.outputBuffer.dispose())
              : R !== _ &&
                (this.inputBuffer.dispose(),
                this.outputBuffer.dispose(),
                console.log("creating new input buffer"),
                (this.inputBuffer = this.createBuffer(
                  I.depthBuffer,
                  I.stencilBuffer,
                  I.texture.type,
                  _,
                  !0,
                  "new input buffer"
                )),
                (this.inputBuffer.depthTexture = this.depthTexture),
                (this.outputBuffer = this.inputBuffer.clone()));
          }
          getTimer() {
            return this.timer;
          }
          getRenderer() {
            return this.renderer;
          }
          setRenderer(_) {
            if (((this.renderer = _), null !== _)) {
              let I = _.getSize(new rs()),
                R = _.getContext().getContextAttributes()?.alpha ?? !1,
                B = this.inputBuffer.texture[0].type;
              for (let z of (1009 === B &&
                3001 === _.outputEncoding &&
                ((this.inputBuffer.texture[0].encoding = 3001),
                (this.outputBuffer.texture[0].encoding = 3001),
                this.inputBuffer.dispose(),
                this.outputBuffer.dispose(),
                console.log("doing some kinda dispose??")),
              (_.autoClear = !1),
              this.setSize(I.width, I.height, !1),
              this.passes))
                z.initialize(_, R, B);
            }
          }
          replaceRenderer(_, I = !0) {
            let R = this.renderer,
              B = R.domElement.parentNode;
            return (
              this.setRenderer(_),
              I &&
                null !== B &&
                (B.removeChild(R.domElement), B.appendChild(_.domElement)),
              R
            );
          }
          createDepthTexture() {
            let _ = (this.depthTexture = new nR(this._width, this._height));
            return (
              (this.inputBuffer.depthTexture = _),
              this.inputBuffer.dispose(),
              this.inputBuffer.stencilBuffer
                ? ((_.format = 1027), (_.type = 1020))
                : (_.type = 1014),
              _
            );
          }
          deleteDepthTexture() {
            if (null !== this.depthTexture)
              for (let _ of (this.depthTexture.dispose(),
              (this.depthTexture = null),
              (this.inputBuffer.depthTexture = null),
              this.inputBuffer.dispose(),
              this.passes))
                _.setDepthTexture(null);
          }
          createBuffer(_, I, R, B, z, k) {
            let V = this.renderer,
              j = null === V ? new rs() : V.getDrawingBufferSize(new rs()),
              G = {
                minFilter: 1006,
                magFilter: 1006,
                wrapS: 1001,
                wrapT: 1001,
                stencilBuffer: I,
                depthBuffer: _,
              },
              q;
            return (
              B > 0
                ? ((q = new rT(j.width, j.height, G)).samples = B)
                : (z
                    ? ((q = new rB(
                        j.width,
                        j.height,
                        2,
                        G
                      )).texture[1].type = 1016)
                    : (q = new rT(j.width, j.height, G)),
                  (q.depthTexture = new nR(2048, 2048)),
                  (q.depthTexture.type = 1015)),
              1009 === R &&
                null !== V &&
                3001 === V.outputEncoding &&
                (Array.isArray(q.texture)
                  ? q.texture.forEach((_) => (_.encoding = 3001))
                  : (q.texture.encoding = 3001)),
              Array.isArray(q.texture)
                ? q.texture.forEach((_, I) => {
                    (_.name = `EffectComposer.Buffer ${z} ${I}`),
                      (_.generateMipmaps = !1);
                  })
                : ((q.texture.name = `EffectComposer.Buffer ${z}`),
                  (q.texture.generateMipmaps = !1)),
              (q.name = k),
              q
            );
          }
          addPass(_, I) {
            let R = this.passes,
              B = this.renderer,
              z = B.getDrawingBufferSize(new rs()),
              k = B.getContext().getContextAttributes()?.alpha ?? !1,
              V;
            if (
              (_.MRTCompatible && (V = this.inputBuffer.texture[0].type),
              _.MRTCompatible || (V = this.inputBuffer.texture.type),
              _.setRenderer(B),
              _.setSize(z.width, z.height),
              _.initialize(B, k, V),
              this.autoRenderToScreen &&
                (R.length > 0 && (R[R.length - 1].renderToScreen = !1),
                _.renderToScreen && (this.autoRenderToScreen = !1)),
              void 0 !== I ? R.splice(I, 0, _) : R.push(_),
              this.autoRenderToScreen && (R[R.length - 1].renderToScreen = !0),
              _.needsDepthTexture || null !== this.depthTexture)
            ) {
              if (null === this.depthTexture) {
                let I = this.createDepthTexture();
                for (_ of R) _.setDepthTexture(I);
              } else _.setDepthTexture(this.depthTexture);
            }
          }
          setHelperStartIndex(_) {
            this.helperStartIndex = _;
          }
          removePass(_) {
            let I = this.passes,
              R = I.indexOf(_);
            -1 !== R &&
              I.splice(R, 1).length > 0 &&
              (null !== this.depthTexture &&
                (I.reduce((_, I) => _ || I.needsDepthTexture, !1) ||
                  (_.getDepthTexture() === this.depthTexture &&
                    _.setDepthTexture(null),
                  this.deleteDepthTexture())),
              this.autoRenderToScreen &&
                R === I.length &&
                ((_.renderToScreen = !1),
                I.length > 0 && (I[I.length - 1].renderToScreen = !0)));
          }
          removeAllPasses() {
            let _ = this.passes;
            this.deleteDepthTexture(),
              _.length > 0 &&
                (this.autoRenderToScreen &&
                  (_[_.length - 1].renderToScreen = !1),
                (this.passes = []));
          }
          render(_) {
            let I = this.renderer,
              R = this.copyPass,
              B = this.inputBuffer,
              z = this.outputBuffer,
              k = this.inputBufferSingle,
              V = this.outputBufferSingle,
              j = !1,
              G,
              q,
              X,
              Q;
            for (let $ of (void 0 === _ && (_ = this.timer.update().getDelta()),
            this.passes))
              $.enabled &&
                ($.MRTCompatible
                  ? $.render(I, B, z, _, j)
                  : $.render(I, k, V, _, j),
                $.needsSwap &&
                  (j &&
                    ((R.renderToScreen = $.renderToScreen),
                    (G = I.getContext()),
                    (q = I.state.buffers.stencil).setFunc(
                      G.NOTEQUAL,
                      1,
                      4294967295
                    ),
                    R.render(I, B, z, _, j),
                    q.setFunc(G.EQUAL, 1, 4294967295)),
                  (X = B),
                  (Q = k),
                  (B = z),
                  (k = V),
                  (z = X),
                  (V = Q)),
                $ instanceof MX ? (j = !0) : $ instanceof MP && (j = !1));
          }
          setSize(_, I, R) {
            let B = this.renderer;
            if (
              ((this._width = _),
              (this._height = I),
              void 0 === _ || void 0 === I)
            ) {
              let R = B.getSize(new rs());
              (_ = R.width), (I = R.height);
            }
            B.setSize(_, I, R);
            let z = B.getDrawingBufferSize(new rs());
            for (let _ of (this.inputBuffer.setSize(z.width, z.height),
            this.outputBuffer.setSize(z.width, z.height),
            this.inputBufferSingle.setSize(z.width, z.height),
            this.outputBufferSingle.setSize(z.width, z.height),
            this.passes))
              _.setSize(z.width, z.height);
          }
          reset() {
            let _ = this.timer.isAutoResetEnabled();
            this.dispose(),
              (this.autoRenderToScreen = !0),
              this.timer.setAutoResetEnabled(_);
          }
          dispose() {
            for (let _ of this.passes) _.dispose();
            (this.passes = []),
              null !== this.inputBuffer && this.inputBuffer.dispose(),
              null !== this.outputBuffer && this.outputBuffer.dispose(),
              null !== this.inputBufferSingle &&
                this.inputBufferSingle.dispose(),
              null !== this.outputBufferSingle &&
                this.outputBufferSingle.dispose(),
              this.deleteDepthTexture(),
              this.copyPass.dispose(),
              this.timer.dispose();
          }
        },
        Ez = new aT({
          name: "CombineMaterial",
          uniforms: { inputBufferA: new lk(null), inputBufferB: new lk(null) },
          blending: 0,
          depthWrite: !1,
          depthTest: !1,
          vertexShader: `
varying vec2 vUv;
void main() {
    gl_Position = vec4(position.xy, 1.0, 1.0);
    vUv = position.xy * 0.5 + 0.5;
}
`,
          fragmentShader: `
    varying vec2 vUv;
    uniform sampler2D inputBufferA;
    uniform sampler2D inputBufferB;

    // TODO: Why do we need these when postpro of framemode is enabled???
    layout(location = 1) out vec4 gVelocity;

    void main() {
	vec4 resA = texture2D(inputBufferA, vUv);
	vec4 resB = texture2D(inputBufferB, vUv);
    float a = resA.a + resB.a * ( 1.0 - resA.a );

	vec4 res;
	res.rgb =  resA.rgb + (resB.rgb * (1.0 - resA.a));
	res.a = resA.a + resB.a * (1.0 - resA.a);
	gl_FragColor = res;
    gVelocity = vec4(0.0);
    }
`,
        }),
        EF = class extends MC {
          constructor(_) {
            super("HelperPass", void 0, _),
              (this.MRTCompatible = !1),
              (this.fullscreenMaterial = Ez),
              (this.helperPass = new EB(!1, void 0, this.camera)),
              (this.helperPass.hasTransmissionPass = !1),
              (this.helperPass.clear = !1),
              (this.helperPass.renderToScreen = !1),
              (this.helperPassOnTop = new EB(!1, void 0, this.camera)),
              (this.helperPassOnTop.hasTransmissionPass = !1),
              (this.helperPassOnTop.clear = !1),
              (this.helperPassOnTop.renderToScreen = !1);
            let I = new Eo({ preset: En.LOW, edgeDetectionMode: Mc.COLOR });
            (this.effectPass = new MH(this.camera, I)),
              (this.rt = new rT(10, 10, {
                minFilter: 1006,
                magFilter: 1006,
                wrapS: 1001,
                wrapT: 1001,
                depthBuffer: !0,
              }));
          }
          setSize(_, I) {
            this.rt.setSize(_, I), this.effectPass.setSize(_, I);
          }
          set sceneHelpers(_) {
            this.helperPass.setScene(_);
          }
          get sceneHelpers() {
            return this.helperPass.getScene();
          }
          set sceneHelpersOnTop(_) {
            this.helperPassOnTop.setScene(_);
          }
          get sceneHelpersOnTop() {
            return this.helperPassOnTop.getScene();
          }
          setCamera(_) {
            this.helperPass.setCamera(_), this.helperPassOnTop.setCamera(_);
          }
          initialize(_, I, R) {
            super.initialize(_, I, R), this.effectPass.initialize(_, I, R);
          }
          dispose() {
            super.dispose(), this.rt.dispose(), this.effectPass.dispose();
          }
          render(_, I, R) {
            this.rt.depthTexture = I.depthTexture;
            let B = _.getClearAlpha();
            _.setClearAlpha(0),
              (this.helperPass.clearDepth = !0),
              (this.helperPass.clearColorOnly = !0),
              this.helperPass.render(_, this.rt),
              this.helperPassOnTop.render(_, this.rt),
              (this.effectPass.renderToScreen = !1),
              this.effectPass.render(_, this.rt, R),
              (this.fullscreenMaterial.uniforms.inputBufferA.value = R.texture),
              (this.fullscreenMaterial.uniforms.inputBufferB.value = I.texture),
              _.setClearAlpha(B),
              _.setRenderTarget(null),
              _.clear(),
              _.render(this.scene, this.camera);
          }
        },
        Ek = `#define GLSLIFY 1
#include <skinning_pars_vertex>
out vec3 n;void main(){
#include <beginnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <begin_vertex>
#include <skinning_vertex>
vec4 view_space=viewMatrix*modelMatrix*vec4(transformed,1.0);gl_Position=projectionMatrix*view_space;n=normalize(transformedNormal);}`,
        EV = `#define GLSLIFY 1
in vec3 n;void main(){gl_FragColor=vec4(n,1.0);}`,
        Ej = `#define GLSLIFY 1
out vec2 v_uv;void main(){v_uv=uv;gl_Position=vec4(position.xy,1.0,1.0);}`,
        EG = `#define GLSLIFY 1
in vec2 v_uv;const float pi=3.14159265;const float num_steps=4.0;const float num_directions=4.0;uniform float near;uniform float far;uniform float fov;uniform vec4 proj_info;uniform bool is_ortho;uniform vec2 resolution;uniform float radius_of_influence;uniform float radius_in_screen_space;uniform float exponent;uniform vec3 ao_color;uniform float bias;uniform sampler2D texture_depth;uniform sampler2D texture_normals;uniform sampler2D texture_blue_noise;uniform sampler2D texture_blue_noise_in_disk;uniform sampler2D texture_color_pass;uniform int frame_index;uniform bool fog_enabled;uniform float fog_near;uniform float fog_far;vec3 uv_to_view_space(vec2 uv,float eye_z){return vec3((uv*proj_info.xy+proj_info.zw)*(is_ortho ? 1.0 : eye_z),eye_z);}float linearize_depth(float depth_sampled){float z=is_ortho ? depth_sampled : depth_sampled*2.0-1.0;return mix((2.0*near*far)/(far+near-z*(far-near)),near+z*(far-near),float(is_ortho));}vec3 get_view_position(vec2 uv_coords){float linear_depth=linearize_depth(texture(texture_depth,uv_coords).x);return uv_to_view_space(uv_coords,linear_depth);}vec3 min_difference(vec3 p,vec3 right,vec3 left){vec3 v1=right-p;vec3 v2=p-left;return(dot(v1,v1)<dot(v2,v2))? v1 : v2;}vec3 rebuild_normal(in vec2 uv,in vec3 p){vec2 one_over_resolution=1.0/resolution;vec3 r=get_view_position(uv+vec2(one_over_resolution.x,0));vec3 l=get_view_position(uv+vec2(-one_over_resolution.x,0));vec3 t=get_view_position(uv+vec2(0,one_over_resolution.y));vec3 b=get_view_position(uv+vec2(0,-one_over_resolution.y));return normalize(cross(min_difference(p,r,l),min_difference(p,t,b)));}float falloff(float distance_squared){float neg_inv_r2=-1.0/(radius_of_influence*radius_of_influence);return distance_squared*neg_inv_r2+1.0;}float ao_contribution(vec3 P,vec3 N,vec3 S){vec3 to_sample=S-P;float norm_squared=dot(to_sample,to_sample);float norm=sqrt(norm_squared);float cos_theta=dot(N,to_sample)/norm;return clamp(cos_theta-bias,0.0,1.0)*clamp(falloff(norm_squared),0.0,1.0);}float compute_ambient_occlusion(vec2 uv,float radius_in_screen_space,vec3 pc,vec3 view_space_n){vec2 one_over_resolution=1.0/resolution;ivec2 noise_uv=ivec2(int(mod(gl_FragCoord.x,128.0)),int(mod(gl_FragCoord.y,128.0)));float noise=texelFetch(texture_blue_noise,noise_uv,0).r;noise=fract(noise+0.61803398875*float(frame_index));float theta=noise*2.0*3.1415;float ct=cos(theta);float st=sin(theta);float step_size=radius_in_screen_space/(num_steps+1.0);const float angle_step=2.0*pi/num_directions;float contribution=0.0;for(int i=0;i<int(num_directions);++i){float current_pixel=step_size+1.0;for(int j=0;j<int(num_steps);++j){int index=i*int(num_steps)+j;vec2 blue_noise_sample=texelFetch(texture_blue_noise_in_disk,ivec2(index,0),0).rg;vec2 disk_point;disk_point.x=blue_noise_sample.x*ct-blue_noise_sample.y*st;disk_point.y=blue_noise_sample.x*st+blue_noise_sample.y*ct;vec2 sample_direction=disk_point;vec2 snapped_uv=round(current_pixel*sample_direction)*one_over_resolution+uv;vec3 ps=get_view_position(snapped_uv);current_pixel+=step_size;contribution+=ao_contribution(pc,view_space_n,ps);}}float mult=1.0/(1.0-bias);contribution*=mult/(num_directions*num_steps);return clamp(1.0-contribution*2.0,0.0,1.0);}
#define USE_GBUFFER_NORMALS
void main(){vec3 view_space_p=get_view_position(v_uv);
#ifdef USE_GBUFFER_NORMALS
vec3 view_space_n=texture(texture_normals,v_uv).rgb;view_space_n.z*=-1.0;
#else
vec3 view_space_n=-rebuild_normal(v_uv,view_space_p);
#endif
float radius_ss=radius_in_screen_space/(is_ortho ? 1.0 : view_space_p.z);float ao=compute_ambient_occlusion(v_uv,radius_ss,view_space_p,view_space_n);float final=pow(ao,exponent);if(view_space_p.z>=far){final=1.0;}vec3 color=mix(ao_color,vec3(1.0),final);if(fog_enabled){float fog_factor=smoothstep(fog_near,fog_far,view_space_p.z);color=mix(color,vec3(1.0),fog_factor);}gl_FragColor=vec4(color,1.0);}`,
        EH = `#define GLSLIFY 1
out vec2 v_uv;void main(){gl_Position=vec4(position.xy,1.0,1.0);v_uv=uv;}`,
        EW = `#define GLSLIFY 1
in vec2 v_uv;uniform sampler2D texture_ao_lrez;uniform sampler2D texture_depth_lrez;uniform sampler2D texture_depth_hrez;uniform float near;uniform float far;float linearize_depth(float depth_sampled){float z=depth_sampled*2.0-1.0;return(2.0*near*far)/(far+near-z*(far-near));}vec2 nearest_depth_filter(in vec2 uv){vec2 resolution=vec2(textureSize(texture_depth_lrez,0));vec2 texel_size=1.0/resolution;vec2 offset=uv-0.5*texel_size;float d_hrez=texture(texture_depth_hrez,uv).r;float a=abs(d_hrez-texture(texture_depth_lrez,offset).r);float b=abs(d_hrez-texture(texture_depth_lrez,offset+vec2(texel_size.x,0.0)).r);float c=abs(d_hrez-texture(texture_depth_lrez,offset+vec2(0.0,texel_size.y)).r);float d=abs(d_hrez-texture(texture_depth_lrez,offset+vec2(texel_size.x,texel_size.y)).r);float min_diff=min(a,min(b,min(c,d)));if(min_diff==a)return offset;if(min_diff==b)return offset+vec2(texel_size.x,0.0);if(min_diff==c)return offset+vec2(0.0,texel_size.y);if(min_diff==d)return offset+vec2(texel_size.x,texel_size.y);}void main(){
#ifdef DEBUG
float d_lrez=texture(texture_depth_lrez,v_uv).r;float d_hrez=texture(texture_depth_hrez,v_uv).r;float output_d=mix(linearize_depth(d_lrez)/far,linearize_depth(d_hrez)/far,step(0.5,v_uv.x));gl_FragColor=vec4(vec3(output_d),1.0);
#else
vec2 filtered_uv=nearest_depth_filter(v_uv);vec4 ao=texture(texture_ao_lrez,filtered_uv);gl_FragColor=vec4(ao.rgb,1.0);gl_FragColor=ao;
#endif
}`,
        Eq = [
          [0.478712, 0.875764],
          [-0.337956, -0.793959],
          [-0.955259, -0.028164],
          [0.864527, 0.325689],
          [0.209342, -0.395657],
          [-0.106779, 0.672585],
          [0.156213, 0.235113],
          [-0.413644, -0.082856],
          [-0.415667, 0.323909],
          [0.141896, -0.93998],
          [0.954932, -0.182516],
          [-0.766184, 0.410799],
          [-0.434912, -0.458845],
          [0.415242, -0.078724],
          [0.728335, -0.491777],
          [-0.058086, -0.066401],
          [0.20299, 0.686837],
          [-0.808362, -0.556402],
          [0.507386, -0.640839],
          [-0.723494, -0.22924],
          [0.48974, 0.317826],
          [-0.622663, 0.765301],
          [-0.01064, 0.929347],
          [0.663146, 0.647618],
          [-0.096674, -0.413835],
          [0.525945, -0.321063],
          [-0.122533, 0.366019],
          [0.195235, -0.687983],
          [-0.563203, 0.098748],
          [0.418563, 0.561335],
          [-0.378595, 0.800367],
          [0.826922, 0.001024],
          [-0.085372, -0.766651],
          [-0.92192, 0.183673],
          [-0.590008, -0.721799],
          [0.167751, -0.164393],
          [0.032961, -0.56253],
          [0.6329, -0.107059],
          [-0.46408, 0.569669],
          [-0.173676, -0.958758],
          [-0.242648, -0.234303],
          [-0.275362, 0.157163],
          [0.382295, -0.795131],
          [0.562955, 0.115562],
          [0.190586, 0.470121],
          [0.770764, -0.297576],
          [0.237281, 0.93105],
          [-0.666642, -0.455871],
          [-0.905649, -0.298379],
          [0.33952, 0.157829],
          [0.701438, -0.7041],
          [-0.062758, 0.160346],
          [-0.220674, 0.957141],
          [0.642692, 0.432706],
          [-0.77339, -0.015272],
          [-0.671467, 0.24688],
          [0.158051, 0.062859],
          [0.806009, 0.527232],
          [-0.05762, -0.247071],
          [0.333436, -0.51671],
          [-0.550658, -0.315773],
          [-0.652078, 0.589846],
          [0.008818, 0.530556],
          [-0.210004, 0.519896],
        ],
        EY = new aT({ vertexShader: Ek, fragmentShader: EV }),
        EX = new aT({
          vertexShader: EH,
          fragmentShader: EW,
          uniforms: {
            texture_ao_lrez: new lk(null),
            texture_depth_lrez: new lk(null),
            texture_depth_hrez: new lk(null),
            near: new lk(null),
            far: new lk(null),
          },
        }),
        EQ = class extends MC {
          constructor(_, I) {
            super("AmbientOcclusionPass", void 0, I),
              (this.fogEnabled = !1),
              (this.fogNear = 1),
              (this.fogFar = 1e3),
              (this.frameIndex = 0),
              (this._runHalfRes = !0),
              (this._width = 1),
              (this._height = 1),
              (this.gBuffer = new rT(1024, 1024, {
                type: 1015,
                depthTexture: new nR(1024, 1024),
                minFilter: 1006,
                magFilter: 1006,
              })),
              (this.depthBufferHighRes = new rT(1024, 1024, {
                depthTexture: new nR(1024, 1024),
              })),
              (this.aoBuffer = new rT(1024, 1024, {
                minFilter: 1006,
                magFilter: 1006,
              })),
              (this.splineScene = _),
              (this.splineCamera = I);
            let R = new Float32Array(2 * Eq.length);
            for (let _ = 0; _ < Eq.length; _++) {
              let I = 2 * _;
              (R[I + 0] = Eq[_][0]), (R[I + 1] = Eq[_][1]);
            }
            (this.blueNoiseInDiskTexture = new nV(R, Eq.length, 1, 1030, 1015)),
              (this.blueNoiseInDiskTexture.wrapS = 1e3),
              (this.blueNoiseInDiskTexture.wrapT = 1e3),
              (this.blueNoiseInDiskTexture.needsUpdate = !0),
              (this.hbaoMaterial = new aT({
                vertexShader: Ej,
                fragmentShader: EG,
                uniforms: {
                  near: new lk(null),
                  far: new lk(null),
                  fov: new lk(null),
                  proj_info: new lk(new rM()),
                  is_ortho: new lk(!1),
                  resolution: new lk(new rs()),
                  radius_of_influence: new lk(8),
                  radius_in_screen_space: new lk(1),
                  exponent: new lk(1),
                  ao_color: new lk(new rF()),
                  bias: new lk(0.5),
                  texture_depth: new lk(null),
                  texture_normals: new lk(null),
                  texture_blue_noise: new lk(null),
                  texture_blue_noise_in_disk: new lk(
                    this.blueNoiseInDiskTexture
                  ),
                  frame_index: new lk(0),
                  fog_enabled: new lk(!1),
                  fog_near: new lk(1),
                  fog_far: new lk(1e3),
                },
              })),
              (this.radius = 128),
              (this.aoColor = { r: 0, g: 0, b: 0 }),
              (this.bias = 0.5),
              (this.hbaoMaterial.uniforms.texture_depth.value =
                this.gBuffer.depthTexture),
              (this.hbaoMaterial.uniforms.texture_normals.value =
                this.gBuffer.texture),
              (this.needsSwap = !0),
              (this.aaBuffer = new rT(1024, 1024, {
                minFilter: 1006,
                magFilter: 1006,
                wrapS: 1001,
                wrapT: 1001,
                depthBuffer: !1,
                type: 1015,
              }));
            let B = new Eo({ preset: En.ULTRA, edgeDetectionMode: Mc.COLOR });
            this.effectPass = new MH(this.camera, B);
          }
          initialize(_, I, R) {
            super.initialize(_, I, R), this.effectPass.initialize(_, I, R);
          }
          setBlueNoiseTexture(_) {
            this.hbaoMaterial.uniforms.texture_blue_noise.value = _;
          }
          setSize(_, I) {
            (this._width = _),
              (this._height = I),
              this.depthBufferHighRes.setSize(_, I);
            let R = this._runHalfRes ? 0.5 : 1,
              B = _ * R,
              z = I * R;
            this.gBuffer.setSize(B, z),
              this.aoBuffer.setSize(B, z),
              this.hbaoMaterial.uniforms.resolution.value.set(B, z),
              this.aaBuffer.setSize(B, z),
              this.effectPass.setSize(B, z);
          }
          get runHalfRes() {
            return this._runHalfRes;
          }
          set runHalfRes(_) {
            (this._runHalfRes = _), this.setSize(this._width, this._height);
          }
          setCamera(_) {
            this.splineCamera = _;
          }
          setScene(_) {
            this.splineScene = _;
          }
          render(_, I, R) {
            this.splineScene.overrideMaterial = EY;
            let B = this.splineCamera.layers.mask;
            if (
              (this.splineCamera.layers.set(5),
              _.setRenderTarget(this.gBuffer),
              _.clear(),
              _.render(this.splineScene, this.splineCamera),
              _.setRenderTarget(this.depthBufferHighRes),
              _.clear(),
              _.render(this.splineScene, this.splineCamera),
              (this.splineScene.overrideMaterial = null),
              (this.splineCamera.layers.mask = B),
              (this.hbaoMaterial.uniforms.radius_of_influence.value =
                this.radius),
              this.hbaoMaterial.uniforms.ao_color.value.set(
                this.aoColor.r,
                this.aoColor.g,
                this.aoColor.b
              ),
              (this.hbaoMaterial.uniforms.bias.value = this.bias),
              (this.hbaoMaterial.uniforms.fog_enabled.value = this.fogEnabled),
              (this.hbaoMaterial.uniforms.fog_near.value = this.fogNear),
              (this.hbaoMaterial.uniforms.fog_far.value = this.fogFar),
              (this.hbaoMaterial.uniforms.frame_index.value = this.frameIndex),
              this.frameIndex++,
              this.splineCamera.isPerspectiveCamera)
            ) {
              (this.hbaoMaterial.uniforms.near.value =
                this.splineCamera.perspCamera.near),
                (this.hbaoMaterial.uniforms.far.value =
                  this.splineCamera.perspCamera.far);
              let _ = this.splineCamera.perspCamera.projectionMatrix.elements,
                I = 2 / _[0],
                R = 2 / _[5],
                B = -(1 - _[8]) / _[0],
                z = -(1 + _[9]) / _[5];
              this.hbaoMaterial.uniforms.proj_info.value.set(I, R, B, z);
              let k = this.splineCamera.perspCamera.fov * (Math.PI / 180),
                V =
                  this.hbaoMaterial.uniforms.resolution.value.y /
                  (2 * Math.tan(0.5 * k)),
                j =
                  0.5 *
                  this.hbaoMaterial.uniforms.radius_of_influence.value *
                  V;
              (this.hbaoMaterial.uniforms.radius_in_screen_space.value = j),
                (this.hbaoMaterial.uniforms.is_ortho.value = !1);
            } else {
              (this.hbaoMaterial.uniforms.near.value =
                this.splineCamera.orthoCamera.near),
                (this.hbaoMaterial.uniforms.far.value =
                  this.splineCamera.orthoCamera.far);
              let _ = this.splineCamera.orthoCamera.projectionMatrix.elements,
                I = 2 / _[0],
                R = 2 / _[5],
                B = -(1 + _[12]) / _[0],
                z = -(1 - _[13]) / _[5];
              this.hbaoMaterial.uniforms.proj_info.value.set(I, R, B, z);
              let k = 0.5 * (this.hbaoMaterial.uniforms.resolution.value.y / R),
                V = this.hbaoMaterial.uniforms.radius_of_influence.value * k;
              (this.hbaoMaterial.uniforms.radius_in_screen_space.value = V),
                (this.hbaoMaterial.uniforms.is_ortho.value = !0);
            }
            this.runHalfRes
              ? ((this.fullscreenMaterial = this.hbaoMaterial),
                _.setRenderTarget(this.aoBuffer),
                _.clear(),
                _.render(this.scene, this.camera),
                (this.fullscreenMaterial = EX),
                (EX.uniforms.texture_ao_lrez.value = this.aoBuffer.texture),
                (EX.uniforms.texture_depth_lrez.value =
                  this.gBuffer.depthTexture),
                (EX.uniforms.texture_depth_hrez.value =
                  this.depthBufferHighRes.depthTexture),
                _.setRenderTarget(_.aoRenderTarget),
                _.clear(),
                _.render(this.scene, this.camera))
              : ((this.fullscreenMaterial = this.hbaoMaterial),
                _.setRenderTarget(this.aaBuffer),
                _.clear(),
                _.render(this.scene, this.camera),
                (this.effectPass.renderToScreen = !1),
                this.effectPass.render(_, this.aaBuffer, _.aoRenderTarget));
          }
          dispose() {
            this.gBuffer.dispose(),
              this.depthBufferHighRes.dispose(),
              this.aoBuffer.dispose();
          }
        },
        EZ = `
varying vec2 vUv;
void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
        EK = `
uniform sampler2D tInput;
uniform sampler2D tMap;
uniform vec2 resolution;
varying vec2 vUv;

uniform vec2 uResolution;
uniform vec2 uCoords;

// Draws a rectangle at center <st> with size <size>
float rectangle(vec2 st, vec2 size) {
    size = vec2(0.5) - size * 0.5;
    vec2 uv = vec2(step(size.x, st.x), step(size.y, st.y));
    uv *= vec2(step(size.x, 1.0 - st.x), step(size.y, 1.0 - st.y));

    return uv.x * uv.y;
}

uniform vec2 uSize;
uniform float uScale;
uniform float uDPR;
uniform float uCurrent;
uniform vec3 uSceneColor;

void main() {
    vec2 screenUv = gl_FragCoord.xy / uResolution.xy;
    screenUv *= 1.0 / uDPR;

    vec2 center = vec2(0.5, -0.5);
    vec2 outsideUv = screenUv;
    outsideUv += center;
    outsideUv -= uCoords.xy / uResolution.xy;
    outsideUv = (outsideUv - 0.5) + 0.5;
    outsideUv -= center;
    vec2 s = (uSize / uResolution) * uScale;
    float isOutside = 1.0 - rectangle(outsideUv, s);
    
    vec2 mid = vec2(0.5);
    vec2 insideUv = (screenUv - mid + s * mid) / s;
    vec4 background = texture2D(tInput, screenUv);
    vec4 image = texture2D(tMap, insideUv);
    gl_FragColor = mix(image, background, isOutside);
}
`,
        EJ = class extends MQ {
          constructor() {
            super(
              new aT({
                vertexShader: EZ,
                fragmentShader: EK,
                uniforms: {
                  tInput: new lk(null),
                  tMap: new lk(null),
                  uResolution: new lk(new rs()),
                  uSize: new lk(new rs()),
                  uCoords: new lk(new rs()),
                  uScale: new lk(1),
                  uSceneColor: new lk(new ry(16711680)),
                  uDPR: new lk(1),
                  uCurrent: new lk(0),
                },
              }),
              "tInput"
            ),
              (this.needsSwap = !0);
          }
          get uniforms() {
            return this.fullscreenMaterial.uniforms;
          }
          get texture() {
            return this.uniforms.tMap.value;
          }
          set texture(_) {
            this.uniforms.tMap.value = _;
          }
        },
        E$ = `
void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
        E0 = `
uniform sampler2D toScene;
uniform sampler2D fromScene;
uniform vec2 resolution;

uniform vec2 uResolution;
uniform float uDPR;

uniform float mixRatio;
uniform sampler2D tMixTexture;
uniform int useTexture;
uniform float threshold;

void main() {
	vec2 screenUv = gl_FragCoord.xy / uResolution.xy;
	screenUv *= 1.0 / uDPR;

	vec4 texel1 = texture2D( fromScene, screenUv );
	vec4 texel2 = texture2D( toScene, screenUv );

	if (useTexture==1) {
		
		vec4 transitionTexel = texture2D( tMixTexture, screenUv );
		float r = mixRatio * (1.0 + threshold * 2.0) - threshold;
		float mixf=clamp((transitionTexel.r - r)*(1.0/threshold), 0.0, 1.0);
		
		gl_FragColor = mix( texel1, texel2, mixf );
	} else {
		
		gl_FragColor = mix( texel1, texel2, mixRatio );
		
	}
}
`,
        E1 = class extends MQ {
          constructor() {
            super(
              new aT({
                vertexShader: E$,
                fragmentShader: E0,
                uniforms: {
                  toScene: new lk(null),
                  fromScene: new lk(null),
                  uResolution: new lk(new rs()),
                  uDPR: new lk(1),
                  mixRatio: new lk(0),
                  threshold: new lk(0.1),
                  useTexture: new lk(0),
                  tMixTexture: { value: [][0] },
                },
              }),
              "toScene"
            ),
              (this.needsSwap = !0);
          }
          get uniforms() {
            return this.fullscreenMaterial.uniforms;
          }
          get texture() {
            return this.uniforms.fromScene.value;
          }
          set texture(_) {
            this.uniforms.fromScene.value = _;
          }
        },
        E3 = `
void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
        E4 = `
uniform sampler2D inputBuffer;
uniform sampler2D blurredInputBuffer;
uniform sampler2D overlay;
uniform float blurIntensity;

uniform vec2 uResolution;
uniform float uDPR;

void main() {
	vec2 screenUv = gl_FragCoord.xy / uResolution.xy;
	screenUv *= 1.0 / uDPR;

	vec4 texel1 = texture2D( overlay, screenUv );
	vec4 texel2 = texture2D( inputBuffer, screenUv );
	vec4 texel3 = texture2D( blurredInputBuffer, screenUv );

	float blurMask2 = max(sign(texel1.a), 0.0) * blurIntensity;
    gl_FragColor = mix( mix(texel2, texel3, blurMask2), texel1, texel1.a );
	gl_FragColor.a = 1.0;
}
`,
        E5 = class extends MQ {
          constructor() {
            super(
              new aT({
                vertexShader: E3,
                fragmentShader: E4,
                uniforms: {
                  inputBuffer: new lk(null),
                  blurredInputBuffer: new lk(null),
                  overlay: new lk(null),
                  uResolution: new lk(new rs()),
                  uDPR: new lk(1),
                  blurIntensity: new lk(0),
                },
              })
            ),
              (this._blurEnabled = !1),
              (this.blurTarget = new rT(1, 1, {
                minFilter: 1006,
                magFilter: 1006,
                wrapS: 1001,
                wrapT: 1001,
              })),
              (this.blurPass = new Mq({
                width: window.innerWidth,
                height: window.innerHeight,
                kernelSize: MK.HUGE,
                resolutionScale: 0.25,
              })),
              (this.blurPass.renderToScreen = !1),
              (this.uniforms.blurredInputBuffer.value =
                this.blurTarget.texture);
          }
          get uniforms() {
            return this.fullscreenMaterial.uniforms;
          }
          get texture() {
            return this.uniforms.overlay.value;
          }
          set texture(_) {
            this.uniforms.overlay.value = _;
          }
          setResolution(_, I, R = 1) {
            this.uniforms.uResolution.value.set(_, I).divideScalar(R),
              (this.uniforms.uDPR.value = R),
              this.blurPass.setSize(_, I),
              this.blurTarget.setSize(_, I),
              this.blurPass.setSize(_, I);
          }
          get uiCanvas() {
            return this._uiCanvas;
          }
          set uiCanvas(_) {
            (this._uiCanvas = _),
              _.texture && (this.uniforms.overlay.value = _.texture);
            let I = _.frame;
            if (I) {
              let _ = I.data.backgroundBlur,
                R = _.radius;
              (this._blurEnabled = _.enabled),
                (this.uniforms.blurIntensity.value = this._blurEnabled ? 1 : 0),
                (this.blurPass.scale = R / 3);
            }
          }
          render(_, I, R, B, z) {
            this._blurEnabled &&
              (this.blurPass.setDepthTexture(this.getDepthTexture()),
              this.blurPass.render(_, I, this.blurTarget, B, z)),
              super.render(_, I, R, B, z);
          }
        };
      function M3(_, I) {
        return I && I.enabled && _.push(I.effect), _;
      }
      var UQ = (_) => (Object.values(MN).includes(_) ? _ : MN.NORMAL),
        E6 = class extends i8 {
          constructor(_) {
            super(),
              (this.postprocessingState = gK.defaultData),
              (this._scene = new nz()),
              (this._camera = new AK()),
              (this.effects = new Map()),
              (this.blueNoiseTexture = new nV()),
              (this._renderToScreen = !0),
              (this._isUIOverlayEnabled = !1),
              (this.clock = new ly()),
              (this.renderer = _),
              (this.debug = !1),
              this.effects.set("bloom", new Ep()),
              this.effects.set("chromaticAberration", new Em()),
              this.effects.set("vignette", new Eb()),
              this.effects.set("noise", new Ex()),
              this.effects.set("colorAverage", new Ev()),
              this.effects.set("hueSaturation", new Ey()),
              this.effects.set("brightnessContrast", new Ef()),
              this.effects.set("depthOfField", new Ew()),
              this.effects.set("pixelation", new E_()),
              (this.effectComposer = new EL(this.renderer)),
              (this.effectComposer.autoRenderToScreen = !1),
              (this.opaquePass = new EB(!0, this.scene, this.camera)),
              (this.opaquePass.clear = !0),
              (this.transmissionPass = new EO(
                this.scene,
                this.camera,
                this.renderer
              )),
              (this.aoPass = new EQ(this.scene, this.camera)),
              (this.taaPass = new ED()),
              (this.taaPass.renderToScreen = !1),
              (this.helperPass = new EF(this.camera)),
              (this.helperPass.renderToScreen = !1),
              (this.stylesOverlayPass = new EJ()),
              (this.stylesOverlayPass.enabled = !1),
              (this.uiOverlayPass = new E5()),
              (this.uiOverlayPass.enabled = !1),
              (this.sceneTransitionPass = new E1()),
              (this.sceneTransitionPass.enabled = !1),
              this._initCopyPass(),
              this._initPasses();
          }
          set overlayTexture(_) {
            void 0 !== _
              ? ((this.stylesOverlayPass.texture = _),
                (this.stylesOverlayPass.enabled = !0))
              : (this.stylesOverlayPass.enabled = !1);
          }
          get overlayTexture() {
            return this.stylesOverlayPass.texture;
          }
          set sceneHelpers(_) {
            this.helperPass.sceneHelpers = _;
          }
          get sceneHelpers() {
            return this.helperPass.sceneHelpers;
          }
          set sceneHelpersOnTop(_) {
            this.helperPass.sceneHelpersOnTop = _;
          }
          get sceneHelpersOnTop() {
            return this.helperPass.sceneHelpersOnTop;
          }
          get scene() {
            return this._scene;
          }
          set scene(_) {
            (this._scene = _),
              this.opaquePass.setScene(_),
              this.transmissionPass.setScene(_),
              this.aoPass.setScene(_);
          }
          get camera() {
            return this._camera;
          }
          set camera(_) {
            (this._camera = _),
              this.opaquePass.setCamera(_),
              this.transmissionPass.setCamera(_),
              this.aoPass.setCamera(_),
              this.helperPass.setCamera(_);
          }
          updateRenderToScreen() {
            let _ = !1;
            for (let I = this.effectComposer.passes.length - 1; I >= 0; I--) {
              let R = this.effectComposer.passes[I];
              if (!0 === R.enabled && !_ && this._renderToScreen) {
                (R.renderToScreen = !0), (_ = !0);
                continue;
              }
              R.renderToScreen = !1;
            }
          }
          get isUIOverlayEnabled() {
            return this._isUIOverlayEnabled;
          }
          disableUIOverlay() {
            this._isUIOverlayEnabled = !1;
          }
          enableUIOverlay() {
            this._isUIOverlayEnabled = !0;
          }
          disableHelpers() {
            (this.helperPass.enabled = !1), this.updateRenderToScreen();
          }
          enableHelpers() {
            (this.helperPass.enabled = !0), this.updateRenderToScreen();
          }
          updateBlueNoiseTexture(_) {
            (this.blueNoiseTexture = new nV(_, 128, 128)),
              (this.blueNoiseTexture.wrapS = 1e3),
              (this.blueNoiseTexture.wrapT = 1e3),
              (this.blueNoiseTexture.minFilter = 1003),
              (this.blueNoiseTexture.magFilter = 1003),
              (this.blueNoiseTexture.needsUpdate = !0);
          }
          setAmbientOcclusionParams(_, I, R, B, z, k, V, j) {
            (this.aoPass.enabled = _),
              (this.aoPass.radius = I),
              (this.aoPass.bias = R),
              (this.aoPass.aoColor = B),
              (this.aoPass.fogEnabled = z),
              (this.aoPass.fogNear = k),
              (this.aoPass.fogFar = V),
              !j !== this.aoPass.runHalfRes && (this.aoPass.runHalfRes = !j);
          }
          setTransmissionPassEnabled(_) {
            (this.transmissionPass.enabled = _),
              (this.opaquePass.hasTransmissionPass = _);
          }
          _initPasses() {
            if (
              (this.uvEffectPass?.dispose(),
              this.effectPass?.dispose(),
              this.effectComposer.removeAllPasses(),
              this.transmissionPass.updatePasses(this.renderer),
              this.effectComposer.addPass(this.aoPass),
              this.effectComposer.addPass(this.opaquePass),
              this.effectComposer.addPass(this.transmissionPass),
              this.effectComposer.addPass(this.taaPass),
              this.postprocessingState.enabled)
            ) {
              let _ = [this.effects.get("pixelation")].reduce(M3, []);
              _.length > 0 &&
                ((this.uvEffectPass = new MH(this.camera, ..._)),
                (this.uvEffectPass.renderToScreen = !1),
                this.effectComposer.addPass(this.uvEffectPass));
              let I = [
                this.effects.get("chromaticAberration"),
                this.effects.get("bloom"),
                this.effects.get("colorAverage"),
                this.effects.get("hueSaturation"),
                this.effects.get("brightnessContrast"),
                this.effects.get("vignette"),
                this.effects.get("noise"),
              ].reduce(M3, []);
              I.length > 0 &&
                ((this.effectPass = new MH(this.camera, ...I)),
                (this.effectPass.renderToScreen = !1),
                this.effectComposer.addPass(this.effectPass));
            }
            this.effectComposer.addPass(this.stylesOverlayPass),
              this.effectComposer.addPass(this.uiOverlayPass),
              this.effectComposer.addPass(this.sceneTransitionPass),
              this.effectComposer.addPass(this.helperPass);
          }
          _initCopyPass() {
            if (this._savePass) return;
            let _ = new rs();
            this.renderer.getDrawingBufferSize(_),
              (this._rt = new rT(_.x, _.y, {
                depthBuffer: !1,
                stencilBuffer: !1,
                wrapS: 1e3,
                wrapT: 1e3,
              })),
              (this._rt.samples = 0),
              (this._savePass = new MT(this._rt, !1)),
              (this._savePass.renderToScreen = !1);
          }
          setCopyPass(_) {
            (this._rt = _),
              (this._savePass = new MT(this._rt, !1)),
              (this.renderToScreen = !1);
          }
          get renderToScreen() {
            return this._renderToScreen;
          }
          set renderToScreen(_) {
            if (this._renderToScreen === _) return;
            let I = this.effectComposer;
            I &&
              (!0 === _
                ? I.removePass(this._savePass)
                : I.addPass(this._savePass),
              (this._renderToScreen = _),
              this.updateRenderToScreen());
          }
          set sceneTransitionFromTexture(_) {
            _ !== this.sceneTransitionPass.texture &&
              (null !== _
                ? (this.sceneTransitionPass.enabled = !0)
                : ((this.sceneTransitionPass.enabled = !1),
                  this.updateRenderToScreen()),
              (this.sceneTransitionPass.texture = _));
          }
          get texture() {
            return this._rt && this._rt.texture;
          }
          get renderTarget() {
            return this._rt;
          }
          updatePostprocessing(_) {
            let { enabled: I, ...R } = _,
              B = !1;
            for (let _ of (I !== this.postprocessingState.enabled && (B = !0),
            Object.entries(R))) {
              let I = _[1],
                R = this.effects.get(_[0]);
              if (R)
                for (let [_, z] of (R.enabled !== I.enabled && (B = !0),
                (R.enabled = I.enabled),
                Object.entries(I)))
                  "blendFunction" === _
                    ? (R.blendFunction = UQ(z))
                    : (R[_] = z);
            }
            (this.postprocessingState = _), B && this._initPasses();
          }
          render() {
            this.effectComposer.render(this.clock.getDelta());
          }
          setScissor(_, I, R, B) {
            _ instanceof rM
              ? (this.effectComposer.inputBuffer.scissor.set(
                  _.x,
                  _.y,
                  _.z,
                  _.w
                ),
                this.effectComposer.outputBuffer.scissor.set(
                  _.x,
                  _.y,
                  _.z,
                  _.w
                ))
              : (this.effectComposer.inputBuffer.scissor.set(_, I, R, B),
                this.effectComposer.outputBuffer.scissor.set(_, I, R, B));
            let z = this.renderer.getPixelRatio();
            this.effectComposer.inputBuffer.scissor.multiplyScalar(z),
              this.effectComposer.outputBuffer.scissor.multiplyScalar(z),
              this.renderer.setScissor(_, I, R, B);
          }
          setScissorTest(_) {
            (this.effectComposer.inputBuffer.scissorTest = _),
              (this.effectComposer.outputBuffer.scissorTest = _),
              this.renderer.setScissorTest(_);
          }
          setViewport(_, I, R, B) {
            _ instanceof rM
              ? (this.effectComposer.inputBuffer.viewport.copy(_),
                this.effectComposer.outputBuffer.viewport.copy(_))
              : (this.effectComposer.inputBuffer.viewport.set(_, I, R, B),
                this.effectComposer.outputBuffer.viewport.set(_, I, R, B));
          }
          resize(_, I, R) {
            if ((this.effectComposer.setSize(_, I, R), this._rt)) {
              let R = this.renderer.getPixelRatio();
              this._rt.setSize(_ * R, I * R);
            }
          }
          dispose() {
            this.uvEffectPass?.dispose(),
              this.effectPass?.dispose(),
              this.effectComposer.dispose();
          }
        },
        GQ = (_) => `

// PCSS implementation based on:
// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/
// NOTE: This number affects how big the shadow blur can
// possibly get. Bigger number == bigger blur, but less precise results

const float  gPenumbraFilterSize = 80.0;
const int   gPenumbraSamples = ${_};
const int gShadowSamples = ${_};
const float gShadowSamplesRpc = 1.0f / float(gShadowSamples);

#ifdef USE_SHADOWMAP
    #if NUM_DIR_LIGHT_SHADOWS > 0

        uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
        varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

        struct DirectionalLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };

        uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

    #endif

    #if NUM_SPOT_LIGHT_SHADOWS > 0

        uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
        varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_SHADOWS ];

        struct SpotLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };

        uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

    #endif

    #if NUM_POINT_LIGHT_SHADOWS > 0

        uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
        varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

        struct PointLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
            float shadowCameraNear;
            float shadowCameraFar;
        };

        uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

    #endif

    /*
    #if NUM_RECT_AREA_LIGHTS > 0

        // TODO (abelnation): create uniforms for area light shadows

    #endif
    */

float computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)
{
    float penumbra = 1.0;
    float blockerDepthAvg = 0.0;
    float blockerCount = 0.0;

    #pragma unroll_loop_start
    for(int i = 0; i < gPenumbraSamples; i ++)
    {
        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;
        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );

        if(depth < compare + 0.0001)
        {
            blockerDepthAvg += depth;
            blockerCount++;
        }
    }
    #pragma unroll_loop_end

    if (blockerCount > 0.0)
    {
        blockerDepthAvg /= blockerCount;

        // Compute penumbra
        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);
        penumbra *= penumbra;
        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows

        return clamp(penumbra, 0.00, 1.0);
    }
    return 0.0;
}

float vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)
{
    float shadow         = 0.0f;

    // NOTE: When using TAA, we should use screen space interleaved gradient noise
    vec2 halton = haltonSequence[frameIndex];
    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
    float temporalAngle  = temporalOffset * PI2;

    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);
    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);
    if (penumbra == -1.0) {
        return 1.0;
    }

    #pragma unroll_loop_start
    for (int i = 0; i < gShadowSamples; i++)
    {
        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;
        // Overall blurring offset
        vec2 offset = vogelSample * (shadowRadius * 2.);

        // Penumbra offset
        offset += vogelSample * (penumbra * texelScalar);

        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );
    }
    #pragma unroll_loop_end

    return shadow * gShadowSamplesRpc;
}


    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

    }

    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

        return unpackRGBATo2Half( texture2D( shadow, uv ) );

    }

    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){

        float occlusion = 1.0;

        vec2 distribution = texture2DDistribution( shadow, uv );

        float hard_shadow = step( compare , distribution.x ); // Hard Shadow

        if (hard_shadow != 1.0 ) {

            float distance = compare - distribution.x ;
            float variance = max( 0.00000, distribution.y * distribution.y );
            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

        }
        return occlusion;

    }

    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

        float shadow = 1.0;

        shadowCoord.xyz /= shadowCoord.w;
        shadowCoord.z += shadowBias;

        // if ( something && something ) breaks ATI OpenGL shader compiler
        // if ( all( something, something ) ) using this instead

        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
        bool inFrustum = all( inFrustumVec );

        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );

        bool frustumTest = all( frustumTestVec );

        if ( frustumTest ) {

        #if defined( SHADOWMAP_TYPE_PCF )

            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );

        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )

            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
            float dx = texelSize.x;
            float dy = texelSize.y;

            vec2 uv = shadowCoord.xy;
            vec2 f = fract( uv * shadowMapSize + 0.5 );
            uv -= f * texelSize;

            shadow = (
                texture2DCompare( shadowMap, uv, shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
                     f.x ) +
                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
                     f.x ) +
                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
                     f.y ) +
                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
                     f.y ) +
                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
                          f.x ),
                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
                          f.x ),
                     f.y )
            ) * ( 1.0 / 9.0 );

        #elif defined( SHADOWMAP_TYPE_VSM )

            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

        #else // no percentage-closer filtering:

            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

        #endif

        }

        return shadow;

    }

    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
    // vector suitable for 2D texture mapping. This code uses the following layout for the
    // 2D texture:
    //
    // xzXZ
    //  y Y
    //
    // Y - Positive y direction
    // y - Negative y direction
    // X - Positive x direction
    // x - Negative x direction
    // Z - Positive z direction
    // z - Negative z direction
    //
    // Source and test bed:
    // https://gist.github.com/tschw/da10c43c467ce8afd0c4

    vec2 cubeToUV( vec3 v, float texelSizeY ) {

        // Number of texels to avoid at the edge of each square

        vec3 absV = abs( v );

        // Intersect unit cube

        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
        absV *= scaleToCube;

        // Apply scale to avoid seams

        // two texels less per square (one texel will do for NEAREST)
        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

        // Unwrap

        // space: -1 ... 1 range for each square
        //
        // #X##         dim    := ( 4 , 2 )
        //  # #         center := ( 1 , 1 )

        vec2 planar = v.xy;

        float almostATexel = 1.5 * texelSizeY;
        float almostOne = 1.0 - almostATexel;

        if ( absV.z >= almostOne ) {

            if ( v.z > 0.0 )
                planar.x = 4.0 - v.x;

        } else if ( absV.x >= almostOne ) {

            float signX = sign( v.x );
            planar.x = v.z * signX + 2.0 * signX;

        } else if ( absV.y >= almostOne ) {

            float signY = sign( v.y );
            planar.x = v.x + 2.0 * signY + 2.0;
            planar.y = v.z * signY - 2.0;

        }

        // Transform to UV space

        // scale := 0.5 / dim
        // translate := ( center + 0.5 ) / dim
        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

    }

    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

        float shadow = 1.0;
        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

        // for point lights, the uniform @vShadowCoord is re-purposed to hold
        // the vector from the light to the world-space position of the fragment.
        vec3 lightToPosition = shadowCoord.xyz;

        // dp = normalized distance from light to fragment position
        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
        compare += shadowBias;

        // bd3D = base direction 3D
        vec3 bd3D = normalize( lightToPosition );

        vec2 halton = haltonSequence[frameIndex];
        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
        float temporalAngle  = temporalOffset * PI2;

        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )
            for (int i = 0; i < gShadowSamples; i++) {
                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;

                // Overall blurring offset
                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);

                // NOTE: Removed for now
                // Penumbra offset
                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);

                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );

            }
            return shadow * gShadowSamplesRpc;

        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )
            for (int i = 0; i < 16; i++) {
                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;

                // Overall blurring offset
                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);

                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );

            }
            return shadow * (1.0 / 16.0);
        #else // no percentage-closer filtering

            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );

        #endif

    }

#endif
`,
        E8 = aY.lights_fragment_begin,
        E9 = aY.shadowmask_pars_fragment,
        E7 = null,
        WQ = (_) => {
          switch (_) {
            case "low":
              return 8;
            case "medium":
            default:
              return 16;
            case "high":
              return 32;
          }
        },
        P3 = (_ = "medium") => {
          if (E7 === _) return !1;
          E7 = _;
          let I = WQ(_);
          aY.shadowmap_pars_fragment = GQ(I);
          let R = E8.slice();
          (R = (R = R.replace(
            "getShadow( spotShadowMap[ i ]",
            "getShadow( UNROLLED_LOOP_INDEX + 3, spotShadowMap[ i ]"
          )).replace(
            "getShadow( directionalShadowMap[ i ]",
            "getShadow( UNROLLED_LOOP_INDEX, directionalShadowMap[ i ]"
          )),
            (aY.lights_fragment_begin = R);
          let B = E9.slice();
          return (
            (B = B.replaceAll(
              "getShadow(",
              "getShadow( UNROLLED_LOOP_INDEX, "
            )),
            (aY.shadowmask_pars_fragment = B),
            !0
          );
        },
        Ce = `
attribute vec3 randomColor;
varying vec3 vNormal;
flat out vec3 vColor;

void main()
{
vNormal = normal;
vColor = randomColor;
gl_Position = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));
}
`,
        Cr = `
uniform float depthContrast;
varying vec3 vNormal;
flat in vec3 vColor;
void main()
{
vec3 normal = (normalize(vNormal)).rgb;

float contrastDepth = (gl_FragCoord.z - 0.5) * depthContrast + 0.5;

vec3 resultColor = mix(mix(vColor, normal, 0.2), vec3(contrastDepth), 0.4);
gl_FragColor = vec4(resultColor, vColor.r);
gl_FragColor = vec4(resultColor, vColor.r);
}
`,
        Ca = new aT({
          vertexShader: Ce,
          fragmentShader: Cr,
          uniforms: { depthContrast: { value: 1 } },
        }),
        Cn = new rA(),
        Cl = class extends Dw {
          constructor(_) {
            super(_),
              (this._pixelRatio = this.getPixelRatio()),
              (this.viewportWidth = 1),
              (this.viewportHeight = 1),
              (this.resolution = new rs()),
              (this.pipeline = new E6(this)),
              (this.dummyCamera = new AK()),
              (this.sceneTransitionDuration = 0),
              (this.sceneTransitionTimeRemaining = -1),
              (this.isXRCopyPassSet = !1),
              (this.clear = (_ = !0, I = !0, R = !0) => {
                let B = this.getContext(),
                  z = 0;
                _ && (z |= B.COLOR_BUFFER_BIT),
                  I && (z |= B.DEPTH_BUFFER_BIT),
                  R && (z |= B.STENCIL_BUFFER_BIT),
                  B.clear(z),
                  B.clearBufferfv(B.COLOR, 1, [0, 0, 0, 1]);
              }),
              (this.autoClear = !1);
            let I = this.setPixelRatio.bind(this),
              R = this.setSize.bind(this);
            (this.shadowMap.enabled = !0),
              (this.shadowMap.type = 1),
              (this.dummyCamera.matrixAutoUpdate = !1);
            let B = this.getContext();
            if (B && "drawingBufferColorSpace" in B)
              try {
                B.drawingBufferColorSpace = "display-p3";
              } catch (_) {
                console.warn(_);
              }
            (this.setPixelRatio = (_) => {
              this._pixelRatio !== _ && ((this._pixelRatio = _), I(_));
            }),
              (this.setSize = (_, I, B = !0) => {
                (this.viewportWidth !== _ || this.viewportHeight !== I) &&
                  ((this.viewportWidth = _),
                  (this.viewportHeight = I),
                  R(_, I, B),
                  this.normalRenderTarget?.setSize(
                    _ * this._pixelRatio,
                    I * this._pixelRatio
                  ),
                  this._resizeTransmission(_, I),
                  this.transmissionDepthTarget?.setSize(
                    (_ * this._pixelRatio) / 2,
                    (I * this._pixelRatio) / 2
                  ),
                  this.pipeline.resize(_, I, B));
              }),
              (this._superDispose = this.dispose),
              (this.dispose = this._currentDispose);
          }
          createAORenderTarget() {
            void 0 === this.aoRenderTarget &&
              (this.aoRenderTarget = new rT(
                this.viewportWidth * this._pixelRatio,
                this.viewportHeight * this._pixelRatio,
                {
                  generateMipmaps: !1,
                  minFilter: 1006,
                  magFilter: 1006,
                  wrapS: 1001,
                  wrapT: 1001,
                  depthBuffer: !1,
                }
              ));
          }
          _resizeTransmission(_, I) {
            this.transmissionRenderTarget?.setSize(
              (_ * this._pixelRatio) / (this.hdTransmission ? 1 : 2),
              (I * this._pixelRatio) / (this.hdTransmission ? 1 : 2)
            ),
              this.aoRenderTarget?.setSize(
                (_ * this._pixelRatio) / 1,
                (I * this._pixelRatio) / 1
              );
          }
          get hdTransmission() {
            return 1 === _j.transmissionLod.value;
          }
          set hdTransmission(_) {
            (_j.transmissionLod.value = !0 === _ ? 1 : 2),
              this._resizeTransmission(this.viewportWidth, this.viewportHeight);
          }
          createTransmissionRenderTarget() {
            void 0 === this.transmissionRenderTarget &&
              ((this.transmissionRenderTarget = new rT(
                (this.viewportWidth * this._pixelRatio) /
                  (this.hdTransmission ? 1 : 2),
                (this.viewportHeight * this._pixelRatio) /
                  (this.hdTransmission ? 1 : 2),
                {
                  generateMipmaps: !0,
                  minFilter: 1008,
                  magFilter: 1006,
                  wrapS: 1001,
                  wrapT: 1001,
                  depthBuffer: !1,
                }
              )),
              (this.transmissionDepthTarget = new rT(
                (this.viewportWidth * this._pixelRatio) / 2,
                (this.viewportHeight * this._pixelRatio) / 2,
                { minFilter: 1003, magFilter: 1003, depthBuffer: !1 }
              )));
          }
          createNormalRenderTarget() {
            void 0 === this.normalRenderTarget &&
              (this.normalRenderTarget = new rT(
                this.viewportWidth * this._pixelRatio,
                this.viewportHeight * this._pixelRatio,
                {
                  generateMipmaps: !1,
                  minFilter: 1003,
                  magFilter: 1003,
                  type: 1015,
                  depthTexture: new nR(
                    this.viewportWidth * this._pixelRatio,
                    this.viewportHeight * this._pixelRatio
                  ),
                }
              ));
          }
          renderNormal(_, I, R) {
            this.normalRenderTarget &&
              (this.setClearColor(0),
              R.layers.enable(8),
              R.layers.disable(0),
              R.layers.disable(3),
              I.traverseEntity((_) => {
                _.layers.isEnabled(8) && (_.copyPreviousMatrix = !1);
              }),
              this.setRenderTarget(this.normalRenderTarget),
              this.clear(),
              R instanceof AK
                ? (Ca.uniforms.depthContrast.value = (R.far - R.near) / 1e4)
                : (Ca.uniforms.depthContrast.value = 1),
              (I.overrideMaterial = Ca),
              this.render(I, R),
              this.setClearColor(I.bgColor, I.bgColor.a),
              this.setRenderTarget(null),
              (I.overrideMaterial = _.wireframeState ? T8 : null),
              R.layers.enable(0),
              R.layers.enable(3),
              I.traverseEntity((_) => {
                _.layers.isEnabled(8) && (_.copyPreviousMatrix = !0);
              }));
          }
          renderSplineSceneWithDummyCamera(_, I, R = 1) {
            this.dummyCamera.updateCameraState(I.dataPatched),
              this.dummyCamera.matrix.copy(I.matrixWorld);
            let B = I.height,
              z = I.width,
              k = this.viewportWidth / this.viewportHeight;
            z < B ? (z = B * k) : (B = z / k),
              this.dummyCamera.setViewplaneSize(z, B);
            for (let I = 0; I < R; I++)
              this.renderSplineScene(_, this.dummyCamera);
          }
          renderSplineScene(
            _,
            I,
            {
              sceneHelpers: R,
              sceneHelpersOnTop: B,
              overrideTransmission: z,
              overrideNormal: k,
            } = {}
          ) {
            let V = _ instanceof T7 ? _.activePage : _,
              j = V.visible;
            V.visible = !0;
            let G = V.scene;
            this.xr.enabled &&
              (!1 === this.isXRCopyPassSet &&
                null !== this.getRenderTarget() &&
                (this.pipeline.setCopyPass(this.getRenderTarget()),
                (this.isXRCopyPassSet = !0)),
              this.xr.updateCamera(I)),
              this.setClearColor(V.bgColor, V.bgColor.a),
              V.penumbraSizeArray.forEach((_, I) => {
                _j.penumbraSize.value[I] = _;
              }),
              (_j.pixelRatioNode.value = this.getPixelRatio()),
              0 !== this.resolution.x && 0 !== this.resolution.y
                ? _j.resolution.value.set(this.resolution.x, this.resolution.y)
                : _j.resolution.value.set(
                    this.viewportWidth * this._pixelRatio,
                    this.viewportHeight * this._pixelRatio
                  ),
              void 0 !== k
                ? ((_j.normalRenderTarget.value = k),
                  (_j.normalRenderTargetDepth.value = Cn))
                : G.needsNormal() &&
                  (this.createNormalRenderTarget(),
                  (_j.normalRenderTarget.value =
                    this.normalRenderTarget.texture),
                  (_j.normalRenderTargetDepth.value =
                    this.normalRenderTarget.depthTexture),
                  this.renderNormal(G, V, I));
            let q = V.data.ao,
              X = q.occlusion;
            X &&
              (this.createAORenderTarget(),
              (_j.aoRenderTarget.value = this.aoRenderTarget.texture)),
              (_j.aoEnabled.value = X),
              this.pipeline.setAmbientOcclusionParams(
                q.occlusion,
                q.radius,
                q.bias,
                V.aoColor,
                null !== V.fog,
                V.backupFog.near,
                V.backupFog.far,
                q.aoFullRes
              ),
              this.pipeline.aoPass.setBlueNoiseTexture(
                this.pipeline.blueNoiseTexture
              ),
              this.pipeline.isUIOverlayEnabled &&
              V.uiCanvas?.enabled &&
              V.uiCanvas.texture &&
              V.uiCanvas.texture.image.width > 0
                ? ((V.uiCanvas.width !== this.viewportWidth ||
                    V.uiCanvas.height !== this.viewportHeight) &&
                    V.uiCanvas.applySize({
                      width: this.viewportWidth,
                      height: this.viewportHeight,
                    }),
                  V.uiCanvas.render(),
                  (this.pipeline.uiOverlayPass.uiCanvas = V.uiCanvas),
                  (this.pipeline.uiOverlayPass.enabled = !0),
                  this.pipeline.uiOverlayPass.setResolution(
                    this.domElement.width,
                    this.domElement.height,
                    window.devicePixelRatio
                  ))
                : (this.pipeline.uiOverlayPass.enabled = !1),
              this.pipeline.updateRenderToScreen();
            let Q = !1;
            if (void 0 !== z)
              (_j.transmissionRenderTarget.value = z),
                (_j.transmissionRenderTargetDepth.value = Cn),
                this.pipeline.setTransmissionPassEnabled(!1);
            else {
              var $, et;
              let _ = G.needsTransmission();
              _ &&
                (void 0 === this.transmissionRenderTarget && (Q = !0),
                this.createTransmissionRenderTarget(),
                (_j.transmissionRenderTarget.value =
                  this.transmissionRenderTarget.texture),
                (_j.aspectRatio.value =
                  ($ = this.viewportWidth) >= (et = this.viewportHeight)
                    ? new rs(et / $, 1)
                    : new rs(1, $ / et)),
                (_j.transmissionRenderTargetDepth.value =
                  this.transmissionDepthTarget.texture)),
                this.pipeline.setTransmissionPassEnabled(_);
            }
            I.layers.enable(3),
              I.layers.enable(8),
              (this.pipeline.sceneHelpers = R),
              (this.pipeline.sceneHelpersOnTop = B),
              (this.pipeline.scene = V),
              (this.pipeline.camera = I),
              Q && this.pipeline.transmissionPass.updatePasses(this),
              this.pipeline.postprocessingState === V.postprocessing ||
                (this.pipeline.updatePostprocessing(V.postprocessing),
                R || B || this.pipeline.disableHelpers()),
              void 0 !== this.clearAlphaOverride &&
                this.setClearAlpha(this.clearAlphaOverride),
              (V.overrideMaterial = G.wireframeState ? T8 : null),
              this.pipeline.render(),
              (_j.frameIndex.value = (_j.frameIndex.value + 1) % 16),
              I instanceof AK && I.copyHistory(),
              (V.visible = j);
          }
          renderFromSceneForSceneTransitionPass(_, I, R) {
            (this.pipeline.renderToScreen = !1),
              this.pipeline.renderTarget,
              this.renderSplineScene(_, I),
              (this.pipeline.sceneTransitionFromTexture =
                this.pipeline.renderTarget.texture),
              (this.sceneTransitionDuration = R),
              (this.sceneTransitionTimeRemaining = R),
              (this.pipeline.renderToScreen = !0);
            let B = this.pipeline.sceneTransitionPass.uniforms;
            (B.uDPR.value = window.devicePixelRatio),
              B.uResolution.value
                .set(this.domElement.width, this.domElement.height)
                .divideScalar(window.devicePixelRatio);
          }
          _currentDispose() {
            this._superDispose(),
              this.pipeline.dispose(),
              this.aoRenderTarget?.dispose(),
              this.transmissionRenderTarget?.dispose(),
              this.transmissionDepthTarget?.dispose(),
              this.normalRenderTarget?.dispose(),
              this.normalRenderTarget?.depthTexture?.dispose();
          }
        },
        Cc = class extends Qo(l1) {
          constructor(_, I = 15, R = 10066329) {
            super(_, I, R),
              (this.object = _),
              (this.added = !1),
              (this.name = `DirectionalLightHelper: ${_.uuid}`);
          }
          raycast(_, I) {
            Ko(this.object, Cc.geometryHelper, _, I);
          }
        },
        Cu = class extends Qo(lK) {
          constructor(_, I = 15, R = 6710886) {
            super(_, I, R),
              (this.object = _),
              (this.name = `PointLightHelper: ${_.uuid}`);
          }
          raycast(_, I) {
            Ko(this.object, Cu.geometryHelper, _, I);
          }
        },
        Cp = class extends Qo(lZ) {
          constructor(_, I = 6710886) {
            super(_, I),
              (this.object = _),
              (this.name = `SpotLightHelper: ${_.uuid}`);
          }
          raycast(_, I) {
            Ko(this.object, Cp.geometryHelper, _, I);
          }
          update() {
            if (void 0 !== this.object) {
              let _ = Cp._vector,
                I = this.object.distance ? this.object.distance : 1e3,
                R = I * Math.tan(this.object.angle);
              this.cone.scale.set(R, R, I),
                _.setFromMatrixPosition(this.object.target.matrixWorld),
                this.cone.lookAt(_);
              let B = void 0 !== this.color ? this.color : this.light.color;
              if (this.cone.material instanceof Array)
                for (let _ = 0, I = this.cone.material.length; _ < I; _++)
                  this.cone.material[_].color.set(B);
              else this.cone.material.color.set(B);
            }
          }
        },
        Cf = Cp;
      Cf._vector = new rF();
      var Cg = class extends bf(lm, Cc) {
          constructor(_, I, R) {
            super(),
              this.super_Entity(_, I),
              (this.castShadow = !0),
              (this.shadow.mapSize.width = 2048),
              (this.shadow.mapSize.height = 2048),
              (this.shadow.normalBias = 1),
              this.layers.enable(3);
            let B = this.shadow.camera;
            (B.top = 1250),
              (B.bottom = -1250),
              (B.right = 1250),
              (B.left = -1250),
              (B.near = -1e4),
              (B.far = 2500);
            let z = new l4(this.shadow.camera);
            (z.visible = !1), (this.gizmos.shadowmap = z);
          }
          update() {
            for (let _ in (this.shadow.camera.updateProjectionMatrix(),
            this.gizmos)) {
              let I = this.gizmos[_];
              I instanceof l4 && I.update();
            }
          }
          updateMatrixWorld(_) {
            super.updateMatrixWorld(_),
              this.objectHelper && this.objectHelper.update();
          }
          updateState(_, I) {
            var R;
            this.updateState_Light(_, I);
            let B =
              (void 0 !== _.depth && _.depth !== this.shadow.camera.far) ||
              (void 0 !== _.size && _.size / 2 !== this.shadow.camera.right);
            void 0 !== _.size &&
              ((R = _.size),
              (this.shadow.camera.right = R / 2),
              (this.shadow.camera.left = -R / 2),
              (this.shadow.camera.top = R / 2),
              (this.shadow.camera.bottom = -R / 2),
              (this.shadow.needsUpdate = !0)),
              void 0 !== _.shadowRadius &&
                (this.shadow.radius = _.shadowRadius),
              void 0 !== _.shadowResolution &&
                (this.shadow.mapSize.set(
                  _.shadowResolution,
                  _.shadowResolution
                ),
                this.shadow.map &&
                  (this.shadow.map.dispose(), (this.shadow.map = null))),
              void 0 !== _.penumbraSize && I.scene.markPenumbraSizeDirty(),
              B && this.update();
          }
        },
        Cy = new rF(),
        Cx = new rF(),
        Cb = new rz(),
        C_ = class extends bf(ll, Cf) {
          constructor(_, I, R) {
            super(),
              this.super_Entity(_, I),
              (this.castShadow = !0),
              (this.shadow.mapSize.width = 1024),
              (this.shadow.mapSize.height = 1024),
              (this.shadow.normalBias = 1),
              this.layers.enable(3);
            let B = this.shadow.camera;
            (B.fov = 2 * rr.RAD2DEG * this.angle),
              (B.aspect = 1),
              (B.near = 100),
              (B.far = 2500);
            let z = new l4(this.shadow.camera);
            (z.visible = !1), (this.gizmos.shadowmap = z), this.update();
          }
          update() {
            for (let _ in (this.shadow.camera.updateProjectionMatrix(),
            this.gizmos)) {
              let I = this.gizmos[_];
              I instanceof l4 && I.update();
            }
          }
          updateMatrixWorld(_) {
            super.updateMatrixWorld(_),
              Cx.setFromMatrixPosition(this.matrixWorld),
              Cb.setFromRotationMatrix(this.matrixWorld),
              Cy.copy(this.up)
                .applyQuaternion(Cb)
                .negate()
                .multiplyScalar(this.distance),
              this.target.position.copy(Cx).add(Cy),
              this.target.updateMatrixWorld(),
              this.objectHelper && this.objectHelper.update();
          }
          updateState(_, I) {
            this.updateState_Light(_, I),
              void 0 !== _.distance && (this.distance = _.distance),
              void 0 !== _.decay && (this.decay = _.decay),
              void 0 !== _.angle && (this.angle = _.angle),
              void 0 !== _.penumbra && (this.penumbra = _.penumbra),
              void 0 !== _.shadowRadius &&
                (this.shadow.radius = _.shadowRadius),
              void 0 !== _.penumbraSize && I.scene.markPenumbraSizeDirty(),
              void 0 !== _.shadowResolution &&
                (this.shadow.mapSize.set(
                  _.shadowResolution,
                  _.shadowResolution
                ),
                this.shadow.map &&
                  (this.shadow.map.dispose(), (this.shadow.map = null)));
          }
        };
      function zx(_, I) {
        return [
          [
            _[0][0] * I[0][0] + _[0][1] * I[1][0],
            _[0][0] * I[0][1] + _[0][1] * I[1][1],
          ],
          [
            _[1][0] * I[0][0] + _[1][1] * I[1][0],
            _[1][0] * I[0][1] + _[1][1] * I[1][1],
          ],
        ];
      }
      function L3(_) {
        return [
          [_[0][0], _[1][0]],
          [_[0][1], _[1][1]],
        ];
      }
      ((_) => {
        function o(_) {
          return [_[0], _[3], _[1], _[4], _[2], _[5]];
        }
        (_.identity = function () {
          return [1, 0, 0, 0, 1, 0, 0, 0, 1];
        }),
          (_.copy = function (I, R = _.identity()) {
            for (let _ = 0, B = I.length; _ < B; _++) R[_] = I[_];
            return R;
          }),
          (_.create = function (I, R, B, z, k, V) {
            return _.setAbcdef(_.identity(), I, R, B, z, k, V);
          }),
          (_.setAbcdef = function (_, I, R, B, z, k, V) {
            return (
              (_[0] = I),
              (_[1] = B),
              (_[2] = k),
              (_[3] = R),
              (_[4] = z),
              (_[5] = V),
              _
            );
          }),
          (_.append = function (I, R) {
            let [B, z, k, V, j, G] = o(I),
              [q, X, Q, $, et, er] = o(R);
            return _.create(
              q * B + X * k,
              q * z + X * V,
              Q * B + $ * k,
              Q * z + $ * V,
              et * B + er * k + j,
              et * z + er * V + G
            );
          }),
          (_.prepend = function (I, R) {
            let [B, z, k, V, j, G] = o(I),
              [q, X, Q, $, et, er] = o(R),
              es = B,
              ea = z,
              en = k,
              eo = V;
            return (
              (1 !== q || 0 !== X || 0 !== Q || 1 !== $) &&
                ((es = B * q + z * Q),
                (ea = B * X + z * $),
                (en = k * q + V * Q),
                (eo = k * X + V * $)),
              _.create(es, ea, en, eo, j * q + G * Q + et, j * X + G * $ + er)
            );
          }),
          (_.getAbcdef = o),
          (_.invert = function (I) {
            let [R, B, z, k, V, j] = _.getAbcdef(I),
              G = R * k - B * z;
            return _.create(
              k / G,
              -B / G,
              -z / G,
              R / G,
              (z * j - k * V) / G,
              -(R * j - B * V) / G
            );
          }),
          (_.apply = function ([I, R], B) {
            let [z, k, V, j, G, q] = _.getAbcdef(B);
            return [z * I + V * R + G, k * I + j * R + q];
          }),
          (_.applyInverse = function (I, R) {
            let [B, z, k, V, j, G] = _.getAbcdef(R),
              q = 1 / (B * V + -(k * z)),
              [X, Q] = I;
            return [
              V * q * X + -k * q * Q + (G * k - j * V) * q,
              B * q * Q + -z * q * X + (-G * B + j * z) * q,
            ];
          }),
          (_.scale = function (I, R, B = R) {
            let [z, k, V, j, G, q] = _.getAbcdef(I);
            return _.setAbcdef(I, z * R, k * B, V * R, j * B, G * R, q * B), I;
          }),
          (_.rotate = function (I, R) {
            let B = Math.cos(R),
              z = Math.sin(R),
              [k, V, j, G, q, X] = _.getAbcdef(I);
            return (
              _.setAbcdef(
                I,
                k * B - V * z,
                k * z + V * B,
                j * B - G * z,
                j * z + G * B,
                q * B - X * z,
                q * z + X * B
              ),
              I
            );
          }),
          (_.rotateAround = function (I, R, B) {
            let [z, k] = B,
              V = _.translate(I, -z, -k);
            return (V = _.rotate(V, R)), (V = _.translate(V, z, k));
          }),
          (_.translate = function (I, R, B) {
            let [z, k, V, j, G, q] = _.getAbcdef(I);
            return _.setAbcdef(I, z, k, V, j, G + R, q + B), I;
          }),
          (_.setTranslate = function (I, R, B) {
            let [z, k, V, j] = _.getAbcdef(I);
            return _.setAbcdef(I, z, k, V, j, R, B), I;
          }),
          (_.setPosition = function (I, R, B) {
            let [z, k, V, j] = _.getAbcdef(I);
            return _.setAbcdef(I, z, k, V, j, R, B), I;
          }),
          (_.getScale = function (I) {
            let [R, B, z, k] = _.getAbcdef(I);
            return [Math.sqrt(R * R + B * B), Math.sqrt(z * z + k * k)];
          }),
          (_.getPosition = function (I) {
            let [, , , , R, B] = _.getAbcdef(I);
            return [R, B];
          }),
          (_.getRotation = function (I, R) {
            return _.decompose(I, R).rotation;
          }),
          (_.decompose = function (I, R) {
            let [B, z, k, V, j, G] = _.getAbcdef(I),
              {
                rotation: q,
                scale: X,
                shear: Q,
              } = (function (_) {
                let I, R, B, z, k, V, j, G, q, X, Q, $;
                let [et, er, es] =
                    ((I = (_[0][0] + _[1][1]) / 2),
                    (R = (_[0][0] - _[1][1]) / 2),
                    (B = (_[1][0] + _[0][1]) / 2),
                    (k = Math.sqrt(I * I + (z = (_[1][0] - _[0][1]) / 2) * z)),
                    (V = Math.sqrt(R * R + B * B)),
                    (j = Math.atan2(B, R)),
                    (q = ((G = Math.atan2(z, I)) - j) / 2),
                    (Q = [
                      [Math.cos((X = (G + j) / 2)), Math.sin(X)],
                      [-Math.sin(X), Math.cos(X)],
                    ]),
                    ($ = [
                      [Math.cos(q), Math.sin(q)],
                      [-Math.sin(q), Math.cos(q)],
                    ]),
                    (Q[0][0] *= -1),
                    (Q[0][1] *= -1),
                    ($[0][0] *= -1),
                    ($[1][0] *= -1),
                    [
                      Q,
                      [
                        [k + V, 0],
                        [0, k - V],
                      ],
                      $,
                    ]),
                  ea = zx(et, L3(es)),
                  en = zx(zx(es, er), L3(es));
                return {
                  rotation: Math.atan2(ea[1][0], ea[0][0]),
                  scale: [en[0][0], en[1][1]],
                  shear: [en[0][1] / en[1][1], en[1][0] / en[0][0]],
                };
              })([
                [B, k],
                [z, V],
              ]);
            return {
              position: [
                j + (R[0] * B + R[1] * k) - R[0],
                G + (R[0] * z + R[1] * V) - R[1],
              ],
              scale: X,
              rotation: q,
              shear: Q,
              pivot: R,
            };
          }),
          (_.compose = function (I, R, B, z, k = [0, 0]) {
            let [V, j] = I,
              [G, q] = z,
              [X, Q, $, et] = (function ({ rotation: _, scale: I, shear: R }) {
                let B = Math.cos(_),
                  z = Math.sin(_),
                  k = zx(
                    [
                      [B, -z],
                      [z, B],
                    ],
                    [
                      [I[0], R[0] * I[1]],
                      [R[1] * I[0], I[1]],
                    ]
                  );
                return [k[0][0], k[1][0], k[0][1], k[1][1]];
              })({ rotation: B, scale: R, shear: k }),
              er = V - (G * X + q * $) + G,
              es = j - (G * Q + q * et) + q;
            return _.create(X, Q, $, et, er, es);
          });
      })(CC || (CC = {}));
      var CS,
        CA,
        CC,
        CT,
        CP = Math.PI / 180,
        CD = class {
          constructor(_, I, R) {
            var B;
            (this.uuid = _),
              (this.data = I),
              (this.localMatrix = CC.identity()),
              (this.worldMatrix = CC.identity()),
              (this.ignoreCameraZoom = !1),
              (this.visible = !0),
              (this._singleBBox = new CB()),
              (this._recursiveBBox = new CB()),
              (this.singleBBoxNeedsUpdate = !0),
              (this.recursiveBBoxNeedsUpdate = !0),
              (this.stateSelection = null),
              (this.prevState = null),
              (this.currentState = null),
              (this.reversibleToState = null),
              (this.currentTransitionEvent = null),
              (this.previousAction = null),
              (this.name = ""),
              (this.position = [0, 0]),
              (this.scale = [1, 1]),
              (this.rotation = 0),
              (this.shear = [0, 0]),
              (this.emitter = {
                all: (B = B || new Map()),
                on: function (_, I) {
                  var R = B.get(_);
                  R ? R.push(I) : B.set(_, [I]);
                },
                off: function (_, I) {
                  var R = B.get(_);
                  R && (I ? R.splice(R.indexOf(I) >>> 0, 1) : B.set(_, []));
                },
                emit: function (_, I) {
                  var R = B.get(_);
                  R &&
                    R.slice().map(function (_) {
                      _(I);
                    }),
                    (R = B.get("*")) &&
                      R.slice().map(function (R) {
                        R(_, I);
                      });
                },
              }),
              (this.dpr = R.dpr ?? 1),
              (this.dataPatched = I);
          }
          project(_, I) {
            let R = this.worldMatrix;
            return (
              I && (R = CC.append(I.worldMatrix, R)), CC.applyInverse(_, R)
            );
          }
          intersects(_, I, R, B = !1) {
            return (
              this.visible &&
              !this.data.raycastLock &&
              this.intersectsInLocalSpace(...this.project([_, I], R), B)
            );
          }
          intersectsInLocalSpace(_, I, R = !1) {
            let { min: B, max: z } = R ? this.recursiveBBox : this.singleBBox;
            return _ >= B[0] && _ <= z[0] && I >= B[1] && I <= z[1];
          }
          applyTransforms(_) {
            _.setTransform(this.worldMatrix, this.ignoreCameraZoom);
          }
          get singleBBox() {
            return (
              this.singleBBoxNeedsUpdate &&
                ((this.singleBBoxNeedsUpdate = !1),
                this._singleBBox.setFromObjectSize(this, !1),
                this._singleBBox.computeVertices(),
                this._singleBBox.computeEdges()),
              this._singleBBox
            );
          }
          get recursiveBBox() {
            return (
              this.recursiveBBoxNeedsUpdate &&
                ((this.recursiveBBoxNeedsUpdate = !1),
                this._recursiveBBox.setFromObjectSize(this, !0),
                this._recursiveBBox.computeVertices(),
                this._recursiveBBox.computeEdges()),
              this._recursiveBBox
            );
          }
          updateLocalMatrix() {
            this.localMatrix = CC.compose(
              this.position,
              this.scale,
              this.rotation * CP,
              v6.getPivot(this.dataPatched),
              this.shear
            );
          }
          updateWorldMatrix(_, I, R) {
            let B = this.parent;
            I && null != B && B.updateWorldMatrix(_, !0, !1),
              _ && this.updateLocalMatrix(),
              this.parent
                ? (this.worldMatrix = CC.append(
                    this.parent.worldMatrix,
                    this.localMatrix
                  ))
                : (this.worldMatrix = CC.copy(this.localMatrix)),
              (this.singleBBoxNeedsUpdate = !0),
              (this.recursiveBBoxNeedsUpdate = !0);
          }
          get pivot() {
            return v6.getPivot(this.data);
          }
          getCenter() {
            return [0, 0];
          }
          getHalfSize() {
            return [0, 0];
          }
          get id() {
            return this.uuid;
          }
          resetBBoxNeedsUpdateSelf() {
            (this.singleBBoxNeedsUpdate = !0),
              (this.recursiveBBoxNeedsUpdate = !0);
          }
          resetBBoxNeedsUpdate() {
            this.resetBBoxNeedsUpdateSelf(),
              this.traverseAncestors((_) => {
                _.resetBBoxNeedsUpdateSelf();
              });
          }
          updateTransformState(_) {
            let I = !1;
            void 0 !== _.position && ((I = !0), (this.position = _.position)),
              void 0 !== _.rotation && ((I = !0), (this.rotation = _.rotation)),
              void 0 !== _.scale && ((I = !0), (this.scale = _.scale)),
              void 0 !== _.shear && ((I = !0), (this.shear = _.shear)),
              I &&
                (this.updateWorldMatrix(!0, !1, !0),
                this.resetBBoxNeedsUpdate());
          }
          updateByOp(_, I, R) {
            0 === _.type &&
              void 0 !== _.props.visible &&
              (this.visible = _.props.visible),
              (this.data = I),
              (this.data = I);
            let B = _,
              z = Rt(_.path, ["states", "*"]);
            if (null !== z) {
              if (0 === _.type) {
                let [I] = z;
                if (this?.stateSelection === I) {
                  let I = { ..._.props };
                  if (
                    (delete I.name,
                    Object.values(_.props).some((_) => void 0 === _))
                  ) {
                    let R = this.data;
                    if (void 0 !== R) {
                      let B = pe.zoom(R, _.path.slice(2));
                      if (B)
                        for (let R in _.props)
                          void 0 === _.props[R] && R in B && (I[R] = B[R]);
                    }
                  }
                  B = { ..._, props: I, path: _.path.slice(2) };
                }
              }
            } else if (0 === _.type) {
              let I = this.stateSelection
                ? this.data.states.data(this.stateSelection)
                : void 0;
              if (void 0 !== I) {
                if (void 0 !== _.props.name && I.name) {
                  let { name: _, ...R } = I;
                  I = R;
                }
                let R = pe.removeOverridden(_.path, _.props, I);
                B = { ..._, props: R };
              }
            }
            this.updateByPatchedOpBase(
              B,
              vY.patch(
                this.data,
                this.stateSelection
                  ? this.data.states.data(this.stateSelection)
                  : void 0
              ),
              R
            );
          }
          changeSelectedState(_, I, R = !1) {
            if (!(0 === this.data.states.length && !R)) {
              for (let _ of this.data.states)
                vY.toOps(this.data, _.data).forEach((_) => {
                  let R = u8.replaceProps(_, this.data);
                  (this.dataPatched = this.data),
                    this.updateByPatchedOp(R, this.data, I);
                });
              if (null !== _) {
                let R = this.data.states.data(_);
                R &&
                  ((this.dataPatched = vY.patch(this.data, R)),
                  vY.toOps(this.data, R).forEach((_) => {
                    this.updateByPatchedOp(_, this.dataPatched, I);
                  }));
              }
              R && this.updateTransformState(this.dataPatched),
                (this.stateSelection = _);
            }
          }
          updateState(_, I) {
            void 0 !== _.name && (this.name = _.name),
              void 0 !== _.visible && (this.visible = _.visible),
              this.updateTransformState(_);
          }
          updateByPatchedOpBase(_, I, R) {
            (this.dataPatched = I), this.updateByPatchedOp(_, I, R);
          }
          updateByPatchedOp(_, I, R) {
            0 === _.path.length && 0 === _.type && this.updateState(_.props, R),
              this.requestRender();
          }
          traverseFrameAncestors(_) {
            this.traverseAncestors((I) => {
              "frame2d" === I.data.type && _(I);
            });
          }
          traverseAncestors(_) {
            let I = this.parent;
            for (; I; ) _(I), (I = I.parent);
          }
          requestRender() {
            this.traverseFrameAncestors((_) => {
              _.requestRender();
            });
          }
          clone(_) {
            let I = new CD(this.uuid, this.data, _);
            return (I.parent = void 0), I;
          }
          addEventListener(_, I) {
            this.emitter.on(_, I);
          }
          removeEventListener(_, I) {
            this.emitter.off(_, I);
          }
          dispatchEvent(_) {
            this.emitter.emit(_.type, { ..._, target: _.target ?? this });
          }
          traverseSortNextHelper() {
            let _ = this.parent;
            if (_) {
              let I = _.children;
              if (I) {
                let R = I.indexOf(this) + 1;
                return I[R] ? I[R] : _.traverseSortNextHelper();
              }
            }
          }
          sortNext() {
            let _ = this.children;
            return _ && _.length > 0 && _[0]
              ? _[0]
              : this.traverseSortNextHelper();
          }
          isDescendantOf(_) {
            _ instanceof CD && (_ = _.uuid);
            let I = this;
            for (; I.parent; ) {
              if (I.parent.uuid === _) return !0;
              I = I.parent;
            }
            return !1;
          }
        },
        CO = class extends CD {
          constructor(_, I, R) {
            super(_, I, R),
              (this.uuid = _),
              (this.data = I),
              (this.context = R),
              (this.children = []);
          }
          add(_) {
            _.parent && _.parent instanceof CO && _.parent.remove(_),
              this.children.push(_),
              (_.parent = this);
          }
          remove(_) {
            let I = this.children.indexOf(_);
            I >= 0 && (this.children.splice(I, 1), (_.parent = void 0));
          }
          traverse(_) {
            let I = _(this);
            if (!0 !== I)
              for (let R of this.children)
                R instanceof CO ? R.traverse(_) : (I = _(R));
          }
          intersectsChildren(_, I, R, B = !1, z = [], k = !1) {
            for (let V of this.children) {
              let j = V instanceof CI;
              if (
                (V instanceof CO &&
                  !j &&
                  k &&
                  V.intersectsChildren(_, I, R, B, z, !1),
                V.intersects(_, I, R, j) && (z.push(V), B))
              )
                break;
            }
            return z;
          }
          updateWorldMatrix(_, I, R) {
            if ((super.updateWorldMatrix(_, I, R), R && this.children))
              for (let I of this.children) I.updateWorldMatrix(_, !1, !0);
          }
          find(_) {
            let I;
            return (
              this.traverse((R) => {
                R.uuid === _ && (I = R);
              }),
              I
            );
          }
          innerDrawChildren(_) {
            for (let I = this.children.length - 1; I >= 0; I--)
              this.children[I].draw(_);
          }
          resetBBoxNeedsUpdate() {
            super.resetBBoxNeedsUpdate(),
              this.traverse((_) => {
                _.resetBBoxNeedsUpdateSelf();
              });
          }
          clone(_) {
            let I = new CO(this.uuid, this.data, _);
            for (let R of ((I.parent = void 0), this.children))
              I.add(R.clone(_));
            return I;
          }
        },
        CI = class extends CO {
          constructor(_, I, R) {
            super(_, I, R),
              (this.uuid = _),
              (this.data = I),
              this.updateState(I, R);
          }
          draw(_) {
            this.visible &&
              (_.save(),
              this.applyTransforms(_),
              this.innerDrawChildren(_),
              _.restore());
          }
          clone(_) {
            let I = new CI(this.uuid, this.data, _);
            for (let R of ((I.parent = void 0), this.children))
              I.add(R.clone(_));
            return I;
          }
        },
        CR = [
          [-1, 1],
          [-1, -1],
          [1, -1],
          [1, 1],
        ],
        V3 = (_, I, R) => {
          let B = _.getCenter(),
            z = _.getHalfSize(),
            k = CC.append(I, _.worldMatrix);
          0 === z[0] && 0 === z[1]
            ? R.push(CC.apply(B, k))
            : CR.forEach((_) => {
                let I = [_[0] * z[0] + B[0], _[1] * z[1] + B[1]];
                R.push(CC.apply(I, k));
              });
        },
        CB = class {
          constructor() {
            (this.matrix = CC.identity()),
              (this.min = [1 / 0, 1 / 0]),
              (this.max = [-1 / 0, -1 / 0]),
              (this.vertices = []),
              (this.edges = []);
          }
          setFromObjectSize(_, I = !1) {
            _.updateWorldMatrix(),
              this.makeEmpty(),
              CC.copy(_.worldMatrix, this.matrix);
            let R = CC.invert(_.worldMatrix);
            this.expandByObjectSize(_, R, I);
          }
          expandByObjectSize(_, I, R = !1) {
            let B = [];
            !0 === R && _ instanceof CO
              ? _.traverse((_) => {
                  _.visible && V3(_, I, B);
                })
              : V3(_, I, B),
              this.setFromPoints(B);
          }
          getCenter() {
            let [_, I] = this.min,
              [R, B] = this.getHalfSize();
            return CC.apply([_ + R, I + B], this.matrix);
          }
          getSize() {
            return [this.max[0] - this.min[0], this.max[1] - this.min[1]];
          }
          getHalfSize() {
            return [
              (this.max[0] - this.min[0]) * 0.5,
              (this.max[1] - this.min[1]) * 0.5,
            ];
          }
          makeEmpty() {
            (this.min = [1 / 0, 1 / 0]), (this.max = [-1 / 0, -1 / 0]);
          }
          setFromPoints(_) {
            for (let I of (this.makeEmpty(), _)) this.expandByPoint(I);
          }
          expandByPoint(_) {
            (this.min = [
              Math.min(this.min[0], _[0]),
              Math.min(this.min[1], _[1]),
            ]),
              (this.max = [
                Math.max(this.max[0], _[0]),
                Math.max(this.max[1], _[1]),
              ]);
          }
          computeVertices() {
            let [_, I] = this.getHalfSize(),
              R = this.getCenter(),
              [B, z, k, V] = CC.getAbcdef(this.matrix),
              j = CC.create(B, z, k, V, R[0], R[1]);
            this.vertices = CR.map(([R, B]) => CC.apply([R * _, B * I], j));
          }
          computeEdges() {
            this.edges = [];
            for (let _ = 0, I = this.vertices.length; _ < I; ++_)
              this.edges.push([this.vertices[_], this.vertices[(_ + 1) % I]]);
          }
          project(_, I) {
            let R = this.matrix;
            return (
              I && (R = CC.append(I.worldMatrix, R)), CC.applyInverse(_, R)
            );
          }
          intersects(_, I, R) {
            return this.intersectsInLocalSpace(...this.project([_, I], R));
          }
          intersectsInLocalSpace(_, I) {
            let { min: R, max: B } = this;
            return _ >= R[0] && _ <= B[0] && I >= R[1] && I <= B[1];
          }
          containsPoint(_) {
            let [I, R] = _,
              [B, z] = this.min,
              [k, V] = this.max;
            return I >= B && I <= k && R >= z && R <= V;
          }
          intersectsBBox2D(_) {
            for (let I = 0, R = this.edges.length; I < R; I++) {
              let R = this.edges[I];
              for (let I = 0, B = _.edges.length; I < B; I++)
                if (
                  (function (_, I) {
                    let [[R, B], [z, k]] = _,
                      [[V, j], [G, q]] = I,
                      X = (R - z) * (j - q) - (B - k) * (V - G);
                    if (0 === X) return !1;
                    let Q = ((R - V) * (j - q) - (B - j) * (V - G)) / X,
                      $ = -((R - z) * (B - j) - (B - k) * (R - V)) / X;
                    return Q >= 0 && Q <= 1 && $ >= 0 && $ <= 1;
                  })(R, _.edges[I])
                )
                  return !0;
            }
            for (let I = 0, R = _.vertices.length; I < R; I++) {
              let R = _.vertices[I];
              if (this.containsPoint(R)) return !0;
            }
            return !1;
          }
          ensureMinMax() {
            let _ = this.min,
              I = this.max;
            (this.min = [Math.min(_[0], I[0]), Math.min(_[1], I[1])]),
              (this.max = [Math.max(_[0], I[0]), Math.max(_[1], I[1])]);
          }
          copy(_) {
            (this.min = [..._.min]),
              (this.max = [..._.max]),
              CC.copy(_.matrix, this.matrix),
              this.computeVertices(),
              this.computeEdges();
          }
          clone() {
            let _ = new CB();
            return _.copy(this), _;
          }
        },
        CL = new Promise((_) => {
          CT = _;
        }),
        Cz = !1;
      function H_(_) {
        let I = !1;
        return (
          _.scene.objects.traverse((_, R) => {
            (("Mesh" === R.type && "UIGeometry" === R.geometry.type) ||
              ("Page" === R.type && void 0 !== R.uiFrame)) &&
              (I = !0);
          }),
          I
        );
      }
      async function JQ(_) {
        let I = await CL;
        CV || (Cj || (Cj = I({ locateFile: () => _ })), (CV = await Cj));
      }
      var CF = CC.identity(),
        CN = class {
          constructor(_, I = 1) {
            (this.canvas = _),
              (this.dpr = I),
              (this._width = 0),
              (this._height = 0),
              (this._strokeMode = "inside"),
              (this._layerBlur = 0),
              (this._backgroundBlur = 0),
              (this._dropShadowBlur = 0),
              (this._dropShadowOffsetX = 0),
              (this._dropShadowOffsetY = 0),
              (this._dropShadowColor = mb.transparent),
              (this._innerShadowBlur = 0),
              (this._innerShadowOffsetX = 0),
              (this._innerShadowOffsetY = 0),
              (this._innerShadowSpread = 0),
              (this._innerShadowColor = mb.transparent),
              (this._fonts = new Map());
            try {
              let R = _.getBoundingClientRect();
              (_.width = R.width * I), (_.height = R.height * I);
            } catch {
              console.log(_.width, I);
            }
            (this._currentM3Transform = CF),
              (this._currentTransform = new Float32Array(CF));
          }
          async init() {
            if (!this.wasmURL)
              throw Error(
                "Your must set the wasm binary url with renderer.wasmURL = ... before you can call renderer.init"
              );
            await JQ(this.wasmURL),
              (this._surface = CV.MakeWebGLCanvasSurface(this.canvas)),
              (this.ctx = this._surface?.getCanvas()),
              (this._paint = new CV.Paint()),
              this._paint.setAntiAlias(!0),
              (this._paintFill = this._paint.copy()),
              this._paintFill.setStyle(CV.PaintStyle.Fill),
              (this._paintStroke = this._paint.copy()),
              this._paintStroke.setStyle(CV.PaintStyle.Stroke),
              this.ctx?.scale(this.dpr, this.dpr);
          }
          get currentTransform() {
            return this._currentM3Transform;
          }
          get currentTransformBuffer() {
            return this._currentTransform;
          }
          set currentTransform(_) {
            (this._currentM3Transform = _), this._currentTransform.set(_);
          }
          async loadFont(_, I) {
            let R = await (await fetch(_)).arrayBuffer();
            this.registerFont(R, I);
          }
          registerFont(_, I) {
            if (this._fonts.has(I)) return;
            let R = CV.FontMgr.FromData(_);
            if (R) this._fonts.set(I, R);
            else throw Error("Invalid font data for " + I);
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          set strokeColor(_) {
            this._paintStroke &&
              this._paintStroke.setColor(Gx(_), CV.ColorSpace.DISPLAY_P3);
          }
          set fillColor(_) {
            this._paintFill &&
              this._paintFill.setColor(Gx(_), CV.ColorSpace.DISPLAY_P3);
          }
          set lineWidth(_) {
            this._paintStroke &&
              this._paintStroke.setStrokeWidth(
                "center" === this._strokeMode ? _ : 2 * _
              );
          }
          set strokeMode(_) {
            this._strokeMode = _;
          }
          set dropShadowBlur(_) {
            this._dropShadowBlur = _;
          }
          set dropShadowColor(_) {
            this._dropShadowColor = _;
          }
          set dropShadowOffsetX(_) {
            this._dropShadowOffsetX = _;
          }
          set dropShadowOffsetY(_) {
            this._dropShadowOffsetY = _;
          }
          set innerShadowBlur(_) {
            this._innerShadowBlur = _;
          }
          set innerShadowColor(_) {
            this._innerShadowColor = _;
          }
          set innerShadowOffsetX(_) {
            this._innerShadowOffsetX = _;
          }
          set innerShadowOffsetY(_) {
            this._innerShadowOffsetY = _;
          }
          set innerShadowSpread(_) {
            this._innerShadowSpread = _;
          }
          set layerBlur(_) {
            this._layerBlur = _;
          }
          set backgroundBlur(_) {
            this._backgroundBlur = _;
          }
          clear() {
            this.ctx?.clear(CV.TRANSPARENT);
          }
          save() {
            this.ctx?.save();
          }
          restore() {
            this.ctx?.restore();
          }
          beginPath() {
            this._currentPath?.delete(), (this._currentPath = new CV.Path());
          }
          closePath() {
            let _ = this._currentPath;
            if (_) {
              if (_.isEmpty()) return;
              let I = _.getBounds();
              (I[3] - I[1] || I[2] - I[0]) && _.close();
            }
          }
          fill() {
            this._paintInner(this._paintFill, !0);
          }
          stroke() {
            this._paintInner(this._paintStroke, !1);
          }
          clipRect(_, I, R, B, z = 0, k = 0, V = 0, j = 0) {
            let G = CV.XYWHRect(_, I, R, B);
            if (0 === z && 0 === k && 0 === j && 0 === V)
              this.ctx?.clipRect(G, CV.ClipOp.Intersect, !0);
            else {
              let _ = CV.RRectXY(G, z, z);
              (_[4] = _[5] = z),
                (_[6] = _[7] = k),
                (_[8] = _[9] = V),
                (_[10] = _[11] = j),
                this.ctx?.clipRRect(_, CV.ClipOp.Intersect, !0);
            }
          }
          _applyShadowOffsetMatrix() {
            if (this.ctx) {
              let _ = CC.invert(this.currentTransform);
              this.ctx.concat(_);
              let I = CC.translate(
                CC.identity(),
                this._dropShadowOffsetX,
                this._dropShadowOffsetY
              );
              this.ctx.concat(I), this.ctx.concat(this._currentTransform);
            }
          }
          _applyEffectsToPaint(_, I, R = !0) {
            if (this.ctx && this._currentPath) {
              let B,
                z = !1;
              if (R && this._hasDropShadow()) {
                let R,
                  B = _.copy();
                B.setColor(Gx(this._dropShadowColor)),
                  this._dropShadowBlur > 0 &&
                    ((R = CV.MaskFilter.MakeBlur(
                      CV.BlurStyle.Normal,
                      this._dropShadowBlur *
                        this.dpr *
                        (this.camera?.scale ?? 1),
                      !1
                    )),
                    B.setMaskFilter(R)),
                  this.ctx.save(),
                  this.ctx.clipPath(
                    this._currentPath,
                    CV.ClipOp.Difference,
                    !0
                  ),
                  this._applyShadowOffsetMatrix(),
                  I(B),
                  this.ctx.restore(),
                  B.delete(),
                  R?.delete();
              }
              if (this._backgroundBlur > 0 && R) {
                this.ctx.save(),
                  this.ctx.clipPath(this._currentPath, CV.ClipOp.Intersect, !0);
                let I = CV.ImageFilter.MakeBlur(
                    this._backgroundBlur,
                    this._backgroundBlur,
                    CV.TileMode.Clamp,
                    null
                  ),
                  R = _.copy();
                R.setImageFilter(I), R.setAlphaf(1);
                let B = this._currentPath.computeTightBounds();
                this.ctx.saveLayer(R, B, null, CV.SaveLayerInitWithPrevious),
                  this.ctx.drawColor(_.getColor()),
                  this.ctx.restore(),
                  this.ctx.restore(),
                  R.delete(),
                  I.delete(),
                  (z = !0);
              }
              if (this._layerBlur > 0) {
                let R = _.copy();
                (B = CV.MaskFilter.MakeBlur(
                  CV.BlurStyle.Normal,
                  this._layerBlur * this.dpr * (this.camera?.scale ?? 1),
                  !1
                )),
                  R.setMaskFilter(B),
                  I(R),
                  R.delete(),
                  B.delete(),
                  (z = !0);
              }
              if ((z || I(_), R && this._hasInnerShadow())) {
                let _,
                  I = new CV.Paint();
                I.setAntiAlias(!0),
                  I.setStyle(CV.PaintStyle.Fill),
                  I.setColor(Gx(this._innerShadowColor)),
                  this._innerShadowBlur > 0 &&
                    ((_ = CV.MaskFilter.MakeBlur(
                      CV.BlurStyle.Normal,
                      this._innerShadowBlur *
                        this.dpr *
                        (this.camera?.scale ?? 1),
                      !1
                    )),
                    I.setMaskFilter(_));
                let R = this._currentPath.computeTightBounds(),
                  [B, z, k, V] = R;
                this.ctx.save(),
                  this.ctx.clipPath(this._currentPath, CV.ClipOp.Intersect, !0),
                  this.ctx.saveLayer(I, R, null, CV.SaveLayerInitWithPrevious),
                  this.ctx?.translate(
                    this._innerShadowOffsetX,
                    this._innerShadowOffsetY
                  ),
                  this.ctx.drawRect(
                    CV.XYWHRect(
                      -1e3 - this._innerShadowOffsetX,
                      -1e3 - this._innerShadowOffsetY,
                      2e3 + (k - B) + Math.abs(2 * this._innerShadowOffsetX),
                      2e3 + (V - z) + Math.abs(2 * this._innerShadowOffsetY)
                    ),
                    I
                  ),
                  I.setBlendMode(CV.BlendMode.Clear),
                  this.ctx.drawPath(this._currentPath, I),
                  this.ctx.restore(),
                  this.ctx.restore(),
                  I.delete(),
                  _?.delete();
              }
            }
          }
          _paintInner(_, I = !0) {
            if (this.ctx && this._currentPath && _) {
              let R = this.ctx,
                B = this._currentPath;
              this._applyEffectsToPaint(
                _,
                (_) => {
                  let z = !1;
                  I ||
                    "center" === this._strokeMode ||
                    (R.save(),
                    R.clipPath(
                      B,
                      "outside" === this._strokeMode
                        ? CV.ClipOp.Difference
                        : CV.ClipOp.Intersect,
                      !0
                    ),
                    (z = !0)),
                    R.drawPath(B, _),
                    z && R.restore();
                },
                I
              );
            }
          }
          _hasDropShadow() {
            return this._dropShadowColor?.a > 0;
          }
          _hasInnerShadow() {
            return this._innerShadowColor?.a > 0;
          }
          path(_) {
            this._currentPath?.addPath(CV.Path.MakeFromSVGString(_));
          }
          ellipse(_, I, R, B, z, k, V, j) {
            if (!q3([_, I, R, B]) || !this._currentPath) return;
            if (R < 0 || B < 0) throw Error("radii cannot be negative");
            let G = CV.XYWHRect(_ - R, I - B, 2 * R, 2 * B);
            this._currentPath?.addOval(G);
          }
          rect(_, I, R, B, z = 0, k = 0, V = 0, j = 0) {
            let G = CV.XYWHRect(_, I, R, B);
            if (q3(G)) {
              if (0 === z && 0 === k && 0 === j && 0 === V)
                this._currentPath?.addRect(G);
              else {
                let _ = CV.RRectXY(G, z, z);
                (_[4] = _[5] = z),
                  (_[6] = _[7] = k),
                  (_[8] = _[9] = V),
                  (_[10] = _[11] = j),
                  this._currentPath?.addRRect(_);
              }
            }
          }
          getHorizontalAlign(_) {
            switch (_) {
              case 2:
                return CV.TextAlign.Right;
              case 3:
                return CV.TextAlign.Center;
              case 4:
                return CV.TextAlign.Justify;
              default:
                return CV.TextAlign.Left;
            }
          }
          drawTextInner(_, I, R, [B, z, k, V], j, G, q = !0) {
            let X = 0,
              { ctx: Q } = this;
            if (!Q) return X;
            let $ = G.copy(),
              et = G.copy();
            return (
              et.setAlphaf(0),
              this._applyEffectsToPaint(
                $,
                (G) => {
                  I.pushPaintStyle(R, G, et), I.addText(_);
                  let q = I.build();
                  q.layout(k);
                  let $ = z;
                  2 === j
                    ? ($ += (V - q.getHeight()) / 2)
                    : 3 === j && ($ += V - q.getHeight()),
                    Q.drawParagraph(q, B, $),
                    (X = q.getHeight()),
                    I.reset(),
                    q.delete();
                },
                q
              ),
              $.delete(),
              et.delete(),
              X
            );
          }
          drawText(_, I) {
            let R = 0,
              B = this._fonts.get(I.font),
              { ctx: z, _paintFill: k, _paintStroke: V } = this;
            if (B && z) {
              let z = new CV.TextStyle({
                  fontFamilies: [I.font],
                  fontSize: I.fontSize,
                  heightMultiplier: I.lineHeight,
                  letterSpacing: I.letterSpacing,
                }),
                j = new CV.ParagraphStyle({
                  textStyle: z,
                  textAlign: this.getHorizontalAlign(I.horizontalAlign),
                }),
                G = CV.XYWHRect(I.x, I.y, I.width, I.height),
                q = CV.ParagraphBuilder.Make(j, B);
              k && (R = this.drawTextInner(_, q, z, G, I.verticalAlign, k, !0)),
                V &&
                  (R = this.drawTextInner(_, q, z, G, I.verticalAlign, V, !1)),
                q.delete();
            }
            return { height: R };
          }
          render() {
            this._surface?.flush();
          }
          moveTo(_, I) {
            this._currentPath?.moveTo(_, I);
          }
          lineTo(_, I) {
            this._currentPath?.lineTo(_, I);
          }
          bezierCurveTo(_, I, R, B, z, k) {
            this._currentPath?.cubicTo(_, I, R, B, z, k);
          }
          quadraticCurveTo(_, I, R, B) {
            this._currentPath?.quadTo(_, I, R, B);
          }
          setTransform(_, I = !1) {
            if (!this.ctx) return;
            let R = this.ctx.getTotalMatrix(),
              B = CC.invert(R);
            if (
              (B && this.ctx.concat(B),
              this.ctx?.scale(this.dpr, this.dpr),
              this.camera?.enabled &&
                (this.ctx?.concat(this.camera.worldMatrix), I))
            ) {
              let _ = CC.getScale(this.camera.worldMatrix);
              this.ctx?.scale(1 / _[0], 1 / _[1]);
            }
            this.ctx?.concat(_), (this.currentTransform = _);
          }
          transform(_) {
            this.ctx?.concat(_);
          }
          setSize(_, I) {
            (_ === this._width && I === this._height) ||
              ((this._width = _),
              (this._height = I),
              (this.canvas.style.width = _ + "px"),
              (this.canvas.style.height = I + "px"),
              (this.canvas.width = _ * this.dpr),
              (this.canvas.height = I * this.dpr),
              this._surface &&
                ((this._surface = CV.MakeWebGLCanvasSurface(this.canvas)),
                (this.ctx = this._surface?.getCanvas())));
          }
        };
      function q3(_) {
        for (let I = 0; I < _.length; I++)
          if (void 0 !== _[I] && !Number.isFinite(_[I])) return !1;
        return !0;
      }
      function Gx({ r: _, g: I, b: R, a: B }) {
        return CV.Color4f(_, I, R, B);
      }
      var Ck,
        CV,
        Cj,
        CG,
        CH = class {
          constructor(_, I, R) {
            (this.uuid = _),
              (this.data = I),
              (this.enabled = !1),
              (this.color = mb.transparent),
              (this.blurRadius = 0),
              (this.offset = [0, 0]),
              (this.spread = 0),
              this.update(I);
          }
          update(_) {
            void 0 !== _.color && (this.color = _.color),
              void 0 !== _.enabled && (this.enabled = _.enabled),
              void 0 !== _.blurRadius && (this.blurRadius = _.blurRadius),
              void 0 !== _.offset && (this.offset = _.offset),
              void 0 !== _.spread && (this.spread = _.spread);
          }
        },
        CW = class {
          constructor(_, I, R) {
            (this.uuid = _),
              (this.data = I),
              (this.enabled = !1),
              (this.radius = 0),
              this.update(I);
          }
          update(_) {
            void 0 !== _.enabled && (this.enabled = _.enabled),
              void 0 !== _.radius && (this.radius = _.radius);
          }
        },
        Cq = class {
          constructor(_, I, R) {
            (this.uuid = _),
              (this.data = I),
              (this.enabled = !1),
              (this.color = mb.transparent),
              this.update(I);
          }
          update(_) {
            void 0 !== _.enabled && (this.enabled = _.enabled),
              void 0 !== _.color && (this.color = _.color);
          }
        },
        CY = class {
          constructor(_, I, R) {
            (this.uuid = _),
              (this.data = I),
              (this.enabled = !1),
              (this.color = mb.transparent),
              (this.thickness = 0),
              (this.mode = "inside"),
              this.update(I);
          }
          update(_) {
            void 0 !== _.enabled && (this.enabled = _.enabled),
              void 0 !== _.color && (this.color = _.color),
              void 0 !== _.thickness && (this.thickness = _.thickness),
              void 0 !== _.mode && (this.mode = _.mode);
          }
        },
        CX = class extends CD {
          constructor(_, I, R) {
            super(_, I, R),
              (this.uuid = _),
              (this.data = I),
              (this.autoClose = !0),
              (this.fill = new Cq(_ + "-fill", I.fill, R)),
              (this.stroke = new CY(_ + "-stroke", I.stroke, R)),
              (this.dropShadow = new CH(_ + "-dropShadow", I.dropShadow, R)),
              (this.innerShadow = new CH(_ + "-innerShadow", I.innerShadow, R)),
              (this.backgroundBlur = new CW(
                _ + "-backgroundBlur",
                I.backgroundBlur,
                R
              )),
              (this.layerBlur = new CW(_ + "-layerBlur", I.layerBlur, R));
          }
          applyFillStroke(_) {
            (_.fillColor = this.fill.enabled
              ? this.fill.color
              : mb.transparent),
              (_.strokeColor =
                this.stroke.enabled && this.stroke.thickness > 0
                  ? this.stroke.color
                  : mb.transparent),
              (_.strokeMode = this.stroke.mode),
              (_.lineWidth = this.stroke.thickness);
          }
          applyFilters(_) {
            this.layerBlur.enabled
              ? (_.layerBlur = 5 * this.layerBlur.radius)
              : (_.layerBlur = 0),
              this.backgroundBlur.enabled
                ? (_.backgroundBlur = 5 * this.backgroundBlur.radius)
                : (_.backgroundBlur = 0),
              this.dropShadow.enabled
                ? ((_.dropShadowBlur = 5 * this.dropShadow.blurRadius),
                  (_.dropShadowColor = this.dropShadow.color),
                  (_.dropShadowOffsetX = this.dropShadow.offset[0]),
                  (_.dropShadowOffsetY = this.dropShadow.offset[1]))
                : (_.dropShadowColor = mb.transparent),
              this.innerShadow.enabled
                ? ((_.innerShadowSpread = this.innerShadow.spread),
                  (_.innerShadowBlur = 5 * this.innerShadow.blurRadius),
                  (_.innerShadowColor = this.innerShadow.color),
                  (_.innerShadowOffsetX = this.innerShadow.offset[0]),
                  (_.innerShadowOffsetY = this.innerShadow.offset[1]))
                : (_.innerShadowColor = mb.transparent);
          }
          innerDraw(_) {}
          draw(_) {
            this.visible &&
              (_.save(),
              this.applyTransforms(_),
              this.applyFilters(_),
              this.applyFillStroke(_),
              _.beginPath(),
              this.innerDraw(_),
              this.autoClose && _.closePath(),
              this.fill.enabled && _.fill(),
              this.stroke.enabled && _.stroke(),
              _.restore());
          }
          updateByPatchedOp(_, I, R) {
            super.updateByPatchedOp(_, I, R),
              0 === _.type &&
                (Rt(_.path, ["fill"])
                  ? this.fill.update(_.props)
                  : Rt(_.path, ["stroke"])
                  ? this.stroke.update(_.props)
                  : Rt(_.path, ["dropShadow"])
                  ? this.dropShadow.update(_.props)
                  : Rt(_.path, ["innerShadow"])
                  ? this.innerShadow.update(_.props)
                  : Rt(_.path, ["layerBlur"])
                  ? this.layerBlur.update(_.props)
                  : Rt(_.path, ["backgroundBlur"])
                  ? this.backgroundBlur.update(_.props)
                  : this.resetBBoxNeedsUpdate());
          }
          updateState(_, I) {
            super.updateState(_, I),
              void 0 !== _.fill && this.fill.update(_.fill),
              void 0 !== _.stroke && this.stroke.update(_.stroke),
              void 0 !== _.dropShadow && this.dropShadow.update(_.dropShadow),
              void 0 !== _.innerShadow &&
                this.innerShadow.update(_.innerShadow),
              void 0 !== _.layerBlur && this.layerBlur.update(_.layerBlur),
              void 0 !== _.backgroundBlur &&
                this.backgroundBlur.update(_.backgroundBlur);
          }
          clone(_) {
            let I = new CX(this.uuid, this.data, _);
            return (I.parent = void 0), I;
          }
        },
        CQ = class extends CX {
          constructor(_, I, R) {
            super(_, I, R),
              (this.uuid = _),
              (this.data = I),
              (this.width = 0),
              (this.height = 0),
              this.updateState(I, R);
          }
          innerDraw(_) {
            _.ellipse(
              0.5 * this.width,
              0.5 * this.height,
              0.5 * this.width,
              0.5 * this.height,
              0,
              0,
              2 * Math.PI
            );
          }
          intersectsInLocalSpace(_, I) {
            var R, B, z, k;
            let V, j;
            return (
              (R = 0.5 * this.width),
              (B = 0.5 * this.height),
              (z = 0.5 * this.width),
              (k = 0.5 * this.height),
              ((V = _ - R) * V) / (z * z) + ((j = I - B) * j) / (k * k) <= 1
            );
          }
          getCenter() {
            return [0.5 * this.width, 0.5 * this.height];
          }
          getHalfSize() {
            return [0.5 * this.width, 0.5 * this.height];
          }
          updateSizeState(_) {
            let I = !1;
            void 0 !== _.width &&
              ((this.width = "number" == typeof _.width ? _.width : this.width),
              (I = !0)),
              void 0 !== _.height &&
                ((this.height =
                  "number" == typeof _.height ? _.height : this.height),
                (I = !0)),
              I && this.updateWorldMatrix(!0, !1, !0);
          }
          updateState(_, I) {
            super.updateState(_, I), this.updateSizeState(_);
          }
          clone(_) {
            let I = new CQ(this.uuid, this.data, _);
            return (I.parent = void 0), I;
          }
        },
        CZ = class extends CX {
          constructor(_, I, R) {
            super(_, I, R),
              (this.uuid = _),
              (this.data = I),
              (this.width = 0),
              (this.height = 0),
              (this.cornerRadius = [0, 0, 0, 0]),
              this.updateState(I, R);
          }
          innerDraw(_) {
            _.rect(0, 0, this.width, this.height, ...this.cornerRadius);
          }
          getCenter() {
            return [0.5 * this.width, 0.5 * this.height];
          }
          getHalfSize() {
            return [0.5 * this.width, 0.5 * this.height];
          }
          updateCornerState(_) {
            void 0 !== _.cornerRadius && (this.cornerRadius = _.cornerRadius);
          }
          updateSizeState(_) {
            let I = !1;
            void 0 !== _.width &&
              ((this.width = "number" == typeof _.width ? _.width : this.width),
              (I = !0)),
              void 0 !== _.height &&
                ((this.height =
                  "number" == typeof _.height ? _.height : this.height),
                (I = !0)),
              I && this.updateWorldMatrix(!0, !1, !0);
          }
          updateState(_, I) {
            super.updateState(_, I),
              this.updateSizeState(_),
              this.updateCornerState(_);
          }
          clone(_) {
            let I = new CZ(this.uuid, this.data, _);
            return (I.parent = void 0), I;
          }
        },
        CK = class extends CX {
          constructor(_, I, R) {
            super(_, I, R),
              (this.uuid = _),
              (this.data = I),
              (this._textHeight = 0),
              (this._textHeightDirty = !0),
              (this.width = 0),
              (this.height = 0),
              this.updateState(I, R);
          }
          get textHeight() {
            return this._textHeight;
          }
          applyFillStroke(_) {
            (_.fillColor = this.fill.enabled
              ? this.fill.color
              : mb.transparent),
              (_.strokeColor =
                this.stroke.enabled && this.stroke.thickness > 0
                  ? this.stroke.color
                  : mb.transparent),
              (_.strokeMode = "center"),
              (_.lineWidth = this.stroke.thickness);
          }
          innerDraw(_) {
            this._fontHolder?.arrayBuffer &&
              this._fontHolder.arrayBuffer.byteLength > 1 &&
              this.data.font &&
              _.registerFont(this._fontHolder.arrayBuffer, this.data.font);
            let I = this.data.textTransform,
              R = this.data.text.textValue.toString(),
              B = 2 === I ? R.toUpperCase() : 3 === I ? R.toLowerCase() : R,
              { height: z } = _.drawText(B, {
                x: 0,
                y: 0,
                width: this.width,
                height: this.height,
                fontSize: this.data.fontSize,
                lineHeight: this.data.lineHeight ?? 1,
                letterSpacing: this.data.letterSpacing ?? 0,
                horizontalAlign: this.data.horizontalAlign,
                verticalAlign: this.data.verticalAlign,
                font: this.data.font,
              });
            this._textHeight = z;
          }
          getCenter() {
            return [0.5 * this.width, 0.5 * this.height];
          }
          getHalfSize() {
            return [0.5 * this.width, 0.5 * this.height];
          }
          updateSizeState(_) {
            let I = !1;
            void 0 !== _.width &&
              ((this.width = "number" == typeof _.width ? _.width : this.width),
              (I = !0)),
              void 0 !== _.height &&
                ((this.height =
                  "number" == typeof _.height ? _.height : this.height),
                (I = !0)),
              I && this.updateWorldMatrix(!0, !1, !0);
          }
          updateFontState(_, { shared: I }) {
            void 0 !== _.font &&
              ((this._fontHolder = I.getFont(_.font)),
              this._fontHolder &&
                !this._fontHolder.isLoaded &&
                this._fontHolder.loadingPromise.then(() => {
                  this.requestRender();
                }));
          }
          updateState(_, I) {
            super.updateState(_, I),
              this.updateSizeState(_),
              this.updateFontState(_, I);
          }
          clone(_) {
            let I = new CK(this.uuid, this.data, _);
            return (I.parent = void 0), I;
          }
        },
        CJ = class extends CX {
          constructor(_, I, R) {
            super(_, I, R),
              (this.uuid = _),
              (this.data = I),
              (this.curves = []),
              (this.extremasBBox = { min: [0, 0], max: [0, 0] }),
              this.updateState(I, R);
          }
          computeExtremas() {
            0 === this.curves.length && this.computeCurves();
            let _ = this.curves.map((_) => CG.extremas(_)),
              I = [1 / 0, 1 / 0],
              R = [-1 / 0, -1 / 0];
            for (let B = 0, z = _.length; B < z; B++) {
              let z = _[B];
              z[0][0] < I[0] && (I[0] = z[0][0]),
                z[0][1] < I[1] && (I[1] = z[0][1]),
                z[1][0] > R[0] && (R[0] = z[1][0]),
                z[1][1] > R[1] && (R[1] = z[1][1]);
            }
            return (
              (this.extremasBBox.min = [I[0], I[1]]),
              (this.extremasBBox.max = [R[0], R[1]]),
              this.extremasBBox
            );
          }
          computeCurves() {
            this.curves = [];
            for (let _ = 1, I = this.data.points.length; _ < I; _++) {
              let I = this.data.points[_].data,
                R = this.data.points[_ - 1].data,
                B = {
                  start: R.position,
                  cp1: R.controlNext.position,
                  cp2: I.controlPrevious.position,
                  end: I.position,
                };
              this.curves.push(B);
            }
            let _ = this.data.points[0].data,
              I = this.data.points[this.data.points.length - 1].data;
            if (this.data.isClosed) {
              let R = {
                start: I.position,
                cp1: I.controlNext.position,
                cp2: _.controlPrevious.position,
                end: _.position,
              };
              this.curves.push(R);
            }
          }
          getCenter() {
            let [_, I] = this.extremasBBox.min,
              [R, B] = this.getHalfSize();
            return [_ + R, I + B];
          }
          getHalfSize() {
            let { min: _, max: I } = this.extremasBBox;
            return [(I[0] - _[0]) * 0.5, (I[1] - _[1]) * 0.5];
          }
          innerDraw(_) {
            for (let I = 0, R = this.data.points.length; I < R; I++) {
              let R = this.data.points[I].data;
              if (0 === I) {
                let [I, B] = R.position;
                _.moveTo(I, B);
              } else {
                let B = this.data.points[I - 1].data,
                  [z, k] = B.controlNext.position,
                  [V, j] = R.controlPrevious.position,
                  [G, q] = R.position,
                  X = {
                    start: B.position,
                    cp1: B.controlNext.position,
                    cp2: R.controlPrevious.position,
                    end: R.position,
                  };
                CG.derive(X), _.bezierCurveTo(z, k, V, j, G, q);
              }
            }
            let I = this.data.points[0].data,
              R = this.data.points[this.data.points.length - 1].data;
            if (this.data.isClosed) {
              let [B, z] = R.controlNext.position,
                [k, V] = I.controlPrevious.position,
                [j, G] = I.position;
              _.bezierCurveTo(B, z, k, V, j, G);
            }
          }
          updateState(_, I) {
            super.updateState(_, I), this.computeExtremas();
          }
          clone(_) {
            let I = new CJ(this.uuid, this.data, _);
            return (I.parent = void 0), I;
          }
        };
      ((_) => {
        function t(_, I, R, B = !1) {
          let z = _ - 2 * I + R;
          if (0 !== z) {
            let B = -Math.sqrt(Math.abs(I * I - _ * R)),
              k = -_ + I;
            return [-(B + k) / z, -(-B + k) / z];
          }
          return I !== R && 0 === z ? [(2 * I - R) / (2 * (I - R))] : [];
        }
        (_.derive = function (_) {
          let I = _.start,
            R = _.cp1,
            B = _.cp2,
            z = _.end,
            k = {
              start: [3 * (R[0] - I[0]), 3 * (R[1] - I[1])],
              cp: [3 * (B[0] - R[0]), 3 * (B[1] - R[1])],
              end: [3 * (z[0] - B[0]), 3 * (z[1] - B[1])],
            };
          return (_.derivative = k), (k.derivative = Pa.derive(k)), k;
        }),
          (_.droot = function (I) {
            let R = I.derivative ?? _.derive(I),
              B = R.start,
              z = R.cp,
              k = R.end;
            return [t(B[0], z[0], k[0]), t(B[1], z[1], k[1])];
          }),
          (_.extremas = function (I) {
            let [R, B] = _.droot(I),
              z = [I.start[0], I.end[0]],
              k = [I.start[1], I.end[1]];
            for (let B of R)
              z.push(_.compute(I, Math.min(1, Math.max(0, B)))[0]);
            for (let R of B)
              k.push(_.compute(I, Math.min(1, Math.max(0, R)))[1]);
            return (
              z.sort((_, I) => _ - I),
              k.sort((_, I) => _ - I),
              [
                [z[0], k[0]],
                [z[z.length - 1], k[k.length - 1]],
              ]
            );
          }),
          (_.compute = function (_, I) {
            if (0 === I) return [..._.start];
            if (1 === I) return [..._.end];
            let R = 1 - I,
              B = R * R,
              z = I * I,
              k = B * R,
              V = B * I * 3,
              j = R * z * 3,
              G = I * z;
            return [
              k * _.start[0] + V * _.cp1[0] + j * _.cp2[0] + G * _.end[0],
              k * _.start[1] + V * _.cp1[1] + j * _.cp2[1] + G * _.end[1],
            ];
          });
      })(CG || (CG = {})),
        ((Pi = Pa || (Pa = {})).derive = function (_) {
          let I = _.start,
            R = _.cp,
            B = _.end,
            z = {
              start: [2 * (R[0] - I[0]), 2 * (R[1] - I[1])],
              end: [2 * (B[0] - R[0]), 2 * (B[1] - R[1])],
            };
          return (z.derivative = Pn.derive(z)), (_.derivative = z), z;
        }),
        (Pi.droot = function (_) {
          let I = _.derivative ?? Pi.derive(_),
            R = I.start,
            B = I.end;
          return [
            R[0] !== B[0] ? R[0] / (R[0] - B[0]) : 0,
            R[1] !== B[1] ? R[1] / (R[1] - B[1]) : 0,
          ];
        }),
        (Pi.compute = function (_, I) {
          if (0 === I) return [..._.start];
          if (1 === I) return [..._.end];
          let R = 1 - I,
            B = R * R,
            z = R * I * 2,
            k = I * I;
          return [
            B * _.start[0] + z * _.cp[0] + k * _.end[0],
            B * _.start[1] + z * _.cp[1] + k * _.end[1],
          ];
        }),
        ((Ps = Pn || (Pn = {})).derive = function (_) {
          let I = _.start,
            R = _.end,
            B = [R[0] - I[0], R[1] - I[1]];
          return (_.derivative = B), _.derivative;
        }),
        (Ps.compute = function (_, I) {
          if (0 === I) return [..._.start];
          if (1 === I) return [..._.end];
          let R = _.start,
            B = _.end;
          return [R[0] + (B[0] - R[0]) * I, R[1] + (B[1] - R[1]) * I];
        });
      var C$ = class extends CO {
          constructor(_, I, R) {
            super(_, I, R),
              (this.uuid = _),
              (this.width = 0),
              (this.height = 0),
              (this.clipped = !0),
              (this.background = new CZ(_ + "-background", v$.defaultData, R)),
              (this.background.parent = this),
              this.updateState(I, R);
          }
          get fill() {
            return this.background.fill;
          }
          get stroke() {
            return this.background.stroke;
          }
          get backgroundBlur() {
            return this.background.backgroundBlur;
          }
          get layerBlur() {
            return this.background.layerBlur;
          }
          get dropShadow() {
            return this.background.dropShadow;
          }
          get innerShadow() {
            return this.background.innerShadow;
          }
          get cornerRadius() {
            return this.background.cornerRadius;
          }
          set cornerRadius(_) {
            this.background.cornerRadius = _;
          }
          updateLocalMatrix() {
            super.updateLocalMatrix(), this.background?.updateLocalMatrix();
          }
          updateWorldMatrix(_, I, R) {
            super.updateWorldMatrix(_, I, R),
              this.background?.updateWorldMatrix(_, I, R);
          }
          draw(_) {
            if (!this.visible) return;
            _.save();
            let I = this.width,
              R = this.height;
            this.applyTransforms(_),
              (this.background.width = I),
              (this.background.height = R),
              this.background.draw(_),
              this.clipped && _.clipRect(0, 0, I, R, ...this.cornerRadius),
              this.innerDrawChildren(_),
              _.restore();
          }
          getCenter() {
            return [0.5 * this.width, 0.5 * this.height];
          }
          getHalfSize() {
            return [0.5 * this.width, 0.5 * this.height];
          }
          updateCornerState(_) {
            void 0 !== _.cornerRadius && (this.cornerRadius = _.cornerRadius);
          }
          updateSizeState(_) {
            let I = !1;
            void 0 !== _.width &&
              ((this.width = "number" == typeof _.width ? _.width : this.width),
              (I = !0)),
              void 0 !== _.height &&
                ((this.height =
                  "number" == typeof _.height ? _.height : this.height),
                (I = !0)),
              I && this.updateWorldMatrix(!0, !1, !0);
          }
          updateState(_, I) {
            super.updateState(_, I),
              this.updateSizeState(_),
              this.updateCornerState(_),
              void 0 !== _.fill && this.fill.update(_.fill),
              void 0 !== _.stroke && this.stroke.update(_.stroke),
              void 0 !== _.dropShadow && this.dropShadow.update(_.dropShadow),
              void 0 !== _.innerShadow &&
                this.innerShadow.update(_.innerShadow),
              void 0 !== _.layerBlur && this.layerBlur.update(_.layerBlur),
              void 0 !== _.backgroundBlur &&
                this.backgroundBlur.update(_.backgroundBlur),
              void 0 !== _.clipped && (this.clipped = _.clipped);
          }
          requestRender() {
            super.requestRender(), this.dispatchEvent({ type: "render" });
          }
          dispose() {
            this.removeEventListener("render");
          }
          updateByPatchedOp(_, I, R) {
            super.updateByPatchedOp(_, I, R),
              0 === _.type &&
                (Rt(_.path, ["fill"])
                  ? this.fill.update(_.props)
                  : Rt(_.path, ["stroke"])
                  ? this.stroke.update(_.props)
                  : Rt(_.path, ["dropShadow"])
                  ? this.dropShadow.update(_.props)
                  : Rt(_.path, ["innerShadow"])
                  ? this.innerShadow.update(_.props)
                  : Rt(_.path, ["layerBlur"])
                  ? this.layerBlur.update(_.props)
                  : Rt(_.path, ["backgroundBlur"])
                  ? this.backgroundBlur.update(_.props)
                  : this.resetBBoxNeedsUpdate());
          }
          clone(_) {
            let I = new C$(this.uuid, this.data, _);
            for (let R of ((I.parent = void 0), this.children))
              I.add(R.clone(_));
            return I;
          }
        },
        C0 = pi(iq(), 1),
        C1 = class extends CX {
          constructor(_, I, R) {
            super(_, I, R),
              (this.uuid = _),
              (this.data = I),
              (this._pathBBox = new DOMRect()),
              (this.path = ""),
              this.updateState(I, R),
              (this.autoClose = !1),
              this.computeSVGBBox();
          }
          computeSVGBBox() {
            let _ = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "svg"
              ),
              I = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "path"
              );
            document.body.appendChild(_),
              I.setAttribute("d", this.path),
              _.appendChild(I),
              (this._pathBBox = I.getBBox()),
              _.remove();
          }
          innerDraw(_) {
            _.path(this.path);
          }
          intersectsInLocalSpace(_, I) {
            return (
              _ >= this._pathBBox.x &&
              _ <= this._pathBBox.x + this._pathBBox.width &&
              I >= this._pathBBox.y &&
              I <= this._pathBBox.y + this._pathBBox.height
            );
          }
          getCenter() {
            return [
              (this._pathBBox.x + this._pathBBox.width) / 2,
              (this._pathBBox.y + this._pathBBox.height) / 2,
            ];
          }
          getHalfSize() {
            return [
              (this._pathBBox.x + this._pathBBox.width) / 2,
              (this._pathBBox.y + this._pathBBox.height) / 2,
            ];
          }
          updateState(_, I) {
            super.updateState(_, I),
              void 0 !== _.path &&
                ((this.path = _.path), this.computeSVGBBox());
          }
          clone(_) {
            let I = new C1(this.uuid, this.data, _);
            return (I.parent = void 0), I;
          }
        },
        C3 = class {
          constructor(_, I, R) {
            (this.uuid = _),
              (this.data = I),
              (this.group = new CI(C3.GROUP_ID, { ...v4.defaultData }, R)),
              this.createChildrenObjects(I.objects, this.group, R);
          }
          createObject(_, I, R, B, z, k) {
            let V = (function (_, I, R) {
              switch (I.type) {
                case "ellipse2d":
                  return new CQ(_, I, R);
                case "rectangle2d":
                  return new CZ(_, I, R);
                case "text2d":
                  return new CK(_, I, R);
                case "vector2d":
                  return new CJ(_, I, R);
                case "path2d":
                  return new C1(_, I, R);
                case "frame2d":
                  return new C$(_, I, R);
                default:
                  return new CI(_, I, R);
              }
            })(_, I, k);
            V &&
              (B.add(V),
              B.children.splice(z, 0, B.children.pop()),
              V.updateWorldMatrix(),
              R.length > 0 &&
                (V instanceof CI || V instanceof C$) &&
                this.createChildrenObjects(R, V, k));
          }
          createChildrenObjects(_, I, R) {
            let B = 0;
            for (let z of _)
              this.createObject(z.id, z.data, z.children, I, B, R), (B += 1);
          }
          draw(_) {
            this.group.draw(_);
          }
          updateEntityByOp(_, I, R, B) {
            let z = this.find(_);
            if (z)
              try {
                z.updateByOp(I, R, { shared: B });
              } catch (_) {
                console.error(_);
              }
          }
          updateTreeByOp(_, I) {
            if (0 === _.path.length && 7 === _.type) {
              let R = null === _.parent ? this.group : this.find(_.parent);
              void 0 !== R &&
                R instanceof CO &&
                (this.createObject(
                  _.id,
                  _.data,
                  _.children,
                  R,
                  _.localIndex,
                  I
                ),
                R.requestRender());
            } else if (0 === _.path.length && 8 === _.type) {
              let I = this.find(_.id);
              if (
                void 0 !== I &&
                void 0 !== I.parent &&
                I.parent instanceof CO
              ) {
                let _ = I.parent;
                I.resetBBoxNeedsUpdate(), _?.remove(I), _?.requestRender();
              }
            } else if (0 === _.path.length && 9 === _.type) {
              let I = this.find(_.id);
              if (void 0 !== I) {
                let R = I.parent,
                  B = null === _.parent ? this : this.find(_.parent);
                if (B instanceof CO || B === this) {
                  B.add(I);
                  let z = _.localIndex;
                  B.children.splice(z, 0, B.children.pop()),
                    I.updateWorldMatrix(!0, !1, !0),
                    R?.requestRender(),
                    I.requestRender();
                }
                I.resetBBoxNeedsUpdate();
              }
            }
          }
          add(_) {
            this.group.add(_);
          }
          remove(_) {
            this.group.remove(_);
          }
          traverse(_) {
            this.group.traverse((I) => {
              I !== this.group && _(I);
            });
          }
          intersectsChildren(_, I, R, B = !1, z = []) {
            return this.group.intersectsChildren(_, I, R, B, z, !0);
          }
          find(_) {
            return this.group.find(_);
          }
          get children() {
            return this.group.children;
          }
          project(_, I) {
            return this.group.project(_, I);
          }
          getWithSortKey(_) {
            let I = this.find(_);
            if (void 0 === I) return;
            let R = [],
              B = I;
            for (; B !== this.group; ) {
              let _ = B,
                I = (B = B.parent).children.indexOf(_);
              R.splice(0, 0, I);
            }
            return { entity: I, sortKey: R };
          }
          getAllSorted(_) {
            let I = [];
            for (let R of _) {
              let _ = this.getWithSortKey(R.id);
              void 0 !== _ && I.push(_);
            }
            return (
              I.sort((_, I) => xv(_.sortKey, I.sortKey)), I.map((_) => _.entity)
            );
          }
        };
      function Q_({
        constraints: _,
        newParentWidth: I,
        newParentHeight: R,
        initialParentWidth: B,
        initialParentHeight: z,
        objectInitialWidth: k,
        objectInitialHeight: V,
        objectInitialPosition: j,
      }) {
        let { horizontalConstraint: G, verticalConstraint: q } = _,
          X = I - B,
          Q = R - z,
          $ = k,
          et = V,
          er = j[0],
          es = j[1];
        if (0 !== G) {
          if (1 === G) er += X;
          else if (3 === G) er += X / 2;
          else if (2 === G) $ = Math.max(1, $ + X);
          else if (4 === G) {
            let _ = I / B;
            ($ *= _), (er *= _);
          }
        }
        if (0 !== q) {
          if (1 === q) es += Q;
          else if (3 === q) es += Q / 2;
          else if (2 === q) et = Math.max(1, et + Q);
          else if (4 === q) {
            let _ = R / z;
            (et *= _), (es *= _);
          }
        }
        return { width: $, height: et, position: [er, es] };
      }
      (C3.GROUP_ID = "scene2d"), pi(iq(), 1);
      var C4 = CC.identity(),
        C5 = class {
          constructor(_, I, R, B) {
            (this.uuid = _),
              (this.width = I),
              (this.height = R),
              (this.context = B),
              (this.enabled = !0),
              (this.isScreenSpace = !1),
              (this.isFrameDirty = !1),
              (this.onRenderRequestedDownstream = () => {
                (this.isFrameDirty = !0), this.context.shared.requestRender();
              }),
              (this.onFrameOverrideObjectEvent = (_) => {
                if (_.target?.uuid !== void 0) {
                  let I = this.frameRoot?.find(_.target.uuid);
                  I && I.dispatchEvent({ ..._, target: I });
                }
              }),
              (this.scene2d = new C3(rr.generateUUID(), v8.defaultData, {
                dpr: window.devicePixelRatio,
                shared: B.shared,
              })),
              (this.canvas = document.createElement("canvas")),
              (this.renderer = new CN(this.canvas)),
              B.shared.addCanvas(this.uuid, this.canvas),
              (this.textureHolder = B.shared.canvas(this.uuid)),
              (this.promise = this.init());
          }
          async init() {
            this.renderer instanceof CN &&
              (this.renderer.wasmURL = _Z.skiaWasmUrl),
              await this.renderer.init();
          }
          render() {
            this.isFrameDirty &&
              (this.renderer.clear(),
              this.frameOverride?.draw(this.renderer),
              this.renderer.render(),
              this.textureHolder?.setNeedsUpdate(!0),
              (this.isFrameDirty = !1));
          }
          updateEntity2DByOp(_, I, R, B) {
            this.scene2d.updateEntityByOp(_, I, R, B), this.applySize();
          }
          updateTreeByOp(_, I) {
            this.scene2d.updateTreeByOp(_, I), this.applySize();
          }
          applyOverrides(_) {
            if (this.frameOverride && this.frameRoot) {
              (this.frameOverride.position = [0, 0]),
                (this.frameOverride.rotation = 0);
              let I = _?.width ?? this.width,
                R = _?.height ?? this.height;
              (this.frameOverride.width = I),
                (this.frameOverride.height = R),
                (this.frameOverride.localMatrix = C4),
                this.isScreenSpace &&
                  (this.frameOverride.fill.color = mb.from0to1([0, 0, 0, 0])),
                (this.frameOverride.data = {
                  ...this.frameOverride.data,
                  width: I,
                  height: R,
                }),
                (function eL({
                  objectOverride: _,
                  objectRoot: I,
                  newParentWidth: R,
                  newParentHeight: B,
                  initialParentWidth: z,
                  initialParentHeight: k,
                }) {
                  if (
                    (_ instanceof C$ && I instanceof C$) ||
                    (_ instanceof CI && I instanceof CI)
                  )
                    for (let V = 0, j = _.children.length; V < j; V++) {
                      let j = _.children[V],
                        G = I.children[V];
                      j &&
                        G &&
                        j.uuid === G.uuid &&
                        (function ({
                          objectOverride: _,
                          objectRoot: I,
                          newParentWidth: R,
                          newParentHeight: B,
                          initialParentWidth: z,
                          initialParentHeight: k,
                        }) {
                          let [V, j] = (function (_) {
                              if (K_(_)) return [_.width, _.height];
                              if (_ instanceof C1) {
                                let [I, R] = _.getHalfSize();
                                return [2 * I, 2 * R];
                              }
                              if (_ instanceof CI) {
                                let [I, R] = _.recursiveBBox.getHalfSize();
                                return [2 * I, 2 * R];
                              }
                              return [0, 0];
                            })(I),
                            {
                              width: G,
                              height: q,
                              position: X,
                            } = Q_({
                              constraints: _.data,
                              newParentWidth: R,
                              newParentHeight: B,
                              initialParentWidth: z,
                              initialParentHeight: k,
                              objectInitialWidth: V,
                              objectInitialHeight: j,
                              objectInitialPosition: I.position,
                            });
                          if (
                            ((_.position = X),
                            (_.data = { ..._.data, position: X }),
                            _.states)
                          )
                            for (let V in _.states)
                              !(function ({
                                stateId: _,
                                objectOverride: I,
                                objectRoot: R,
                                newParentWidth: B,
                                newParentHeight: z,
                                initialParentWidth: k,
                                initialParentHeight: V,
                              }) {
                                let j = I.states?.[_],
                                  G = R.states?.[_];
                                if (j && G) {
                                  let {
                                    width: R,
                                    height: q,
                                    position: X,
                                  } = Q_({
                                    constraints: I.data,
                                    newParentWidth: B,
                                    newParentHeight: z,
                                    initialParentWidth: k,
                                    initialParentHeight: V,
                                    objectInitialWidth: v6.isResizeable(G)
                                      ? G.width
                                      : 0,
                                    objectInitialHeight: v6.isResizeable(G)
                                      ? G.height
                                      : 0,
                                    objectInitialPosition: G.position,
                                  });
                                  Object.assign(I.states[_], { position: X }),
                                    v6.isResizeable(j) &&
                                      Object.assign(I.states[_], {
                                        width: R,
                                        height: q,
                                      });
                                }
                              })({
                                stateId: V,
                                objectOverride: _,
                                objectRoot: I,
                                newParentWidth: R,
                                newParentHeight: B,
                                initialParentWidth: z,
                                initialParentHeight: k,
                              });
                          if (K_(_) || _ instanceof CI)
                            K_(_) &&
                              ((_.width = G),
                              (_.height = q),
                              (_.data = { ..._.data, width: G, height: q })),
                              eL({
                                objectOverride: _,
                                objectRoot: I,
                                newParentWidth: G,
                                newParentHeight: q,
                                initialParentWidth: V,
                                initialParentHeight: j,
                              });
                          else if (_ instanceof C1) {
                            let R = 0 !== V ? G / V : 1,
                              B = 0 !== j ? q / j : 1;
                            (_.path = (function (_, I = 1, R = 1) {
                              return I <= 0 || R <= 0
                                ? _
                                : (function (_) {
                                    let I = [
                                        "rx",
                                        "ry",
                                        "xAxisRotation",
                                        "largeArc",
                                        "sweep",
                                        "x1",
                                        "y1",
                                        "x2",
                                        "y2",
                                        "x",
                                        "y",
                                      ],
                                      R;
                                    return _.map((_) => {
                                      let B = [];
                                      I.forEach((I) => {
                                        if (I in _) {
                                          let R = 1 * _[I];
                                          B.length && R >= 0 && B.push(","),
                                            B.push(R);
                                        }
                                      });
                                      let z =
                                        (R === _.code
                                          ? B[0] < 0
                                            ? ""
                                            : ","
                                          : _.code) + B.join("");
                                      return (R = _.code), z;
                                    }).join("");
                                  })(
                                    (0, C0.parseSVG)(_).map((_) => {
                                      let B = { ..._ };
                                      return (
                                        "x" in B && (B.x = B.x * I),
                                        "y" in B && (B.y = B.y * R),
                                        "x1" in B && (B.x1 = B.x1 * I),
                                        "x2" in B && (B.x2 = B.x2 * I),
                                        "y1" in B && (B.y1 = B.y1 * R),
                                        "y2" in B && (B.y2 = B.y2 * R),
                                        "rx" in B && (B.rx = B.rx * I),
                                        "ry" in B && (B.ry = B.ry * R),
                                        B
                                      );
                                    })
                                  );
                            })(I.path, R, B)),
                              (_.data = { ..._.data, path: _.path });
                          }
                        })({
                          objectOverride: j,
                          objectRoot: G,
                          newParentWidth: R,
                          newParentHeight: B,
                          initialParentWidth: z,
                          initialParentHeight: k,
                        });
                    }
                })({
                  objectOverride: this.frameOverride,
                  objectRoot: this.frameRoot,
                  newParentWidth: this.frameOverride.width,
                  newParentHeight: this.frameOverride.height,
                  initialParentWidth: this.frameRoot.width,
                  initialParentHeight: this.frameRoot.height,
                }),
                this.frameOverride.updateWorldMatrix(!0, !1, !0);
            }
          }
          applySize(_) {
            let I = _?.width ?? this.width,
              R = _?.height ?? this.height;
            (this.width = I),
              (this.height = R),
              (this.renderer.dpr = this.isScreenSpace
                ? window.devicePixelRatio
                : Math.floor(2048 / Math.max(I, R))),
              this.renderer.setSize(I, R),
              this.textureHolder?.dispose(),
              this.applyOverrides(_),
              this.frameOverride?.requestRender();
          }
          applyFrame(_) {
            let I = this.context.scene.find2D(_);
            if (!(!I || !(I instanceof C$)))
              return (
                this.disposeFrameOverride(),
                (this.frameRoot = I),
                (this.frameOverride = I.clone({
                  dpr: this.renderer.dpr,
                  shared: this.context.shared,
                })),
                this.scene2d.add(this.frameOverride),
                this.applySize(),
                this.textureHolder?.dispose(),
                this.frame?.addEventListener(
                  "render",
                  this.onRenderRequestedDownstream
                ),
                this.frameOverride.traverse((_) => {
                  _.addEventListener(
                    "beginState",
                    this.onFrameOverrideObjectEvent
                  );
                }),
                this.frameOverride.traverse((_) => {
                  _.addEventListener(
                    "completeState",
                    this.onFrameOverrideObjectEvent
                  );
                }),
                this.frame?.requestRender(),
                I
              );
          }
          get frame() {
            return this.frameOverride;
          }
          get frameId() {
            return this.frame?.uuid;
          }
          find(_) {
            return this.scene2d.find(_);
          }
          get texture() {
            return this.textureHolder?.getTexture(1001);
          }
          disposeFrameOverride() {
            this.frameOverride?.removeEventListener(
              "render",
              this.onRenderRequestedDownstream
            ),
              this.frameOverride?.traverse((_) => {
                _.removeEventListener(
                  "beginStateChange",
                  this.onFrameOverrideObjectEvent
                );
              }),
              this.frameOverride?.traverse((_) => {
                _.removeEventListener(
                  "completeState",
                  this.onFrameOverrideObjectEvent
                );
              }),
              this.frameOverride && this.scene2d.remove(this.frameOverride);
          }
        };
      function K_(_) {
        return (
          _ instanceof CZ ||
          _ instanceof C$ ||
          _ instanceof CQ ||
          _ instanceof CK
        );
      }
      var C6 = class extends Cd(nz) {
          constructor(_, I, R) {
            super(),
              (this.data = I),
              (this.bgColor = new wA(1, 1, 1, 1)),
              (this.fog = null),
              (this.backupFog = new nL(16777215, 0.1, 2e3)),
              (this.fogUseBGColor = !1),
              (this.isActive = !1),
              (this.aoColor = new ry()),
              (this.penumbraSizeArrayCache = null),
              this.super_Entity(_, I),
              (this.personalCamera = new AK(fx, {
                ...vn.defaultData,
                ...I.camera,
                name: "Personal Camera",
              })),
              (this.personalCamera.objectHelper.visible = !1),
              this.add(this.personalCamera),
              (this.activeCamera = this.personalCamera),
              (this.ambientLight = new lt(13882323, 8553090, 0.75)),
              (this.ambientLight.name = "Default Ambient Light"),
              this.ambientLight.layers.enable(3),
              this.ambientLight.removeFromParent(),
              this.add(this.ambientLight),
              I.uiScene
                ? (this.uiScene = new C3(
                    (Array.isArray(_) ? _[0] : _) + "-ui",
                    I.uiScene,
                    { dpr: window.devicePixelRatio, shared: R.shared }
                  ))
                : I.uiFrame && this.createUICanvas(I.uiFrame, R);
          }
          get scene() {
            return this.parent;
          }
          get postprocessing() {
            return this.data.postprocessing;
          }
          get frameId() {
            return this.data.uiFrame;
          }
          get frame() {
            return this.uiCanvas?.frame;
          }
          createUICanvas(_, I) {
            (this.uiCanvas = new C5(
              this.uuid + "-uiscreen",
              window.innerWidth,
              window.innerHeight,
              I
            )),
              (this.uiCanvas.isScreenSpace = !0),
              this.uiCanvas.promise.then(() => {
                this.uiCanvas?.applyFrame(_), this.uiCanvas?.applySize();
              });
          }
          updateVisible() {}
          setBackgroundColor(_) {
            (this.bgColor = _),
              !0 === this.fogUseBGColor && (this.backupFog.color = _);
          }
          entityChildrenCount() {
            return this.uiScene
              ? this.uiScene.children.length
              : super.entityChildrenCount();
          }
          updateAmbientLight(_, I) {
            void 0 !== _.color && (this.ambientLight.color = on(_.color, I)),
              void 0 !== _.intensity &&
                (this.ambientLight.intensity = _.intensity),
              void 0 !== _.enabled &&
                (_.enabled
                  ? this.add(this.ambientLight)
                  : this.remove(this.ambientLight));
          }
          onDeactive() {
            this.isActive = !1;
          }
          onActive(_) {
            (this.isActive = !0),
              (_.fog = this.fog),
              this.traverseEntity((_) => {
                _ instanceof A1 && _.recomputeBoolean();
              }),
              this.updateShadow(this.data.shadow);
          }
          forceMaterialsUpdate() {
            this.traverseEntity((_) => {
              if (_ instanceof SZ) {
                if (Array.isArray(_.material))
                  for (let I of _.material) I.needsUpdate = !0;
                else (_.material.needsUpdate = !0), _.material.dispose();
              }
            });
          }
          updateShadow(_) {
            void 0 !== _.softShadowQuality &&
              this.isActive &&
              P3(_.softShadowQuality) &&
              this.forceMaterialsUpdate();
          }
          updateFog(_, I) {
            _.enabled ? (this.fog = this.backupFog) : (this.fog = null),
              this.isActive && (this.scene.fog = this.fog),
              (this.fogUseBGColor = _.useBackgroundColor),
              _.useBackgroundColor
                ? this.backupFog.color.set(this.bgColor)
                : (this.backupFog.color = on(_.color, I)),
              (this.backupFog.near = _.near),
              (this.backupFog.far = _.far);
          }
          updateAo(_, I) {
            void 0 !== _.aoColor && (this.aoColor = on(_.aoColor, I));
          }
          updateByOp(_, I, R, B) {
            let z = this.data.uiFrame;
            super.updateByOp(_, I, R, B),
              Rt(_.path, ["fog"])
                ? this.updateFog(I.fog, R.shared)
                : Rt(_.path, ["ao"])
                ? this.updateAo(I.ao, R.shared)
                : Rt(_.path, ["ambient"])
                ? this.updateAmbientLight(I.ambient, R.shared)
                : Rt(_.path, ["shadow"])
                ? this.updateShadow(I.shadow)
                : 0 === _.type &&
                  0 === _.path.length &&
                  (void 0 !== _.props.uiFrame || z !== I.uiFrame) &&
                  this.updateUIFrame(_.props.uiFrame, R);
          }
          updateUIFrame(_, I) {
            _
              ? (this.uiCanvas || this.createUICanvas(_, I),
                (this.uiCanvas.enabled = !0),
                this.uiCanvas.applyFrame(_))
              : this.uiCanvas && (this.uiCanvas.enabled = !1);
          }
          updateState(_, I) {
            this.updateState_Entity(_, I),
              void 0 !== _.backgroundColor &&
                this.setBackgroundColor(on(_.backgroundColor, I.shared)),
              void 0 !== _.fog && this.updateFog(_.fog, I.shared),
              void 0 !== _.ambient &&
                this.updateAmbientLight(_.ambient, I.shared),
              void 0 !== _.ao && this.updateAo(_.ao, I.shared),
              void 0 !== _.shadow && this.updateShadow(_.shadow);
          }
          createFrame(_, I) {}
          raycast(_, I) {
            super.raycast(_, I);
          }
          switchActiveCamera(_) {
            _ &&
              _.isDescendantOf(this) &&
              (this.activeCamera !== this.personalCamera &&
                (this.activeCamera.objectHelper.visible = !0),
              (this.activeCamera = _),
              (_.objectHelper.visible = !1));
          }
          get playCamera() {
            return (
              this.scene?.find(this.data.publish.playCamera) ??
              this.personalCamera
            );
          }
          switchToPlayCamera() {
            this.switchActiveCamera(this.playCamera);
          }
          get penumbraSizeArray() {
            return (
              null === this.penumbraSizeArrayCache &&
                this.updatePenumbraSizeArray(),
              this.penumbraSizeArrayCache
            );
          }
          updatePenumbraSizeArray() {
            this.penumbraSizeArrayCache = [, , , , ,].fill(0.5);
            let _ = 0,
              I = 0;
            this.traverseEntity((R) => {
              if (!R.visible) return !0;
              R instanceof Cg &&
                R.visible &&
                _ < 3 &&
                ((this.penumbraSizeArrayCache[_] = R.data.penumbraSize),
                (_ += 1)),
                R instanceof C_ &&
                  R.visible &&
                  _ < 2 &&
                  ((this.penumbraSizeArrayCache[3 + I] = R.data.penumbraSize),
                  (I += 1));
            });
          }
          raycastWithClones(_) {
            let I = [],
              i = (R) => {
                for (let B of R.children) {
                  let R = B.cloner;
                  bG.is(B) &&
                    (B.visible || R?.object.data.visible) &&
                    ((mn(B) ||
                      (Wm(B) &&
                        this.scene.enableHelpers &&
                        B.objectHelper.visible)) &&
                      (_.intersectObject(B, !1, I), eg(B, _, I, !0)),
                    i(B));
                }
              };
            return i(this), I;
          }
          updateEntity2DByOp(_, I, R, B) {
            this.uiCanvas?.updateEntity2DByOp(_, I, R, B);
          }
        },
        C8 = class extends bf(lp, Cu) {
          constructor(_, I, R) {
            super(),
              this.super_Entity(_, I),
              (this.castShadow = !0),
              (this.shadow.mapSize.width = 1024),
              (this.shadow.mapSize.height = 1024),
              (this.shadow.normalBias = 1),
              this.layers.enable(3);
            let B = this.shadow.camera;
            (B.fov = 90), (B.aspect = 1), (B.near = 100), (B.far = 2500);
            let z = new rF(
                -B.far + this.position.x,
                -B.far + this.position.y,
                -B.far + this.position.z
              ),
              k = new rF(
                B.far + this.position.x,
                B.far + this.position.y,
                B.far + this.position.z
              ),
              V = new rU(z, k),
              j = new l5(V, new ry(16755200));
            (j.visible = !1), (this.gizmos.shadowmap = j), this.update();
          }
          update() {
            if (
              this.shadow &&
              (this.shadow.camera.updateProjectionMatrix(), this.gizmos)
            )
              for (let _ in this.gizmos) {
                let I = this.gizmos[_];
                if (I instanceof l5) {
                  let _ = this.shadow.camera,
                    R = new rF(
                      -_.far + this.position.x,
                      -_.far + this.position.y,
                      -_.far + this.position.z
                    ),
                    B = new rF(
                      _.far + this.position.x,
                      _.far + this.position.y,
                      _.far + this.position.z
                    );
                  I.box.set(R, B), I.updateMatrixWorld(!0);
                }
              }
          }
          updateMatrixWorld(_) {
            super.updateMatrixWorld(_),
              this.objectHelper && this.objectHelper.update();
          }
          updateState(_, I) {
            this.updateState_Light(_, I),
              void 0 !== _.distance && (this.distance = _.distance),
              void 0 !== _.decay && (this.decay = _.decay),
              void 0 !== _.shadowRadius &&
                (this.shadow.radius = _.shadowRadius),
              void 0 !== _.shadowResolution &&
                (this.shadow.mapSize.set(
                  _.shadowResolution,
                  _.shadowResolution
                ),
                this.shadow.map &&
                  (this.shadow.map.dispose(), (this.shadow.map = null)));
          }
        },
        C9 = class extends S2 {
          get forceComputeSize() {
            return !0;
          }
          get shape() {
            return this.geometry.userData.shape;
          }
          updateEntityBoxSize(_, I) {
            let R = this.geometry.getAttribute("position");
            void 0 !== R
              ? Cm(
                  R,
                  this.geometry.drawRange.start,
                  this.geometry.drawRange.count < 1 / 0
                    ? this.geometry.drawRange.count
                    : R.count,
                  _,
                  I
                )
              : super.updateEntityBoxSize(_, I);
          }
        },
        C7 = class extends S2 {
          constructor(_, I, R) {
            super(_, I, R), (this._shapeId = null), (this._context = R);
          }
          updateState(_, I) {
            super.updateState(_, I), this.updateShape();
          }
          updateShape() {
            let _,
              I = { ...this.data.geometry.extrusion.shape };
            for (let _ in I)
              "string" == typeof I[_] &&
                (I[_] = this._context.shared.getVariable(I[_], [
                  this.uuid,
                  "geometry",
                  "extrusion",
                  "shape",
                  _,
                ]));
            if ("Custom" === I.type) {
              let R = I.shapeId;
              if ((R !== this._shapeId && this.detachShape(), R)) {
                this._shapeId = R;
                let I = this._context.scene.find(R);
                I?.data &&
                  (I.attachedPaths.add(this), (_ = I.geometry.userData?.shape)),
                  _ ||
                    this._context.scene.addPendingCommand(() =>
                      this.updateShape()
                    );
              }
            } else {
              let R;
              switch (I.type) {
                case "Rectangle":
                  R = bv;
                  break;
                case "Ellipse":
                  R = xK;
                  break;
                case "Polygon":
                  R = bd;
                  break;
                case "Star":
                  R = b_;
                  break;
                default:
                  throw Error(`Unknown shape type: ${I.type}`);
              }
              _ = R.create({ parameters: I }).userData.shape;
            }
            let R = this.geometry;
            _ &&
              R.inputs &&
              ((R.inputs.shapeData = _),
              R.build(),
              this.attachedSurfaceCloners.forEach((_) => _.update()));
          }
          detachShape() {
            null !== this._shapeId &&
              this._context.scene
                .find(this._shapeId)
                ?.attachedPaths.delete(this);
          }
          createGeometryDelayed(_) {
            (this.geometryCreateDeleyed = _.shared),
              this.updateShape(),
              this.refreshAttachedPaths(_);
          }
          updateTransformState(_, I) {
            return super.updateTransformState(_, I);
          }
          updateGeometryInteractions(_, I) {
            super.updateGeometryInteractions(_, I), this.updateShape();
          }
          updateEntityBoxSize(_, I) {
            let R = this.geometry.getAttribute("position");
            void 0 !== R
              ? Cm(
                  R,
                  this.geometry.drawRange.start,
                  this.geometry.drawRange.count < 1 / 0
                    ? this.geometry.drawRange.count
                    : R.count,
                  _,
                  I
                )
              : super.updateEntityBoxSize(_, I);
          }
        },
        Te = class extends Is(nT, A2) {
          constructor(_, I, R) {
            super(),
              "Instance" === I.type &&
                "string" == typeof _ &&
                (I = this.transformAssignData(I, R)),
              this.super_Entity(_, I),
              this.objectHelper.update();
          }
          get isComponentRoot() {
            return (
              "Component" === this.data.type && "string" == typeof this.identity
            );
          }
          get isInstanceRoot() {
            return (
              "Instance" === this.data.type && "string" == typeof this.identity
            );
          }
          transformAssignData(_, I) {
            let R = vj.getComponentData(
              { scene: I.scene.data, shared: I.shared.data },
              _.component
            );
            if (!R)
              return {
                ...g7.defaultData,
                ..._,
                ...uo(g7.defaultData, vc.rootOverrideProps),
              };
            {
              let I, B;
              for (let z of vc.rootOverrideProps)
                void 0 === _[z]
                  ? (void 0 === I && (I = { ..._ }), (I[z] = R.data[z]))
                  : (void 0 === B && (B = {}),
                    (B[z] = _[z]),
                    void 0 === I && (I = { ..._ }),
                    (I[z] = uj.apply(R.data[z], _[z])));
              return (this.overrideData = B), I;
            }
          }
          updateByOp(_, I, R, B) {
            let z;
            if (this.isInstanceRoot && !B) {
              if (
                ((I = this.transformAssignData(I, R)),
                0 === _.type && 0 === _.path.length && this.component)
              )
                for (let I of vc.rootOverrideProps)
                  I in _.props &&
                    void 0 === _.props[I] &&
                    (void 0 === z && (z = { ..._, props: { ..._.props } }),
                    (z.props[I] = this.component.data[I]));
              else if (
                0 === _.type &&
                _.path.length > 0 &&
                vc.rootOverrideProps.includes(_.path[0])
              ) {
                let R = _.path[0];
                void 0 === z && (z = { ..._, path: [], props: { [R]: I[R] } });
              }
            }
            super.updateByOp(z ?? _, I, R, B);
          }
          updateState(_, I) {
            this.updateState_Entity(_, I);
          }
          expandInstanceChildren(_) {
            let I = this.data;
            if (void 0 === this.component) {
              let R = _.scene.find(I.component) ?? null,
                B = !1;
              if (R !== this.oldComponent) {
                if (this.oldComponent) {
                  let I = 0;
                  for (let R of this.children)
                    if (bG.is(R))
                      _.scene.disposeAndUnregisterEntityRecursivelyIfNotReregistered(
                        R
                      ),
                        Qx(R),
                        (I += 1);
                    else break;
                  this.children.splice(0, I);
                }
                B = !0;
              }
              if (R) {
                let z = {};
                for (let k of ((function rL(_, I, R, B, z, k, V, j, G) {
                  if (V > 50) return !1;
                  if (B.component !== z) {
                    if (B.component) {
                      let _ = B.component.instances.indexOf(B);
                      _ >= 0 && B.component.instances.splice(_, 1);
                    }
                    z.instances.find((_) => _ === B) || z.instances.push(B),
                      (B.component = z);
                  }
                  z instanceof Te &&
                    z.isInstanceRoot &&
                    z.expandInstanceChildren(_);
                  let q = 0;
                  for (let X of z.children)
                    if (bG.is(X)) {
                      let z = [
                          ...I,
                          ...("string" == typeof X.identity
                            ? [X.identity]
                            : X.identity),
                        ],
                        Q = vh.resolve(R, z, 1);
                      null == Q ||
                        Q instanceof uG ||
                        (Object.setPrototypeOf(Q, uG.prototype),
                        console.error("wrong prototype"));
                      let $ = null,
                        et;
                      if (!j) {
                        let I = B.children[q];
                        if (null !== ($ = bG.is(I) ? I : null)) {
                          let _ = tL($, X, Q, z);
                          (et = _ >= 1 ? $.stateSelection : void 0),
                            2 !== _ && ($ = null);
                        }
                        if (
                          null === $ &&
                          null !== ($ = _.scene.findInstance(z) ?? null)
                        ) {
                          let I = tL($, X, Q, z);
                          if (
                            ((et = I >= 1 ? $.stateSelection : void 0), 2 !== I)
                          )
                            $ = null;
                          else {
                            let I = $.parent.children.indexOf($);
                            $.parent.children.splice(I, 1),
                              B.children.splice(q, 0, $),
                              $.parent === B
                                ? I <= q && console.error("not possible")
                                : (($.parent = B),
                                  ($.matrixWorldNeedsUpdate = !0),
                                  $.resetBBoxNeedsUpdate(),
                                  $.updateVisible(),
                                  _.pendingDeletes.delete($));
                          }
                        }
                      }
                      if (null === $) {
                        let I = Q ? uj.apply(X.data, Q) : X.data;
                        mP.is(I.type) && (I = { ...I, type: "Empty" }),
                          (($ = yZ.createEntity(z, I, _)).overrideData = Q),
                          B.add($),
                          B.children.splice(B.children.length - 1, 1),
                          B.children.splice(q, 0, $),
                          $.updateState($.data, _),
                          et && $.changeSelectedState(et, _),
                          _.scene.registerInstanceAndSetUuid($);
                      }
                      $.isBone &&
                        (G[$.identity[$.identity.length - 1]] = $.uuid),
                        (q += 1),
                        rL(_, I, R, $, X, k, V + 1, j, G);
                    }
                  if (!j) {
                    let I = q;
                    for (;;) {
                      let I = B.children[q];
                      if (bG.is(I)) _.pendingDeletes.add(I);
                      else break;
                      q += 1;
                    }
                    B.children.splice(I, q - I);
                  }
                  return !0;
                })(_, [this.uuid], I.overrides, this, R, R, 0, B, z),
                this.children))
                  if (bG.is(k)) {
                    let I = k.data;
                    "Empty" === I.type &&
                      I.animations &&
                      k.traverseEntity((I) => {
                        if (I instanceof S2 && I.isSkinnedMesh) {
                          let R = I.dataPatched;
                          if (R.bones && R.boneInverses) {
                            let B = R.bones.map((I) => _.scene.find(z[I])),
                              k = R.boneInverses.map((_) =>
                                new sa().fromArray(_)
                              ),
                              V = new nW(B, k);
                            I.bind(V, I.bindMatrix);
                          }
                        } else I.matrixAutoUpdate = !0;
                      });
                  }
              }
              this.oldComponent = this.component;
            }
          }
        };
      function Qx(_) {
        if (_.component) {
          let I = _.component.instances.indexOf(_);
          for (let R of (I >= 0 && _.component.instances.splice(I, 1),
          _.children))
            bG.is(R) && Qx(R);
        }
      }
      function tL(_, I, R, B) {
        return _.component === I && Xp(_.identity, B)
          ? _.overrideData === R
            ? 2
            : 1
          : 0;
      }
      var Tt = class extends Is(nU, A2) {
          constructor(_, I) {
            super(),
              this.super_Entity(_, I),
              this.objectHelper.update(),
              (this.matrixAutoUpdate = !0);
          }
          updateState(_, I) {
            this.updateState_Entity(_, I);
          }
        },
        Ti = class extends S2 {
          constructor(_, I, R) {
            super(_, I, R),
              (this.onBeforeRender = () => {
                this.uiCanvas.render();
              }),
              (this.uiCanvas = new C5(
                _ + "-canvas",
                I.geometry.width,
                I.geometry.height,
                R
              )),
              this.uiCanvas.promise.then(() => {
                this.applyFrame(this.dataPatched.geometry.frame, R.shared);
              });
          }
          updateByPatchedOpGeometry(_, I, R) {
            super.updateByPatchedOpGeometry(_, I, R),
              0 === _.type &&
                (void 0 !== _.props.frame &&
                  this.applyFrame(_.props.frame, R.shared),
                (void 0 !== _.props.width || void 0 !== _.props.height) &&
                  this.applySize(_.props, R.shared));
          }
          applySize(_, I) {
            let R = _?.width ?? this.dataPatched.geometry.width,
              B = _?.height ?? this.dataPatched.geometry.height;
            this.uiCanvas.applySize({ width: R, height: B }),
              this.applyGeometryParametersFromFrame(I);
          }
          applyFrame(_, I) {
            this.uiCanvas.applyFrame(_),
              this.applyGeometryParametersFromFrame(I),
              this.applyMaterialParametersFromFrame({ shared: I });
          }
          applyGeometryParametersFromFrame(_) {
            let I = this.frame;
            I &&
              (Object.assign(this.data, {
                geometry: Object.assign(this.data.geometry, {
                  cornerRadius: I.cornerRadius,
                  cornerType: 0,
                }),
              }),
              Object.assign(this.dataPatched, {
                geometry: Object.assign(this.dataPatched.geometry, {
                  cornerRadius: I.cornerRadius,
                  cornerType: 0,
                }),
              }),
              this.localGeometry?.dispose(),
              (this.localGeometry = Va(
                this.dataPatched.geometry,
                _,
                this.data.flatShading,
                this
              )));
          }
          applyMaterialParametersFromFrame(_) {
            let I = this.frame;
            if (I) {
              let R = I.data.backgroundBlur;
              Object.assign(this.data.material.layers[0].data.texture, {
                image: this.uiCanvas.uuid,
              }),
                Object.assign(this.data.material.layers[1].data, {
                  roughness: R.radius,
                  alpha: R.enabled ? 1 : 0,
                }),
                Object.assign(
                  this.dataPatched.material.layers[0].data.texture,
                  { image: this.uiCanvas.uuid }
                ),
                Object.assign(this.dataPatched.material.layers[1].data, {
                  roughness: R.radius,
                  alpha: R.enabled ? 1 : 0,
                }),
                this.material.reset(this.dataPatched.material, _, !0);
            }
          }
          updateEntity2DByOp(_, I, R, B) {
            this.uiCanvas.updateEntity2DByOp(_, I, R, B),
              _ === this.frameId &&
                0 === I.type &&
                (void 0 !== I.props.cornerRadius
                  ? this.applyGeometryParametersFromFrame(B)
                  : Rt(I.path, ["backgroundBlur"]) &&
                    this.applyMaterialParametersFromFrame({ shared: B }));
          }
          get frame() {
            return this.uiCanvas.frame;
          }
          get frameId() {
            return this.frame?.uuid;
          }
          removeInteractionGeometry(_) {
            super.removeInteractionGeometry(_), this.applySize({}, _);
          }
          updateGeometryInteractions(_, I) {
            super.updateGeometryInteractions(_, I),
              this.applySize({ width: _.width, height: _.height }, I);
          }
        },
        Tr = class {
          constructor(_, I, R) {
            (this.variables = []), (this.currentTextureIndex = 0);
            let B = 1015,
              z = new nz(),
              k = new aP();
            k.position.z = 1;
            let V = { passThruTexture: { value: null } },
              j = h(
                `uniform sampler2D passThruTexture;

void main() {

	vec2 uv = gl_FragCoord.xy / resolution.xy;

	gl_FragColor = texture2D( passThruTexture, uv );

}
`,
                V
              ),
              G = new aw(new aq(2, 2), j);
            function c(R) {
              R.defines.resolution =
                "vec2( " + _.toFixed(1) + ", " + I.toFixed(1) + " )";
            }
            function h(_, I) {
              I = I || {};
              let R = new aT({
                uniforms: I,
                vertexShader: `void main()	{

	gl_Position = vec4( position, 1.0 );

}
`,
                fragmentShader: _,
              });
              return c(R), R;
            }
            z.add(G),
              (this.setDataType = function (_) {
                return (B = _), this;
              }),
              (this.addVariable = function (_, I, R) {
                let B = {
                  name: _,
                  initialValueTexture: R,
                  material: this.createShaderMaterial(I),
                  dependencies: null,
                  renderTargets: [],
                  wrapS: null,
                  wrapT: null,
                  minFilter: 1003,
                  magFilter: 1003,
                };
                return this.variables.push(B), B;
              }),
              (this.setVariableDependencies = function (_, I) {
                _.dependencies = I;
              }),
              (this.init = function () {
                if (
                  !1 === R.capabilities.isWebGL2 &&
                  !1 === R.extensions.has("OES_texture_float")
                )
                  return "No OES_texture_float support for float textures.";
                if (0 === R.capabilities.maxVertexTextures)
                  return "No support for vertex shader textures.";
                for (let R = 0; R < this.variables.length; R++) {
                  let B = this.variables[R];
                  (B.renderTargets[0] = this.createRenderTarget(
                    _,
                    I,
                    B.wrapS,
                    B.wrapT,
                    B.minFilter,
                    B.magFilter
                  )),
                    (B.renderTargets[1] = this.createRenderTarget(
                      _,
                      I,
                      B.wrapS,
                      B.wrapT,
                      B.minFilter,
                      B.magFilter
                    )),
                    this.renderTexture(
                      B.initialValueTexture,
                      B.renderTargets[0]
                    ),
                    this.renderTexture(
                      B.initialValueTexture,
                      B.renderTargets[1]
                    );
                  let z = B.material,
                    k = z.uniforms;
                  if (null !== B.dependencies)
                    for (let _ = 0; _ < B.dependencies.length; _++) {
                      let I = B.dependencies[_];
                      if (I.name !== B.name) {
                        let _ = !1;
                        for (let R = 0; R < this.variables.length; R++)
                          if (I.name === this.variables[R].name) {
                            _ = !0;
                            break;
                          }
                        if (!_)
                          return (
                            "Variable dependency not found. Variable=" +
                            B.name +
                            ", dependency=" +
                            I.name
                          );
                      }
                      (k[I.name] = { value: null }),
                        (z.fragmentShader =
                          `
uniform sampler2D ` +
                          I.name +
                          `;
` +
                          z.fragmentShader);
                    }
                }
                return (this.currentTextureIndex = 0), null;
              }),
              (this.compute = function () {
                let _ = this.currentTextureIndex,
                  I = 0 === this.currentTextureIndex ? 1 : 0;
                for (let R = 0, B = this.variables.length; R < B; R++) {
                  let B = this.variables[R];
                  if (null !== B.dependencies) {
                    let I = B.material.uniforms;
                    for (let R = 0, z = B.dependencies.length; R < z; R++) {
                      let z = B.dependencies[R];
                      I[z.name].value = z.renderTargets[_].texture;
                    }
                  }
                  this.doRenderTarget(B.material, B.renderTargets[I]);
                }
                this.currentTextureIndex = I;
              }),
              (this.getCurrentRenderTarget = function (_) {
                return _.renderTargets[this.currentTextureIndex];
              }),
              (this.getAlternateRenderTarget = function (_) {
                return _.renderTargets[0 === this.currentTextureIndex ? 1 : 0];
              }),
              (this.dispose = function () {
                G.geometry.dispose(), G.material.dispose();
                let _ = this.variables;
                for (let I = 0; I < _.length; I++) {
                  let R = _[I];
                  R.initialValueTexture && R.initialValueTexture.dispose();
                  let B = R.renderTargets;
                  for (let _ = 0; _ < B.length; _++) B[_].dispose();
                }
              }),
              (this.addResolutionDefine = c),
              (this.createShaderMaterial = h),
              (this.createRenderTarget = function (R, z, k, V, j, G) {
                return (
                  (R = R || _),
                  (z = z || I),
                  (k = k || 1001),
                  (V = V || 1001),
                  (j = j || 1003),
                  (G = G || 1003),
                  new rT(R, z, {
                    wrapS: k,
                    wrapT: V,
                    minFilter: j,
                    magFilter: G,
                    format: 1023,
                    type: B,
                    depthBuffer: !1,
                  })
                );
              }),
              (this.createTexture = function () {
                let R = new Float32Array(_ * I * 4),
                  B = new nV(R, _, I, 1023, 1015);
                return (B.needsUpdate = !0), B;
              }),
              (this.renderTexture = function (_, I) {
                (V.passThruTexture.value = _),
                  this.doRenderTarget(j, I),
                  (V.passThruTexture.value = null);
              }),
              (this.doRenderTarget = function (_, I) {
                let B = R.getRenderTarget(),
                  V = R.xr.enabled,
                  q = R.shadowMap.autoUpdate,
                  X = R.outputEncoding,
                  Q = R.toneMapping;
                (R.xr.enabled = !1),
                  (R.shadowMap.autoUpdate = !1),
                  (R.outputEncoding = 3e3),
                  (R.toneMapping = 0),
                  (G.material = _),
                  R.setRenderTarget(I),
                  R.render(z, k),
                  (G.material = j),
                  (R.xr.enabled = V),
                  (R.shadowMap.autoUpdate = q),
                  (R.outputEncoding = X),
                  (R.toneMapping = Q),
                  R.setRenderTarget(B);
              });
          }
        },
        Ta = new sX(),
        Tn = new rF(),
        To = class {
          constructor(_) {
            let I = _.geometry;
            if (!I.isBufferGeometry || 3 !== I.attributes.position.itemSize)
              throw Error(
                "THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh."
              );
            I.index &&
              (console.warn(
                "THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry."
              ),
              (I = I.toNonIndexed())),
              (this.geometry = I),
              (this.randomFunction = Math.random),
              (this.positionAttribute = this.geometry.getAttribute("position")),
              (this.colorAttribute = this.geometry.getAttribute("color")),
              (this.weightAttribute = null),
              (this.distribution = null);
          }
          setWeightAttribute(_) {
            return (
              (this.weightAttribute = _ ? this.geometry.getAttribute(_) : null),
              this
            );
          }
          build() {
            let _ = this.positionAttribute,
              I = this.weightAttribute,
              R = new Float32Array(_.count / 3);
            for (let B = 0; B < _.count; B += 3) {
              let z = 1;
              I && (z = I.getX(B) + I.getX(B + 1) + I.getX(B + 2)),
                Ta.a.fromBufferAttribute(_, B),
                Ta.b.fromBufferAttribute(_, B + 1),
                Ta.c.fromBufferAttribute(_, B + 2),
                (z *= Ta.getArea()),
                (R[B / 3] = z);
            }
            this.distribution = new Float32Array(_.count / 3);
            let B = 0;
            for (let _ = 0; _ < R.length; _++)
              (B += R[_]), (this.distribution[_] = B);
            return this;
          }
          setRandomGenerator(_) {
            return (this.randomFunction = _), this;
          }
          sample(_, I, R) {
            let B = this.distribution[this.distribution.length - 1],
              z = this.binarySearch(this.randomFunction() * B);
            return this.sampleFace(z, _, I, R);
          }
          binarySearch(_) {
            let I = this.distribution,
              R = 0,
              B = I.length - 1,
              z = -1;
            for (; R <= B; ) {
              let k = Math.ceil((R + B) / 2);
              if (0 === k || (I[k - 1] <= _ && I[k] > _)) {
                z = k;
                break;
              }
              _ < I[k] ? (B = k - 1) : (R = k + 1);
            }
            return z;
          }
          sampleFace(_, I, R, B) {
            let z = this.randomFunction(),
              k = this.randomFunction();
            return (
              z + k > 1 && ((z = 1 - z), (k = 1 - k)),
              Ta.a.fromBufferAttribute(this.positionAttribute, 3 * _),
              Ta.b.fromBufferAttribute(this.positionAttribute, 3 * _ + 1),
              Ta.c.fromBufferAttribute(this.positionAttribute, 3 * _ + 2),
              I.set(0, 0, 0)
                .addScaledVector(Ta.a, z)
                .addScaledVector(Ta.b, k)
                .addScaledVector(Ta.c, 1 - (z + k)),
              void 0 !== R && Ta.getNormal(R),
              void 0 !== B &&
                void 0 !== this.colorAttribute &&
                (Ta.a.fromBufferAttribute(this.colorAttribute, 3 * _),
                Ta.b.fromBufferAttribute(this.colorAttribute, 3 * _ + 1),
                Ta.c.fromBufferAttribute(this.colorAttribute, 3 * _ + 2),
                Tn.set(0, 0, 0)
                  .addScaledVector(Ta.a, z)
                  .addScaledVector(Ta.b, k)
                  .addScaledVector(Ta.c, 1 - (z + k)),
                (B.r = Tn.x),
                (B.g = Tn.y),
                (B.b = Tn.z)),
              this
            );
          }
        };
      function Z_(_, I) {
        let R = new Float32Array(4 * I * I);
        for (let B = 0; B < I * I; B++)
          (R[4 * B] = _[3 * B]),
            (R[4 * B + 1] = _[3 * B + 1]),
            (R[4 * B + 2] = _[3 * B + 2]),
            (R[4 * B + 3] = 0);
        let B = new nV(R, I, I, 1023, 1015);
        return (B.needsUpdate = !0), B;
      }
      var Tc = `
// uniform sampler2D uCurrentPosition; // Pass in the variable from GPGPU
// uniform sampler2D uCurrentVelocity; // Pass in the variable from GPGPU
// uniform sampler2D uCurrentEmissionRate; // Pass in the variable from GPGPU
uniform sampler2D uOriginalPosition;
uniform float uTime;
uniform float uSpeed;     // update speed of the particles
uniform vec3 uWorldOffset;    
uniform vec4 uWorldQuaternion;
uniform float uMaxLifeTime;
uniform vec3 uEmitterSize;
uniform float uFPSRatio;     // 1  for 60 FPS

float random (vec2 st) {
    return fract(sin(dot(st.xy,
        vec2(12.9898,78.233)))*
        43758.5453123);
}
vec3 applyQuaternionToVector( vec4 q, vec3 v ){
    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );
}

vec3 applyForce(vec3 force, float mass) {
    vec3 acceleration = force / mass;
    
    return acceleration;
  }
  

void main() {
    vec2 vUv = gl_FragCoord.xy / resolution.xy;
    vec3 position = texture2D( uCurrentPosition, vUv ).xyz;
    float currentLife = texture2D( uCurrentPosition, vUv ).w;   // from 1 to 0
    float isSpawning = texture2D( uCurrentEmissionRate, vUv ).r;        // 1. = spawning, 0. = not spawning
    float isActive = texture2D( uCurrentEmissionRate, vUv ).g;          // 1. = active, 0. = not active
    float timeStart = texture2D( uCurrentEmissionRate, vUv ).b;         // timeStart in seconds when the particle was emitted
    vec3 originalPosition = ((texture2D( uOriginalPosition, vUv ).xyz) * uEmitterSize);
    vec3 velocity = texture2D( uCurrentVelocity, vUv ).xyz;
    float collisionFlag = texture2D( uCurrentVelocity, vUv ).w;             // 1. = collided, 0. = not collided
    float lifeTime = uMaxLifeTime;

    // Calculate the position adjustment based on collision
    //     if (collisionFlag > .5) {  
    float isColliding = step(0.5, collisionFlag); // 1.0 if collisionFlag > 0.5, otherwise 0.0
    float bounceOffset = 3.0 * isColliding; // Becomes 3.0 if colliding, 0.0 otherwise
    vec3 collisionAdjustedVelocity = velocity * (1.0 + bounceOffset);

    // Update position based on collision or normal movement
    vec3 fpsVelocity = velocity * min(uFPSRatio, 5.0);
    position += mix(fpsVelocity, collisionAdjustedVelocity, isColliding);

    // EMISSION RATE - BIRTH
    // if (isSpawning == 1.0) {
    // Better Approach to avoid If statement
    vec3 newPosition = applyQuaternionToVector(uWorldQuaternion, originalPosition) + uWorldOffset;
    originalPosition = mix(originalPosition, newPosition, isSpawning);
    position = mix(position, originalPosition, isSpawning);;
    timeStart = mix(timeStart, uTime, isSpawning);

    // Calculate timeLeft for life normalization
    float timeLeft = max(lifeTime - (uTime - timeStart), 0.0);
    float life_Normalize = timeLeft / lifeTime;

    // Use isActive to blend between the calculated color and black
    vec4 activeColor = vec4(position, life_Normalize);
    // if (isActive == 1.0) {
    gl_FragColor = mix(vec4(0.0), activeColor, isActive);

}
`,
        Tu = `
  #ifdef USE_COLLIDER
    float restitution = max(uBounce * 2., .01); // Energy Loss
    // SPHERE COLLIDER
    // **************************************************************
    #ifdef USE_SPHERE_COLLIDER       
      // Convert collider size to radii (assuming uColliderSize is the diameter in each axis)
      vec3 radii = uColliderSize;
      // Adjust position relative to collider
      vec3 relPos = position - uColliderPos;
      // Apply rotation of the collider to the relative position
      relPos = applyQuaternionToVector(uColliderQuaternionInvert, relPos);            
      // Scale relative position by radii (for ellipsoid collision detection)
      vec3 scaledPos = relPos / radii;
      // Calculate ellipsoidal distance
      float dist = length(scaledPos); // Distance in terms of ellipsoid
      
      // Check for collision
      if (dist <= 1. + particleSize / length(radii) && collisionFlag == 0.0) {
          // Compute the normal at the collision point, accounting for particle size
        vec3 adjustedPos = scaledPos * (1.0 + particleSize / length(radii));          
        // Compute the normal at the collision point
        vec3 normal = ellipsoidNormal(adjustedPos, radii);
        // Rotate the normal back to world space
        normal = applyQuaternionToVector(uColliderQuaternion, normal);
        // Reflect the velocity vector off the normal
        velocity = reflect(velocity, normal) * restitution;

        collisionFlag = 1.0;
      } else {
        collisionFlag = 0.0;
      }
    #endif

    // BOX COLLIDER or PLANE COLLIDER 
    // **************************************************************
    #ifdef USE_BOX_COLLIDER
      // Box dimensions and repulsion variables
      vec3 boxHalfSize = uColliderSize / 2.0;
      // Convert world position to box's local space
      vec3 localPos = applyQuaternionToVector(uColliderQuaternionInvert, position - uColliderPos);      
      // Collision detection
      vec3 localDistance = abs(localPos) - boxHalfSize;
      float distToSurface = max(localDistance.x, max(localDistance.y, localDistance.z));    

      // Collision Detected
      if (distToSurface <= particleSize * 0.5 && collisionFlag == 0.0) {      
        // Find the nearest face normal for bounce direction
        vec3 normal;
        if (localDistance.x > localDistance.y && localDistance.x > localDistance.z) {
            normal = vec3(sign(localPos.x), 0.0, 0.0);
        } else if (localDistance.y > localDistance.z) {
            normal = vec3(0.0, sign(localPos.y), 0.0);
        } else {
            normal = vec3(0.0, 0.0, sign(localPos.z));
        }            
        // Rotate normal back to world space
        normal = applyQuaternionToVector(uColliderQuaternion, normal);      
        // Reflect velocity and apply repulsion force
        velocity = reflect(velocity, normal) * restitution;
        
        collisionFlag = 1.0;
      } else {
        collisionFlag = 0.0;
      }
    #endif      
  #endif      
  // END COLLIDER    
`,
        Tp = `
  #ifdef USE_ATTRACTOR

      #ifdef USE_SPHERE_COLLIDER      
        // Convert collider size to radii (assuming uColliderSize is the diameter in each axis)
        vec3 radii = uColliderSize;
        // Adjust position relative to collider
        vec3 relPos = position - uColliderPos;
        // Apply rotation of the collider to the relative position
        relPos = applyQuaternionToVector(uColliderQuaternionInvert, relPos);            
        // Scale relative position by radii (for ellipsoid collision detection)
        vec3 scaledPos = relPos / radii;
        // Calculate ellipsoidal distance
        float distToSurface = length(scaledPos); // Distance in terms of ellipsoid
        float insideCheck = 1.0;

      #endif


      #ifdef USE_BOX_COLLIDER
        // Box dimensions
        vec3 boxHalfSize = uColliderSize / 2.0;
        // Convert world position to box's local space
        vec3 localPos = applyQuaternionToVector(uColliderQuaternionInvert, position - uColliderPos);      
        vec3 localDistance = abs(localPos) - boxHalfSize;
        float distToSurface = max(localDistance.x, max(localDistance.y, localDistance.z));
        float insideCheck = particleSize;
      #endif      
  
      // Apply vortex force inside the Helper
      #ifdef USE_FORCE_LOCAL_SPACE
        if (distToSurface <= insideCheck ) {    
            // Define parameters for the attractor field
            #ifdef USE_SPHERE_COLLIDER      
              float attractorStrength = (1.0 - distToSurface ) * uForceIntensity; // Adjust as needed
            #endif

            #ifdef USE_BOX_COLLIDER
              float attractorStrength = max((1.0 - insideCheck / distToSurface), 0.) * uForceIntensity; // Adjust as needed
              #endif

            float attractorDamping = uForceDamping;  // Adjust as needed (higher values will attenuate velocity more)
          
            // Use the same radii calculation code as for the collider
            vec3 attractorRadii = uColliderSize;
            // Adjust position relative to attractor center
            vec3 relPos = position - uColliderPos;
            // Apply rotation of the collider to the relative position
            relPos = applyQuaternionToVector(uColliderQuaternionInvert, relPos);            
            // Scale relative position by radii (for ellipsoid attraction)
            vec3 scaledPos = relPos / attractorRadii;

            // Calculate ellipsoidal distance as attractor radius
            float attractorRadius = length(scaledPos);
            // Calculate the distance from the attractor center
            vec3 relativePosition = position - uColliderPos;
            // Calculate the force vector towards the attractor center
            vec3 attractorForce = normalize(relativePosition) * attractorStrength;
            // Apply the attractor force to the particle
            velocity -= attractorForce;
            // Attenuate the particle's velocity
            velocity *= attractorDamping;
        }
      #else 
            // Calculate the distance from the attractor center
            vec3 relativePosition = position - uColliderPos;
            // Calculate the force vector towards the attractor center
            vec3 attractorForce = normalize(relativePosition) * uForceIntensity;
            // Apply the attractor force to the particle
            velocity -= attractorForce;
            // Attenuate the particle's velocity
            velocity *= uForceDamping;
      #endif    
  #endif      
`,
        Tf = `
  #ifdef USE_VORTEX
    // Box dimensions
    vec3 boxHalfSize = uColliderSize / 2.0;
    // Convert world position to box's local space
    vec3 localPos = applyQuaternionToVector(uColliderQuaternionInvert, position - uColliderPos);      
    vec3 localDistance = abs(localPos) - boxHalfSize;
    float distToSurface = max(localDistance.x, max(localDistance.y, localDistance.z));

    // Apply vortex force inside the box
    if (distToSurface <= particleSize) {
      float vortexStrength = uForceIntensity;
      vec3 localTopCenter = vec3(0.0, 0., 0.0);

      // Transform the local top center to the world space
      vec3 vortexCenter = uColliderPos + applyQuaternionToVector(uColliderQuaternion, localTopCenter);
      // Calculate the vector from particle to vortex center
      vec3 vortexVector = vortexCenter - position;

      // Calculate the rotation axis from the inverse of the collider's quaternion and the fixed up vector
      // Note: important to add a tiny z component to the up vector to avoid instability
      vec3 upVector = vec3(0.0, 1.0, 0.01);
      vec3 rotationAxis = cross(upVector, applyQuaternionToVector(uColliderQuaternion, vortexVector));
      rotationAxis = normalize(rotationAxis);

      // Add rotational component to velocity
      float rotationSpeed = length(vortexVector * vortexStrength * 3.0) ; 

      vec3 rotationVelocity = rotationAxis * rotationSpeed;
      // velocity += rotationVelocity * 0.005 ;
      velocity = rotationVelocity * 0.005 ;

      // Calculate vortex force
      // vec3 vortexForce = normalize(vortexVector) * uSpeed * .1 ;
      // Apply the vortex force to the particle
      vec3 originDirection = applyQuaternionToVector(uWorldQuaternion, directions);
      velocity += applyForce( originDirection * uSpeed * (1. - uForceDamping) , mass * .5);
    }
  #endif      
`,
        Tg = `
// uniform sampler2D uCurrentPosition; // Pass in the variable from GPGPU
// uniform sampler2D uCurrentVelocity; // Pass in the variable from GPGPU
// uniform sampler2D uCurrentEmissionRate; // Pass in the variable from GPGPU
uniform sampler2D uOriginalPosition;
uniform sampler2D uDirections;     
uniform vec3 uDirectionsAxis;
uniform vec4 uWorldQuaternion;
uniform vec3 uGravity;        
uniform float uNoiseStrength;     // Variation of the noise
uniform float uNoiseScale;        // Scale of the noise
uniform float uNoiseSeed;         // Seed of the noise
uniform float particleSize;
uniform float uSpeed;     // update speed of the particles
uniform float uRandomMassFactor;

// COLLIDER
uniform vec3 uColliderPos;                // Collider Position
uniform vec3 uColliderSize;               // Collider Dimension
uniform vec4 uColliderQuaternion;         // Collider Rotation
uniform vec4 uColliderQuaternionInvert;   // Collider Rotation
uniform float uBounce;                    // Bounce factor
uniform float uForceDamping;
uniform float uForceIntensity;




    vec3 mod289(vec3 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }
    
    vec4 mod289(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
    }
    
    vec4 permute(vec4 x) {
        return mod289(((x*34.0)+1.0)*x);
    }
    
    vec4 taylorInvSqrt(vec4 r)
    {
    return 1.79284291400159 - 0.85373472095314 * r;
    }
    
    vec3 fade(vec3 t) {
  return t*t*t*(t*(t*6.0-15.0)+10.0);
}

    float snoise(vec3 v)
    {
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 =   v - i + dot(i, C.xxx) ;
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );
    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
    
    // Permutations
    i = mod289(i);
    vec4 p = permute( permute( permute(
                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
              + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
              + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
    
    // Gradients: 7x7 points over a square, mapped onto an octahedron.
    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
    float n_ = 0.142857142857; // 1.0/7.0
    vec3  ns = n_ * D.wyz - D.xzx;
    
    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)
    
    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
    
    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);
    
    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );
    
    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));
    
    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
    
    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);
    
    //Normalise gradients
    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;
    
    // Mix final noise value
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                  dot(p2,x2), dot(p3,x3) ) );
    }
    
    vec3 snoiseVec3( vec3 x ){
    
      float s  = snoise(vec3( x ));
      float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));
      float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));
      vec3 c = vec3( s , s1 , s2 );
      return c;
    
    }
    
      
    vec3 curlNoise( vec3 p, float seed){
      p += seed;
      const float e = .1;
      vec3 dx = vec3( e   , 0.0 , 0.0 );
      vec3 dy = vec3( 0.0 , e   , 0.0 );
      vec3 dz = vec3( 0.0 , 0.0 , e   );
    
      vec3 p_x0 = snoiseVec3( p - dx );
      vec3 p_x1 = snoiseVec3( p + dx );
      vec3 p_y0 = snoiseVec3( p - dy );
      vec3 p_y1 = snoiseVec3( p + dy );
      vec3 p_z0 = snoiseVec3( p - dz );
      vec3 p_z1 = snoiseVec3( p + dz );
    
      float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;
      float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;
      float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;
    
      const float divisor = 1.0 / ( 2.0 * e );
      return normalize( vec3( x , y , z ) * divisor );
    
    }


// Classic Perlin noise
float cnoise(vec3 P)
{
  vec3 Pi0 = floor(P); // Integer part for indexing
  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
  Pi0 = mod289(Pi0);
  Pi1 = mod289(Pi1);
  vec3 Pf0 = fract(P); // Fractional part for interpolation
  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = Pi0.zzzz;
  vec4 iz1 = Pi1.zzzz;

  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0);
  vec4 ixy1 = permute(ixy + iz1);

  vec4 gx0 = ixy0 * (1.0 / 7.0);
  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
  gx0 = fract(gx0);
  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
  vec4 sz0 = step(gz0, vec4(0.0));
  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

  vec4 gx1 = ixy1 * (1.0 / 7.0);
  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
  gx1 = fract(gx1);
  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
  vec4 sz1 = step(gz1, vec4(0.0));
  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  float n000 = dot(g000, Pf0);
  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
  float n111 = dot(g111, Pf1);

  vec3 fade_xyz = fade(Pf0);
  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
  return 2.2 * n_xyz;
}


vec3 fbm_vec3(vec3 p, float frequency, float offset)
{
  return vec3(
    cnoise((p+vec3(offset))*frequency),
    cnoise((p+vec3(offset+20.0))*frequency),
    cnoise((p+vec3(offset-30.0))*frequency)
  );
}


float rand(vec2 co){
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}
vec3 applyQuaternionToVector( vec4 q, vec3 v ){
    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );
 } 
vec3 applyForce(vec3 force, float mass) {
  vec3 acceleration = force / mass;
  
  return acceleration;
}

vec4 conjugate(vec4 q) {
  return vec4(q.w, -q.x, -q.y, -q.z);
}

// Function to compute the normal of the ellipsoid at a given point
vec3 ellipsoidNormal(vec3 p, vec3 radii) {
  return normalize(p / (radii * radii));
}

float friction = .3;

void main() {
    vec2 vUv = gl_FragCoord.xy / resolution.xy;
    vec3 position = texture2D( uCurrentPosition, vUv ).xyz;
    vec3 originalPosition = texture2D( uOriginalPosition, vUv ).xyz;
    float timeLeft = texture2D( uCurrentPosition, vUv ).w;
    vec3 directions = texture2D( uDirections, vUv ).xyz;    
    vec3 velocity = texture2D( uCurrentVelocity, vUv ).xyz;
    float mass = rand(originalPosition.xy) * 0.5 + 0.5;
    float isSpawning = texture2D( uCurrentEmissionRate, vUv ).x;        // 1. = spawning, 0. = not spawning
    float isActive = texture2D( uCurrentEmissionRate, vUv ).y;          // 1. = active, 0. = not active
    float collisionFlag =texture2D( uCurrentVelocity, vUv ).w;          // Indicate collision

    // Randomness Mass
    mass = (1.0 - (uRandomMassFactor * mass));
    
    if (isActive == 1.0) {
      // **************************************************************
      // FORCES NOISES
      // **************************************************************
      #ifdef USE_CURL_NOISE
        if (uNoiseScale > 0.0 ) {
          velocity = curlNoise(position * uNoiseScale * .002, uNoiseSeed) * ( uNoiseStrength + 1.0) * .05 * uSpeed;
        }
        // Variation of the noise Over Time
        if (uNoiseStrength > 0.0 && uNoiseScale == 0.0 ) {
          velocity += curlNoise( position, uNoiseSeed)  * uNoiseStrength * 0.05 * uSpeed;
        }
      #endif
      // **************************************************************
      #ifdef USE_SIMPLEX_NOISE
        if (uNoiseScale > 0.0 ) {
          velocity = vec3(snoise(position * uNoiseScale * .001) * ( uNoiseStrength + 1.0) * .1);
          velocity *= uSpeed;
        }
        // Variation of the noise Over Time
        if (uNoiseStrength > 0.0 && uNoiseScale == 0.0) {
          velocity += vec3(snoise(position * uNoiseStrength * .001) * .05 * uSpeed);
        }
      #endif
      // ************************************************************** 
      #ifdef USE_FBM_NOISE
        if (uNoiseScale > 0.0 ) {
          float offset = 0.0;
          velocity = fbm_vec3(position * uNoiseScale * .001, ( uNoiseStrength + 1.0), offset);
          velocity *= uSpeed;
        }
        // Variation of the noise Over Time
        if (uNoiseStrength > 0.0 && uNoiseScale == 0.0 ) {      
          float offset = 0.0;
          velocity += fbm_vec3(position * uNoiseStrength * .001, ( uNoiseStrength + 1.0), uNoiseSeed) * .1 * uSpeed;
        }
      #endif

      // COLLIDER
      ${Tu}
      // ATTRACTION
      ${Tp}  
      // VORTEX
      ${Tf}
    } 
    // End isActive

    // SPAWN BIRTH 
    // **************************************************************
    // if (isSpawning == 1.)
    #ifdef USE_NORMALS
      velocity = mix(velocity, applyQuaternionToVector(uWorldQuaternion, directions) * uSpeed, isSpawning);
    #else
      velocity = mix(velocity, applyQuaternionToVector(uWorldQuaternion, uDirectionsAxis) * uSpeed, isSpawning);    
    #endif
    
    // if (collisionFlag == 0.0)
    velocity += applyForce(uGravity, mass * .5) * (1.0 - collisionFlag);

    gl_FragColor = vec4(velocity, collisionFlag);
}
`,
        Ty = `

  // Linear Fade In
  float linearFadeIn(float t) {
    return t;
  }


  // linear fade out
  float linearFadeOut(float t) {
    return 1.0 - t;
  }
  
  float linearInOut(float t) {
    return t < 0.5 ? t :  (1.0 - t);  
  }

    // lerp
    float lerp(float a, float b, float t) {
      return a + (b - a) * t;
    }

  // Ease In Out Quart
  float exponentialInOut(float t) {
    return t < 0.4 ? lerp(0.0, 1.0, t / 0.4) :
    t > 0.6 ? lerp(1.0, 0.0, (t - 0.6) / 0.4) :
    1.0;
   }

  // constant
  float constant(float t) {
    return 1.0;
  } 
`,
        Tx = `

float rand(vec3 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 applyQuaternionToVector( vec4 q, vec3 v ){
  return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );
}

vec3 applyForce(vec3 force, float mass) {
  vec3 acceleration = force / mass;
    
  return acceleration;
}
`,
        Tb = `
vec3 rgb2xyz (in vec3 rgb) {
    float r = rgb.r;
	float g = rgb.g;
	float b = rgb.b;

	r = r > 0.04045 ? pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	float x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	float y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	float z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);
    
    vec3 xyz = vec3(
        (r * 0.4124) + (g * 0.3576) + (b * 0.1805) * 100.0,
        (r * 0.2126) + (g * 0.7152) + (b * 0.0722) * 100.0,
        (r * 0.0193) + (g * 0.1192) + (b * 0.9505) * 100.0
    );
    return(xyz);
}

vec3 xyz2lab (in vec3 xyz) {
	float x = xyz.x / 95.047;
	float y = xyz.y / 100.0;
	float z = xyz.z / 108.883;

	x = x > 0.008856 ? pow(x, 1.0 / 3.0) : (7.787 * x) + (16.0 / 116.0);
	y = y > 0.008856 ? pow(y, 1.0 / 3.0) : (7.787 * y) + (16.0 / 116.0);
	z = z > 0.008856 ? pow(z, 1.0 / 3.0) : (7.787 * z) + (16.0 / 116.0);

    vec3 lab = vec3((116.0 * y) - 16.0, 500.0 * (x - y), 200.0 * (y - z));
    return(lab);
}

vec3 rgb2lab(in vec3 rgb) {
    vec3 xyz = rgb2xyz(rgb);
    vec3 lab = xyz2lab(xyz);
    return(lab);
}

vec3 xyz2rgb (in vec3 xyz) {
	float x = xyz.x / 100.0;
	float y = xyz.y / 100.0;
	float z = xyz.z / 100.0;
	
    
	float r = (x *  3.2406) + (y * -1.5372) + (z * -0.4986);
	float g = (x * -0.9689) + (y *  1.8758) + (z *  0.0415);
	float b = (x *  0.0557) + (y * -0.2040) + (z *  1.0570);

	r = r > 0.0031308 ? ((1.055 * pow(r, 1.0 / 2.4)) - 0.055) : r * 12.92;
	g = g > 0.0031308 ? ((1.055 * pow(g, 1.0 / 2.4)) - 0.055) : g * 12.92;
	b = b > 0.0031308 ? ((1.055 * pow(b, 1.0 / 2.4)) - 0.055) : b * 12.92;

	r = min(max(0.0, r), 1.0);
	g = min(max(0.0, g), 1.0);
	b = min(max(0.0, b), 1.0);

	return(vec3(r, g, b));
}

vec3 lab2xyz (in vec3 lab) {
    float l = lab.x;
	float a = lab.y;
	float b = lab.z;

  	float y = (l + 16.0) / 116.0;
	float x = a / 500.0 + y;
	float z = y - b / 200.0;

	float y2 = pow(y, 3.0);
	float x2 = pow(x, 3.0);
	float z2 = pow(z, 3.0);

  	y = y2 > 0.008856 ? y2 : (y - 16.0 / 116.0) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16.0 / 116.0) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16.0 / 116.0) / 7.787;

	x *= 95.047;
	y *= 100.0;
	z *= 108.883;

	return(vec3(x, y, z));
}
vec3 lab2rgb (in vec3 lab) {
    vec3 xyz = lab2xyz(lab);
    vec3 rgb = xyz2rgb(xyz);
    return(rgb);
}

`,
        Tw = `
  uniform sampler2D uPosition;
  uniform float uSize;
  uniform float uSizeEnd;
  uniform vec3 uWorldOffset;
  uniform vec4 uWorldQuaternion;
  // Billboard Behavior - Currently at Zero, but we can change that
  uniform float uRotation;
  uniform float uRotationEnd;
  uniform vec2 center;

  // Randomness
  uniform float uRandScaleFactor;
  uniform float uRandRotationFactor;

  attribute vec2 ref;

  varying float v_LifeLeft;    // normalized lifetime 1 to 0
  varying vec2 vUv;
  varying vec2 vRef;

  ${Tx}
  ${Ty}
`,
        yL = ({ easeSize: _ = "linearFadeOut" }) => `
  vUv = uv;  
  vRef = ref;
  // Normalized LifeTime 1 to 0
  float lifeLeft = texture2D(uPosition, ref).w;
  v_LifeLeft = lifeLeft;
  // Position From DataTexture Simulation
  vec3 pos = texture2D(uPosition, ref).rgb - uWorldOffset;
  // Apply World Quaternion
  pos = applyQuaternionToVector(uWorldQuaternion, pos);  
            
  #ifdef  USE_SIZE_END
    // Scaled Over Time
    float t = 1. - lifeLeft;
    float currentSize = mix(uSize, uSizeEnd, t); // Linearly interpolate between uSize and uSizeEnd
    vec3 scaledPosition = position * vec3(currentSize);
  #else
    // Change Size Behavior over LifeTime
    float easeSize = ${_}(1. - lifeLeft);
    // Scaled Over Time
    vec3 scaledPosition = position * vec3(uSize * easeSize);
  #endif

  // Billboard Behavior
  vec2 scale;
  scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
  scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );    
  // Randomness 
  float randRef = rand(ref);
  scale *= (1.0 - (uRandScaleFactor * randRef));
  // Rotation
  float randRotation =  2.0 * PI * ( uRandRotationFactor * randRef);
  float originalRotation = (1.0 - uRotation) * 2.0 * PI;
  float originalRotationEnd = (1.0 - uRotationEnd) * 2.0 * PI;
  // OverTime
  float finalRotation = mix(originalRotation + randRotation, originalRotationEnd + randRotation, lifeLeft);

  vec2 alignedPosition = ( scaledPosition.xy - ( center - vec2( 0.5 ) ) ) * scale;
  vec2 rotatedPosition;
  rotatedPosition.x = cos( finalRotation ) * alignedPosition.x - sin( finalRotation ) * alignedPosition.y;
  rotatedPosition.y = sin( finalRotation ) * alignedPosition.x + cos( finalRotation ) * alignedPosition.y;
  
  mat4 instanceMatrix = mat4(
    vec4(1.0, 0.0, 0.0, 0.0),
    vec4(0.0, 1.0, 0.0, 0.0),
    vec4(0.0, 0.0, 1.0, 0.0),
    vec4(pos.x, pos.y, pos.z, 1.0)
  );  

  mvPosition = modelViewMatrix * instanceMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
  mvPosition.xy += rotatedPosition;
  gl_Position = projectionMatrix  * mvPosition;   
`,
        T_ =
          `
  uniform vec4 uColor;                // start color
  uniform vec4 uColor2;               // end color
  uniform sampler2D uTexture;         // texture
  varying float v_LifeLeft;   // normalized lifetime 1 to 0
  varying vec2 vUv;
  varying vec2 vRef;

  float random(vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
  }
  ` +
          Ty +
          `  
  ${Tb}

`,
        xL = ({ easeOpacity: _ = "linearFadeOut" }) => `  
  // if Particle is dead, hide it
  if (v_LifeLeft <= 0.005 ) {
    discard;
  }

  #ifdef USE_RANDOM_COLORING
    float randVal = random(vRef); // Generate a random value based on the reference
    vec4 color = mix(uColor, uColor2, randVal); // Interpolate between the two colors
  #else
    vec4 color = mix(uColor, uColor2, 1. - v_LifeLeft);
  #endif

  // Opacity over Life Time
  float finalAlpha = ${_}(1. - v_LifeLeft);  
  vec4 textureColor = texture2D(uTexture, vUv).rgba; 
  finalColor = textureColor.rgb * color.rgb;
  finalAlpha = color.a * textureColor.a * finalAlpha;
  
  gl_FragColor = vec4(finalColor, finalAlpha);     

`,
        TS = class extends aT {
          constructor(_, I) {
            super(),
              (this.needsJitter = !0),
              (this.type = "ParticleMaterial"),
              (this.easeOpacity = "linearFadeIn"),
              (this.easeSize = "linearFadeIn"),
              (this.useSizeEnd = !1),
              (this.isColoringRandom = !1),
              this.init(_, I),
              (this.context = I);
          }
          reset() {}
          init(_, I) {
            (this.transparent = !0),
              (this.depthTest = !0),
              (this.depthWrite = !1),
              (this.easeOpacity = _.ease),
              (this.easeSize = _.easeSize),
              (this.layers = []),
              (this.lightLayer = new SM(
                0,
                "",
                { ...mq.defaultData("light", "phong"), visible: !1 },
                new _K(),
                {},
                I.shared
              )),
              this.build();
          }
          updateState(_) {
            void 0 !== _.coloring &&
              (this.isColoringRandom = "random" === _.coloring),
              void 0 !== _.color &&
                (_.color instanceof Array
                  ? (this.uniforms.uColor.value = _.color)
                  : (this.uniforms.uColor.value = this.context.shared.color(
                      _.color
                    ))),
              void 0 !== _.color2 &&
                (_.color2 instanceof Array
                  ? (this.uniforms.uColor2.value = _.color2)
                  : (this.uniforms.uColor2.value = this.context.shared.color(
                      _.color2
                    ))),
              void 0 !== _.size &&
                ((this.uniforms.uSize.value = _.size[0]),
                (this.uniforms.uSizeEnd.value = _.size[1]),
                _.size[0] !== _.size[1]
                  ? (this.useSizeEnd = !0)
                  : (this.useSizeEnd = !1)),
              void 0 !== _.ease && ((this.easeOpacity = _.ease), this.build()),
              void 0 !== _.easeSize &&
                ((this.easeSize = _.easeSize), this.build()),
              (this.needsUpdate = !0);
          }
          onBeforeCompile(_) {
            this.build(),
              (_.defines = this.defines),
              (_.uniforms = this.uniforms),
              (_.vertexShader = this.vertexShader),
              (_.fragmentShader = this.fragmentShader);
          }
          build() {
            let _ = new w7();
            return (
              (_.needsJitter = this.needsJitter),
              _.addFragmentParsCode(w3),
              _.buildShader("vertex", this.fragment),
              _.buildShader("fragment", this.fragment),
              _.addFragmentFinalCode(w4),
              this.isColoringRandom && _.define("USE_RANDOM_COLORING"),
              this.useSizeEnd && _.define("USE_SIZE_END"),
              _.addVertexParsCode(Tw),
              _.addFragmentParsCode(T_),
              _.addVertexFinalCode(yL({ easeSize: this.easeSize })),
              _.addFragmentFinalCode(xL({ easeOpacity: this.easeOpacity })),
              (this.vertexShader = _.getCode("vertex")),
              (this.fragmentShader = _.getCode("fragment")),
              (this.defines = _.defines),
              (this.uniforms = { ..._.uniforms, ...this.uniforms }),
              (this.extensions = _.extensions),
              this
            );
          }
          get nodeMaterial() {
            return this;
          }
          get fragment() {
            return this.lightLayer.node;
          }
          getDefines() {
            return this.defines;
          }
          nodeMaterialDispose() {
            this.layers.forEach((_) => _.dispose()), super.dispose();
          }
        },
        TA = class {
          constructor(_, I, R, B) {
            (this.type = "SphereEmitterShape"),
              (this.targetMesh = void 0),
              (this.size = _),
              (this.type = R),
              (this.textureSize = Math.max(Math.ceil(Math.sqrt(I)), 1)),
              (this.targetMesh =
                B?.type === "Mesh" && B ? B : this.getMesh(R, 1));
            let {
              positions: z,
              dataTexture: k,
              dataTextureNormals: V,
            } = this.createPositions(
              this.textureSize,
              this.targetMesh ?? this.getMesh(R, 1)
            );
            (this.positionsTexture = k),
              (this.positionsAttribute = z),
              (this.directionsTexture = V);
          }
          createPositions(_, I) {
            let { positions: R, normals: B } = (function (_, I) {
              let R = new aw(_.geometry, _.material),
                B = [],
                z = [],
                k = new rF(),
                V = new rF();
              null !== R.geometry.index &&
                (R.geometry = R.geometry.toNonIndexed());
              let j = new To(R).build();
              for (let _ = 0; _ < I; _++)
                j.sample(k, V), B.push(k.x, k.y, k.z), z.push(V.x, V.y, V.z);
              return {
                positions: new Float32Array(B),
                normals: new Float32Array(z),
              };
            })(I, _ * _);
            return {
              dataTexture: Z_(R, _),
              positions: R,
              dataTextureNormals: Z_(B, _),
            };
          }
          getMesh(_, I) {
            let R = null;
            switch (_) {
              case "SphereEmitterShape":
                R = new oN(0.5 * I, 32, 32);
                break;
              case "TorusEmitterShape":
                R = new ok(0.5 * I, 0.3, 15, 40);
                break;
              case "ConeEmitterShape":
                R = new oT(I, I, 15);
                break;
              case "BoxEmitterShape":
                R = new aS(I, I, I);
                break;
              case "PlaneEmitterShape":
                (R = new aq(I, I)).rotateX(-Math.PI / 2);
                break;
              default:
                R = new oN(I, 32, 32);
            }
            return new aw(R, new sK({ color: 16711680 }));
          }
          applyToShader(_, I) {
            (this.size = new rF().fromArray(I.size)),
              (_.uEmitterSize.value = this.size);
          }
          dispose() {
            this.positionsTexture.dispose(),
              this.directionsTexture.dispose(),
              (this.positionsAttribute = new Float32Array());
          }
        };
      function cu(_) {
        let I = { ..._ },
          R = mF.defaultData;
        I.forceFieldObjectId && (I.colliderEntityId = I.forceFieldObjectId);
        let B = { ...R.shape, ...I.shape },
          z = { ...R.renderMaterial, ...I.renderMaterial };
        return { ...R, ...I, shape: B, renderMaterial: z };
      }
      var TC = `
// uniform sampler2D uCurrentPosition; // Pass in the variable from GPGPU
// uniform sampler2D uCurrentVelocity; // Pass in the variable from GPGPU
// uniform sampler2D uCurrentEmissionRate; // Pass in the variable from GPGPU

uniform sampler2D uIndex; // Texture with corresponding index
uniform float uLastIndexEmitted; // Last emitted index
uniform float uParticlesToEmit; // Number of particles to emit on that frame
uniform float uTime;

void main() {
    vec2 vUv = gl_FragCoord.xy / resolution.xy;
    float particleIndex = texture(uIndex, vUv).x;
    float timeLeft = texture2D( uCurrentPosition, vUv ).w;
    float isActive = texture2D( uCurrentEmissionRate, vUv ).g;    // 1. = active, 0. = not active
    float timeStart = texture2D( uCurrentEmissionRate, vUv ).b;


    // ********** Detect Colision to Create a flag and use it in position **********
    // We are doing this here, so

    // ********** Emit Particles **********
    // X = isSpawning 0.0 or 1.0
    // Y = isActive 0.0 or 1.0
    // Check if the vertex index is between the first value and the last value
    // if (particleIndex >= uLastIndexEmitted && particleIndex < uLastIndexEmitted + uParticlesToEmit) {
    //     // Emit a particle by writing 1 to the red channel of the color output
    //     // r: 1. == emit the particle
    //     // g: 1. == particle is now active
    //     timeStart = uTime;
    //     gl_FragColor = vec4(1.0, 1.0, timeStart, 1.0);
    // } else {
    //     // The Particle is either already emitted or not in the range of the particles to emit
    //     // Do not emit a particle by writing 0 to the red channel of the color output        
    //     gl_FragColor = vec4(0.0, isActive, timeStart, 1.0);
    // }
    // Determine if the particle is within the emission range
    float emitLowerBound = step(uLastIndexEmitted, particleIndex);
    float emitUpperBound = step(particleIndex, uLastIndexEmitted + uParticlesToEmit - 1.0);
    float emitParticle = emitLowerBound * emitUpperBound; // 1.0 if in range, 0.0 otherwise

    // Set timeStart and color
    timeStart = mix(timeStart, uTime, emitParticle);
    gl_FragColor = vec4(emitParticle, mix(isActive, 1.0, emitParticle), timeStart, 1.0);


}
`,
        TT = class extends sL {
          constructor(_, I) {
            super(),
              (this.type = "ParticleEmitter"),
              (this.debugMode = !1),
              (this.worldSpace = !0),
              (this.rootObject = null),
              (this.gpuCompute = null),
              (this.positionSimRT = null),
              (this.velocitySimRT = null),
              (this.emissionRateSimRT = null),
              (this.emitterShape = void 0),
              (this.isEmitting = !1),
              (this.hasBeenReset = !1),
              (this.emittedParticlesAmount = 0),
              (this.lastEmitTime = 0),
              (this.globalTime = 0),
              (this.targetFPS = 60),
              (this.previousRatio = 1),
              (this.lerpFactor = 0.4),
              (this.particlesAmount = 0),
              (this.noiseStrength = 0),
              (this.noiseScale = 0),
              (this.isBillboardBased = !0),
              (this.simFeaturesDefinition = {
                USE_COLLIDER: !1,
                USE_ATTRACTOR: !1,
                USE_VORTEX: !1,
                USE_SPHERE_COLLIDER: !1,
                USE_BOX_COLLIDER: !1,
                USE_FORCE_LOCAL_SPACE: !1,
                USE_NORMALS: !1,
                USE_CURL_NOISE: !0,
                USE_SIMPLEX_NOISE: !1,
                USE_FBM_NOISE: !1,
              }),
              (this.textureLoader = new o7()),
              (this.currentWorldPosition = new rF()),
              (this.systemQuaternion = new rz()),
              (this.worldGravity = new rF(0, 0, 0)),
              (this.directionAxis = new rF(0, 0, 0)),
              (this.colliderV3 = new rF(0, 0, 0)),
              (this.colliderQuaternion = new rz(0, 0, 0, 1)),
              (this.matrixAutoUpdate = !0),
              (this.renderer = _),
              (this.system = I),
              (this.shared = I.context.shared);
            let R = I.data;
            (this.material = new TS(R.renderMaterial, I.context)),
              (this.material.uniforms = {
                uSize: { value: 0 },
                uSizeEnd: { value: 0 },
                uColor: { value: R.renderMaterial.color },
                uColor2: { value: R.renderMaterial.color2 },
                uPosition: { value: new rF(0, 0, 0) },
                uEmissionData: { value: new rF(0, 0, 0) },
                uTexture: { value: this.defaultTexture },
                uWorldOffset: { value: new rF(0, 0, 0) },
                uWorldQuaternion: { value: new rM(0, 0, 0, 1) },
                uRandScaleFactor: { value: R.randomScale ?? 0 },
                uRandRotationFactor: { value: R.randomRotation ?? 0 },
                uRotation: { value: R.renderMaterial.spriteRotation[0] ?? 0 },
                uRotationEnd: {
                  value: R.renderMaterial.spriteRotation[1] ?? 0,
                },
              }),
              this.setTexture(this.material.uniforms, R.renderMaterial.texture),
              this.init(R);
          }
          setTexture(_, I) {
            let R = I.data;
            if ("string" == typeof I) {
              let R = this.shared.image(I),
                B = new rA(R.img);
              (B.needsUpdate = !0), (_.uTexture.value = B);
              return;
            }
            if ("string" != typeof R) {
              let I = new Image();
              I.onload = () => {
                let R = new rA(I);
                (R.needsUpdate = !0), (_.uTexture.value = R);
              };
              let B = new Blob([R], { type: "image/*" }),
                z = URL.createObjectURL(B);
              I.src = z;
            }
          }
          updateGeometryAttributes(_, I) {
            let R = (function (_) {
              let I = new Float32Array(_ * _ * 2);
              for (let R = 0; R < _; R++)
                for (let B = 0; B < _; B++) {
                  let z = R * _ + B;
                  (I[2 * z + 0] = R / (_ - 1)), (I[2 * z + 1] = B / (_ - 1));
                }
              return I;
            })(I);
            this.emitterShape?.positionsAttribute &&
              _.geometry.setAttribute("ref", new nq(R, 2));
          }
          applyWorldSpace() {
            if (
              !this.system.started ||
              !this.worldSpace ||
              !this.positionSimRT ||
              !this.velocitySimRT
            )
              return;
            let _ = this.system;
            _.getWorldQuaternion(this.systemQuaternion),
              this.systemQuaternion.invert(),
              _.getWorldPosition(this.currentWorldPosition),
              (this.material.uniforms.uWorldOffset.value =
                this.currentWorldPosition),
              this.material.uniforms.uWorldQuaternion.value.copy(
                this.systemQuaternion.normalize()
              ),
              (this.positionSimRT.material.uniforms.uWorldOffset.value =
                this.currentWorldPosition),
              this.systemQuaternion.invert(),
              this.positionSimRT.material.uniforms.uWorldQuaternion.value.copy(
                this.systemQuaternion.normalize()
              ),
              this.velocitySimRT.material.uniforms.uWorldQuaternion.value.copy(
                this.systemQuaternion.normalize()
              );
          }
          update(_, I) {
            if (
              !this.gpuCompute ||
              !this.positionSimRT ||
              !this.velocitySimRT ||
              !this.emissionRateSimRT ||
              this.hasBeenReset
            )
              return;
            if (this.checkIfAllParticlesAreDead() && !this.hasBeenReset) {
              this.reset();
              return;
            }
            this.applyWorldSpace(),
              (this.globalTime = _),
              (this.positionSimRT.material.uniforms.uTime.value = _),
              (this.emissionRateSimRT.material.uniforms.uTime.value = _);
            let R = this.targetFPS / (1e3 / I),
              B =
                this.previousRatio + (R - this.previousRatio) * this.lerpFactor;
            (this.positionSimRT.material.uniforms.uFPSRatio.value = B),
              (this.previousRatio = B);
            let z = this.isEmitting
              ? this.GoEmitSomeParticles(_, this.system.data.birthRatePerSec)
              : 0;
            (this.emissionRateSimRT.material.uniforms.uLastIndexEmitted.value =
              this.emittedParticlesAmount),
              (this.emissionRateSimRT.material.uniforms.uParticlesToEmit.value =
                z),
              (this.material.uniforms.uPosition.value =
                this.gpuCompute.getCurrentRenderTarget(
                  this.positionSimRT
                )?.texture),
              this.system.colliderEntities.length > 0 && this.renderColliders(),
              this.gpuCompute.compute();
          }
          renderColliders() {
            if (!this.velocitySimRT) return;
            let _ = this.system.colliderEntities[0];
            if (!_) return;
            _.getWorldPosition(this.colliderV3),
              0 === this.colliderV3.y && (this.colliderV3.y = 1e-4),
              this.velocitySimRT.material.uniforms.uColliderPos.value.copy(
                this.colliderV3
              );
            let I = _.data.size;
            this.colliderV3.fromArray(I),
              this.velocitySimRT.material.uniforms.uColliderSize.value.copy(
                this.simFeaturesDefinition.USE_SPHERE_COLLIDER
                  ? this.colliderV3.multiplyScalar(0.5)
                  : this.colliderV3
              ),
              _.getWorldQuaternion(this.colliderQuaternion),
              this.velocitySimRT.material.uniforms.uColliderQuaternion.value.copy(
                this.colliderQuaternion.normalize()
              ),
              this.velocitySimRT.material.uniforms.uColliderQuaternionInvert.value.copy(
                this.colliderQuaternion.normalize().invert()
              );
          }
          updateState(_) {
            this.velocitySimRT &&
              this.positionSimRT &&
              (_.renderMaterial && this.updateMaterialState(_.renderMaterial),
              this.updateParticleState(_));
          }
          updateVariableState(_, I) {
            if (!this.velocitySimRT || !this.positionSimRT) return;
            "size" === I[2] &&
              this.material.updateState({
                size: [_, this.material.uniforms.uSizeEnd.value],
              }),
              "sizeEnd" === I[2] &&
                this.material.updateState({
                  size: [this.material.uniforms.uSize.value, _],
                });
            let i = (_, I) => {
              let R = [...this.system.data.shape.size];
              (R[_] = I),
                this.updateParticleState({
                  shape: { ...this.system.data.shape, size: R },
                });
            };
            "shape_size_0" === I[2] && i(0, _),
              "shape_size_1" === I[2] && i(1, _),
              "shape_size_2" === I[2] && i(2, _),
              "speed" === I[2] &&
                (this.velocitySimRT.material.uniforms.uSpeed.value = _ / 10),
              "gravity" === I[2] && this.worldGravity.set(0, _ / 100, 0),
              "noiseStrength" === I[2] &&
                ((this.noiseStrength = _),
                (this.velocitySimRT.material.uniforms.uNoiseStrength.value =
                  this.noiseStrength)),
              "noiseScale" === I[2] &&
                ((this.noiseScale = _),
                (this.velocitySimRT.material.uniforms.uNoiseScale.value =
                  this.noiseScale)),
              "direction_x" === I[2] &&
                (this.directionAxis = this.getDirectionAxis([
                  Number(_),
                  this.system.data.direction[1],
                  this.system.data.direction[2],
                ])),
              "direction_y" === I[2] &&
                (this.directionAxis = this.getDirectionAxis([
                  this.system.data.direction[0],
                  Number(_),
                  this.system.data.direction[2],
                ])),
              "direction_z" === I[2] &&
                (this.directionAxis = this.getDirectionAxis([
                  this.system.data.direction[0],
                  this.system.data.direction[1],
                  Number(_),
                ]));
          }
          updateMaterialState(_) {
            this.material.updateState({
              ..._,
              size: _.size
                ? [
                    Number(
                      this.shared.getVariable(_.size[0], [
                        this.uuid,
                        "particles",
                        "size",
                      ])
                    ),
                    Number(
                      this.shared.getVariable(_.size[1], [
                        this.uuid,
                        "particles",
                        "sizeEnd",
                      ])
                    ),
                  ]
                : [0, 0],
            }),
              _.texture &&
                (this.setTexture(this.material.uniforms, _.texture),
                (this.material.needsUpdate = !0));
          }
          updateParticleState(_) {
            if (!(!this.positionSimRT || !this.velocitySimRT)) {
              if (
                (this.shouldReInitGPUCompute(_) &&
                  this.init(cu(this.system.data)),
                void 0 !== _.life &&
                  (this.positionSimRT.material.uniforms.uMaxLifeTime.value =
                    _.life),
                void 0 !== _.speed &&
                  (this.velocitySimRT.material.uniforms.uSpeed.value =
                    Number(
                      this.shared.getVariable(_.speed, [
                        this.uuid,
                        "particles",
                        "speed",
                      ])
                    ) / 10),
                void 0 !== _.collisionBounce &&
                  (this.velocitySimRT.material.uniforms.uBounce.value =
                    _.collisionBounce),
                void 0 !== _.noiseStrength &&
                  ((this.noiseStrength = Number(
                    this.shared.getVariable(_.noiseStrength, [
                      this.uuid,
                      "particles",
                      "noiseStrength",
                    ])
                  )),
                  (this.velocitySimRT.material.uniforms.uNoiseStrength.value =
                    this.noiseStrength)),
                void 0 !== _.noiseScale &&
                  ((this.noiseScale = Number(
                    this.shared.getVariable(_.noiseScale, [
                      this.uuid,
                      "particles",
                      "noiseScale",
                    ])
                  )),
                  (this.velocitySimRT.material.uniforms.uNoiseScale.value =
                    this.noiseScale)),
                void 0 !== _.noiseSeed &&
                  (this.velocitySimRT.material.uniforms.uNoiseSeed.value =
                    _.noiseSeed),
                void 0 !== _.randomMass &&
                  (this.velocitySimRT.material.uniforms.uRandomMassFactor.value =
                    _.randomMass),
                _.renderMaterial?.size !== void 0)
              ) {
                let I = this.shared.getVariable(_.renderMaterial.size[0], [
                  this.uuid,
                  "particles",
                  "size",
                ]);
                this.velocitySimRT.material.uniforms.particleSize.value =
                  Number(I);
              }
              if (
                (_.renderMaterial?.spriteRotation !== void 0 &&
                  ((this.material.uniforms.uRotation.value =
                    _.renderMaterial.spriteRotation[0]),
                  (this.material.uniforms.uRotationEnd.value =
                    _.renderMaterial.spriteRotation[1])),
                void 0 !== _.shape)
              ) {
                let I = _.shape.size ?? this.system.data.shape.size,
                  R = [
                    Number(
                      this.shared.getVariable(I[0], [
                        this.uuid,
                        "particles",
                        "shape_size_0",
                      ])
                    ),
                    Number(
                      this.shared.getVariable(I[1], [
                        this.uuid,
                        "particles",
                        "shape_size_1",
                      ])
                    ),
                    Number(
                      this.shared.getVariable(I[2], [
                        this.uuid,
                        "particles",
                        "shape_size_2",
                      ])
                    ),
                  ],
                  B = { ...cu(this.system.data).shape, size: R };
                this.emitterShape?.applyToShader(
                  this.positionSimRT.material.uniforms,
                  B
                );
              }
              if (
                (void 0 !== _.gravity &&
                  (this.worldGravity.set(
                    0,
                    Number(
                      this.shared.getVariable(this.system.data.gravity, [
                        this.uuid,
                        "particles",
                        "gravity",
                      ])
                    ) / 100,
                    0
                  ),
                  (this.velocitySimRT.material.uniforms.uGravity = {
                    value: this.worldGravity,
                  })),
                void 0 !== _.direction)
              ) {
                let I = this.getDirectionFromVariable(_.direction);
                (this.directionAxis = this.getDirectionAxis(I)),
                  (this.velocitySimRT.material.uniforms.uDirectionsAxis.value =
                    this.directionAxis);
              }
              void 0 !== _.randomRotation &&
                (this.material.uniforms.uRandRotationFactor.value =
                  _.randomRotation),
                void 0 !== _.randomScale &&
                  (this.material.uniforms.uRandScaleFactor.value =
                    _.randomScale);
            }
          }
          updateForceFieldParameters(_) {
            this.velocitySimRT &&
              (void 0 !== _.forceIntensity &&
                (this.velocitySimRT.material.uniforms.uForceIntensity.value =
                  _.forceIntensity),
              void 0 === _.forceDambing ||
                (this.velocitySimRT.material.uniforms.uForceDamping.value =
                  _.forceDambing));
          }
          getDirectionAxis(_) {
            let I = [
                Number(_[0]) * rr.DEG2RAD,
                Number(_[1]) * rr.DEG2RAD,
                Number(_[2]) * rr.DEG2RAD,
              ],
              R = new sg(I[0], I[1], I[2], "XYZ");
            return (
              this.directionAxis.set(0, 1, 0).applyEuler(R).normalize(),
              this.velocitySimRT &&
                (this.velocitySimRT.material.uniforms.uDirectionsAxis.value =
                  this.directionAxis),
              this.directionAxis
            );
          }
          shouldReInitGPUCompute(_) {
            let {
              birthRatePerSec: I,
              rootObjectType: R,
              colliderEntityId: B,
              shape: z,
              emitTimeDuration: k,
              emitTimeCycle: V,
              life: j,
              directionMode: G,
              noiseType: q,
            } = _;
            return (
              void 0 !== I ||
              void 0 !== R ||
              B ||
              null === B ||
              void 0 !== V ||
              void 0 !== z ||
              void 0 !== j ||
              void 0 !== k ||
              void 0 !== G ||
              void 0 !== q
            );
          }
          init(_) {
            this.dispose(),
              (this.particlesAmount = this.getMaxParticlesAmount({
                birthRatePerSecond: _.birthRatePerSec,
                particleMaxLifeTime: _.life,
                loopDuration:
                  "infinity" === _.emitTimeCycle ? 0 : _.emitTimeDuration,
              })),
              this.particlesAmount > 1e5 &&
                (console.warn(
                  "The maximum number of particles is limited to 100000."
                ),
                (this.particlesAmount = 1e5)),
              (this.emitterShape = this.createShape(
                _.shape,
                this.particlesAmount
              ));
            let I = setInterval(() => {
              if (this.emitterShape) {
                if (
                  isNaN(this.emitterShape.positionsTexture.source.data.data[0])
                ) {
                  this.init(_);
                  return;
                }
                clearInterval(I);
              }
            }, 100);
            if (!this.emitterShape) return;
            let R = new Tr(
                this.emitterShape.textureSize,
                this.emitterShape.textureSize,
                this.renderer
              ),
              B = this.updateSimulationDefinition(_),
              z = R.addVariable(
                "uCurrentPosition",
                B + Tc,
                this.emitterShape.positionsTexture
              ),
              k = R.addVariable(
                "uCurrentVelocity",
                B + Tg,
                this.emitterShape.directionsTexture
              ),
              V = R.addVariable(
                "uCurrentEmissionRate",
                TC,
                (function (_) {
                  let I = new Float32Array(4 * _ * _);
                  for (let R = 0; R < _ * _; R++)
                    (I[4 * R] = 0),
                      (I[4 * R + 1] = 0),
                      (I[4 * R + 2] = 0),
                      (I[4 * R + 3] = 0);
                  let R = new nV(I, _, _, 1023, 1015);
                  return (R.needsUpdate = !0), R;
                })(this.emitterShape.textureSize)
              );
            R.setVariableDependencies(z, [z, k, V]),
              R.setVariableDependencies(k, [z, k, V]),
              R.setVariableDependencies(V, [z, k, V]);
            let j = (function ({ size: _ }) {
                let I = new Float32Array(4 * _ * _);
                for (let R = 0; R < _ * _; R++)
                  (I[4 * R] = R),
                    (I[4 * R + 1] = 0),
                    (I[4 * R + 2] = 0),
                    (I[4 * R + 3] = 0);
                let R = new nV(I, _, _, 1023, 1015);
                return (R.needsUpdate = !0), R;
              })({ size: this.emitterShape.textureSize }),
              G = {
                uOriginalPosition: {
                  value: this.emitterShape.positionsTexture,
                },
                uWorldOffset: { value: new rF(0, 0, 0) },
                uWorldQuaternion: { value: new rM(0, 0, 0, 1) },
                uTime: { value: 0 },
                uFPSRatio: { value: 1 },
                uMaxLifeTime: { value: _.life },
                uEmitterSize: {
                  value: new rF(
                    Number(
                      this.shared.getVariable(_.shape.size[0], [
                        this.uuid,
                        "particles",
                        "shape_size_0",
                      ])
                    ),
                    Number(
                      this.shared.getVariable(_.shape.size[1], [
                        this.uuid,
                        "particles",
                        "shape_size_1",
                      ])
                    ),
                    Number(
                      this.shared.getVariable(_.shape.size[2], [
                        this.uuid,
                        "particles",
                        "shape_size_2",
                      ])
                    )
                  ),
                },
                particleSize: { value: 0 },
              };
            z.material.uniforms = G;
            let q = this.getDirectionFromVariable(_.direction);
            (this.directionAxis = this.getDirectionAxis(q)),
              this.worldGravity.set(
                0,
                Number(
                  this.shared.getVariable(this.system.data.gravity, [
                    this.uuid,
                    "particles",
                    "gravity",
                  ])
                ) / 100,
                0
              ),
              (this.noiseStrength = Number(
                this.shared.getVariable(_.noiseStrength, [
                  this.uuid,
                  "particles",
                  "noiseStrength",
                ])
              )),
              (this.noiseScale = Number(
                this.shared.getVariable(_.noiseScale, [
                  this.uuid,
                  "particles",
                  "noiseScale",
                ])
              ));
            let X =
                _.colliderEntityId &&
                this.system.getColliderData(_.colliderEntityId),
              Q = {
                uOriginalPosition: {
                  value: this.emitterShape.positionsTexture,
                },
                uDirections: { value: this.emitterShape.directionsTexture },
                uDirectionsAxis: { value: this.directionAxis },
                uWorldQuaternion: { value: new rM(0, 0, 0, 1) },
                uColliderPos: { value: new rF(0, 0, 0) },
                uColliderSize: { value: new rF(0, 0, 0) },
                uForceIntensity: { value: X ? X.forceIntensity : 0 },
                uForceDamping: { value: X ? X.forceDambing : 0 },
                uColliderQuaternion: { value: new rM(0, 0, 0, 1) },
                uColliderQuaternionInvert: { value: new rM(0, 0, 0, 1) },
                particleSize: { value: 0 },
                uGravity: { value: this.worldGravity },
                uNoiseStrength: { value: this.noiseStrength },
                uNoiseScale: { value: this.noiseScale },
                uNoiseSeed: { value: _.noiseSeed },
                uRandomMassFactor: { value: _.randomMass },
                uBounce: { value: _.collisionBounce },
                uSpeed: {
                  value:
                    Number(
                      this.shared.getVariable(_.speed, [
                        this.uuid,
                        "particles",
                        "speed",
                      ])
                    ) / 10,
                },
              };
            (k.material.uniforms = Q),
              (V.material.uniforms = {
                uIndex: { value: j },
                uTime: { value: 0 },
                uLastIndexEmitted: { value: 0 },
                uParticlesToEmit: { value: 0 },
              });
            let $ = [
                Number(
                  this.shared.getVariable(_.shape.size[0], [
                    this.uuid,
                    "particles",
                    "shape_size_0",
                  ])
                ),
                Number(
                  this.shared.getVariable(_.shape.size[1], [
                    this.uuid,
                    "particles",
                    "shape_size_1",
                  ])
                ),
                Number(
                  this.shared.getVariable(_.shape.size[2], [
                    this.uuid,
                    "particles",
                    "shape_size_2",
                  ])
                ),
              ],
              et = { ...cu(this.system.data).shape, size: $ };
            this.emitterShape.applyToShader(z.material.uniforms, et),
              R.init(),
              (this.gpuCompute = R),
              (this.positionSimRT = z),
              (this.velocitySimRT = k),
              (this.emissionRateSimRT = V),
              (this.rootObject = this.createPrimaryEmitter(
                this.emitterShape.textureSize
              )),
              this.add(this.rootObject),
              (this.material.needsUpdate = !0);
          }
          getDirectionFromVariable(_) {
            return [
              Number(
                this.shared.getVariable(_[0], [
                  this.uuid,
                  "particles",
                  "direction_x",
                ])
              ),
              Number(
                this.shared.getVariable(_[1], [
                  this.uuid,
                  "particles",
                  "direction_y",
                ])
              ),
              Number(
                this.shared.getVariable(_[2], [
                  this.uuid,
                  "particles",
                  "direction_z",
                ])
              ),
            ];
          }
          updateSimulationDefinition(_) {
            if (
              ((this.simFeaturesDefinition.USE_COLLIDER = !1),
              (this.simFeaturesDefinition.USE_ATTRACTOR = !1),
              (this.simFeaturesDefinition.USE_VORTEX = !1),
              (this.simFeaturesDefinition.USE_SPHERE_COLLIDER = !1),
              (this.simFeaturesDefinition.USE_BOX_COLLIDER = !1),
              (this.simFeaturesDefinition.USE_FORCE_LOCAL_SPACE = !1),
              (this.simFeaturesDefinition.USE_NORMALS = !1),
              (this.simFeaturesDefinition.USE_CURL_NOISE = !1),
              (this.simFeaturesDefinition.USE_SIMPLEX_NOISE = !1),
              (this.simFeaturesDefinition.USE_FBM_NOISE = !1),
              _.colliderEntityId && this.system.colliderEntities.length > 0)
            ) {
              let I = this.system.getColliderData(_.colliderEntityId);
              switch (I?.forceType) {
                case "attractor":
                  this.simFeaturesDefinition.USE_ATTRACTOR = !0;
                  break;
                case "collider":
                  this.simFeaturesDefinition.USE_COLLIDER = !0;
                  break;
                case "vortex":
                  this.simFeaturesDefinition.USE_VORTEX = !0;
              }
              let R = I?.colliderType;
              "sphere" === R &&
                (this.simFeaturesDefinition.USE_SPHERE_COLLIDER = !0),
                "box" === R &&
                  (this.simFeaturesDefinition.USE_BOX_COLLIDER = !0),
                I?.forceRange === "helper" &&
                  (this.simFeaturesDefinition.USE_FORCE_LOCAL_SPACE = !0);
            }
            "normals" === _.directionMode &&
              (this.simFeaturesDefinition.USE_NORMALS = !0),
              "curl" === _.noiseType &&
                (this.simFeaturesDefinition.USE_CURL_NOISE = !0),
              "simplex" === _.noiseType &&
                (this.simFeaturesDefinition.USE_SIMPLEX_NOISE = !0),
              "fbm" === _.noiseType &&
                (this.simFeaturesDefinition.USE_FBM_NOISE = !0);
            let I = "";
            for (let [_, R] of Object.entries(this.simFeaturesDefinition))
              R &&
                (I += `#define ${_}
`);
            return I;
          }
          createShape(_, I) {
            this.emitterShape && this.emitterShape.dispose();
            let R = new rF(
              Number(
                this.shared.getVariable(_.size[0], [
                  this.uuid,
                  "particles",
                  "shape_size_0",
                ])
              ),
              Number(
                this.shared.getVariable(_.size[1], [
                  this.uuid,
                  "particles",
                  "shape_size_1",
                ])
              ),
              Number(
                this.shared.getVariable(_.size[2], [
                  this.uuid,
                  "particles",
                  "shape_size_2",
                ])
              )
            );
            if ("MeshEmitterShape" !== _.type) return new TA(R, I, _.type);
            {
              let B = null;
              return (
                this.system.context.scene.traverseEntity((I) => {
                  I.uuid === _.fromMeshId && (B = I);
                }),
                B ? new TA(R, I, _.type, B) : new TA(R, I, "SphereEmitterShape")
              );
            }
          }
          createPrimaryEmitter(_) {
            let I,
              R = _ * _;
            return (
              (I = new nJ(new aq(1, 1, 1), this.material, R)),
              this.updateGeometryAttributes(I, _),
              (this.material.needsUpdate = !0),
              (I.onBeforeRender = () => {
                this.applyWorldSpace();
              }),
              I
            );
          }
          getMaxParticlesAmount({
            birthRatePerSecond: _,
            particleMaxLifeTime: I,
            loopDuration: R = 0,
          }) {
            return Math.ceil(_ * (I + R));
          }
          dispose() {
            this.gpuCompute &&
              (this.rootObject?.parent?.remove(this.rootObject),
              this.gpuCompute.dispose(),
              this.material.nodeMaterialDispose(),
              this.emitterShape?.dispose());
          }
          GoEmitSomeParticles(_, I) {
            let R = _ - this.lastEmitTime,
              B = 1 / I;
            if (R >= B) {
              let I = Math.max(1, Math.floor(R / B));
              return (
                (this.lastEmitTime = _),
                this.emittedParticlesAmount + I > this.particlesAmount &&
                  (this.emittedParticlesAmount = 0),
                (this.emittedParticlesAmount += I),
                I
              );
            }
            return 0;
          }
          checkIfAllParticlesAreDead() {
            return (
              this.lastEmitTime + this.system.data.life + 1 < this.globalTime
            );
          }
          reset() {
            (this.hasBeenReset = !0),
              (this.lastEmitTime = 0),
              (this.emittedParticlesAmount = 0),
              this.gpuCompute && this.init(cu(this.system.data));
          }
          startEmitting(_) {
            (this.isEmitting = !0),
              (this.hasBeenReset = !1),
              (this.lastEmitTime = _);
          }
          stopEmitting() {
            this.isEmitting = !1;
          }
        },
        TP = class extends wp {
          constructor(_, I, R) {
            super(_, I),
              (this.type = "ParticleSystem"),
              (this.geometry = new ai()),
              (this.actualTime = 0),
              (this.currentLoopTime = 0),
              (this.started = !1),
              (this.stopped = !1),
              (this.isFrozen = !1),
              (this.isIdle = !0),
              (this.emitter = null),
              (this.colliderEntities = []),
              (this.renderer = null),
              (this.isPreWarm = !1),
              (this._hasOnAfterRenderBeenCalled = !1),
              (this.onAfterRender = (_) => {
                this._hasOnAfterRenderBeenCalled ||
                  ((this._hasOnAfterRenderBeenCalled = !0), this.init(_));
              }),
              (this.context = R),
              (this.data = { ...I, ...cu(I) }),
              this.geometry.setAttribute("position", new s4([], 3)),
              (this.material = new sK({ colorWrite: !1 })),
              (this.frustumCulled = !1);
          }
          init(_) {
            (this.renderer = _),
              (this.emitter = new TT(_, this)),
              this.add(this.emitter),
              this.updateParticleState(this.data);
          }
          update(_) {
            if (!this.isReady || !this.started || this.isFrozen || this.isIdle)
              return;
            (this.actualTime += _), this.stopped || (this.currentLoopTime += _);
            let I = "one_time" === this.data.emitTimeCycle;
            if (
              (("loop" === this.data.emitTimeCycle || I) &&
                this.currentLoopTime > 1e3 * this.data.emitTimeDuration &&
                (this.stopped ||
                  (this.stop(),
                  I ||
                    this.start(
                      "start" === this.data.emitTimeLoopDelayStart
                        ? 0
                        : 1e3 * this.data.emitTimeDelay
                    ))),
              this.emitter && this.started)
            ) {
              let I = this.actualTime / 1e3;
              this.emitter.update(I, _);
            }
            this.scale.set(1, 1, 1), this.updateMatrix();
          }
          isReady() {
            return !!this.emitter;
          }
          hasCollider(_) {
            return this.colliderEntities.some((I) => I.identity === _);
          }
          getColliderData(_) {
            let I = this.colliderEntities.find((I) => I.identity === _);
            return I ? I.data : null;
          }
          updateByPatchedOp(_, I, R) {
            super.updateByPatchedOp(_, I, R),
              Rt(_.path, ["renderMaterial"]) &&
                this.updateParticleState({
                  renderMaterial: {
                    ...this.data.renderMaterial,
                    ...u9.drop(_, 1).props,
                  },
                }),
              Rt(_.path, ["shape"]) &&
                this.updateParticleState({
                  shape: { ...this.data.shape, ...u9.drop(_, 1).props },
                });
          }
          updateState(_, I) {
            super.updateState(_, I), this.updateParticleState(_);
          }
          updateParticleState(_) {
            if (this.emitter) {
              if (
                void 0 !== _.colliderEntityId &&
                null !== _.colliderEntityId
              ) {
                let I = this.context.scene.find(_.colliderEntityId);
                this.colliderEntities = I ? [I] : [];
              }
              null === _.colliderEntityId && (this.colliderEntities = []),
                this.emitter.updateState(_),
                _.emitTimeCycle && this.started && this.start();
            }
          }
          updateFromColliderEntity(_) {
            this.emitter &&
              (this.emitter.updateForceFieldParameters(_),
              this.stop(),
              this.start());
          }
          start(_ = 0) {
            if (((this.currentLoopTime = 0), _)) {
              setTimeout(() => {
                this.start(0);
              }, _);
              return;
            }
            (this.started = !0),
              (this.stopped = !1),
              (this.isFrozen = !1),
              this.emitter?.startEmitting(this.actualTime / 1e3);
          }
          froze() {
            this.isFrozen = !0;
          }
          unFroze() {
            this.isFrozen = !1;
          }
          stop() {
            (this.stopped = !0),
              (this.currentLoopTime = 0),
              this.emitter?.stopEmitting();
          }
          reset() {
            (this.started = !1), (this.stopped = !1), this.emitter?.reset();
          }
          wakeUp() {
            this.isIdle = !1;
          }
          sleep() {
            (this.isIdle = !0), this.reset();
          }
        };
      function rb(_, I, R) {
        return (
          console.assert(void 0 !== I.type),
          "Mesh" === I.type
            ? "TextGeometry" === I.geometry.type
              ? new Ax(_, I, R)
              : "SubdivGeometry" === I.geometry.type
              ? new S5(_, I, R)
              : "PathGeometry" === I.geometry.type
              ? new C7(_, I, R)
              : "VectorGeometry" === I.geometry.type
              ? new C9(_, I, R)
              : "BooleanGeometry" === I.geometry.type
              ? new A1(_, I, R)
              : "UIGeometry" === I.geometry.type
              ? new Ti(_, I, R)
              : new S2(_, I, R)
            : "Empty" === I.type
            ? new A3(_, I)
            : "Particle" === I.type
            ? new TP(_, I, R)
            : "ParticleCollider" === I.type
            ? new A4(_, I, R)
            : "Splat" === I.type
            ? new A3(_, I)
            : "Bone" === I.type
            ? new Tt(_, I)
            : "Page" === I.type
            ? new C6(_, I, R)
            : "PointLight" === I.type
            ? new C8(_, I, R)
            : "SpotLight" === I.type
            ? new C_(_, I, R)
            : "DirectionalLight" === I.type
            ? new Cg(_, I, R)
            : "Component" === I.type || "Instance" === I.type
            ? new Te(_, I, R)
            : mP.is(I.type)
            ? new AK(_, I)
            : (console.error(I), new A3(_, I))
        );
      }
      function AL(_, I) {
        let R = !1,
          B = I.getLayersOfType("transmission"),
          z = I.getLayersOfType("outline");
        return (
          z.length > 0 &&
            (_.layers.set(8),
            B.length > 0 && _.layers.enable(3),
            (R = !0),
            pf(_),
            ff(_)),
          0 === B.length && 0 === z.length && _.layers.set(0),
          _ instanceof SZ && _.needsAO && _.layers.enable(5),
          R
        );
      }
      function _L(_, I) {
        if (!I.layers) return !1;
        let R = !1,
          B = I.getLayersOfType("transmission").filter((_) => _.data.visible),
          z = I.getLayersOfType("outline").filter((_) => _.data.visible);
        return (
          B.length > 0 &&
            (_.layers.set(3), z.length > 0 && _.layers.enable(8), (R = !0)),
          0 === B.length && 0 === z.length && _.layers.set(0),
          _.needsAO && _.layers.enable(5),
          R
        );
      }
      (yZ.createEntity = rb),
        (yZ.changeEntityProptotype = function (_, I, R) {
          let B = rb(_.identity, I, R),
            z = _.children,
            k = _.attachedPaths,
            V = _.parent,
            j = _.component,
            G = _.instances,
            q = _.overrideData,
            X = _.uuid,
            Q = _.stateSelection;
          for (let I of (_.dispose(), Object.keys(_))) delete _[I];
          for (let I of (Object.setPrototypeOf(_, Object.getPrototypeOf(B)),
          Object.keys(B)))
            _[I] = B[I];
          (_.children = [..._.children, ...z]),
            (_.attachedPaths = k),
            (_.parent = V),
            (_.component = j),
            (_.instances = G),
            (_.uuid = X),
            (_.overrideData = q),
            _.updateState(_.data, R),
            Q && _.changeSelectedState(Q, R),
            _.resetBBoxNeedsUpdate();
        }),
        (yZ.Cloner = AI);
      var TD = new lV(),
        TO = new sa(),
        TI = new ss();
      function eg(_, I, R, B = !1) {
        let z = _.cloner;
        if (z)
          for (let k of z.children) {
            let z = TO.copy(k.matrixWorld).invert(),
              V = TI.copy(I.ray).applyMatrix4(z),
              j = _.matrixWorld;
            V.applyMatrix4(j),
              TD.set(V.origin, V.direction),
              (TD.near = I.near),
              (TD.far = I.far);
            let G = TD.intersectObject(_, !1);
            G.length > 0 && R.push({ ...G[0], object: B ? k : _ });
          }
      }
      var TR = class {
          constructor() {
            this._constraints = new Map();
          }
          setConstraint(_, I) {
            null === I
              ? this._constraints.delete(_)
              : this._constraints.set(_, I);
          }
          removeDependencies(_) {
            this._constraints.delete(_);
          }
          applyConstraints(_) {
            let I = new Set();
            this._constraints.forEach((R, B) => {
              let z = [B, R],
                k = R;
              for (; this._constraints.has(k); )
                (k = this._constraints.get(k)), I.has(k) || z.push(k);
              for (let R = z.length - 2; R >= 0; R--)
                if (!I.has(z[R])) {
                  let B = _.find(z[R]);
                  B
                    ? B.applyPathSnapping(_)
                    : console.warn(`missing entity ${z[R]}`),
                    I.add(z[R]);
                }
            });
          }
          findDependency(_, I) {
            let R = _;
            for (; this._constraints.has(R); )
              if ((R = this._constraints.get(R)) === I) return !0;
            return !1;
          }
        },
        TB = pi(iZ()),
        TL = pi(i1()),
        Tz = pi(iZ()),
        TF = pi(i1()),
        Tk = class {
          constructor(_, I, R) {
            (this._dataNormalized = _), (this._minD = I), (this._maxD = R);
          }
          static createFromUnnormalized(_) {
            let I = TF.sup(_),
              R = TF.inf(_),
              B = (0, Tz.default)(new Float32Array(_.size), _.shape),
              z = I - R;
            return (
              z < 1e-4
                ? TF.assigns(B, 0)
                : (TF.subs(B, _, R), TF.divs(B, B, z)),
              new Tk(B, R, I)
            );
          }
          get data() {
            return this._dataNormalized;
          }
          get minD() {
            return this._minD;
          }
          get maxD() {
            return this._maxD;
          }
          denormalize() {
            let _ = (0, Tz.default)(
              new Float32Array(this._dataNormalized.size),
              this._dataNormalized.shape
            );
            return (
              TF.muls(_, this._dataNormalized, this._maxD - this._minD),
              TF.adds(_, _, this._minD),
              _
            );
          }
        },
        TV = class {
          constructor(_, I) {
            (this._quantized = _), (this._method = I);
          }
          get quantized() {
            return this._quantized;
          }
          static maxIntBits(_) {
            return 2 ** _ - 1;
          }
          static fromNormalized(_, I) {
            let R = _.data,
              B;
            if ("norm8x" === I) {
              let _ = TV.maxIntBits(8),
                I = (0, Tz.default)(new Float32Array(R.size), R.shape);
              TF.muls(I, R, _),
                TF.roundeq(I),
                (B = (0, Tz.default)(new Uint8Array(I.data), R.shape));
            } else if ("norm565" === I) {
              let _ = (0, Tz.default)(new Float32Array(R.size), R.shape);
              TF.assign(_, R),
                TF.mulseq(_.pick(null, 0), TV.maxIntBits(5)),
                TF.mulseq(_.pick(null, 1), TV.maxIntBits(6)),
                TF.mulseq(_.pick(null, 2), TV.maxIntBits(5)),
                TF.roundeq(_);
              let I = (0, Tz.default)(new Uint16Array(_.data), R.shape),
                z = (0, Tz.default)(new Uint16Array(R.shape[0]), [R.shape[0]]),
                k = (0, Tz.default)(new Uint16Array(R.shape[0]), [R.shape[0]]);
              TF.lshifts(z, I.pick(null, 0), 11),
                TF.lshifts(k, I.pick(null, 1), 5),
                TF.boreq(z, k),
                TF.boreq(z, I.pick(null, 2)),
                (B = z);
            } else {
              let _ = (0, Tz.default)(new Float32Array(R.size), R.shape);
              TF.assign(_, R),
                TF.mulseq(_.pick(null, 0), TV.maxIntBits(11)),
                TF.mulseq(_.pick(null, 1), TV.maxIntBits(10)),
                TF.mulseq(_.pick(null, 2), TV.maxIntBits(11)),
                TF.roundeq(_);
              let I = (0, Tz.default)(new Uint32Array(_.data), R.shape),
                z = (0, Tz.default)(new Uint32Array(R.shape[0]), [R.shape[0]]),
                k = (0, Tz.default)(new Uint32Array(R.shape[0]), [R.shape[0]]);
              TF.lshifts(z, I.pick(null, 0), 21),
                TF.lshifts(k, I.pick(null, 1), 11),
                TF.boreq(z, k),
                TF.boreq(z, I.pick(null, 2)),
                (B = z);
            }
            return new TV(B, I);
          }
          dequantize(_, I) {
            let R = this._method,
              B,
              z = this._quantized;
            if ("norm8x" === R) {
              let _ = TV.maxIntBits(8);
              (B = (0, Tz.default)(new Float32Array(z.size), z.shape)),
                TF.muls(B, z, 1 / _);
            } else if ("norm565" === R) {
              let _ = (0, Tz.default)(new Uint8Array(z.shape[0]), [z.shape[0]]),
                I = (0, Tz.default)(new Uint8Array(z.shape[0]), [z.shape[0]]),
                R = (0, Tz.default)(new Uint8Array(z.shape[0]), [z.shape[0]]);
              TF.rrshifts(_, z, 11),
                TF.rrshifts(I, z, 5),
                TF.bandseq(I, TV.maxIntBits(6)),
                TF.bands(R, z, TV.maxIntBits(5)),
                (B = (0, Tz.default)(new Float32Array(3 * z.shape[0]), [
                  z.shape[0],
                  3,
                ])),
                TF.muls(B.pick(null, 0), _, 1 / TV.maxIntBits(5)),
                TF.muls(B.pick(null, 1), I, 1 / TV.maxIntBits(6)),
                TF.muls(B.pick(null, 2), R, 1 / TV.maxIntBits(5));
            } else {
              let _ = (0, Tz.default)(new Uint16Array(z.shape[0]), [
                  z.shape[0],
                ]),
                I = (0, Tz.default)(new Uint16Array(z.shape[0]), [z.shape[0]]),
                R = (0, Tz.default)(new Uint16Array(z.shape[0]), [z.shape[0]]);
              TF.rrshifts(_, z, 21),
                TF.rrshifts(I, z, 11),
                TF.bandseq(I, TV.maxIntBits(10)),
                TF.bands(R, z, TV.maxIntBits(11)),
                (B = (0, Tz.default)(new Float32Array(3 * z.shape[0]), [
                  z.shape[0],
                  3,
                ])),
                TF.muls(B.pick(null, 0), _, 1 / TV.maxIntBits(11)),
                TF.muls(B.pick(null, 1), I, 1 / TV.maxIntBits(10)),
                TF.muls(B.pick(null, 2), R, 1 / TV.maxIntBits(11));
            }
            return new Tk(B, _, I);
          }
        },
        Tj = class {
          constructor(_, I, R, B, z, k = !1) {
            (this._quantized = _),
              (this._minMaxMatrix = I),
              (this._chunkSize = R),
              (this._quantizationMethod = B),
              (this._variableChunkSize = z),
              (this._isDynamicChunks = k);
          }
          get length() {
            return this._quantized.shape[0];
          }
          get nchunks() {
            return this._minMaxMatrix.shape[0];
          }
          get quantized() {
            return this._quantized;
          }
          get method() {
            return this._quantizationMethod;
          }
          get minmaxMatrix() {
            return this._minMaxMatrix;
          }
          _createPrunedMinMax(_) {
            let I = _.length,
              R = this.minmaxMatrix.shape[0] - I,
              B = (0, TB.default)(new Float32Array(2 * R), [R, 2]),
              z = 0,
              k = R,
              V = 0,
              j = this.minmaxMatrix.shape[0];
            for (let I = 0; I < _.length; I++)
              (k = (j = _[I]) - V + z) > z &&
                TL.assign(
                  B.hi(k, 2).lo(z, 0),
                  this.minmaxMatrix.hi(j, 2).lo(V, 0)
                ),
                (z = k),
                (V = j + 1);
            return (
              z < R && TL.assign(B.lo(z, 0), this.minmaxMatrix.lo(V, 0)), B
            );
          }
          _createPrunedQuantized(_) {
            let I = _.length,
              R = this.quantized.shape[0] - I,
              B = this._quantizationMethod,
              z,
              k;
            if ("norm8x" === B) {
              let _ = (k = this._quantized.shape[1]) ? R * k : R;
              z = (0, TB.default)(new Uint8Array(_), k ? [R, k] : [R, 1]);
            } else
              z =
                "norm565" === B
                  ? (0, TB.default)(new Uint16Array(R), [R])
                  : (0, TB.default)(new Uint32Array(R), [R]);
            let V = 0,
              j = R,
              G = 0,
              q = z.shape[0];
            for (let I = 0; I < _.length; I++)
              (j = (q = _[I]) - G + V) > V &&
                (k
                  ? TL.assign(
                      z.hi(j, k).lo(V, 0),
                      this._quantized.hi(q, k).lo(G, 0)
                    )
                  : TL.assign(z.hi(j).lo(V), this._quantized.hi(q).lo(G))),
                (V = j),
                (G = q + 1);
            return (
              V < R &&
                (k
                  ? TL.assign(z.lo(V, 0), this._quantized.lo(G, 0))
                  : TL.assign(z.lo(V), this._quantized.lo(G))),
              z
            );
          }
          pruneFeature(_, I, R) {
            let B = this._createPrunedQuantized(_),
              z = this._createPrunedMinMax(I);
            return new Tj(
              B,
              z,
              this._chunkSize,
              this._quantizationMethod,
              R,
              !0
            );
          }
          static getRequiredNChunks(_, I) {
            return Math.floor(_ / I);
          }
          static fromArray(_, I, R) {
            let B = _.shape[0],
              z = Math.floor(B / R),
              k = (0, TB.default)(new Float32Array(2 * z), [z, 2], [2, 1]),
              V;
            V =
              "norm8x" === I
                ? (0, TB.default)(new Uint8Array(_.size), _.shape)
                : "norm565" === I
                ? (0, TB.default)(new Uint16Array(_.shape[0]), [_.shape[0]])
                : (0, TB.default)(new Uint32Array(_.shape[0]), [_.shape[0]]);
            for (let j = 0; j < z; j++) {
              let G = j * R,
                q = j + 1 < z ? (j + 1) * R : B,
                X;
              (X =
                _.shape.length > 1
                  ? Tk.createFromUnnormalized(_.hi(q, _.shape[1]).lo(G, 0))
                  : Tk.createFromUnnormalized(_.hi(q).lo(G))),
                k.set(j, 0, X.minD),
                k.set(j, 1, X.maxD),
                V.shape.length > 1
                  ? TL.assign(
                      V.hi(q, V.shape[1]).lo(G, 0),
                      TV.fromNormalized(X, I).quantized
                    )
                  : TL.assign(V.hi(q).lo(G), TV.fromNormalized(X, I).quantized);
            }
            return new Tj(V, k, R, I);
          }
          denormDequant() {
            let _,
              I = this._minMaxMatrix.shape[0],
              R = this._quantized,
              B = R.shape[0],
              z = this._quantizationMethod,
              k = this._chunkSize,
              V;
            if (this._isDynamicChunks) {
              if (!this._variableChunkSize)
                throw Error(
                  "variable chunk must exists if chunkSize isDynamic"
                );
              V = this._variableChunkSize;
            }
            _ =
              "norm8x" === z
                ? (0, TB.default)(new Float32Array(R.size), R.shape)
                : (0, TB.default)(new Float32Array(3 * B), [B, 3]);
            let j = 0,
              G = k;
            for (let k = 0; k < I; k++) {
              let [q, X] = [
                this._minMaxMatrix.get(k, 0),
                this._minMaxMatrix.get(k, 1),
              ];
              this._isDynamicChunks && (G = V[k]);
              let Q = k + 1 < I ? j + G : B,
                $;
              ($ =
                R.shape.length > 1
                  ? new TV(R.hi(Q, R.shape[1]).lo(j, 0), z)
                  : new TV(R.hi(Q).lo(j), z)),
                TL.assign(
                  _.hi(Q, _.shape[1]).lo(j, 0),
                  $.dequantize(q, X).denormalize()
                ),
                (j = Q);
            }
            return _;
          }
          static async fetchArrayBuffer(_) {
            return await (await fetch(_, { mode: "cors" })).arrayBuffer();
          }
        },
        TG = pi(iZ()),
        TH = pi(i1()),
        TW = pi(iZ()),
        Tq = pi(i1()),
        TY = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];
      function KL(_) {
        return _ < 1e5
          ? _ < 100
            ? _ < 10
              ? 0
              : 1
            : _ < 1e4
            ? _ < 1e3
              ? 2
              : 3
            : 4
          : _ < 1e7
          ? _ < 1e6
            ? 5
            : 6
          : _ < 1e9
          ? _ < 1e8
            ? 7
            : 8
          : 9;
      }
      function ZL(_, I) {
        if (_ === I) return 0;
        if (~~_ === _ && ~~I === I) {
          if (0 === _ || 0 === I) return _ < I ? -1 : 1;
          if (_ < 0 || I < 0) {
            if (I >= 0) return -1;
            if (_ >= 0) return 1;
            (_ = -_), (I = -I);
          }
          let R = KL(_),
            B = KL(I),
            z = 0;
          return (
            R < B
              ? ((_ *= TY[B - R - 1]), (I /= 10), (z = -1))
              : R > B && ((I *= TY[R - B - 1]), (_ /= 10), (z = 1)),
            _ === I ? z : _ < I ? -1 : 1
          );
        }
        let R = String(_),
          B = String(I);
        return R === B ? 0 : R < B ? -1 : 1;
      }
      function JL(_, I, R, B) {
        let z = I + 1;
        if (z === R) return 1;
        if (0 > B(_[z++], _[I])) {
          for (; z < R && 0 > B(_[z], _[z - 1]); ) z++;
          !(function (_, I, R) {
            for (R--; I < R; ) {
              let B = _[I];
              (_[I++] = _[R]), (_[R--] = B);
            }
          })(_, I, z);
        } else for (; z < R && B(_[z], _[z - 1]) >= 0; ) z++;
        return z - I;
      }
      function $L(_, I, R, B, z) {
        for (B === I && B++; B < R; B++) {
          let R = _[B],
            k = I,
            V = B;
          for (; k < V; ) {
            let I = (k + V) >>> 1;
            0 > z(R, _[I]) ? (V = I) : (k = I + 1);
          }
          let j = B - k;
          switch (j) {
            case 3:
              _[k + 3] = _[k + 2];
            case 2:
              _[k + 2] = _[k + 1];
            case 1:
              _[k + 1] = _[k];
              break;
            default:
              for (; j > 0; ) (_[k + j] = _[k + j - 1]), j--;
          }
          _[k] = R;
        }
      }
      function rE(_, I, R, B, z, k) {
        let V = 0,
          j = 0,
          G = 1;
        if (k(_, I[R + z]) > 0) {
          for (j = B - z; G < j && k(_, I[R + z + G]) > 0; )
            (V = G), (G = (G << 1) + 1) <= 0 && (G = j);
          G > j && (G = j), (V += z), (G += z);
        } else {
          for (j = z + 1; G < j && 0 >= k(_, I[R + z - G]); )
            (V = G), (G = (G << 1) + 1) <= 0 && (G = j);
          G > j && (G = j);
          let B = V;
          (V = z - G), (G = z - B);
        }
        for (V++; V < G; ) {
          let B = V + ((G - V) >>> 1);
          k(_, I[R + B]) > 0 ? (V = B + 1) : (G = B);
        }
        return G;
      }
      function iE(_, I, R, B, z, k) {
        let V = 0,
          j = 0,
          G = 1;
        if (0 > k(_, I[R + z])) {
          for (j = z + 1; G < j && 0 > k(_, I[R + z - G]); )
            (V = G), (G = (G << 1) + 1) <= 0 && (G = j);
          G > j && (G = j);
          let B = V;
          (V = z - G), (G = z - B);
        } else {
          for (j = B - z; G < j && k(_, I[R + z + G]) >= 0; )
            (V = G), (G = (G << 1) + 1) <= 0 && (G = j);
          G > j && (G = j), (V += z), (G += z);
        }
        for (V++; V < G; ) {
          let B = V + ((G - V) >>> 1);
          0 > k(_, I[R + B]) ? (G = B) : (V = B + 1);
        }
        return G;
      }
      var TX = class {
        constructor(_, I) {
          Ui(this, "array", null),
            Ui(this, "compare", null),
            Ui(this, "minGallop", 7),
            Ui(this, "length", 0),
            Ui(this, "tmpStorageLength", 256),
            Ui(this, "stackLength", 0),
            Ui(this, "runStart", null),
            Ui(this, "runLength", null),
            Ui(this, "stackSize", 0),
            (this.array = _),
            (this.compare = I),
            (this.length = _.length),
            this.length < 512 && (this.tmpStorageLength = this.length >>> 1),
            (this.tmp = Array(this.tmpStorageLength)),
            (this.stackLength =
              this.length < 120
                ? 5
                : this.length < 1542
                ? 10
                : this.length < 119151
                ? 19
                : 40),
            (this.runStart = Array(this.stackLength)),
            (this.runLength = Array(this.stackLength));
        }
        pushRun(_, I) {
          (this.runStart[this.stackSize] = _),
            (this.runLength[this.stackSize] = I),
            (this.stackSize += 1);
        }
        mergeRuns() {
          for (; this.stackSize > 1; ) {
            let _ = this.stackSize - 2;
            if (
              (_ >= 1 &&
                this.runLength[_ - 1] <=
                  this.runLength[_] + this.runLength[_ + 1]) ||
              (_ >= 2 &&
                this.runLength[_ - 2] <=
                  this.runLength[_] + this.runLength[_ - 1])
            )
              this.runLength[_ - 1] < this.runLength[_ + 1] && _--;
            else if (this.runLength[_] > this.runLength[_ + 1]) break;
            this.mergeAt(_);
          }
        }
        forceMergeRuns() {
          for (; this.stackSize > 1; ) {
            let _ = this.stackSize - 2;
            _ > 0 && this.runLength[_ - 1] < this.runLength[_ + 1] && _--,
              this.mergeAt(_);
          }
        }
        mergeAt(_) {
          let I = this.compare,
            R = this.array,
            B = this.runStart[_],
            z = this.runLength[_],
            k = this.runStart[_ + 1],
            V = this.runLength[_ + 1];
          (this.runLength[_] = z + V),
            _ === this.stackSize - 3 &&
              ((this.runStart[_ + 1] = this.runStart[_ + 2]),
              (this.runLength[_ + 1] = this.runLength[_ + 2])),
            this.stackSize--;
          let j = iE(R[k], R, B, z, 0, I);
          (B += j),
            0 != (z -= j) &&
              0 !== (V = rE(R[B + z - 1], R, k, V, V - 1, I)) &&
              (z <= V ? this.mergeLow(B, z, k, V) : this.mergeHigh(B, z, k, V));
        }
        mergeLow(_, I, R, B) {
          let z = this.compare,
            k = this.array,
            V = this.tmp,
            j = 0;
          for (j = 0; j < I; j++) V[j] = k[_ + j];
          let G = 0,
            q = R,
            X = _;
          if (((k[X++] = k[q++]), 0 == --B)) {
            for (j = 0; j < I; j++) k[X + j] = V[G + j];
            return;
          }
          if (1 === I) {
            for (j = 0; j < B; j++) k[X + j] = k[q + j];
            k[X + B] = V[G];
            return;
          }
          let Q = this.minGallop;
          for (;;) {
            let _ = 0,
              R = 0,
              $ = !1;
            do
              if (0 > z(k[q], V[G])) {
                if (((k[X++] = k[q++]), R++, (_ = 0), 0 == --B)) {
                  $ = !0;
                  break;
                }
              } else if (((k[X++] = V[G++]), _++, (R = 0), 1 == --I)) {
                $ = !0;
                break;
              }
            while ((_ | R) < Q);
            if ($) break;
            do {
              if (0 !== (_ = iE(k[q], V, G, I, 0, z))) {
                for (j = 0; j < _; j++) k[X + j] = V[G + j];
                if (((X += _), (G += _), (I -= _) <= 1)) {
                  $ = !0;
                  break;
                }
              }
              if (((k[X++] = k[q++]), 0 == --B)) {
                $ = !0;
                break;
              }
              if (0 !== (R = rE(V[G], k, q, B, 0, z))) {
                for (j = 0; j < R; j++) k[X + j] = k[q + j];
                if (((X += R), (q += R), 0 == (B -= R))) {
                  $ = !0;
                  break;
                }
              }
              if (((k[X++] = V[G++]), 1 == --I)) {
                $ = !0;
                break;
              }
              Q--;
            } while (_ >= 7 || R >= 7);
            if ($) break;
            Q < 0 && (Q = 0), (Q += 2);
          }
          if (((this.minGallop = Q), Q < 1 && (this.minGallop = 1), 1 === I)) {
            for (j = 0; j < B; j++) k[X + j] = k[q + j];
            k[X + B] = V[G];
          } else {
            if (0 === I)
              throw Error("mergeLow preconditions were not respected");
            for (j = 0; j < I; j++) k[X + j] = V[G + j];
          }
        }
        mergeHigh(_, I, R, B) {
          let z = this.compare,
            k = this.array,
            V = this.tmp,
            j = 0;
          for (j = 0; j < B; j++) V[j] = k[R + j];
          let G = _ + I - 1,
            q = B - 1,
            X = R + B - 1,
            Q = 0,
            $ = 0;
          if (((k[X--] = k[G--]), 0 == --I)) {
            for (Q = X - (B - 1), j = 0; j < B; j++) k[Q + j] = V[j];
            return;
          }
          if (1 === B) {
            for (X -= I, G -= I, $ = X + 1, Q = G + 1, j = I - 1; j >= 0; j--)
              k[$ + j] = k[Q + j];
            k[X] = V[q];
            return;
          }
          let et = this.minGallop;
          for (;;) {
            let R = 0,
              er = 0,
              es = !1;
            do
              if (0 > z(V[q], k[G])) {
                if (((k[X--] = k[G--]), R++, (er = 0), 0 == --I)) {
                  es = !0;
                  break;
                }
              } else if (((k[X--] = V[q--]), er++, (R = 0), 1 == --B)) {
                es = !0;
                break;
              }
            while ((R | er) < et);
            if (es) break;
            do {
              if (0 != (R = I - iE(V[q], k, _, I, I - 1, z))) {
                for (
                  X -= R, G -= R, I -= R, $ = X + 1, Q = G + 1, j = R - 1;
                  j >= 0;
                  j--
                )
                  k[$ + j] = k[Q + j];
                if (0 === I) {
                  es = !0;
                  break;
                }
              }
              if (((k[X--] = V[q--]), 1 == --B)) {
                es = !0;
                break;
              }
              if (0 != (er = B - rE(k[G], V, 0, B, B - 1, z))) {
                for (
                  X -= er, q -= er, B -= er, $ = X + 1, Q = q + 1, j = 0;
                  j < er;
                  j++
                )
                  k[$ + j] = V[Q + j];
                if (B <= 1) {
                  es = !0;
                  break;
                }
              }
              if (((k[X--] = k[G--]), 0 == --I)) {
                es = !0;
                break;
              }
              et--;
            } while (R >= 7 || er >= 7);
            if (es) break;
            et < 0 && (et = 0), (et += 2);
          }
          if (
            ((this.minGallop = et), et < 1 && (this.minGallop = 1), 1 === B)
          ) {
            for (X -= I, G -= I, $ = X + 1, Q = G + 1, j = I - 1; j >= 0; j--)
              k[$ + j] = k[Q + j];
            k[X] = V[q];
          } else {
            if (0 === B)
              throw Error("mergeHigh preconditions were not respected");
            for (Q = X - (B - 1), j = 0; j < B; j++) k[Q + j] = V[j];
          }
        }
      };
      function sE(_) {
        let I = (0, TW.default)(new Int32Array(_.shape[0]), [_.shape[0]]),
          R = (0, TW.default)(new Int32Array(_.shape[0]), [_.shape[0]]);
        return (
          Tq.bands(I, _, 1023),
          Tq.lshifts(R, I, 16),
          Tq.bxoreq(I, R),
          Tq.bandseq(I, 4278190335),
          Tq.lshifts(R, I, 8),
          Tq.bxoreq(I, R),
          Tq.bandseq(I, 50393103),
          Tq.lshifts(R, I, 4),
          Tq.bxoreq(I, R),
          Tq.bandseq(I, 51130563),
          Tq.lshifts(R, I, 2),
          Tq.bxoreq(I, R),
          Tq.bandseq(I, 153391689),
          I
        );
      }
      function ac(_, I) {
        if (_.shape[0] !== I.shape[0]) throw Error("wrong length");
        let R = (0, TW.default)(
          new Float32Array(_.size),
          _.shape,
          _.stride,
          _.offset
        );
        for (let B = 0; B < I.shape[0]; B++) {
          let z = I.get(B);
          if (_.shape.length > 1)
            for (let I = 0; I < _.shape[1]; I++) R.set(B, I, _.get(z, I));
          else R.set(B, _.get(z));
        }
        return R;
      }
      var TQ = class {
          constructor(_, I, R, B, z, k, V, j, G, q) {
            (this.propertyDescs = _),
              (this.format = I),
              (this.nsplats = R),
              (this.xyz = B),
              (this.colors = z),
              (this.harmonics = k),
              (this.opacity = V),
              (this.scaling = j),
              (this.rotation = G),
              (this.maxSHDegree = q);
          }
          getPlyBinary() {
            let _ = TQ._generateHeaderString(
                this.propertyDescs,
                this.format,
                this.nsplats
              ),
              I = new TextEncoder().encode(_),
              R = Object.keys(this.propertyDescs).length,
              B = (0, TG.default)(new Float32Array(this.nsplats * R), [
                this.nsplats,
                R,
              ]);
            if (
              (TH.assign(
                B.pick(null, this.propertyDescs.x.index),
                this.xyz.pick(null, 0)
              ),
              TH.assign(
                B.pick(null, this.propertyDescs.y.index),
                this.xyz.pick(null, 1)
              ),
              TH.assign(
                B.pick(null, this.propertyDescs.z.index),
                this.xyz.pick(null, 2)
              ),
              TH.assign(
                B.pick(null, this.propertyDescs.f_dc_0.index),
                this.colors.pick(null, 0)
              ),
              TH.assign(
                B.pick(null, this.propertyDescs.f_dc_1.index),
                this.colors.pick(null, 1)
              ),
              TH.assign(
                B.pick(null, this.propertyDescs.f_dc_2.index),
                this.colors.pick(null, 2)
              ),
              TH.assign(
                B.pick(null, this.propertyDescs.opacity.index),
                this.opacity.pick(null, 0)
              ),
              TH.assign(
                B.pick(null, this.propertyDescs.scale_0.index),
                this.scaling.pick(null, 0)
              ),
              TH.assign(
                B.pick(null, this.propertyDescs.scale_1.index),
                this.scaling.pick(null, 1)
              ),
              TH.assign(
                B.pick(null, this.propertyDescs.scale_2.index),
                this.scaling.pick(null, 2)
              ),
              TH.assign(
                B.pick(null, this.propertyDescs.rot_0.index),
                this.rotation.pick(null, 0)
              ),
              TH.assign(
                B.pick(null, this.propertyDescs.rot_1.index),
                this.rotation.pick(null, 1)
              ),
              TH.assign(
                B.pick(null, this.propertyDescs.rot_2.index),
                this.rotation.pick(null, 2)
              ),
              TH.assign(
                B.pick(null, this.propertyDescs.rot_3.index),
                this.rotation.pick(null, 3)
              ),
              this.harmonics && this.harmonics.length > 0)
            )
              for (let _ = 0; _ < this.harmonics.length; _++) {
                let I = 3 * _;
                TH.assign(
                  B.pick(null, this.propertyDescs[`f_rest_${I}`].index),
                  this.harmonics[_].pick(null, 0)
                ),
                  TH.assign(
                    B.pick(null, this.propertyDescs[`f_rest_${I + 1}`].index),
                    this.harmonics[_].pick(null, 1)
                  ),
                  TH.assign(
                    B.pick(null, this.propertyDescs[`f_rest_${I + 2}`].index),
                    this.harmonics[_].pick(null, 2)
                  );
              }
            let z = new Uint8Array(B.data.buffer),
              k = new Uint8Array(z.length + I.length);
            return k.set(I), k.set(z, I.length), k.buffer;
          }
          save(_, I) {
            let R = this.getPlyBinary(),
              B = new Blob([R], { type: "application/octet-stream" }),
              z = new File([B], _),
              k = new FormData();
            k.append("file", z),
              k.append("filename", _),
              k.append("basedir", I),
              fetch("http://127.0.0.1:8000/push_file", {
                method: "POST",
                body: k,
              });
          }
          static async loadFile(_) {
            return await (await fetch(_)).arrayBuffer();
          }
          mortonPositionSplatsSort() {
            var _, I;
            let R, B, z, k, V, j, G;
            let q =
                ((_ = this.xyz),
                (R = 1e3 / Math.min(1e3, Tq.sup(_) - Tq.inf(_))),
                (B = (0, TW.default)(new Float32Array(_.data), _.shape)),
                Tq.mulseq(B, R),
                !(function (_, I, R, B) {
                  if (!Array.isArray(_))
                    throw TypeError("Can only sort arrays");
                  I
                    ? "function" != typeof I && ((B = R), (R = I), (I = ZL))
                    : (I = ZL),
                    R || (R = 0),
                    B || (B = _.length);
                  let z = B - R;
                  if (z < 2) return;
                  let k = 0;
                  if (z < 32) {
                    (k = JL(_, R, B, I)), $L(_, R, B, R + k, I);
                    return;
                  }
                  let V = new TX(_, I),
                    j = (function (_) {
                      let I = 0;
                      for (; _ >= 32; ) (I |= 1 & _), (_ >>= 1);
                      return _ + I;
                    })(z);
                  do {
                    if ((k = JL(_, R, B, I)) < j) {
                      let B = z;
                      B > j && (B = j), $L(_, R, R + B, R + k, I), (k = B);
                    }
                    V.pushRun(R, k), V.mergeRuns(), (z -= k), (R += k);
                  } while (0 !== z);
                  V.forceMergeRuns();
                })(
                  (j = Array.from(
                    ((z = sE(
                      (I = (0, TW.default)(
                        new Int32Array(B.data),
                        _.shape
                      )).pick(null, 0)
                    )),
                    (k = sE(I.pick(null, 1))),
                    Tq.lshiftseq(k, 1),
                    (V = sE(I.pick(null, 2))),
                    Tq.lshiftseq(V, 2),
                    Tq.boreq(z, k),
                    Tq.boreq(z, V),
                    z).data
                  ).map((_, I) => [_, I])),
                  (_, I) => _[0] - I[0]
                ),
                (G = j.map(([_, I]) => I)),
                (0, TW.default)(Uint32Array.from(G))),
              X = ac(this.xyz, q),
              Q = ac(this.colors, q),
              $ = ac(this.opacity, q),
              et = ac(this.scaling, q),
              er = ac(this.rotation, q),
              es = [];
            for (let _ = 0; _ < this.harmonics.length; _++)
              es.push(ac(this.harmonics[_], q));
            return new TQ(
              this.propertyDescs,
              this.format,
              this.nsplats,
              X,
              Q,
              es,
              $,
              et,
              er,
              this.maxSHDegree
            );
          }
          static _generateHeaderString(_, I, R) {
            let B = `ply
format ${I.format} ${I.version}
element vertex ${R}`,
              z = Array(Object.keys(_).length);
            for (let I in _) {
              let R = _[I];
              z[R.index] = { name: I, dtype: R.dtype };
            }
            for (let _ = 0; _ < z.length; _++)
              B = `${B}
property ${z[_].dtype} ${z[_].name}`;
            return `${B}
end_header
`;
          }
          static fromArrayBuffer(_, I = 3) {
            let {
                splatCount: R,
                vertexData: B,
                propertiesDesc: z,
                format: k,
              } = TQ.decodeHeader(_),
              V = B.buffer.slice(B.byteOffset),
              j = Object.keys(z).length,
              G = (0, TG.default)(new Float32Array(V), [R, j]),
              q = 0,
              X = {},
              Q = {
                double: 8,
                int: 4,
                uint: 4,
                float: 4,
                short: 2,
                ushort: 2,
                uchar: 1,
              };
            for (let _ in z)
              if (z.hasOwnProperty(_)) {
                let I = z[_].dtype;
                (X[_] = q), (q += Q[I]);
              }
            let $ = (0, TG.default)(new Float32Array(3 * R), [R, 3]);
            TH.assign($.pick(null, 0), G.pick(null, X.x / 4)),
              TH.assign($.pick(null, 1), G.pick(null, X.y / 4)),
              TH.assign($.pick(null, 2), G.pick(null, X.z / 4));
            let et = (0, TG.default)(new Float32Array(3 * R), [R, 3]);
            TH.assign(et.pick(null, 0), G.pick(null, X.scale_0 / 4)),
              TH.assign(et.pick(null, 1), G.pick(null, X.scale_1 / 4)),
              TH.assign(et.pick(null, 2), G.pick(null, X.scale_2 / 4));
            let er = (0, TG.default)(new Float32Array(3 * R), [R, 3]);
            TH.assign(er.pick(null, 0), G.pick(null, X.f_dc_0 / 4)),
              TH.assign(er.pick(null, 1), G.pick(null, X.f_dc_1 / 4)),
              TH.assign(er.pick(null, 2), G.pick(null, X.f_dc_2 / 4));
            let es = (0, TG.default)(new Float32Array(4 * R), [R, 4]);
            TH.assign(es.pick(null, 0), G.pick(null, X.rot_1 / 4)),
              TH.assign(es.pick(null, 1), G.pick(null, X.rot_2 / 4)),
              TH.assign(es.pick(null, 2), G.pick(null, X.rot_3 / 4)),
              TH.assign(es.pick(null, 3), G.pick(null, X.rot_0 / 4));
            for (let _ = 0; _ < R; _++) {
              let I = es.pick(_, null),
                R = Math.sqrt(
                  I.get(0) ** 2 + I.get(1) ** 2 + I.get(2) ** 2 + I.get(3) ** 2
                );
              TH.divseq(I, R);
            }
            let ea = (0, TG.default)(new Float32Array(1 * R), [R, 1]);
            TH.assign(ea.pick(null, 0), G.pick(null, X.opacity / 4));
            let en = (Math.min(Math.max(I, 0), 3) + 1) ** 2 - 1,
              eo = [];
            for (let _ = 0; _ < en; _++) {
              let I = (0, TG.default)(new Float32Array(3 * R), [R, 3]),
                B = 3 * _;
              TH.assign(I.pick(null, 0), G.pick(null, X[`f_rest_${B}`] / 4)),
                TH.assign(
                  I.pick(null, 1),
                  G.pick(null, X[`f_rest_${B + 1}`] / 4)
                ),
                TH.assign(
                  I.pick(null, 2),
                  G.pick(null, X[`f_rest_${B + 2}`] / 4)
                ),
                eo.push(I);
            }
            return new TQ(z, k, R, $, er, eo, ea, et, es, I);
          }
          static async fromPLYFile(_, I = 3) {
            let R = await TQ.loadFile(_);
            return TQ.fromArrayBuffer(R, I);
          }
          static decodeHeader(_) {
            let I = new TextDecoder(),
              R = 0,
              B = "";
            for (;;) {
              if (R + 100 >= _.byteLength)
                throw Error(
                  "End of file reached while searching for end of header"
                );
              let z = new Uint8Array(_, R, 100);
              B += I.decode(z);
              let k = (R += 100) - 200,
                V = new Uint8Array(_, Math.max(0, k), k > 0 ? 200 : 100);
              if (I.decode(V).includes("end_header")) break;
            }
            let z = B.split(`
`),
              k = 0,
              V = {},
              j = {},
              G = 0,
              q;
            for (let _ = 0; _ < z.length; _++) {
              let I = z[_].trim();
              if (I.startsWith("element vertex")) {
                let _ = I.match(/\d+/);
                _ && (k = parseInt(_[0]));
              } else if (I.startsWith("property")) {
                let _ = I.match(/(\w+)\s+(\w+)\s+(\w+)/);
                if (_) {
                  let I = _[2],
                    R = _[3];
                  (V[R] = G), (j[R] = { dtype: I, index: G }), G++;
                }
              } else if (I.startsWith("format")) {
                let _ = I.match(/(\w+)\s+(\w+)\s+(\d+\.?\d*)/);
                _ && (q = { format: _[2], version: _[3] });
              } else if ("end_header" === I) break;
            }
            let X = B.indexOf("end_header") + 10 + 1;
            return {
              splatCount: k,
              vertexData: new DataView(_, X),
              headerOffset: R,
              propertiesDesc: j,
              format: q,
            };
          }
        },
        TZ = class {
          constructor(_, I, R, B, z, k, V, j) {
            (this.config = _),
              (this.xyz = I),
              (this.scaling = R),
              (this.color = B),
              (this.opacity = z),
              (this.harmonics = V),
              (this.quaternion = k),
              (this.variableChunkSize = j);
          }
          get isDynamicChunks() {
            return this.variableChunkSize && this.variableChunkSize.length > 0;
          }
          get nchunks() {
            return this.xyz.nchunks;
          }
          get nsplats() {
            return this.xyz.length;
          }
          get chunkSize() {
            return this.config.chunkSize;
          }
          static compressFromGaussianData(_, I) {
            let R = Tj.fromArray(_.xyz, I.xyz, I.chunkSize),
              B = Tj.fromArray(_.scaling, I.scaling, I.chunkSize),
              z = Tj.fromArray(_.colors, I.color, I.chunkSize),
              k = Tj.fromArray(_.opacity, I.opacity, I.chunkSize),
              V = Tj.fromArray(_.rotation, I.quaternion, I.chunkSize),
              j = _.harmonics,
              G = [];
            if (I.harmonics)
              for (let _ = 0; _ < j.length; _++) {
                let R = Tj.fromArray(j[_], I.harmonics, I.chunkSize);
                G.push(R);
              }
            return new TZ(I, R, B, z, k, V, G);
          }
          _countIndexesInChunks(_) {
            let I = [],
              R = this.nchunks,
              B = this.chunkSize,
              z = this.nsplats;
            if (R === Tj.getRequiredNChunks(z, B))
              for (let R = 0; R < _.length; R++) {
                let B = _[R],
                  z = Math.floor(B / this.chunkSize);
                z in I ? I[z].push(B) : (I[z] = [B]);
              }
            else {
              let z = this.variableChunkSize,
                k = {},
                V = 0;
              for (let _ = 0; _ < R; _++) (k[_] = V), (V += z[_]);
              for (let V = 0; V < _.length; V++) {
                let j = _[V],
                  G = Math.min(Math.floor(j / B), R - 1);
                for (; j >= k[G] + z[G]; ) G++;
                G in I ? I[G].push(j) : (I[G] = [j]);
              }
            }
            return I;
          }
          pruneSplats(_) {
            let I = this._countIndexesInChunks(_),
              R,
              B = [];
            return (
              I.length > 0 &&
                ((R = this.variableChunkSize
                  ? [...this.variableChunkSize]
                  : Array(this.nchunks).fill(this.chunkSize)),
                I.forEach((_, I) => {
                  (R[I] -= _.length), R[I] <= 0 && B.push(I);
                }),
                (R = R.filter((_) => _ > 0))),
              new TZ(
                this.config,
                this.xyz.pruneFeature(_, B, R),
                this.scaling.pruneFeature(_, B, R),
                this.color.pruneFeature(_, B, R),
                this.opacity.pruneFeature(_, B, R),
                this.quaternion.pruneFeature(_, B, R),
                this.harmonics
                  ? this.harmonics.map((I) =>
                      I.pruneFeature(_, B, this.variableChunkSize)
                    )
                  : void 0,
                R
              )
            );
          }
          static async loadConfig(_) {
            return await (
              await fetch(_, {
                method: "GET",
                mode: "cors",
                headers: { Accept: "application/json" },
              })
            ).json();
          }
          toGaussians() {
            let _ = {},
              I = 0;
            if (
              ((_.x = { dtype: "float", index: I }),
              I++,
              (_.y = { dtype: "float", index: I }),
              I++,
              (_.z = { dtype: "float", index: I }),
              I++,
              (_.f_dc_0 = { dtype: "float", index: I }),
              I++,
              (_.f_dc_1 = { dtype: "float", index: I }),
              I++,
              (_.f_dc_2 = { dtype: "float", index: I }),
              I++,
              this.harmonics && this.harmonics.length > 0)
            )
              for (let R = 0; R < this.harmonics.length; R++)
                (_[`f_rest_${R}`] = { dtype: "float", index: I }),
                  I++,
                  (_[`f_rest_${R + 1}`] = { dtype: "float", index: I }),
                  I++,
                  (_[`f_rest_${R + 2}`] = { dtype: "float", index: I }),
                  I++;
            (_.opacity = { dtype: "float", index: I }),
              I++,
              (_.scale_0 = { dtype: "float", index: I }),
              I++,
              (_.scale_1 = { dtype: "float", index: I }),
              I++,
              (_.scale_2 = { dtype: "float", index: I }),
              I++,
              (_.rot_0 = { dtype: "float", index: I }),
              I++,
              (_.rot_1 = { dtype: "float", index: I }),
              I++,
              (_.rot_2 = { dtype: "float", index: I }),
              I++,
              (_.rot_3 = { dtype: "float", index: I }),
              I++;
            let R = this.harmonics?.map((_) => _.denormDequant());
            return new TQ(
              _,
              { format: "binary_little_endian", version: "1.0" },
              this.xyz.length,
              this.xyz.denormDequant(),
              this.color.denormDequant(),
              R || [],
              this.opacity.denormDequant(),
              this.scaling.denormDequant(),
              this.quaternion.denormDequant(),
              3
            );
          }
        },
        TK = pi(iZ()),
        TJ = pi(i1()),
        T$ = {
          xyz: 3,
          color: 3,
          opacity: 1,
          scaling: 3,
          quaternion: 4,
          harmonics: 3,
        },
        T1 = class {
          constructor(_) {
            this._buffer = _;
          }
          get buffer() {
            return this._buffer;
          }
          get decoded() {
            return (
              this._decoded || (this._decoded = this.decodeBuffer()),
              this._decoded
            );
          }
          get colorsA() {
            let _ = this.decoded.color.denormDequant(),
              I = this.decoded.opacity.denormDequant(),
              R = (0, TK.default)(new Float32Array(4 * _.shape[0]), [
                _.shape[0],
                4,
              ]);
            return (
              TJ.mulseq(_, 0.28209479177387814),
              TJ.addseq(_, 0.5),
              TJ.mulseq(_, 255),
              TJ.maxseq(_, 0),
              TJ.minseq(_, 255),
              TJ.negeq(I),
              TJ.expeq(I),
              TJ.addseq(I, 1),
              TJ.recipeq(I),
              TJ.mulseq(I, 255),
              TJ.assign(R.hi(_.shape[0], 3).lo(0, 0), _),
              TJ.assign(R.hi(_.shape[0], 4).lo(0, 3), I),
              (0, TK.default)(new Uint8Array(R.data), [_.shape[0], 4]).data
            );
          }
          get nsplats() {
            return this.decoded.nsplats;
          }
          getSplatCount() {
            return this.decoded.nsplats;
          }
          get precomputedCovarianceBufferData() {
            return this._precomputedCovarianceBufferData;
          }
          decodeBuffer() {
            let {
                splatCount: _,
                chunkCount: I,
                chunkSize: R,
                typeChunks: B,
                vertexData: z,
                propertiesDesc: k,
              } = this.decodeHeader(),
              V = {
                xyz: k.xyz.compressionMethod,
                color: k.color.compressionMethod,
                opacity: k.opacity.compressionMethod,
                scaling: k.scaling.compressionMethod,
                quaternion: k.quaternion.compressionMethod,
                chunkSize: R,
              };
            k.harmonics_0 && (V.harmonics = k.harmonics_0.compressionMethod);
            let j = z.byteOffset,
              G = Array(Object.keys(k).length);
            for (let _ in k)
              G[k[_].index] = { name: _, method: k[_].compressionMethod };
            let q = 8 * I,
              X = j,
              Q = "dynamic" === B ? 2 * I : 0,
              $,
              et = !1;
            if (Q > 0) {
              let _ = new Uint16Array(z.buffer.slice(X, X + Q));
              (X += Q), ($ = Array.from(_)), (et = !0);
            }
            let er = {};
            for (let B of G) {
              let k,
                V,
                j = 0,
                G = !0;
              if ("norm8x" === B.method) j = 1 * _ * T$[B.name];
              else if ("norm11" === B.method) j = 4 * _;
              else if ("norm565" === B.method) j = 2 * _;
              else
                throw ((G = !1), Error(`Not Implemented format: ${B.method}`));
              if (G) {
                let _ = z.buffer.slice(X, X + q);
                (k = (0, TK.default)(new Float32Array(_), [I, 2])), (X += q);
              } else throw Error("loading chunk byt hasnot minmax!");
              let Q = z.buffer.slice(X, X + j);
              if (((X += j), "norm8x" === B.method))
                V = (0, TK.default)(new Uint8Array(Q), [_, T$[B.name]]);
              else if ("norm11" === B.method)
                V = (0, TK.default)(new Uint32Array(Q));
              else if ("norm565" === B.method)
                V = (0, TK.default)(new Uint16Array(Q));
              else throw Error(`Not Implemented format: ${B.method}`);
              er[B.name] = new Tj(V, k, R, B.method, $, et);
            }
            let es = [];
            for (let _ = 0; _ < 15; _++) {
              let I = er[`harmonics_${_}`];
              I && (es.push(I), delete er[`harmonics_${_}`]);
            }
            return (
              es.length > 0 && (er.harmonics = es),
              new TZ(
                V,
                er.xyz,
                er.scaling,
                er.color,
                er.opacity,
                er.quaternion,
                er.harmonics,
                $
              )
            );
          }
          buildPreComputedBuffers() {
            let _ = this.decoded,
              I = _.nsplats,
              R = new ArrayBuffer(24 * I),
              B = new Float32Array(R),
              z = _.scaling.denormDequant(),
              k = _.quaternion.denormDequant(),
              V = new rz(),
              j = new ro(),
              G = new ro(),
              q = new ro(),
              X = new sa();
            for (let _ = 0; _ < I; _++) {
              X.makeScale(
                Math.exp(z.get(_, 0)),
                Math.exp(z.get(_, 1)),
                Math.exp(z.get(_, 2))
              ),
                G.setFromMatrix4(X),
                V.set(k.get(_, 0), k.get(_, 1), k.get(_, 2), k.get(_, 3)),
                X.makeRotationFromQuaternion(V),
                j.setFromMatrix4(X),
                q.copy(j).multiply(G);
              let I = q.elements;
              (B[6 * _] = I[0] * I[0] + I[3] * I[3] + I[6] * I[6]),
                (B[6 * _ + 1] = I[0] * I[1] + I[3] * I[4] + I[6] * I[7]),
                (B[6 * _ + 2] = I[0] * I[2] + I[3] * I[5] + I[6] * I[8]),
                (B[6 * _ + 3] = I[1] * I[1] + I[4] * I[4] + I[7] * I[7]),
                (B[6 * _ + 4] = I[1] * I[2] + I[4] * I[5] + I[7] * I[8]),
                (B[6 * _ + 5] = I[2] * I[2] + I[5] * I[5] + I[8] * I[8]);
            }
            this._precomputedCovarianceBufferData = R;
          }
          decodeHeader() {
            let _ = this._buffer,
              I = new TextDecoder(),
              R = 0,
              B = "";
            for (;;) {
              if (R + 100 >= _.byteLength)
                throw Error(
                  "End of file reached while searching for end of header"
                );
              let z = new Uint8Array(_, R, 100);
              B += I.decode(z);
              let k = (R += 100) - 200,
                V = new Uint8Array(_, Math.max(0, k), k >= 0 ? 200 : 100);
              if (I.decode(V).includes("end_header")) break;
            }
            let z = B.split(`
`),
              k = 0,
              V = 0,
              j = 0,
              G = 0,
              q = "",
              X = {};
            for (let _ = 0; _ < z.length; _++) {
              let I = z[_].trim();
              if (I.startsWith("element vertex")) {
                let _ = I.match(/\d+/);
                _ && (k = parseInt(_[0]));
              } else if (I.startsWith("property")) {
                let _ = I.match(/(\w+)\s+(\w+)\s+(\w+)/);
                if (_) {
                  let I = _[2],
                    R = _[3];
                  (X[I] = { compressionMethod: R, index: G }), G++;
                }
              } else if (I.startsWith("element chunks")) {
                let _ = I.match(/\d+/);
                _ && (V = parseInt(_[0]));
              } else if (I.startsWith("element chunkSize")) {
                let _ = I.match(/\d+/);
                _ && (j = parseInt(_[0]));
              } else if (I.startsWith("element typeChunks")) {
                let _ = I.match(/(\w+)\s+(\w+)\s+(\w+)/);
                _ && (q = _[3]);
              } else if ("end_header" === I) break;
            }
            let Q = B.indexOf("end_header") + 10 + 1;
            return {
              splatCount: k,
              chunkCount: V,
              chunkSize: j,
              typeChunks: q,
              vertexData: new DataView(_, Q),
              propertiesDesc: X,
            };
          }
          pruneSplats(_) {
            let I = this.decodeBuffer().pruneSplats(_);
            return T1.fromCompressedGaussianSplats(I);
          }
          static fromCompressedGaussianSplats(_) {
            let I = _.xyz.length,
              R = _.xyz.nchunks,
              B = `gspline
element vertex ${I}
element chunks ${R}
element chunkSize ${_.chunkSize}
element typeChunks ${_.isDynamicChunks ? "dynamic" : "static"}
property xyz ${_.xyz.method}
property color ${_.color.method}
property opacity ${_.opacity.method}
property scaling ${_.scaling.method}
property quaternion ${_.quaternion.method}`;
            if (_.harmonics && _.harmonics.length > 0)
              for (let I = 0; I < _.harmonics.length; I++)
                B = `${B}
property harmonics_${I} ${_.harmonics[I].method}`;
            B = `${B}
end_header
`;
            let z = new TextEncoder().encode(B),
              k = 8 * R,
              V = _.xyz.quantized.data.buffer.byteLength,
              j = _.xyz instanceof Tj ? k : 0,
              G = _.color.quantized.data.buffer.byteLength,
              q = _.color instanceof Tj ? k : 0,
              X = _.opacity.quantized.data.buffer.byteLength,
              Q = _.opacity instanceof Tj ? k : 0,
              $ = _.scaling.quantized.data.buffer.byteLength,
              et = _.scaling instanceof Tj ? k : 0,
              er = _.quaternion.quantized.data.buffer.byteLength,
              es = _.quaternion instanceof Tj ? k : 0,
              ea = _.variableChunkSize
                ? Uint16Array.from(_.variableChunkSize)
                : void 0,
              en = ea ? ea.byteLength : 0,
              eo = z.byteLength + en + V + j + G + q + X + Q + $ + et + er + es,
              el = 0,
              eh = 0;
            if (_.harmonics && _.harmonics.length > 0)
              for (let I = 0; I < _.harmonics.length; I++)
                (el += _.harmonics[I].quantized.data.buffer.byteLength),
                  _.harmonics[I];
            eo += (el = 0) + 0;
            let ec = new Uint8Array(eo),
              ed = 0;
            if (
              (ec.set(z, ed),
              (ed += z.byteLength),
              en > 0 && (ec.set(new Uint8Array(ea.buffer), ed), (ed += en)),
              _.xyz instanceof Tj &&
                (ec.set(new Uint8Array(_.xyz.minmaxMatrix.data.buffer), ed),
                (ed += k)),
              ec.set(new Uint8Array(_.xyz.quantized.data.buffer), ed),
              (ed += V),
              _.color instanceof Tj &&
                (ec.set(new Uint8Array(_.color.minmaxMatrix.data.buffer), ed),
                (ed += k)),
              ec.set(new Uint8Array(_.color.quantized.data.buffer), ed),
              (ed += G),
              _.opacity instanceof Tj &&
                (ec.set(new Uint8Array(_.opacity.minmaxMatrix.data.buffer), ed),
                (ed += k)),
              ec.set(new Uint8Array(_.opacity.quantized.data.buffer), ed),
              (ed += X),
              _.scaling instanceof Tj &&
                (ec.set(new Uint8Array(_.scaling.minmaxMatrix.data.buffer), ed),
                (ed += k)),
              ec.set(new Uint8Array(_.scaling.quantized.data.buffer), ed),
              (ed += $),
              _.quaternion instanceof Tj &&
                (ec.set(
                  new Uint8Array(_.quaternion.minmaxMatrix.data.buffer),
                  ed
                ),
                (ed += k)),
              ec.set(new Uint8Array(_.quaternion.quantized.data.buffer), ed),
              (ed += er),
              el > 0 && _.harmonics && _.harmonics.length > 0)
            )
              for (let I = 0; I < _.harmonics.length; I++) {
                let R = _.harmonics[I];
                R instanceof Tj &&
                  (ec.set(new Uint8Array(R.minmaxMatrix.data.buffer), ed),
                  (ed += k)),
                  ec.set(new Uint8Array(R.quantized.data.buffer), ed),
                  (ed += R.quantized.data.byteLength);
              }
            return new T1(ec.buffer);
          }
        },
        T2 = class {};
      function VK(_) {
        let I, R, B, z, k, V, j, G, q, X, Q, $, et, er, es, ea;
        function v(_, I, V) {
          let j = new Float32Array(X, k, 3 * R);
          B = 0;
          let G = new Uint32Array(X, z, R);
          for (let R = 0; R < V.length - 1; R++) {
            let z = I[R],
              k = _[R].elements,
              q = z
                .filter((_) => _.enabled && "Include" === _.mode)
                .map((_) => ("Box" === _.type ? A(_) : T(_))),
              X = z
                .filter((_) => _.enabled && "Exclude" === _.mode)
                .map((_) => ("Box" === _.type ? A(_) : T(_)));
            for (let _ = V[R]; _ < V[R + 1]; _++) {
              let I = et[3 * _],
                R = et[3 * _ + 1],
                z = et[3 * _ + 2];
              if (
                (0 === q.length || S(I, R, z, q)) &&
                (0 === X.length || !S(I, R, z, X))
              ) {
                let V = 1 / (k[3] * I + k[7] * R + k[11] * z + k[15]);
                (j[3 * B] = (k[0] * I + k[4] * R + k[8] * z + k[12]) * V),
                  (j[3 * B + 1] = (k[1] * I + k[5] * R + k[9] * z + k[13]) * V),
                  (j[3 * B + 2] =
                    (k[2] * I + k[6] * R + k[10] * z + k[14]) * V),
                  (G[B] = _),
                  B++;
              }
            }
          }
        }
        function S(_, I, R, B, z) {
          return B["Intersect" === z ? "every" : "some"]((B) => {
            var z, k, V, j, G, q, X, Q;
            let $, et, er, es, ea, en, eo;
            let el =
              ((z = B.invRotationMatrix),
              ($ = _ - (k = B.cropCenter)[0]),
              (et = I - k[1]),
              (er = R - k[2]),
              (es = 1 / (z[3] * $ + z[7] * et + z[11] * er + z[15])),
              {
                x: (z[0] * $ + z[4] * et + z[8] * er + z[12]) * es + k[0],
                y: (z[1] * $ + z[5] * et + z[9] * er + z[13]) * es + k[1],
                z: (z[2] * $ + z[6] * et + z[10] * er + z[14]) * es + k[2],
              });
            return Array.isArray(B)
              ? ((V = el.x),
                (j = el.y),
                (G = el.z),
                V >= B[0] &&
                  V <= B[3] &&
                  j >= B[1] &&
                  j <= B[4] &&
                  G >= B[2] &&
                  G <= B[5])
              : ((q = el.x),
                (X = el.y),
                (Q = el.z),
                (ea = (q - B.cropCenter[0]) * B.invRadiusX),
                ea * ea +
                  (en = (X - B.cropCenter[1]) * B.invRadiusY) * en +
                  (eo = (Q - B.cropCenter[2]) * B.invRadiusZ) * eo <=
                  1);
          });
        }
        function A(_) {
          let I = _.cropSize[0] / 2,
            R = _.cropSize[1] / 2,
            B = _.cropSize[2] / 2;
          return Object.assign(
            [
              _.cropCenter[0] - I,
              _.cropCenter[1] - R,
              _.cropCenter[2] - B,
              _.cropCenter[0] + I,
              _.cropCenter[1] + R,
              _.cropCenter[2] + B,
            ],
            { invRotationMatrix: E(_.cropRotation), cropCenter: _.cropCenter }
          );
        }
        function E(_) {
          let I = [],
            R = (_[0] * Math.PI) / 180,
            B = (_[1] * Math.PI) / 180,
            z = (_[2] * Math.PI) / 180,
            k = Math.cos(R),
            V = Math.sin(R),
            j = Math.cos(B),
            G = Math.sin(B),
            q = Math.cos(z),
            X = Math.sin(z),
            Q = k * q,
            $ = k * X,
            et = V * q,
            er = V * X;
          return (
            (I[0] = j * q),
            (I[1] = -j * X),
            (I[2] = G),
            (I[4] = $ + et * G),
            (I[5] = Q - er * G),
            (I[6] = -V * j),
            (I[8] = er - Q * G),
            (I[9] = et + $ * G),
            (I[10] = k * j),
            (I[12] = 0),
            (I[13] = 0),
            (I[14] = 0),
            (I[3] = 0),
            (I[7] = 0),
            (I[11] = 0),
            (I[15] = 1),
            I
          );
        }
        function T(_) {
          let I = 2 / _.cropSize[0],
            R = 2 / _.cropSize[1],
            B = 2 / _.cropSize[2],
            z = E(_.cropRotation);
          return {
            invRadiusX: I,
            invRadiusY: R,
            invRadiusZ: B,
            cropCenter: _.cropCenter,
            invRotationMatrix: z,
          };
        }
        _.onmessage = (en) => {
          if (en.data.getCroppedIndexes) {
            let I = new Uint32Array(
              (function (_, I) {
                let R = [],
                  B = I.filter((_) => _.enabled && "Include" === _.mode).map(
                    (_) => ("Box" === _.type ? A(_) : T(_))
                  ),
                  z = I.filter((_) => _.enabled && "Exclude" === _.mode).map(
                    (_) => ("Box" === _.type ? A(_) : T(_))
                  ),
                  k = _.length;
                for (let I = 0; I < k; I += 3) {
                  let k = _[I],
                    V = _[I + 1],
                    j = _[I + 2];
                  ((0 === B.length || S(k, V, j, B)) &&
                    (0 === z.length || !S(k, V, j, z))) ||
                    R.push(I / 3);
                }
                return console.log(R), R;
              })(new Float32Array(en.data.positions), en.data.crops)
            ).buffer;
            _.postMessage({ outOfBoundsIndexes: I }, [I]);
          } else if (en.data.positions)
            (Q = en.data.positions),
              (et = new Float32Array(Q)),
              (es = en.data.meshMatrixWorlds),
              (ea = en.data.cropsArray),
              (er = en.data.meshIndexIntervals),
              v(es, ea, er),
              _.postMessage({ sortSetupComplete: !0 });
          else if (
            en.data.sort ||
            en.data.newMatrixWorlds ||
            en.data.newCropsArray
          )
            (en.data.newMatrixWorlds || en.data.newCropsArray) &&
              ((ea = en.data.newCropsArray || ea),
              v((es = en.data.newMatrixWorlds || es), ea, er)),
              (function (Q) {
                let et,
                  er = new Float64Array(X, V, 16);
                for (let _ = 0; _ < 16; _++) er[_] = Q[_];
                if (B > 1) {
                  I.exports.sortIndexes(z, k, q, V, j, G, $.DepthMapRange, B);
                  let _ = new Uint32Array(B);
                  (et = _.buffer), _.set(new Uint32Array(X, G, B));
                } else if (1 === B) {
                  let _ = new Uint32Array(B);
                  (_[0] = new Uint32Array(X, z, R)[0]), (et = _.buffer);
                } else et = new ArrayBuffer(0);
                _.postMessage({ sortDone: !0, indexesBuffer: et }, [et]);
              })(en.data.sort.view, en.data.sort.cameraPosition);
          else if (en.data.init) {
            ($ = en.data.init.Constants), (R = en.data.init.splatCount);
            let B = $.BytesPerInt,
              Q = 3 * $.BytesPerFloat,
              et = new Uint8Array(en.data.init.sorterWasmBytes),
              er =
                Math.floor(
                  (R * (B + Q) +
                    (R * $.BytesPerInt * 2 +
                      $.DepthMapRange * $.BytesPerInt * 2) +
                    32 * $.MemoryPageSize) /
                    $.MemoryPageSize
                ) + 1,
              es = {
                module: {},
                env: {
                  memory: new WebAssembly.Memory({
                    initial: 2 * er,
                    maximum: 3 * er,
                    shared: !0,
                  }),
                },
              };
            WebAssembly.compile(et)
              .then((_) => WebAssembly.instantiate(_, es))
              .then((et) => {
                (I = et),
                  (z = 0),
                  (G =
                    (j =
                      (q =
                        (V = (k = R * B) + R * Q) + 16 * $.BytesPerFloat * 2) +
                      R * $.BytesPerInt) +
                    $.DepthMapRange * $.BytesPerInt),
                  (X = es.env.memory.buffer),
                  _.postMessage({ sortSetupPhase1Complete: !0 });
              });
          }
        };
      }
      Ui(T2, "DepthMapRange", 65536),
        Ui(T2, "MemoryPageSize", 65536),
        Ui(T2, "BytesPerFloat", 4),
        Ui(T2, "BytesPerInt", 4);
      var T3 =
          ((id = new Float32Array(1)),
          (iu = new Int32Array(id.buffer)),
          function (_) {
            return (id[0] = _), iu[0];
          }),
        T4 = new rs(),
        T5 = class extends aw {
          constructor(_, I, R, B, z = !1, k = 1, V, j) {
            super(R, B),
              (this.splatCount = I),
              (this.meshIndexIntervals = V),
              (this.meshMatrixWorlds = j),
              (this.splatBuffers = _),
              (this.geometry = R),
              (this.material = B),
              (this.splatDataTextures = null),
              (this.halfPrecisionCovariancesOnGPU = z),
              (this.devicePixelRatio = k),
              this.resetLocalSplatDataAndTexturesFromSplatBuffer();
          }
          static buildMesh(_, I, R = !1, B = 1, z, k) {
            let V = T5.buildGeomtery(I),
              j = T5.buildMaterial(z);
            return new T5(_, I, V, j, R, B, z, k);
          }
          static buildMaterial(_) {
            let I = `
            precision highp float;
            #include <common>

            attribute uint splatIndex;

            uniform highp sampler2D covariancesTexture;
            uniform highp usampler2D centersColorsTexture;
            uniform vec2 focal;
            uniform vec2 viewport;
            uniform vec2 basisViewport;
            uniform vec2 covariancesTextureSize;
            uniform vec2 centersColorsTextureSize;
						uniform highp sampler2D meshMatrixWorldsTexture;
						uniform uint meshIndexIntervals[257];
						uniform float orthoZoom;

            varying vec4 vColor;
            varying vec2 vUv;

            varying vec2 vPosition;

            const vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);
            const uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));
            const uvec4 shift4 = uvec4(0, 8, 16, 24);
            vec4 uintToRGBAVec (uint u) {
               uvec4 urgba = mask4 & u;
               urgba = urgba >> shift4;
               vec4 rgba = vec4(urgba) * encodeNorm4;
               return rgba;
            }

            vec2 getDataUV(in int stride, in int offset, in vec2 dimensions) {
                vec2 samplerUV = vec2(0.0, 0.0);
                float d = float(splatIndex * uint(stride) + uint(offset)) / dimensions.x;
                samplerUV.y = float(floor(d)) / dimensions.y;
                samplerUV.x = fract(d);
                return samplerUV;
            }

            void main () {
                uvec4 sampledCenterColor = texture(centersColorsTexture, getDataUV(1, 0, centersColorsTextureSize));
                vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));
                vColor = uintToRGBAVec(sampledCenterColor.r);

                vPosition = position.xy * 2.0;

								uint meshIndex;
								for (int i = 1; i < 257; i++) {
									if (splatIndex < meshIndexIntervals[i]) {
										meshIndex = uint(i - 1);
										break;
									}
								}

								float strideMulmeshIndex = float(4u*meshIndex);
								float meshMatrixWorldsTextureLength = float(256*4);

								mat4 modelMat = mat4(
									texture(meshMatrixWorldsTexture, vec2((strideMulmeshIndex+0.0)/meshMatrixWorldsTextureLength, 0)),
									texture(meshMatrixWorldsTexture, vec2((strideMulmeshIndex+1.0)/meshMatrixWorldsTextureLength, 0)),
									texture(meshMatrixWorldsTexture, vec2((strideMulmeshIndex+2.0)/meshMatrixWorldsTextureLength, 0)),
									texture(meshMatrixWorldsTexture, vec2((strideMulmeshIndex+3.0)/meshMatrixWorldsTextureLength, 0))
								);
								mat4 modelViewMat = viewMatrix * modelMat;
								vec4 viewCenter = modelViewMat * vec4(splatCenter, 1.0); 
                vec4 clipCenter = projectionMatrix * viewCenter;

                vec2 sampledCovarianceA = texture(covariancesTexture, getDataUV(3, 0, covariancesTextureSize)).rg;
                vec2 sampledCovarianceB = texture(covariancesTexture, getDataUV(3, 1, covariancesTextureSize)).rg;
                vec2 sampledCovarianceC = texture(covariancesTexture, getDataUV(3, 2, covariancesTextureSize)).rg;

                vec3 cov3D_M11_M12_M13 = vec3(sampledCovarianceA.rg, sampledCovarianceB.r);
                vec3 cov3D_M22_M23_M33 = vec3(sampledCovarianceB.g, sampledCovarianceC.rg);

                // Compute the 2D covariance matrix from the upper-right portion of the 3D covariance matrix
                mat3 Vrk = mat3(
                    cov3D_M11_M12_M13.x, cov3D_M11_M12_M13.y, cov3D_M11_M12_M13.z,
                    cov3D_M11_M12_M13.y, cov3D_M22_M23_M33.x, cov3D_M22_M23_M33.y,
                    cov3D_M11_M12_M13.z, cov3D_M22_M23_M33.y, cov3D_M22_M23_M33.z
                );
                float s = 1.0 / (viewCenter.z * viewCenter.z);

                mat3 W = transpose(mat3(modelViewMat));
                mat3 T = orthoZoom > 0.0 ? W : W * mat3(
									focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,
									0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,
									0., 0., 0.
								);
                mat3 cov2Dm = transpose(T) * Vrk * T;
                cov2Dm[0][0] += 0.3;
                cov2Dm[1][1] += 0.3;

                // We are interested in the upper-left 2x2 portion of the projected 3D covariance matrix because
                // we only care about the X and Y values. We want the X-diagonal, cov2Dm[0][0],
                // the Y-diagonal, cov2Dm[1][1], and the correlation between the two cov2Dm[0][1]. We don't
                // need cov2Dm[1][0] because it is a symetric matrix.
                vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);

                vec3 ndcCenter = clipCenter.xyz / clipCenter.w;

                // We now need to solve for the eigen-values and eigen vectors of the 2D covariance matrix
                // so that we can determine the 2D basis for the splat. This is done using the method described
                // here: https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
                //
                // This is a different approach than in the original work at INRIA. In that work they compute the
                // max extents of the 2D covariance matrix in screen space to form an axis aligned bounding rectangle
                // which forms the geometry that is actually rasterized. They then use the inverse 2D covariance
                // matrix (called 'conic') to determine fragment opacity.
                float a = cov2Dv.x;
                float d = cov2Dv.z;
                float b = cov2Dv.y;
                float D = a * d - b * b;
                float trace = a + d;
                float traceOver2 = 0.5 * trace;
                float term2 = sqrt(trace * trace / 4.0 - D);
                float eigenValue1 = traceOver2 + term2;
								float eigenValue2 = max(traceOver2 - term2, 0.00); // prevent negative eigen value

                const float maxSplatSize = 1024.0;
                vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));
                // since the eigen vectors are orthogonal, we derive the second one from the first
                vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);
                vec2 basisVector1 = eigenVector1 * min(sqrt(2.0 * eigenValue1), maxSplatSize);
                vec2 basisVector2 = eigenVector2 * min(sqrt(2.0 * eigenValue2), maxSplatSize);

                vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) * basisViewport;

								if (orthoZoom > 0.0) {
									ndcOffset *= orthoZoom;
								}

                gl_Position = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);
            }`,
              R = `
            precision highp float;
            #include <common>

            uniform vec3 debugColor;

            varying vec4 vColor;
            varying vec2 vUv;

            varying vec2 vPosition;
						layout(location = 1) out vec4 gVelocity; 

            void main () {
                // compute the negative squared distance from the center of the splat to the
                // current fragment in the splat's local space.
                float A = -dot(vPosition, vPosition);
                if (A < -4.0) discard;
                vec3 color = vColor.rgb;
                A = exp(A) * vColor.a;
                gl_FragColor = vec4(color.rgb, A);
								gVelocity = vec4(0.0); // so it is ignored by TAA
            }`,
              B = {
                covariancesTexture: { type: "t", value: null },
                centersColorsTexture: { type: "t", value: null },
                meshIndexIntervals: { value: _ },
                meshMatrixWorldsTexture: { type: "t", value: null },
                focal: { type: "v2", value: new rs() },
                viewport: { type: "v2", value: new rs() },
                basisViewport: { type: "v2", value: new rs() },
                debugColor: { type: "v3", value: new ry() },
                covariancesTextureSize: {
                  type: "v2",
                  value: new rs(1024, 1024),
                },
                centersColorsTextureSize: {
                  type: "v2",
                  value: new rs(1024, 1024),
                },
                orthoZoom: { type: "f", value: -1 },
              };
            return new aT({
              uniforms: B,
              vertexShader: I,
              fragmentShader: R,
              transparent: !0,
              alphaTest: 1,
              blending: 1,
              depthTest: !0,
              depthWrite: !1,
              side: 2,
            });
          }
          static buildGeomtery(_) {
            let I = new ai();
            I.setIndex([0, 1, 2, 0, 2, 3]);
            let R = new Float32Array(12),
              B = new s0(R, 3);
            I.setAttribute("position", B),
              B.setXYZ(0, -1, -1, 0),
              B.setXYZ(1, -1, 1, 0),
              B.setXYZ(2, 1, 1, 0),
              B.setXYZ(3, 1, -1, 0),
              (B.needsUpdate = !0);
            let z = new lg().copy(I),
              k = new Uint32Array(_),
              V = new nq(k, 1, !1);
            return (
              V.setUsage(35048),
              z.setAttribute("splatIndex", V),
              (z.instanceCount = _),
              z
            );
          }
          resetLocalSplatDataAndTexturesFromSplatBuffer() {
            this.updateLocalSplatDataFromSplatBuffer(),
              this.allocateAndStoreLocalSplatDataInTextures();
          }
          updateLocalSplatDataFromSplatBuffer() {
            this.splatBuffers.forEach((_) => _.buildPreComputedBuffers()),
              (this.covariances = new Float32Array(6 * this.splatCount)),
              (this.colors = new Uint8Array(4 * this.splatCount)),
              (this.centers = new Float32Array(3 * this.splatCount));
            let _ = 0,
              I = 0,
              R = 0;
            for (let B of this.splatBuffers) {
              let z = B.nsplats;
              this.colors.subarray(_, _ + 4 * z).set(B.colorsA),
                (_ += 4 * z),
                this.centers
                  .subarray(I, I + 3 * z)
                  .set(B.decoded.xyz.denormDequant().data),
                (I += 3 * z),
                this.covariances
                  .subarray(R, R + 6 * z)
                  .set(new Float32Array(B.precomputedCovarianceBufferData)),
                (R += 6 * z);
            }
          }
          allocateAndStoreLocalSplatDataInTextures() {
            let _,
              I,
              R = this.splatCount,
              B = new rs(4096, 1024);
            for (; B.x * B.y * 2 < 6 * R; ) B.y *= 2;
            let z = new rs(4096, 1024);
            for (; z.x * z.y * 4 < 4 * R; ) z.y *= 2;
            if (this.halfPrecisionCovariancesOnGPU) {
              I = new Uint16Array(B.x * B.y * 2);
              for (let _ = 0; _ < this.covariances.length; _++)
                I[_] = l9.toHalfFloat(this.covariances[_]);
              _ = new nV(I, B.x, B.y, 1030, 1016);
            } else
              (I = new Float32Array(B.x * B.y * 2)).set(this.covariances),
                (_ = new nV(I, B.x, B.y, 1030, 1015));
            (_.needsUpdate = !0),
              (this.material.uniforms.covariancesTexture.value = _),
              this.material.uniforms.covariancesTextureSize.value.copy(B);
            let k = new Uint32Array(z.x * z.y * 4);
            for (let _ = 0; _ < R; _++) {
              var V;
              let I = 4 * _,
                R = 3 * _,
                B = 4 * _;
              (k[B] =
                ((V = this.colors[I]),
                V +
                  (this.colors[I + 1] << 8) +
                  (this.colors[I + 2] << 16) +
                  (this.colors[I + 3] << 24))),
                (k[B + 1] = T3(this.centers[R])),
                (k[B + 2] = T3(this.centers[R + 1])),
                (k[B + 3] = T3(this.centers[R + 2]));
            }
            let j = new nV(k, z.x, z.y, 1033, 1014);
            (j.internalFormat = "RGBA32UI"),
              (j.needsUpdate = !0),
              (this.material.uniforms.centersColorsTexture.value = j),
              this.material.uniforms.centersColorsTextureSize.value.copy(z);
            let G = new Float32Array(4096);
            for (let _ = 0; _ < this.meshMatrixWorlds.length; _++)
              G.set(this.meshMatrixWorlds[_].elements, 16 * _);
            let q = new nV(G, 1024, 1, 1023, 1015);
            (q.needsUpdate = !0),
              (this.material.uniforms.meshMatrixWorldsTexture.value = q),
              (this.material.uniformsNeedUpdate = !0),
              (this.splatDataTextures = {
                covariances: { data: I, texture: _, size: B },
                centerColors: { data: k, texture: j, size: z },
                meshMatrixWorlds: { data: G, texture: q },
              });
          }
          updateIndexes(_) {
            let I = this.geometry;
            I.attributes.splatIndex.set(_),
              (I.attributes.splatIndex.needsUpdate = !0),
              (I.instanceCount = _.length);
          }
          updateUniforms(_, I, R, B) {
            this.splatCount > 0 &&
              (T4.set(_.x * this.devicePixelRatio, _.y * this.devicePixelRatio),
              this.material.uniforms.viewport.value.copy(T4),
              this.material.uniforms.basisViewport.value.set(
                2 / T4.x,
                2 / T4.y
              ),
              this.material.uniforms.focal.value.set(I, R),
              (this.material.uniforms.orthoZoom.value = B),
              (this.material.uniformsNeedUpdate = !0));
          }
          getSplatDataTextures() {
            return this.splatDataTextures;
          }
          getSplatCount() {
            return this.splatCount;
          }
          getCenters() {
            return this.centers;
          }
          getColors() {
            return this.colors;
          }
          getCovariances() {
            return this.covariances;
          }
          dispose() {
            this.geometry.dispose(),
              this.material.dispose(),
              this.splatDataTextures &&
                (this.splatDataTextures.covariances.texture.dispose(),
                this.splatDataTextures.centerColors.texture.dispose(),
                this.splatDataTextures.meshMatrixWorlds.texture.dispose());
          }
        },
        T6 = class {
          constructor(_ = {}) {
            let I, R, B, z, k, V, j;
            Ui(
              this,
              "updateSplatMeshUniforms",
              ((I = new rs()),
              function () {
                null !== this.splatMesh &&
                  this.splatMesh.getSplatCount() > 0 &&
                  (this.renderer.getSize(I),
                  (this.cameraFocalLengthX =
                    this.camera.projectionMatrix.elements[0] *
                    this.devicePixelRatio *
                    I.x *
                    0.45),
                  (this.cameraFocalLengthY =
                    this.camera.projectionMatrix.elements[5] *
                    this.devicePixelRatio *
                    I.y *
                    0.45),
                  this.splatMesh.updateUniforms(
                    I,
                    this.cameraFocalLengthX,
                    this.cameraFocalLengthY,
                    this.camera.isPerspectiveCamera
                      ? -1
                      : this.camera.zoom * this.devicePixelRatio
                  ));
              })
            ),
              Ui(
                this,
                "updateView",
                ((R = new sa()),
                (B = []),
                (z = new rF(0, 0, -1)),
                (k = new rF(0, 0, -1)),
                (V = new rF()),
                (j = new rF()),
                function (_ = !1) {
                  let I = this.updateMatrixWorldsInWorkerIfNeeded(),
                    G = this.cropsChanged();
                  if (!_) {
                    k.set(0, 0, -1).applyQuaternion(this.camera.quaternion);
                    let _ = !1,
                      R = !1;
                    if (
                      (0.95 >= k.dot(z) && (_ = !0),
                      j.copy(this.camera.position).sub(V).length() >= 1 &&
                        (R = !0),
                      !_ && !R && !I && !G)
                    )
                      return;
                  }
                  V.copy(this.camera.position),
                    z.copy(k),
                    R.copy(this.camera.matrixWorld).invert(),
                    R.premultiply(this.camera.perspCamera.projectionMatrix),
                    (B[0] = this.camera.position.x),
                    (B[1] = this.camera.position.y),
                    (B[2] = this.camera.position.z);
                  let q = {
                    sort: {
                      view: R.elements,
                      cameraPosition: B,
                      splatRenderCount: this.splatRenderCount,
                      splatSortCount: this.splatRenderCount,
                    },
                    ...(I ? { newMatrixWorlds: this.meshMatrixWorlds } : {}),
                    ...(G ? { newCropsArray: this.cropsArray } : {}),
                  };
                  this.sortRunning
                    ? (this.queuedMessage = q)
                    : ((this.queuedMessage = null),
                      (this.sortRunning = !0),
                      this.sortWorker.postMessage(q));
                })
              ),
              (this.scene = _.scene),
              (this.currentPage = null),
              (this.renderer = _.renderer),
              (this.devicePixelRatio = window.devicePixelRatio),
              (this.sortWorker = null),
              (this.splatRenderCount = 0),
              (this.splatSortCount = 0),
              (this.splatMesh = null),
              (this.sortRunning = !1),
              (this.splatRenderingInitialized = !1),
              (this.meshMatrixWorlds = null),
              (this.meshMatrixWorldsOld = null),
              (this.cropsArray = null),
              (this.splatEntries = null),
              (this.queuedMessage = null);
          }
          get camera() {
            return this.scene.activeCamera;
          }
          reloadSplats() {
            this.splatRenderingInitialized = !1;
            let _ = this.loadSplat();
            this.renderer.pipeline.opaquePass.splatViewer = _ ? this : null;
          }
          loadSplat(_ = {}) {
            (this.activePage = this.scene.activePage),
              _.position && (_.position = new rF().fromArray(_.position)),
              _.orientation &&
                (_.orientation = new rz().fromArray(_.orientation)),
              (_.halfPrecisionCovariances = !!_.halfPrecisionCovariances);
            let I = [];
            if (
              ((this.splatEntries = I),
              this.activePage.traverseEntity((_) => {
                if ("Splat" === _.data.type) {
                  let R = _.visible;
                  _.traverseAncestors((_) => {
                    R && (R = _.visible);
                  }),
                    R && I.push(_);
                }
              }),
              this.splatMesh && this.splatMesh.dispose(),
              0 === I.length)
            )
              return (this.splatMesh = null), !1;
            (this.meshMatrixWorlds = I.map((_) => _.matrixWorld)),
              (this.meshMatrixWorldsOld = I.map((_) => _.matrixWorld.clone())),
              (this.cropsArray = I.map((_) => _.data.crops.map((_) => _.data)));
            let R = I.map((_) => new T1(new Uint8Array(_.data.buffer).buffer)),
              B = 0,
              z = [0];
            for (let _ of R) (B += _.getSplatCount()), z.push(B);
            return (
              this.setupSplatMesh(
                R,
                B,
                _.position,
                _.orientation,
                _.halfPrecisionCovariances,
                this.devicePixelRatio,
                z,
                this.meshMatrixWorlds
              ),
              this.setupSortWorker(B),
              !0
            );
          }
          updateMatrixWorldsInWorkerIfNeeded() {
            let _ = this.splatDataTextures.meshMatrixWorlds.data;
            for (let I = 0; I < this.meshMatrixWorlds.length; I++)
              _.set(this.meshMatrixWorlds[I].elements, 16 * I);
            return (
              (this.splatDataTextures.meshMatrixWorlds.texture.needsUpdate =
                !0),
              !this.meshMatrixWorlds.every((_, I) =>
                _.equals(this.meshMatrixWorldsOld[I])
              ) &&
                ((this.meshMatrixWorldsOld = this.meshMatrixWorlds.map((_) =>
                  _.clone()
                )),
                !0)
            );
          }
          cropsChanged() {
            let _ = !1;
            return (
              this.splatEntries.forEach((I, R) => {
                I.data.crops.forEach((I, B) => {
                  void 0 === this.cropsArray[R][B]
                    ? ((_ = !0), (this.cropsArray[R][B] = I.data))
                    : Object.entries(I.data).forEach(([I, z]) => {
                        Array.isArray(z) &&
                        z.some((_, z) => _ !== this.cropsArray[R][B][I][z])
                          ? ((_ = !0), (this.cropsArray[R][B][I] = z))
                          : z !== this.cropsArray[R][B]?.[I] &&
                            ((_ = !0), (this.cropsArray[R][B][I] = z));
                      });
                }),
                  I.data.crops.length !== this.cropsArray[R]?.length &&
                    ((this.cropsArray[R].length = I.data.crops.length),
                    (_ = !0));
              }),
              _
            );
          }
          setupSplatMesh(
            _,
            I,
            R = new rF(),
            B = new rz(),
            z = !1,
            k = 1,
            V,
            j
          ) {
            (this.splatMesh = T5.buildMesh(_, I, z, k, V, j)),
              this.splatMesh.position.copy(R),
              this.splatMesh.quaternion.copy(B),
              (this.splatMesh.frustumCulled = !1),
              (this.splatMesh.renderOrder = 10),
              this.updateSplatMeshUniforms(),
              (this.splatRenderCount = I);
          }
          setupSortWorker(_) {
            (this.sortWorker = (function (_) {
              let I = new Worker(
                  URL.createObjectURL(
                    new Blob(["(", VK.toString(), ")(self)"], {
                      type: "application/javascript",
                    })
                  )
                ),
                R = atob(
                  "AGFzbQEAAAAADwhkeWxpbmsuMAEEAAAAAAETA2AAAGAIf39/f39/f38AYAABfwISAQNlbnYGbWVtb3J5AgMAgIAEAwQDAAECBzkDEV9fd2FzbV9jYWxsX2N0b3JzAAALc29ydEluZGV4ZXMAARNlbXNjcmlwdGVuX3Rsc19pbml0AAIK3gMDAwABC9IDAwF/BnwBfgJAIAdFDQAgAysDUCEMIAMrAzAhDSADKwMQIQ5BACEDRP///////+9/IQtEAAAAAAAAEAAhCgNAIAIgA0ECdGoCfyAOIAEgA0EMbGoiCCoCALuiIA0gCCoCBLuioCAMIAgqAgi7oqBEAAAAAAAAsECiIgmZRAAAAAAAAOBBYwRAIAmqDAELQYCAgIB4CzYCACAJIAsgCSALYxshCyAJIAogCSAKZBshCiADQQFqIgMgB0cNAAsgB0UNACAGuCAKIAuhoyEJQQAhAwNAAn8gCSACIANBAnRqIgEoAgC3IAuhoiIKmUQAAAAAAADgQWMEQCAKqgwBC0GAgICAeAshCCABIAg2AgAgBCAIQQJ0aiIBIAEoAgBBAWo2AgAgA0EBaiIDIAdHDQALCyAGQQJPBEAgBCgCACEIQQEhAwNAIAQgA0ECdGoiASABKAIAIAhqIgg2AgAgA0EBaiIDIAZHDQALCyAHQQFrIgGtIQ8DQCAEIAIgD6dBAnQiA2ooAgBBAnRqIgcgBygCAEEBayIHNgIAIAUgASAHa0ECdGogACADaigCADYCACAPUCEDIA9CAX0hDyADRQ0ACyAGBEAgBEEAIAZBAnT8CwALCwQAQQAL"
                ),
                B = new Uint8Array(R.length);
              for (let _ = 0; _ < R.length; _++) B[_] = R.charCodeAt(_);
              return (
                I.postMessage({
                  init: {
                    sorterWasmBytes: B.buffer,
                    splatCount: _,
                    Constants: {
                      BytesPerFloat: T2.BytesPerFloat,
                      BytesPerInt: T2.BytesPerInt,
                      DepthMapRange: T2.DepthMapRange,
                      MemoryPageSize: T2.MemoryPageSize,
                    },
                  },
                }),
                I
              );
            })(_)),
              (this.sortWorker.onmessage = (_) => {
                _.data.sortDone
                  ? ((this.sortRunning = !1),
                    this.splatMesh?.updateIndexes(
                      new Uint32Array(_.data.indexesBuffer)
                    ),
                    (this.lastSortTime = _.data.sortTime),
                    this.queuedMessage &&
                      (this.sortWorker.postMessage(this.queuedMessage),
                      (this.queuedMessage = null)))
                  : _.data.sortCanceled
                  ? (this.sortRunning = !1)
                  : _.data.sortSetupPhase1Complete
                  ? this.sortWorker.postMessage({
                      positions: this.splatMesh.getCenters().buffer,
                      meshMatrixWorlds: this.splatMesh.meshMatrixWorlds,
                      meshIndexIntervals: this.splatMesh.meshIndexIntervals,
                      cropsArray: this.cropsArray,
                    })
                  : _.data.sortSetupComplete &&
                    ((this.splatDataTextures =
                      this.splatMesh.getSplatDataTextures()),
                    this.updateView(!0, !0),
                    (this.splatRenderingInitialized = !0));
              });
          }
          update() {
            !1 !== this.splatRenderingInitialized &&
              (this.updateSplatMeshUniforms(), this.updateView());
          }
          getSplatMesh() {
            return this.splatMesh;
          }
        },
        T8 = new sK();
      T8.wireframe = !0;
      var T9 = new rF(),
        T7 = class extends nz {
          constructor(_, I) {
            super(),
              (this.data = _),
              (this.sharedAssets = I),
              (this.enableHelpers = !1),
              (this.wireframeState = !1),
              (this.needsTransmissionDirty = !0),
              (this.needsNormalDirty = !0),
              (this._needsTransmission = !1),
              (this._needsNormal = !1),
              (this.geometryCacheChanged = !1),
              (this.splatViewer = null),
              (this.entityByUuid = {}),
              (this.entityIdentityToEntity = {}),
              (this.toExpandCloner = new Set()),
              (this.toUpdateCloner = new Set()),
              (this.pendingCommands = []),
              (this.pathConstraints = new TR()),
              (this.invisibleObjects = new A3("jflkdsafjasdifjaslk", {
                ...vt.defaultData,
                visible: !1,
                name: "buildin invisible",
              })),
              (this.needsRecomputeInstances = !1),
              this.init(_, I),
              (this.matrixAutoUpdate = !1),
              (this.errorPage = new C6(
                "fdasfa",
                { ...vd.defaultData, name: "" },
                { shared: I, scene: this }
              ));
          }
          markGeometryCacheDirty() {
            this.geometryCacheChanged = !0;
          }
          markNeedsUpdateRendererDirty() {
            (this.needsTransmissionDirty = !0), (this.needsNormalDirty = !0);
          }
          needsTransmission() {
            let _;
            return (
              this.needsTransmissionDirty &&
                ((this._needsTransmission =
                  ((_ = !1),
                  this.traverseEntity((I) => {
                    if (I instanceof SZ) {
                      if (Array.isArray(I.material))
                        for (let R = 0; R < I.material.length; R++)
                          _L(I, I.material[R]) && (_ = !0);
                      else _L(I, I.material) && (_ = !0);
                    }
                  }),
                  _)),
                (this.needsTransmissionDirty = !1)),
              this._needsTransmission
            );
          }
          needsNormal() {
            let _;
            return (
              this.needsNormalDirty &&
                ((this._needsNormal =
                  ((_ = !1),
                  this.traverseEntity((I) => {
                    if (I instanceof SZ) {
                      if (Array.isArray(I.material))
                        for (let R = 0; R < I.material.length; R++)
                          AL(I, I.material[R]) && (_ = !0);
                      else AL(I, I.material) && (_ = !0);
                    }
                  }),
                  _)),
                (this.needsNormalDirty = !1)),
              this._needsNormal
            );
          }
          registerInstanceAndSetUuid(_) {
            let I = _.identity.join("-"),
              R = this.entityIdentityToEntity[I];
            R && (_.uuid = R.uuid),
              (this.entityIdentityToEntity[I] = _),
              (this.entityByUuid[_.uuid] = _);
          }
          markPenumbraSizeDirty() {
            for (let _ of this.children)
              _ instanceof C6 && (_.penumbraSizeArrayCache = null);
          }
          findInstance(_) {
            return this.entityIdentityToEntity[_.join("-")];
          }
          get bgColor() {
            return this.activePage.bgColor;
          }
          get postprocessing() {
            return this.activePage.data.postprocessing;
          }
          getWithSortKey(_) {
            let I = this.find(_);
            if (void 0 === I) return;
            let R = [],
              B = I;
            for (; B !== this; ) {
              let _ = B,
                I = (B = B.parent).children.indexOf(_);
              R.splice(0, 0, I);
            }
            return { entity: I, sortKey: R };
          }
          getAllSorted(_) {
            let I = [];
            for (let R of _) {
              let _ = this.getWithSortKey(R.id);
              void 0 !== _ && I.push(_);
            }
            return (
              I.sort((_, I) => xv(_.sortKey, I.sortKey)), I.map((_) => _.entity)
            );
          }
          nonExistOrDescendantOf(_, I) {
            let R = this.find(_);
            if (void 0 === R) return !0;
            for (; R; ) {
              if (R.uuid === I) return !0;
              R = R.parent;
            }
            return !1;
          }
          find(_) {
            if (
              this.activePage &&
              this.activePage.personalCamera.parent &&
              ("f23858d0-4a3b-4bd8-8173-66ed0af7f6fb-personalCamera" === _ ||
                _ === fx)
            )
              return this.activePage.personalCamera;
            if ("" === _ || void 0 === _) return;
            let I = this.entityByUuid[_];
            return void 0 === I ? this.getObjectByProperty("uuid", _) : I;
          }
          find2D(_) {
            for (let I of this.children)
              if (I instanceof C6 && I.uiScene) {
                let R = I.uiScene.find(_);
                if (R) return R;
              }
          }
          findScene2DfromObject2D(_) {
            for (let I of this.children)
              if (I instanceof C6 && I.uiScene && I.uiScene.find(_))
                return I.uiScene;
          }
          find2DInUIObjects(_) {
            let I;
            return (
              this.traverseEntity((R) => {
                void 0 === I && R instanceof Ti && (I = R.uiCanvas.find(_));
              }),
              I
            );
          }
          traverse2D(_) {
            for (let I of this.children)
              I instanceof C6 && I.uiScene && I.uiScene.traverse(_);
          }
          debugEnsureEntity(_) {
            let I = this.find(_);
            I
              ? Array.isArray(I.identity) &&
                void 0 === this.findInstance(I.identity) &&
                console.error("not found instance")
              : console.error("not found");
          }
          addPendingExpandCloner(_) {
            this.toExpandCloner.add(_);
          }
          addPendingUpdateCloner(_) {
            this.toUpdateCloner.add(_);
          }
          markToExpandCloner(_) {
            this.toExpandCloner.add(_),
              _.traverseEntityAncestors((_) => {
                this.toExpandCloner.add(_);
              });
          }
          doPendingExpandCloner() {
            this.toExpandCloner.forEach((_) => {
              _.expandCloner(this);
            }),
              this.toExpandCloner.clear();
          }
          doPendingUpdateCloner() {
            this.toUpdateCloner.forEach((_) => {
              _.cloner?.update();
            }),
              this.toUpdateCloner.clear();
          }
          doPendingUpdates() {
            this.doPendingExpandCloner(),
              this.doPendingUpdateCloner(),
              this.applyPendingCommands();
          }
          addPendingCommand(_) {
            this.pendingCommands.push(_);
          }
          applyPendingCommands() {
            this.pendingCommands.forEach((_) => _()),
              (this.pendingCommands.length = 0);
          }
          updateByLibOp(_, I) {
            1 === _.path.length &&
              "components" === _.path[0] &&
              1 === _.type &&
              this.createChildrenObjects(
                [{ ..._.data.asset, id: _.id }],
                this.invisibleObjects,
                I
              );
          }
          updateTreeByOp(_, I) {
            if (0 === _.path.length && 7 === _.type) {
              let R = null === _.parent ? this : this.find(_.parent);
              if (void 0 === R) throw Error("unexpected");
              let B = this.createObject(
                _.id,
                _.data,
                _.children,
                R,
                _.localIndex,
                I
              );
              B.updateVisible(this),
                B.resetBBoxNeedsUpdate(),
                mn(B) &&
                  Rn(B.parent) &&
                  (B.invalidateUpstreamBooleanData(),
                  B.parent
                    .invalidateDownstreamBooleanData()
                    .recomputeBoolean()),
                this.markNeedsRecomputeInstancesForAncessors(R),
                this.markNeedsRecomputeInstancesForChildren(B),
                this.markToExpandCloner(B),
                this.markPenumbraSizeDirty(),
                B.updatePathSnapping();
            } else if (0 === _.path.length && 8 === _.type) {
              let I = this.find(_.id);
              if (void 0 === I) throw Error("unexpected");
              this.markToExpandCloner(I),
                I.resetBBoxNeedsUpdate(),
                this.unregisterObject(I);
              let R = I.parent;
              this.markNeedsRecomputeInstancesForAncessors(R),
                this.markNeedsRecomputeInstancesForChildren(I),
                this.markPenumbraSizeDirty(),
                I.parent.remove(I),
                Rn(I.parent) &&
                  (I.parent.invalidateUpstreamBooleanData(),
                  I.parent
                    .invalidateDownstreamBooleanData()
                    .recomputeBoolean()),
                mn(I) &&
                  (I.freeBooleanPointer(),
                  R instanceof A1 &&
                    R.invalidateDownstreamBooleanData().recomputeBoolean()),
                I instanceof C7 && I.detachShape(),
                this.disposeAndUnregisterEntityRecursivelyIfNotReregistered(I),
                this.pathConstraints.removeDependencies(I.uuid),
                I.updatePathSnapping();
            } else if (0 === _.path.length && 9 === _.type) {
              let I = this.find(_.id);
              if (void 0 === I) throw Error("unexpected");
              this.markNeedsRecomputeInstancesForChildren(I);
              let R = I.parent;
              this.markNeedsRecomputeInstancesForAncessors(R),
                I.cloner?.resetOnMove(),
                this.markToExpandCloner(I);
              let B = null === _.parent ? this : this.find(_.parent);
              if (void 0 === B) throw Error("unexpected");
              B.add(I),
                this.markNeedsRecomputeInstancesForAncessors(B),
                this.markToExpandCloner(I),
                I.invalidateClonerTransform(I),
                I.updateVisible(this),
                I.resetBBoxNeedsUpdate(),
                this.markPenumbraSizeDirty();
              let z = _.localIndex;
              B.children.splice(z, 0, B.children.pop()),
                mn(I) &&
                  (I.invalidateUpstreamBooleanData(),
                  Rn(I.parent)
                    ? I.parent
                        .invalidateDownstreamBooleanData()
                        .recomputeBoolean()
                    : R instanceof A1 &&
                      R.invalidateDownstreamBooleanData().recomputeBoolean()),
                I.updatePathSnapping();
            }
            this.markNeedsUpdateRendererDirty(), this.markGeometryCacheDirty();
          }
          get playPage() {
            return this.find(this.data.publish.playPage) ?? this.errorPage;
          }
          updatePage(_) {
            for (let I of (this.activePage && this.activePage.onDeactive(),
            (this.activePage = this.errorPage),
            this.children))
              I instanceof C6 &&
                ((I.visible = I.uuid === _),
                I.visible &&
                  ((this.activePage = I), this.activePage.onActive(this)));
            this.activePage !== this.splatViewer?.activePage &&
              this.reloadSplats();
          }
          updateEntityByOp(_, I, R, B) {
            if (0 === I.type) {
              if (
                (("overrides" in I.props || "component" in I.props) &&
                  this.markNeedsRecomputeInstances(),
                "visible" in I.props && this.markPenumbraSizeDirty(),
                I.path.includes("overrides") && "states" in I.props)
              ) {
                let { rest: _ } = I.props;
                (I = { ...I, props: _ }), this.markNeedsRecomputeInstances();
              }
              "pathSnapping" === I.path[0] &&
                void 0 !== I.props.pathId &&
                this.pathConstraints.setConstraint(_, I.props.pathId);
            }
            let z = this.find(_);
            if (z)
              try {
                (function (_, I, R, B) {
                  _.updateByOp(I, R, B, !1);
                })(z, I, R, { scene: this, shared: B }),
                  z instanceof S2 && z.updateGeometryGroupsIfNeeded();
              } catch (_) {
                console.error(_);
              }
          }
          updateEntity2DByOp(_, I, R, B, z, k = []) {
            _.updateEntityByOp(I, R, B, z),
              this.traverseEntity((_) => {
                (_ instanceof Ti || _ instanceof C6) &&
                  (k.includes(_.frameId ?? "") || _.frameId === I) &&
                  _.updateEntity2DByOp(I, R, B, z);
              });
          }
          get activeCamera() {
            return this.activePage.activeCamera;
          }
          switchActiveCamera(_) {
            this.activePage.switchActiveCamera(_);
          }
          isInvisibleObjects(_) {
            return (
              _ === this.invisibleObjects ||
              _.hasAnccestor(this.invisibleObjects)
            );
          }
          init(_, I) {
            let R = Object.entries(I.data.lib.components).map((_, I) => ({
              data: _[1].asset.data,
              children: _[1].asset.children,
              id: _[0],
              fi: I,
            }));
            this.invisibleObjects.updateState(this.invisibleObjects.data, {
              scene: this,
              shared: I,
            }),
              this.add(this.invisibleObjects),
              this.createChildrenObjects(R, this.invisibleObjects, I),
              this.createChildrenObjects(_.objects, this, I),
              this.updatePage(_.publish.playPage),
              this.activePage.switchToPlayCamera(),
              this.expandInstances(I, !0),
              this.traverseEntity((_) => {
                _ instanceof AK && _.updateUp();
              }),
              this.doPendingExpandCloner(),
              this.applyPendingCommands();
          }
          markNeedsRecomputeInstances() {
            this.needsRecomputeInstances = !0;
          }
          markNeedsRecomputeInstancesForChildren(_) {
            _.traverseEntity((_) => {
              ("Component" === _.data.type || "Instance" === _.data.type) &&
                this.markNeedsRecomputeInstances();
            });
          }
          markNeedsRecomputeInstancesForAncessors(_) {
            bG.is(_) &&
              ("Component" === _.data.type &&
                this.markNeedsRecomputeInstances(),
              _.traverseAncestors((_) => {
                bG.is(_) &&
                  "Component" === _.data.type &&
                  this.markNeedsRecomputeInstances();
              }));
          }
          relativeizeInner(_, I, R, B, z, k, V) {
            if (_) {
              let j = B.find(_);
              j &&
                j !== B &&
                z.forInstancesRec((B) => {
                  B.data = Tl(B.data, (z) => {
                    let j = z.events.data(V.id),
                      G = B.goUp(k);
                    if (G) {
                      let B = [...vv(G.identity), _].join("-"),
                        z = this.entityIdentityToEntity[B];
                      if (z) {
                        let _ = z.uuid;
                        pe.zoom(j, I)[R] = _;
                      } else console.warn("cannot find instance");
                    }
                  }).data;
                });
            }
          }
          rewriteActions(_, I, R, B, z, k) {
            _.forEach((_) => {
              "Transition" === _.data.type
                ? this.relativeizeInner(
                    _.data.object,
                    [...I, _.id],
                    "object",
                    R,
                    B,
                    z,
                    k
                  )
                : "Animation" === _.data.type &&
                  this.relativeizeInner(
                    _.data.object,
                    [...I, _.id],
                    "object",
                    R,
                    B,
                    z,
                    k
                  );
            });
          }
          rewriteEventsBeforeGoToPlayMode() {
            this.traverseEntity((_) => {
              if (
                _ instanceof Te &&
                "string" == typeof _.identity &&
                "Component" === _.data.type
              )
                return (
                  _.traverseEntity((I, R) => {
                    I.data.events.forEach((B) => {
                      if ("GameControl" === B.data.type) {
                        let z = !1;
                        if (
                          (I.forInstancesRec((_) => {
                            _.data = Tl(_.data, (I) => {
                              _.isInstanceRoot ||
                                (I.events.delete(B.id), (z = !0));
                            }).data;
                          }),
                          !1 === z)
                        )
                          for (let z of vk.list)
                            this.rewriteActions(
                              B.data.gameActions[z],
                              ["gameActions", z],
                              _,
                              I,
                              R,
                              B
                            );
                      } else
                        "Conditional" === B.data.type
                          ? ("Distance" === B.data.condition.type
                              ? (this.relativeizeInner(
                                  B.data.condition.fromObject,
                                  ["condition"],
                                  "fromObject",
                                  _,
                                  I,
                                  R,
                                  B
                                ),
                                this.relativeizeInner(
                                  B.data.condition.toObject,
                                  ["condition"],
                                  "toObject",
                                  _,
                                  I,
                                  R,
                                  B
                                ))
                              : "State" === B.data.condition.type
                              ? this.relativeizeInner(
                                  B.data.condition.object,
                                  ["condition"],
                                  "object",
                                  _,
                                  I,
                                  R,
                                  B
                                )
                              : "Comparison" === B.data.condition.type &&
                                ("Property" ===
                                  B.data.condition.lOperand.type &&
                                  this.relativeizeInner(
                                    B.data.condition.lOperand.value[0],
                                    ["condition", "lOperand", "value"],
                                    0,
                                    _,
                                    I,
                                    R,
                                    B
                                  ),
                                "Property" === B.data.condition.rOperand.type &&
                                  this.relativeizeInner(
                                    B.data.condition.rOperand.value[0],
                                    ["condition", "rOperand", "value"],
                                    0,
                                    _,
                                    I,
                                    R,
                                    B
                                  )),
                            this.rewriteActions(
                              B.data.inActions,
                              ["inActions"],
                              _,
                              I,
                              R,
                              B
                            ),
                            this.rewriteActions(
                              B.data.outActions,
                              ["outActions"],
                              _,
                              I,
                              R,
                              B
                            ))
                          : "actions" in B.data &&
                            this.rewriteActions(
                              B.data.actions,
                              ["actions"],
                              _,
                              I,
                              R,
                              B
                            );
                    });
                  }),
                  !0
                );
            });
          }
          expandInstances(_, I, R) {
            let B = new Set();
            for (let z of (this.traverseEntity((z) => {
              if (z instanceof Te && z.isInstanceRoot)
                return (
                  z.expandInstanceChildren({
                    scene: this,
                    shared: _,
                    pendingDeletes: B,
                  }),
                  I || z.resetBBoxNeedsUpdate(),
                  R &&
                    z.traverseEntity((_) => {
                      R.addClip(_);
                    }),
                  !0
                );
            }),
            B))
              this.disposeAndUnregisterEntityRecursivelyIfNotReregistered(z),
                Qx(z);
          }
          recomputeInstances(_, I) {
            this.needsRecomputeInstances &&
              ((this.needsRecomputeInstances = !1),
              this.traverseEntity((_) => {
                _ instanceof Te && _.isInstanceRoot && (_.component = void 0);
              }),
              this.expandInstances(_, !1, I));
          }
          disposeAndUnregisterEntityRecursivelyIfNotReregistered(_) {
            _.traverseEntity((_) => {
              let I =
                "string" == typeof _.identity
                  ? _.identity
                  : _.identity.join("-");
              this.entityIdentityToEntity[I] === _ &&
                (delete this.entityByUuid[_.uuid],
                delete this.entityIdentityToEntity[I]),
                _.dispose();
            });
          }
          clearScene() {
            for (let _ of this.children) bG.is(_) && _.disposeRecursively();
            this.children.length = 0;
          }
          resetAfterClear(_, I) {
            this.init(_, I);
          }
          raycast(_) {
            return this.raycast1(_, !1);
          }
          raycast1(_, I) {
            let R = [],
              s = (B) => {
                for (let z of B.children) {
                  let B = z.cloner;
                  if (
                    bG.is(z) &&
                    !z.raycastLock &&
                    (z.visible || B?.object.data.visible)
                  ) {
                    if (!0 === I && z.isInstanceRoot) {
                      let I = [];
                      if ((_.intersectObject(z, !0, I), I.length)) {
                        let _ = I[0];
                        (_.object = z),
                          _.point.applyMatrix4(_.object.matrixWorld);
                        let B = z.matrixWorld.clone().invert();
                        _.point.applyMatrix4(B), R.push(_);
                      }
                    } else
                      (mn(z) ||
                        (Wm(z) &&
                          this.enableHelpers &&
                          z.objectHelper.visible)) &&
                        (_.intersectObject(z, !1, R), eg(z, _, R)),
                        s(z);
                  }
                }
              };
            return s(this.activePage), R;
          }
          raycastWithClones(_) {
            let I = [],
              i = (R) => {
                for (let B of R.children) {
                  let R = B.cloner;
                  bG.is(B) &&
                    (B.visible || R?.object.data.visible) &&
                    ((mn(B) ||
                      (Wm(B) &&
                        this.enableHelpers &&
                        B.objectHelper.visible)) &&
                      (_.intersectObject(B, !1, I), eg(B, _, I, !0)),
                    i(B));
                }
              };
            return i(this), I;
          }
          forEachEntity(_) {
            for (let I of this.children) bG.is(I) && _(I);
          }
          traverseConcreteEntity(_) {
            for (let I of this.children)
              bG.is(I) && I.isConcreteEntity && I.traverseEntity(_);
          }
          traverseEntity(_) {
            for (let I of this.children) bG.is(I) && I.traverseEntity(_);
          }
          updateFont(_, I) {
            this.traverseEntity((R) => {
              if (
                R instanceof S2 &&
                "Mesh" === R.data.type &&
                "TextGeometry" === R.data.geometry.type &&
                R.data.geometry.font === _
              ) {
                let B = R.geometry,
                  z = R.data.geometry;
                B.updateFont(_, I).then(() => {
                  B.update(z);
                  let _ = R.invalidateDownstreamBooleanData();
                  Rn(_) && _.recomputeBoolean();
                });
              }
            });
          }
          traverseObject(_) {
            for (let I of this.children) yO.is(I) && I.traverseObject(_);
          }
          traverseVisibleEntity(_) {
            for (let I of this.children)
              bG.is(I) && I.visible && I.traverseVisibleEntity(_);
          }
          dispose() {
            this.clearScene();
          }
          createChildrenObjects(_, I, R) {
            let B = 0;
            for (let z of _)
              this.createObject(z.id, z.data, z.children, I, B, R), (B += 1);
          }
          registerObjectCreatedInLegacy(_) {
            this.entityByUuid[_.uuid] = _;
          }
          unregisterObject(_) {
            for (let I of (delete this.entityByUuid[_.uuid], _.children))
              this.unregisterObject(I);
          }
          createObject(_, I, R, B, z, k) {
            let V = { scene: this, shared: k },
              j = rb(_, I, V);
            return (
              j &&
                ((this.entityByUuid[_] = j),
                B.add(j),
                B.children.splice(z, 0, B.children.pop()),
                R.length > 0 &&
                  (j.isInstanceRoot
                    ? console.error("instance should not have children!")
                    : this.createChildrenObjects(R, j, k)),
                j.updateState(I, V),
                j instanceof S2 && j.updateGeometryGroupsIfNeeded(),
                j.updateVisible(this),
                j.cloner && this.toExpandCloner.add(j),
                I.pathSnapping?.pathId &&
                  this.pathConstraints.setConstraint(_, I.pathSnapping.pathId)),
              "Empty" === I.type &&
                I.animations &&
                j.traverseEntity((_) => {
                  let I = _.dataPatched;
                  if (_ instanceof S2 && I.bones && I.boneInverses) {
                    let R = I.bones.map((_) => this.find(_)),
                      B = I.boneInverses.map((_) => new sa().fromArray(_)),
                      z = new nW(R, B);
                    _.bind(z, _.bindMatrix);
                  } else _.matrixAutoUpdate = !0;
                }),
              j
            );
          }
          getCenter(_) {
            let I = [];
            for (let R = 0, B = _.length; R < B; ++R) {
              let { id: B, recursive: z } = _[R],
                k = this.find(B),
                V = z ? k.recursiveBBox : k.singleBBox;
              I.push(...V.vertices);
            }
            let R = new rU();
            return R.setFromPoints(I), R.getCenter(T9), T9;
          }
          copyMatrixWorld(_, I) {
            if (null === _) {
              I.identity();
              return;
            }
            let R = this.find(_);
            R ? I.copy(R.matrixWorld) : I.identity();
          }
          copyParentMatrixWorld(_, I) {
            if (null === _) {
              I.identity();
              return;
            }
            let R = this.find(_)?.parent;
            R ? I.copy(R.matrixWorld) : I.identity();
          }
          traverseMaterial(_) {
            this.traverseEntity((I) => {
              if (I instanceof wp) {
                if (Array.isArray(I.material))
                  for (let R = 0; R < I.material.length; R++)
                    I.material[R] instanceof SC && _(I.material[R]);
                else I.material instanceof SC && _(I.material);
              }
            });
          }
          updateViewPlaneSize(_, I, R = !1) {
            this.traverseConcreteEntity((B) => {
              B instanceof AK && B.setViewplaneSize(_, I, R);
            });
          }
          initializeSplatViewer(_) {
            (this.splatViewer = new T6({ scene: this, renderer: _ })),
              this.reloadSplats();
          }
          reloadSplats() {
            this.splatViewer?.reloadSplats();
          }
        },
        rg = (_, I) => {
          let R = I.x - _.x,
            B = I.y - _.y;
          return Math.sqrt(R * R + B * B);
        },
        oB = (_, I) => {
          let R = I.x - _.x;
          return zK(Math.atan2(I.y - _.y, R));
        },
        aB = (_, I, R) => {
          let B = { x: 0, y: 0 };
          return (
            (R = lb(R)),
            (B.x = _.x - I * Math.cos(R)),
            (B.y = _.y - I * Math.sin(R)),
            B
          );
        },
        lb = (_) => _ * (Math.PI / 180),
        zK = (_) => _ * (180 / Math.PI),
        lB = (_) => (isNaN(_.buttons) ? 0 !== _.pressure : 0 !== _.buttons),
        Pe = new Map(),
        lE = (_) => {
          Pe.has(_) && clearTimeout(Pe.get(_)), Pe.set(_, setTimeout(_, 100));
        },
        Gf = (_, I, R) => {
          let B = I.split(/[ ,]+/g),
            z;
          for (let I = 0; I < B.length; I += 1)
            (z = B[I]),
              _.addEventListener
                ? _.addEventListener(z, R, !1)
                : _.attachEvent && _.attachEvent(z, R);
        },
        cE = (_, I, R) => {
          let B = I.split(/[ ,]+/g),
            z;
          for (let I = 0; I < B.length; I += 1)
            (z = B[I]),
              _.removeEventListener
                ? _.removeEventListener(z, R)
                : _.detachEvent && _.detachEvent(z, R);
        },
        cb = (_) => (
          _.preventDefault(), _.type.match(/^touch/) ? _.changedTouches : _
        ),
        uE = () => {
          if (!(typeof window > "u"))
            return {
              x:
                void 0 !== window.pageXOffset
                  ? window.pageXOffset
                  : (
                      document.documentElement ||
                      document.body.parentNode ||
                      document.body
                    ).scrollLeft,
              y:
                void 0 !== window.pageYOffset
                  ? window.pageYOffset
                  : (
                      document.documentElement ||
                      document.body.parentNode ||
                      document.body
                    ).scrollTop,
            };
        },
        ub = (_, I) => {
          I.top || I.right || I.bottom || I.left
            ? ((_.style.top = I.top),
              (_.style.right = I.right),
              (_.style.bottom = I.bottom),
              (_.style.left = I.left))
            : ((_.style.left = I.x + "px"), (_.style.top = I.y + "px"));
        },
        hb = (_, I, R) => {
          let B = uB(_);
          for (let _ in B)
            if (B.hasOwnProperty(_)) {
              if ("string" == typeof I) B[_] = I + " " + R;
              else {
                let z = "";
                for (let _ = 0, B = I.length; _ < B; _ += 1)
                  z += I[_] + " " + R + ", ";
                B[_] = z.slice(0, -2);
              }
            }
          return B;
        },
        cB = (_, I) => {
          let R = uB(_);
          for (let _ in R) R.hasOwnProperty(_) && (R[_] = I);
          return R;
        },
        uB = (_) => {
          let I = {};
          return (
            (I[_] = ""),
            ["webkit", "Moz", "o"].forEach(function (R) {
              I[R + _.charAt(0).toUpperCase() + _.slice(1)] = "";
            }),
            I
          );
        },
        db = (_, I) => {
          for (let R in I) I.hasOwnProperty(R) && (_[R] = I[R]);
          return _;
        },
        hB = (_, I) => {
          let R = {};
          for (let B in _)
            _.hasOwnProperty(B) && I.hasOwnProperty(B)
              ? (R[B] = I[B])
              : _.hasOwnProperty(B) && (R[B] = _[B]);
          return R;
        },
        ig = (_, I) => {
          if (_.length) for (let R = 0, B = _.length; R < B; R += 1) I(_[R]);
          else I(_);
        },
        dB = (_, I, R) => ({
          x: Math.min(Math.max(_.x, I.x - R), I.x + R),
          y: Math.min(Math.max(_.y, I.y - R), I.y + R),
        });
      "u" > typeof window &&
        ((Po = "ontouchstart" in window),
        (Pc = !!window.PointerEvent),
        (Pd = !!window.MSPointerEvent));
      var Pi,
        Ps,
        Pa,
        Pn,
        Po,
        Pc,
        Pd,
        Pu,
        Pp = {
          touch: {
            start: "touchstart",
            move: "touchmove",
            end: "touchend, touchcancel",
          },
          mouse: { start: "mousedown", move: "mousemove", end: "mouseup" },
          pointer: {
            start: "pointerdown",
            move: "pointermove",
            end: "pointerup, pointercancel",
          },
          MSPointer: {
            start: "MSPointerDown",
            move: "MSPointerMove",
            end: "MSPointerUp",
          },
        },
        Pf = {};
      function fu() {}
      function Fi(_, I) {
        return (
          (this.identifier = I.identifier),
          (this.position = I.position),
          (this.frontPosition = I.frontPosition),
          (this.collection = _),
          (this.defaults = {
            size: 100,
            threshold: 0.1,
            color: "white",
            fadeTime: 250,
            dataOnly: !1,
            restJoystick: !0,
            restOpacity: 1,
            mode: "dynamic",
            zone: document.body,
            lockX: !1,
            lockY: !1,
            shape: "circle",
          }),
          this.config(I),
          "dynamic" === this.options.mode && (this.options.restOpacity = 0),
          (this.id = Fi.id),
          (Fi.id += 1),
          this.buildEl().stylize(),
          (this.instance = {
            el: this.ui.el,
            on: this.on.bind(this),
            off: this.off.bind(this),
            show: this.show.bind(this),
            hide: this.hide.bind(this),
            add: this.addToDom.bind(this),
            remove: this.removeFromDom.bind(this),
            destroy: this.destroy.bind(this),
            setPosition: this.setPosition.bind(this),
            resetDirection: this.resetDirection.bind(this),
            computeDirection: this.computeDirection.bind(this),
            trigger: this.trigger.bind(this),
            position: this.position,
            frontPosition: this.frontPosition,
            ui: this.ui,
            identifier: this.identifier,
            id: this.id,
            options: this.options,
          }),
          this.instance
        );
      }
      function ci(_, I) {
        (this.nipples = []),
          (this.idles = []),
          (this.actives = []),
          (this.ids = []),
          (this.pressureIntervals = {}),
          (this.manager = _),
          (this.id = ci.id),
          (ci.id += 1),
          (this.defaults = {
            zone: document.body,
            multitouch: !1,
            maxNumberOfNipples: 10,
            mode: "dynamic",
            position: { top: 0, left: 0 },
            catchDistance: 200,
            size: 100,
            threshold: 0.1,
            color: "white",
            fadeTime: 250,
            dataOnly: !1,
            restJoystick: !0,
            restOpacity: 1,
            lockX: !1,
            lockY: !1,
            shape: "circle",
            dynamicPage: !1,
            follow: !1,
          }),
          this.config(I),
          ("static" === this.options.mode || "semi" === this.options.mode) &&
            (this.options.multitouch = !1),
          this.options.multitouch || (this.options.maxNumberOfNipples = 1);
        let R = getComputedStyle(this.options.zone.parentElement);
        return (
          R && "flex" === R.display && (this.parentIsFlex = !0),
          this.updateBox(),
          this.prepareNipples(),
          this.bindings(),
          this.begin(),
          this.nipples
        );
      }
      function $i(_) {
        var I = this;
        (I.ids = {}),
          (I.index = 0),
          (I.collections = []),
          (I.scroll = uE()),
          I.config(_),
          I.prepareCollections();
        var e = function () {
          var _;
          I.collections.forEach(function (R) {
            R.forEach(function (R) {
              (_ = R.el.getBoundingClientRect()),
                (R.position = {
                  x: I.scroll.x + _.left,
                  y: I.scroll.y + _.top,
                });
            });
          });
        };
        if (typeof window > "u") return I.collections;
        Gf(window, "resize", function () {
          lE(e);
        });
        var r = function () {
          I.scroll = uE();
        };
        return (
          Gf(window, "scroll", function () {
            lE(r);
          }),
          I.collections
        );
      }
      Pc
        ? (Pu = Pp.pointer)
        : Pd
        ? (Pu = Pp.MSPointer)
        : Po
        ? ((Pu = Pp.touch), (Pf = Pp.mouse))
        : (Pu = Pp.mouse),
        (fu.prototype.on = function (_, I) {
          var R,
            B = _.split(/[ ,]+/g);
          this._handlers_ = this._handlers_ || {};
          for (var z = 0; z < B.length; z += 1)
            (R = B[z]),
              (this._handlers_[R] = this._handlers_[R] || []),
              this._handlers_[R].push(I);
          return this;
        }),
        (fu.prototype.off = function (_, I) {
          return (
            (this._handlers_ = this._handlers_ || {}),
            void 0 === _
              ? (this._handlers_ = {})
              : void 0 === I
              ? (this._handlers_[_] = null)
              : this._handlers_[_] &&
                this._handlers_[_].indexOf(I) >= 0 &&
                this._handlers_[_].splice(this._handlers_[_].indexOf(I), 1),
            this
          );
        }),
        (fu.prototype.trigger = function (_, I) {
          var R,
            B = this,
            z = _.split(/[ ,]+/g);
          B._handlers_ = B._handlers_ || {};
          for (var k = 0; k < z.length; k += 1)
            (R = z[k]),
              B._handlers_[R] &&
                B._handlers_[R].length &&
                B._handlers_[R].forEach(function (_) {
                  _.call(B, { type: R, target: B }, I);
                });
        }),
        (fu.prototype.config = function (_) {
          (this.options = this.defaults || {}),
            _ && (this.options = hB(this.options, _));
        }),
        (fu.prototype.bindEvt = function (_, I) {
          var R = this;
          return (
            (R._domHandlers_ = R._domHandlers_ || {}),
            (R._domHandlers_[I] = function () {
              "function" == typeof R["on" + I]
                ? R["on" + I].apply(R, arguments)
                : console.warn('[WARNING] : Missing "on' + I + '" handler.');
            }),
            Gf(_, Pu[I], R._domHandlers_[I]),
            Pf[I] && Gf(_, Pf[I], R._domHandlers_[I]),
            R
          );
        }),
        (fu.prototype.unbindEvt = function (_, I) {
          return (
            (this._domHandlers_ = this._domHandlers_ || {}),
            cE(_, Pu[I], this._domHandlers_[I]),
            Pf[I] && cE(_, Pf[I], this._domHandlers_[I]),
            delete this._domHandlers_[I],
            this
          );
        }),
        (Fi.prototype = new fu()),
        (Fi.constructor = Fi),
        (Fi.id = 0),
        (Fi.prototype.buildEl = function (_) {
          return (
            (this.ui = {}),
            this.options.dataOnly ||
              ((this.ui.el = document.createElement("div")),
              (this.ui.back = document.createElement("div")),
              (this.ui.front = document.createElement("div")),
              (this.ui.el.className =
                "nipple collection_" + this.collection.id),
              (this.ui.back.className = "back"),
              (this.ui.front.className = "front"),
              this.ui.el.setAttribute(
                "id",
                "nipple_" + this.collection.id + "_" + this.id
              ),
              this.ui.el.appendChild(this.ui.back),
              this.ui.el.appendChild(this.ui.front)),
            this
          );
        }),
        (Fi.prototype.stylize = function () {
          if (this.options.dataOnly) return this;
          var _ = this.options.fadeTime + "ms",
            I = cB("borderRadius", "50%"),
            R = hb("transition", "opacity", _),
            B = {};
          return (
            (B.el = {
              position: "absolute",
              opacity: this.options.restOpacity,
              display: "block",
              zIndex: 999,
            }),
            (B.back = {
              position: "absolute",
              display: "block",
              width: this.options.size + "px",
              height: this.options.size + "px",
              marginLeft: -this.options.size / 2 + "px",
              marginTop: -this.options.size / 2 + "px",
              background: "rgba(255, 255, 255, .4)",
              border: "solid 2px rgba(0, 0, 0, .1)",
            }),
            (B.front = {
              width: this.options.size / 2 + "px",
              height: this.options.size / 2 + "px",
              position: "absolute",
              display: "block",
              marginLeft: -this.options.size / 4 + "px",
              marginTop: -this.options.size / 4 + "px",
              background: "rgba(255, 255, 255, .8)",
              border: "solid 2px rgba(0, 0, 0, .1)",
            }),
            db(B.el, R),
            "circle" === this.options.shape && db(B.back, I),
            db(B.front, I),
            this.applyStyles(B),
            this
          );
        }),
        (Fi.prototype.applyStyles = function (_) {
          for (var I in this.ui)
            if (this.ui.hasOwnProperty(I))
              for (var R in _[I]) this.ui[I].style[R] = _[I][R];
          return this;
        }),
        (Fi.prototype.addToDom = function () {
          return (
            this.options.dataOnly ||
              document.body.contains(this.ui.el) ||
              this.options.zone.appendChild(this.ui.el),
            this
          );
        }),
        (Fi.prototype.removeFromDom = function () {
          return (
            this.options.dataOnly ||
              !document.body.contains(this.ui.el) ||
              this.options.zone.removeChild(this.ui.el),
            this
          );
        }),
        (Fi.prototype.destroy = function () {
          clearTimeout(this.removeTimeout),
            clearTimeout(this.showTimeout),
            clearTimeout(this.restTimeout),
            this.trigger("destroyed", this.instance),
            this.removeFromDom(),
            this.off();
        }),
        (Fi.prototype.show = function (_) {
          var I = this;
          return (
            I.options.dataOnly ||
              (clearTimeout(I.removeTimeout),
              clearTimeout(I.showTimeout),
              clearTimeout(I.restTimeout),
              I.addToDom(),
              I.restCallback(),
              setTimeout(function () {
                I.ui.el.style.opacity = 1;
              }, 0),
              (I.showTimeout = setTimeout(function () {
                I.trigger("shown", I.instance),
                  "function" == typeof _ && _.call(this);
              }, I.options.fadeTime))),
            I
          );
        }),
        (Fi.prototype.hide = function (_) {
          var I = this;
          if (I.options.dataOnly) return I;
          if (
            ((I.ui.el.style.opacity = I.options.restOpacity),
            clearTimeout(I.removeTimeout),
            clearTimeout(I.showTimeout),
            clearTimeout(I.restTimeout),
            (I.removeTimeout = setTimeout(function () {
              var R = "dynamic" === I.options.mode ? "none" : "block";
              (I.ui.el.style.display = R),
                "function" == typeof _ && _.call(I),
                I.trigger("hidden", I.instance);
            }, I.options.fadeTime)),
            I.options.restJoystick)
          ) {
            let R = I.options.restJoystick,
              B = {};
            (B.x = !0 === R || !1 !== R.x ? 0 : I.instance.frontPosition.x),
              (B.y = !0 === R || !1 !== R.y ? 0 : I.instance.frontPosition.y),
              I.setPosition(_, B);
          }
          return I;
        }),
        (Fi.prototype.setPosition = function (_, I) {
          var R = this;
          R.frontPosition = { x: I.x, y: I.y };
          var B = R.options.fadeTime + "ms",
            z = {};
          z.front = hb("transition", ["top", "left"], B);
          var k = { front: {} };
          (k.front = {
            left: R.frontPosition.x + "px",
            top: R.frontPosition.y + "px",
          }),
            R.applyStyles(z),
            R.applyStyles(k),
            (R.restTimeout = setTimeout(function () {
              "function" == typeof _ && _.call(R), R.restCallback();
            }, R.options.fadeTime));
        }),
        (Fi.prototype.restCallback = function () {
          var _ = {};
          (_.front = hb("transition", "none", "")),
            this.applyStyles(_),
            this.trigger("rested", this.instance);
        }),
        (Fi.prototype.resetDirection = function () {
          this.direction = { x: !1, y: !1, angle: !1 };
        }),
        (Fi.prototype.computeDirection = function (_) {
          var I,
            R,
            B,
            z = _.angle.radian,
            k = Math.PI / 4,
            V = Math.PI / 2;
          if (
            (z > k && z < 3 * k && !_.lockX
              ? (I = "up")
              : z > -k && z <= k && !_.lockY
              ? (I = "left")
              : z > -(3 * k) && z <= -k && !_.lockX
              ? (I = "down")
              : _.lockY || (I = "right"),
            _.lockY || (R = z > -V && z < V ? "left" : "right"),
            _.lockX || (B = z > 0 ? "up" : "down"),
            _.force > this.options.threshold)
          ) {
            var j,
              G = {};
            for (j in this.direction)
              this.direction.hasOwnProperty(j) && (G[j] = this.direction[j]);
            var q = {};
            for (j in ((this.direction = { x: R, y: B, angle: I }),
            (_.direction = this.direction),
            G))
              G[j] === this.direction[j] && (q[j] = !0);
            if (q.x && q.y && q.angle) return _;
            (q.x && q.y) || this.trigger("plain", _),
              q.x || this.trigger("plain:" + R, _),
              q.y || this.trigger("plain:" + B, _),
              q.angle || this.trigger("dir dir:" + I, _);
          } else this.resetDirection();
          return _;
        }),
        (ci.prototype = new fu()),
        (ci.constructor = ci),
        (ci.id = 0),
        (ci.prototype.prepareNipples = function () {
          var _ = this.nipples;
          (_.on = this.on.bind(this)),
            (_.off = this.off.bind(this)),
            (_.options = this.options),
            (_.destroy = this.destroy.bind(this)),
            (_.ids = this.ids),
            (_.id = this.id),
            (_.processOnMove = this.processOnMove.bind(this)),
            (_.processOnEnd = this.processOnEnd.bind(this)),
            (_.get = function (I) {
              if (void 0 === I) return _[0];
              for (var R = 0, B = _.length; R < B; R += 1)
                if (_[R].identifier === I) return _[R];
              return !1;
            });
        }),
        (ci.prototype.bindings = function () {
          this.bindEvt(this.options.zone, "start"),
            (this.options.zone.style.touchAction = "none"),
            (this.options.zone.style.msTouchAction = "none");
        }),
        (ci.prototype.begin = function () {
          var _ = this.options;
          if ("static" === _.mode) {
            var I = this.createNipple(_.position, this.manager.getIdentifier());
            I.add(), this.idles.push(I);
          }
        }),
        (ci.prototype.createNipple = function (_, I) {
          var R = this.manager.scroll,
            B = {},
            z = this.options,
            k = {
              x: this.parentIsFlex ? R.x : R.x + this.box.left,
              y: this.parentIsFlex ? R.y : R.y + this.box.top,
            };
          if (_.x && _.y) B = { x: _.x - k.x, y: _.y - k.y };
          else if (_.top || _.right || _.bottom || _.left) {
            var V = document.createElement("DIV");
            (V.style.display = "hidden"),
              (V.style.top = _.top),
              (V.style.right = _.right),
              (V.style.bottom = _.bottom),
              (V.style.left = _.left),
              (V.style.position = "absolute"),
              z.zone.appendChild(V);
            var j = V.getBoundingClientRect();
            z.zone.removeChild(V),
              (B = _),
              (_ = { x: j.left + R.x, y: j.top + R.y });
          }
          var G = new Fi(this, {
            color: z.color,
            size: z.size,
            threshold: z.threshold,
            fadeTime: z.fadeTime,
            dataOnly: z.dataOnly,
            restJoystick: z.restJoystick,
            restOpacity: z.restOpacity,
            mode: z.mode,
            identifier: I,
            position: _,
            zone: z.zone,
            frontPosition: { x: 0, y: 0 },
            shape: z.shape,
          });
          return (
            z.dataOnly || (ub(G.ui.el, B), ub(G.ui.front, G.frontPosition)),
            this.nipples.push(G),
            this.trigger("added " + G.identifier + ":added", G),
            this.manager.trigger("added " + G.identifier + ":added", G),
            this.bindNipple(G),
            G
          );
        }),
        (ci.prototype.updateBox = function () {
          this.box = this.options.zone.getBoundingClientRect();
        }),
        (ci.prototype.bindNipple = function (_) {
          var I,
            R = this,
            r = function (_, B) {
              (I = _.type + " " + B.id + ":" + _.type), R.trigger(I, B);
            };
          _.on("destroyed", R.onDestroyed.bind(R)),
            _.on("shown hidden rested dir plain", r),
            _.on("dir:up dir:right dir:down dir:left", r),
            _.on("plain:up plain:right plain:down plain:left", r);
        }),
        (ci.prototype.pressureFn = function (_, I, R) {
          var B = this,
            z = 0;
          clearInterval(B.pressureIntervals[R]),
            (B.pressureIntervals[R] = setInterval(
              function () {
                var R = _.force || _.pressure || _.webkitForce || 0;
                R !== z &&
                  (I.trigger("pressure", R),
                  B.trigger("pressure " + I.identifier + ":pressure", R),
                  (z = R));
              }.bind(B),
              100
            ));
        }),
        (ci.prototype.onstart = function (_) {
          var I = this,
            R = I.options,
            B = _;
          return (
            (_ = cb(_)),
            I.updateBox(),
            ig(_, function (z) {
              I.actives.length < R.maxNumberOfNipples
                ? I.processOnStart(z)
                : B.type.match(/^touch/) &&
                  (Object.keys(I.manager.ids).forEach(function (R) {
                    if (
                      0 >
                      Object.values(B.touches).findIndex(function (_) {
                        return _.identifier === R;
                      })
                    ) {
                      var z = [_[0]];
                      (z.identifier = R), I.processOnEnd(z);
                    }
                  }),
                  I.actives.length < R.maxNumberOfNipples &&
                    I.processOnStart(z));
            }),
            I.manager.bindDocument(),
            !1
          );
        }),
        (ci.prototype.processOnStart = function (_) {
          var I,
            R = this,
            B = R.options,
            z = R.manager.getIdentifier(_),
            k = _.force || _.pressure || _.webkitForce || 0,
            V = { x: _.pageX, y: _.pageY },
            j = R.getOrCreate(z, V);
          j.identifier !== z && R.manager.removeIdentifier(j.identifier),
            (j.identifier = z);
          var l = function (I) {
            I.trigger("start", I),
              R.trigger("start " + I.id + ":start", I),
              I.show(),
              k > 0 && R.pressureFn(_, I, I.identifier),
              R.processOnMove(_);
          };
          if (
            ((I = R.idles.indexOf(j)) >= 0 && R.idles.splice(I, 1),
            R.actives.push(j),
            R.ids.push(j.identifier),
            "semi" !== B.mode)
          )
            l(j);
          else if (rg(V, j.position) <= B.catchDistance) l(j);
          else {
            j.destroy(), R.processOnStart(_);
            return;
          }
          return j;
        }),
        (ci.prototype.getOrCreate = function (_, I) {
          var R,
            B = this.options;
          return /(semi|static)/.test(B.mode)
            ? (R = this.idles[0])
              ? (this.idles.splice(0, 1), R)
              : "semi" === B.mode
              ? this.createNipple(I, _)
              : (console.warn("Coudln't find the needed nipple."), !1)
            : (R = this.createNipple(I, _));
        }),
        (ci.prototype.processOnMove = function (_) {
          var I = this.options,
            R = this.manager.getIdentifier(_),
            B = this.nipples.get(R),
            z = this.manager.scroll;
          if (!lB(_)) {
            this.processOnEnd(_);
            return;
          }
          if (!B) {
            console.error("Found zombie joystick with ID " + R),
              this.manager.removeIdentifier(R);
            return;
          }
          if (I.dynamicPage) {
            var k = B.el.getBoundingClientRect();
            B.position = { x: z.x + k.left, y: z.y + k.top };
          }
          B.identifier = R;
          var V = B.options.size / 2,
            j = { x: _.pageX, y: _.pageY };
          I.lockX && (j.y = B.position.y), I.lockY && (j.x = B.position.x);
          var G,
            q,
            X = rg(j, B.position),
            Q = oB(j, B.position),
            $ = lb(Q),
            et = X / V,
            er = { distance: X, position: j };
          if (
            ("circle" === B.options.shape
              ? ((G = Math.min(X, V)), (q = aB(B.position, G, Q)))
              : (G = rg((q = dB(j, B.position, V)), B.position)),
            I.follow)
          ) {
            if (X > V) {
              let _ = j.x - q.x,
                I = j.y - q.y;
              (B.position.x += _),
                (B.position.y += I),
                (B.el.style.top = B.position.y - (this.box.top + z.y) + "px"),
                (B.el.style.left = B.position.x - (this.box.left + z.x) + "px"),
                (X = rg(j, B.position));
            }
          } else (j = q), (X = G);
          var es = j.x - B.position.x,
            ea = j.y - B.position.y;
          (B.frontPosition = { x: es, y: ea }),
            I.dataOnly || ub(B.ui.front, B.frontPosition);
          var en = {
            identifier: B.identifier,
            position: j,
            force: et,
            pressure: _.force || _.pressure || _.webkitForce || 0,
            distance: X,
            angle: { radian: $, degree: Q },
            vector: { x: es / V, y: -ea / V },
            raw: er,
            instance: B,
            lockX: I.lockX,
            lockY: I.lockY,
          };
          ((en = B.computeDirection(en)).angle = {
            radian: lb(180 - Q),
            degree: 180 - Q,
          }),
            B.trigger("move", en),
            this.trigger("move " + B.id + ":move", en);
        }),
        (ci.prototype.processOnEnd = function (_) {
          var I = this,
            R = I.options,
            B = I.manager.getIdentifier(_),
            z = I.nipples.get(B),
            k = I.manager.removeIdentifier(z.identifier);
          !z ||
            (R.dataOnly ||
              z.hide(function () {
                "dynamic" === R.mode &&
                  (z.trigger("removed", z),
                  I.trigger("removed " + z.id + ":removed", z),
                  I.manager.trigger("removed " + z.id + ":removed", z),
                  z.destroy());
              }),
            clearInterval(I.pressureIntervals[z.identifier]),
            z.resetDirection(),
            z.trigger("end", z),
            I.trigger("end " + z.id + ":end", z),
            I.ids.indexOf(z.identifier) >= 0 &&
              I.ids.splice(I.ids.indexOf(z.identifier), 1),
            I.actives.indexOf(z) >= 0 &&
              I.actives.splice(I.actives.indexOf(z), 1),
            /(semi|static)/.test(R.mode)
              ? I.idles.push(z)
              : I.nipples.indexOf(z) >= 0 &&
                I.nipples.splice(I.nipples.indexOf(z), 1),
            I.manager.unbindDocument(),
            /(semi|static)/.test(R.mode) &&
              (I.manager.ids[k.id] = k.identifier));
        }),
        (ci.prototype.onDestroyed = function (_, I) {
          this.nipples.indexOf(I) >= 0 &&
            this.nipples.splice(this.nipples.indexOf(I), 1),
            this.actives.indexOf(I) >= 0 &&
              this.actives.splice(this.actives.indexOf(I), 1),
            this.idles.indexOf(I) >= 0 &&
              this.idles.splice(this.idles.indexOf(I), 1),
            this.ids.indexOf(I.identifier) >= 0 &&
              this.ids.splice(this.ids.indexOf(I.identifier), 1),
            this.manager.removeIdentifier(I.identifier),
            this.manager.unbindDocument();
        }),
        (ci.prototype.destroy = function () {
          for (var _ in (this.unbindEvt(this.options.zone, "start"),
          this.nipples.forEach(function (_) {
            _.destroy();
          }),
          this.pressureIntervals))
            this.pressureIntervals.hasOwnProperty(_) &&
              clearInterval(this.pressureIntervals[_]);
          this.trigger("destroyed", this.nipples),
            this.manager.unbindDocument(),
            this.off();
        }),
        ($i.prototype = new fu()),
        ($i.constructor = $i),
        ($i.prototype.prepareCollections = function () {
          var _ = this;
          (_.collections.create = _.create.bind(_)),
            (_.collections.on = _.on.bind(_)),
            (_.collections.off = _.off.bind(_)),
            (_.collections.destroy = _.destroy.bind(_)),
            (_.collections.get = function (I) {
              var R;
              return (
                _.collections.every(function (_) {
                  return !(R = _.get(I));
                }),
                R
              );
            });
        }),
        ($i.prototype.create = function (_) {
          return this.createCollection(_);
        }),
        ($i.prototype.createCollection = function (_) {
          var I = new ci(this, _);
          return this.bindCollection(I), this.collections.push(I), I;
        }),
        ($i.prototype.bindCollection = function (_) {
          var I,
            R = this,
            r = function (_, B) {
              (I = _.type + " " + B.id + ":" + _.type), R.trigger(I, B);
            };
          _.on("destroyed", R.onDestroyed.bind(R)),
            _.on("shown hidden rested dir plain", r),
            _.on("dir:up dir:right dir:down dir:left", r),
            _.on("plain:up plain:right plain:down plain:left", r);
        }),
        ($i.prototype.bindDocument = function () {
          this.binded ||
            (this.bindEvt(document, "move").bindEvt(document, "end"),
            (this.binded = !0));
        }),
        ($i.prototype.unbindDocument = function (_) {
          (Object.keys(this.ids).length && !0 !== _) ||
            (this.unbindEvt(document, "move").unbindEvt(document, "end"),
            (this.binded = !1));
        }),
        ($i.prototype.getIdentifier = function (_) {
          var I;
          return (
            _
              ? void 0 ===
                  (I = void 0 === _.identifier ? _.pointerId : _.identifier) &&
                (I = this.latest || 0)
              : (I = this.index),
            void 0 === this.ids[I] &&
              ((this.ids[I] = this.index), (this.index += 1)),
            (this.latest = I),
            this.ids[I]
          );
        }),
        ($i.prototype.removeIdentifier = function (_) {
          var I = {};
          for (var R in this.ids)
            if (this.ids[R] === _) {
              (I.id = R), (I.identifier = this.ids[R]), delete this.ids[R];
              break;
            }
          return I;
        }),
        ($i.prototype.onmove = function (_) {
          return this.onAny("move", _), !1;
        }),
        ($i.prototype.onend = function (_) {
          return this.onAny("end", _), !1;
        }),
        ($i.prototype.oncancel = function (_) {
          return this.onAny("end", _), !1;
        }),
        ($i.prototype.onAny = function (_, I) {
          var R,
            B = this,
            z = "processOn" + _.charAt(0).toUpperCase() + _.slice(1);
          I = cb(I);
          var s = function (_, I, R) {
            R.ids.indexOf(I) >= 0 && (R[z](_), (_._found_ = !0));
          };
          return (
            ig(I, function (_) {
              (R = B.getIdentifier(_)),
                ig(B.collections, s.bind(null, _, R)),
                _._found_ || B.removeIdentifier(R);
            }),
            !1
          );
        }),
        ($i.prototype.destroy = function () {
          this.unbindDocument(!0),
            (this.ids = {}),
            (this.index = 0),
            this.collections.forEach(function (_) {
              _.destroy();
            }),
            this.off();
        }),
        ($i.prototype.onDestroyed = function (_, I) {
          if (0 > this.collections.indexOf(I)) return !1;
          this.collections.splice(this.collections.indexOf(I), 1);
        });
      var Pm = new $i(),
        Pg = {
          create: function (_) {
            return Pm.create(_);
          },
          factory: Pm,
        },
        Pv = new Map(),
        Py = new Map(),
        Px = class {
          constructor(_, I, R, B) {
            this.data = I;
            let { audio: z, volume: k, delay: V, loop: j } = I;
            if (!z) throw Error("Missing property");
            let G = "string" == typeof z ? B.getAudio(z).src : z.data;
            (this.audioPlayer = new Sz({
              src: G,
              volume: k,
              delay: V,
              loop: j,
            })),
              Py.has(R.uuid)
                ? Py.get(R.uuid).push(this)
                : Py.set(R.uuid, [this]),
              Pv.set(_, this);
          }
          playByToggle() {
            "stop" === this.data.toggle
              ? "playing" === this.audioPlayer.status
                ? this.audioPlayer.stop()
                : (this.audioPlayer.stop(), this.audioPlayer.play())
              : "pause" === this.data.toggle
              ? "playing" === this.audioPlayer.status
                ? this.audioPlayer.pause()
                : this.audioPlayer.play()
              : (this.audioPlayer.stop(), this.audioPlayer.play());
          }
          dispose() {
            this.audioPlayer.stop();
          }
        },
        Pb = class {
          constructor(_) {
            this.data = _;
          }
          dispatch() {
            this.data.playAudio
              ? this.pauseAudio(this.data.playAudio)
              : this.data.object
              ? this.pauseAllAudiosFromObject(this.data.object)
              : this.pauseAllAudios();
          }
          pauseAudio(_) {
            let I = Pv.get(_);
            I &&
              (this.data.delay > 0
                ? (this.disposeDelay(),
                  (this.timeoutId = window.setTimeout(() => {
                    I.audioPlayer[this.data.interaction](), this.disposeDelay();
                  }, this.data.delay)))
                : I.audioPlayer[this.data.interaction]());
          }
          pauseAllAudiosFromObject(_) {
            let I = Py.get(_);
            I?.length &&
              (this.data.delay > 0
                ? (this.disposeDelay(),
                  (this.timeoutId = window.setTimeout(() => {
                    I.forEach((_) => _.audioPlayer[this.data.interaction]()),
                      this.disposeDelay();
                  }, this.data.delay)))
                : I.forEach((_) => _.audioPlayer[this.data.interaction]()));
          }
          pauseAllAudios() {
            let _ = [...Py.values()];
            _.length &&
              (this.data.delay > 0
                ? (this.disposeDelay(),
                  (this.timeoutId = window.setTimeout(() => {
                    _.forEach((_) => {
                      _.forEach((_) => {
                        _.audioPlayer[this.data.interaction]();
                      });
                    }),
                      this.disposeDelay();
                  }, this.data.delay)))
                : _.forEach((_) => {
                    _.forEach((_) => {
                      _.audioPlayer[this.data.interaction]();
                    });
                  }));
          }
          disposeDelay() {
            clearTimeout(this.timeoutId), delete this.timeoutId;
          }
          dispose() {
            clearTimeout(this.timeoutId), delete this.timeoutId;
          }
        },
        P_ = class {
          constructor(_, I, R, B, z) {
            if (
              ((this.data = I),
              (this.shared = B),
              (this.condition = z),
              "play" === I.interaction)
            )
              this.interaction = new Px(_, I, R, B);
            else if ("pause" === I.interaction || "stop" === I.interaction)
              this.interaction = new Pb(I);
            else throw Error("Missing property");
          }
          dispatchBasic() {
            if (!1 === Ut(this.shared, this.condition)) return !1;
            this.interaction instanceof Px
              ? this.interaction.playByToggle()
              : this.interaction.dispatch();
          }
          dispatchConditional() {
            if (!1 === Ut(this.shared, this.condition)) return !1;
            this.interaction instanceof Px
              ? this.interaction.audioPlayer.play()
              : this.interaction.dispatch();
          }
          dispatchGameControl(_) {
            if (!1 === Ut(this.shared, this.condition)) return !1;
            this.interaction instanceof Px &&
              ("start" === _
                ? this.interaction.audioPlayer.play()
                : this.interaction.audioPlayer.stop());
          }
          dispose() {
            this.interaction.dispose();
          }
        },
        PS = class {
          constructor(_, I, R, B) {
            (this.data = _),
              (this.page = I),
              (this.shared = R),
              (this.condition = B),
              (this.delay = 0),
              (this.emission = _.emission),
              void 0 !== _.delay && (this.delay = _.delay),
              (this.particleSystem = this.page.scene.find(
                this.data.emitterObjectId
              ));
          }
          toggleEmitting() {
            this.particleSystem.started && !this.particleSystem.stopped
              ? this.stop()
              : this.start(this.delay);
          }
          toggleFroze() {
            this.particleSystem.started && !this.particleSystem.isFrozen
              ? this.freeze()
              : this.unFreeze();
          }
          start(_ = 0) {
            if (_) {
              this.delayTimerId = window.setTimeout(() => {
                this.start(0), this.clearDelay();
              }, this.delay);
              return;
            }
            this.particleSystem.start();
          }
          stop() {
            this.particleSystem.stop(), this.clearDelay();
          }
          freeze() {
            this.particleSystem.froze(), this.clearDelay();
          }
          unFreeze() {
            this.particleSystem.unFroze(), this.clearDelay();
          }
          reset() {
            this.particleSystem.reset(), this.clearDelay();
          }
          reverseFromCurrent() {
            switch (this.emission) {
              case "emitToggle":
                this.toggleEmitting();
                break;
              case "pauseToggle":
                this.toggleFroze();
            }
          }
          dispatchBasic() {
            if (!1 === Ut(this.shared, this.condition) || !this.particleSystem)
              return !1;
            switch (this.emission) {
              case "start":
                this.start(this.delay);
                break;
              case "emitToggle":
                this.toggleEmitting();
                break;
              case "pause":
                this.freeze();
                break;
              case "pauseToggle":
                this.toggleFroze();
                break;
              case "stop":
                this.stop();
                break;
              case "reset":
                this.reset();
            }
          }
          dispatchConditional() {
            if (!1 === Ut(this.shared, this.condition) || !this.particleSystem)
              return !1;
            switch (this.emission) {
              case "start":
                this.particleSystem.start();
                break;
              case "stop":
                this.particleSystem.stop();
                break;
              case "reset":
                this.particleSystem.reset();
            }
          }
          dispatchGameControl(_) {
            if (!1 === Ut(this.shared, this.condition) || !this.particleSystem)
              return !1;
            "start" === _
              ? this.particleSystem.start()
              : this.particleSystem.stop();
          }
          dispose() {
            this.particleSystem &&
              (this.particleSystem.reset(), this.clearDelay());
          }
          clearDelay() {
            this.delayTimerId &&
              (clearTimeout(this.delayTimerId), delete this.delayTimerId);
          }
        },
        wB = (_, I) =>
          I.some((I) => (I instanceof RegExp ? I.test(_) : I === _)),
        jK = (_, { stripHash: I }) => {
          let R =
            /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(_);
          if (!R) throw Error(`Invalid URL: ${_}`);
          let { type: B, data: z, hash: k } = R.groups,
            V = B.split(";");
          k = I ? "" : k;
          let j = !1;
          "base64" === V[V.length - 1] && (V.pop(), (j = !0));
          let G = (V.shift() || "").toLowerCase(),
            q = [
              ...V.map((_) => {
                let [I, R = ""] = _.split("=").map((_) => _.trim());
                return "charset" === I && "us-ascii" === (R = R.toLowerCase())
                  ? ""
                  : `${I}${R ? `=${R}` : ""}`;
              }).filter(Boolean),
            ];
          return (
            j && q.push("base64"),
            (q.length > 0 || (G && "text/plain" !== G)) && q.unshift(G),
            `data:${q.join(";")},${j ? z.trim() : z}${k ? `#${k}` : ""}`
          );
        },
        PA = class {
          constructor({ url: _, context: I }, R, B, z) {
            if (
              ((this.controlsManager = R),
              (this.shared = B),
              (this.condition = z),
              !_)
            )
              throw Error("Missing property");
            (this.url = _.startsWith("mailto:")
              ? _
              : (function (_, I) {
                  if (
                    ((I = {
                      defaultProtocol: "http:",
                      normalizeProtocol: !0,
                      forceHttp: !1,
                      forceHttps: !1,
                      stripAuthentication: !0,
                      stripHash: !1,
                      stripTextFragment: !0,
                      stripWWW: !0,
                      removeQueryParameters: [/^utm_\w+/i],
                      removeTrailingSlash: !0,
                      removeSingleSlash: !0,
                      removeDirectoryIndex: !1,
                      sortQueryParameters: !0,
                      ...I,
                    }),
                    (_ = _.trim()),
                    /^data:/i.test(_))
                  )
                    return jK(_, I);
                  if (/^view-source:/i.test(_))
                    throw Error(
                      "`view-source:` is not supported as it is a non-standard protocol"
                    );
                  let R = _.startsWith("//");
                  (!R && /^\.*\//.test(_)) ||
                    (_ = _.replace(
                      /^(?!(?:\w+:)?\/\/)|^\/\//,
                      I.defaultProtocol
                    ));
                  let B = new URL(_);
                  if (I.forceHttp && I.forceHttps)
                    throw Error(
                      "The `forceHttp` and `forceHttps` options cannot be used together"
                    );
                  if (
                    (I.forceHttp &&
                      "https:" === B.protocol &&
                      (B.protocol = "http:"),
                    I.forceHttps &&
                      "http:" === B.protocol &&
                      (B.protocol = "https:"),
                    I.stripAuthentication &&
                      ((B.username = ""), (B.password = "")),
                    I.stripHash
                      ? (B.hash = "")
                      : I.stripTextFragment &&
                        (B.hash = B.hash.replace(/#?:~:text.*?$/i, "")),
                    B.pathname)
                  ) {
                    let _ = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g,
                      I = 0,
                      R = "";
                    for (;;) {
                      let z = _.exec(B.pathname);
                      if (!z) break;
                      let k = z[0],
                        V = z.index;
                      (R += B.pathname.slice(I, V).replace(/\/{2,}/g, "/") + k),
                        (I = V + k.length);
                    }
                    (R += B.pathname
                      .slice(I, B.pathname.length)
                      .replace(/\/{2,}/g, "/")),
                      (B.pathname = R);
                  }
                  if (B.pathname)
                    try {
                      B.pathname = decodeURI(B.pathname);
                    } catch {}
                  if (
                    (!0 === I.removeDirectoryIndex &&
                      (I.removeDirectoryIndex = [/^index\.[a-z]+$/]),
                    Array.isArray(I.removeDirectoryIndex) &&
                      I.removeDirectoryIndex.length > 0)
                  ) {
                    let _ = B.pathname.split("/");
                    wB(_[_.length - 1], I.removeDirectoryIndex) &&
                      ((_ = _.slice(0, -1)),
                      (B.pathname = _.slice(1).join("/") + "/"));
                  }
                  if (
                    (B.hostname &&
                      ((B.hostname = B.hostname.replace(/\.$/, "")),
                      I.stripWWW &&
                        /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(
                          B.hostname
                        ) &&
                        (B.hostname = B.hostname.replace(/^www\./, ""))),
                    Array.isArray(I.removeQueryParameters))
                  )
                    for (let _ of [...B.searchParams.keys()])
                      wB(_, I.removeQueryParameters) &&
                        B.searchParams.delete(_);
                  if (
                    (!0 === I.removeQueryParameters && (B.search = ""),
                    I.sortQueryParameters)
                  ) {
                    B.searchParams.sort();
                    try {
                      B.search = decodeURIComponent(B.search);
                    } catch {}
                  }
                  I.removeTrailingSlash &&
                    (B.pathname = B.pathname.replace(/\/$/, ""));
                  let z = _;
                  return (
                    (_ = B.toString()),
                    I.removeSingleSlash ||
                      "/" !== B.pathname ||
                      z.endsWith("/") ||
                      "" !== B.hash ||
                      (_ = _.replace(/\/$/, "")),
                    (I.removeTrailingSlash || "/" === B.pathname) &&
                      "" === B.hash &&
                      I.removeSingleSlash &&
                      (_ = _.replace(/\/$/, "")),
                    R &&
                      !I.normalizeProtocol &&
                      (_ = _.replace(/^http:\/\//, "//")),
                    I.stripProtocol && (_ = _.replace(/^(?:https?:)?\/\//, "")),
                    _
                  );
                })(_, { removeTrailingSlash: !1, removeSingleSlash: !1 })),
              (this.context = I ?? "tab");
          }
          dispatch() {
            if (!1 === Ut(this.shared, this.condition)) return !1;
            uc
              ? window.location.assign(this.url)
              : ("tab" === this.context
                  ? window.open(this.url, "_blank")
                  : "window" === this.context
                  ? window.open(
                      this.url,
                      "_blank",
                      `width=${window.innerWidth}, height=${window.innerHeight}`
                    )
                  : window.open(this.url, "_parent"),
                this.controlsManager.orbitControls?.onPointerUp(um[0]),
                um.splice(0, um.length));
          }
        },
        PE = class {
          constructor(_, I, R, B, z) {
            (this.data = _),
              (this.page = I),
              (this.controlsManager = R),
              (this.shared = B),
              (this.condition = z),
              (this.timeoutIdQueue = []),
              (this.dispatchInner = () => {
                this.objects.forEach(this.destroyCallback);
              }),
              (this.destroyCallback = (_) => {
                this.timeoutIdQueue.shift();
                let I = this.page.scene.find(_);
                if (void 0 === I) return;
                let R =
                    this.controlsManager.sharedGameControlGlobals.rapierWorld,
                  B = !R || I.dataPatched.physics?.fusedBody;
                if (I.cloner) {
                  for (let _ of I.cloner.children)
                    B
                      ? ((_.playModeVisible = !1),
                        _.rigidBody &&
                          I.dataPatched.physics?.rigidBody === "positioned" &&
                          (this.controlsManager.sharedGameControlGlobals.colliderToEntity.delete(
                            _.rigidBody.collider(0).handle
                          ),
                          R.removeRigidBody(_.rigidBody),
                          (_.rigidBody = void 0)),
                        _.bvhGeometry && (_.bvhGeometry = void 0))
                      : void 0 === this.clone || this.clone === _
                      ? ((_.playModeVisible = !1),
                        _.rigidBody &&
                          (this.controlsManager.sharedGameControlGlobals.colliderToEntity.delete(
                            _.rigidBody.collider(0).handle
                          ),
                          R.removeRigidBody(_.rigidBody),
                          (_.rigidBody = void 0)))
                      : void 0 === _.playModeVisible &&
                        (_.playModeVisible = !0);
                  (B || void 0 === this.clone || !1 === this.clone) &&
                    ((I.visible = !1),
                    I.rigidBody &&
                      (this.controlsManager.sharedGameControlGlobals.colliderToEntity.delete(
                        I.rigidBody.collider(0).handle
                      ),
                      R.removeRigidBody(I.rigidBody),
                      (I.rigidBody = void 0)),
                    I.bvhGeometry && (I.bvhGeometry = void 0));
                } else
                  I.rigidBody &&
                    (this.controlsManager.sharedGameControlGlobals.colliderToEntity.delete(
                      I.rigidBody.collider(0).handle
                    ),
                    R.removeRigidBody(I.rigidBody),
                    (I.rigidBody = void 0)),
                    I.bvhGeometry && (I.bvhGeometry = void 0),
                    (I.visible = !1);
                void 0 === R
                  ? (this.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim =
                      this.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim.filter(
                        (_) => void 0 !== _.bvhGeometry
                      ))
                  : (this.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim =
                      this.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim.filter(
                        (_) => void 0 !== _.rigidBody
                      )),
                  (I.destroyedInAction = !0),
                  this.controlsManager.requestRender();
              }),
              (this.objects = [..._.objects]);
          }
          dispatch(_) {
            if (!1 === Ut(this.shared, this.condition)) return !1;
            (this.clone = _),
              this.data.delay
                ? this.timeoutIdQueue.push(
                    window.setTimeout(this.dispatchInner, 1e3 * this.data.delay)
                  )
                : this.dispatchInner();
          }
          dispatchFromStart() {
            if (!1 === Ut(this.shared, this.condition)) return !1;
            this.timeoutIdQueue.push(
              window.setTimeout(this.dispatchInner, 1e3 * this.data.delay)
            );
          }
          dispose() {
            this.timeoutIdQueue.forEach((_) => window.clearTimeout(_));
          }
        },
        PT = class {
          constructor(_, I, R, B, z) {
            (this.data = _),
              (this.page = I),
              (this.shared = R),
              (this.eventManager = B),
              (this.condition = z),
              (this.shared = R);
          }
          dispatch() {
            if (!1 === Ut(this.shared, this.condition)) return !1;
            clearTimeout(this.timeoutId),
              delete this.timeoutId,
              (this.timeoutId = window.setTimeout(() => {
                this.shared.reset(this.shared.data, !0),
                  qf(this.page, this.shared, !0),
                  this.eventManager.reset(),
                  this.eventManager.controlsManager.gameControl?.reset(!0),
                  this.page.switchToPlayCamera(),
                  this.eventManager.controlsManager.requestRender(),
                  delete this.timeoutId;
              }, (this.data.delay ?? 0) * 1e3));
          }
          dispose() {
            clearTimeout(this.timeoutId), delete this.timeoutId;
          }
        },
        PP = {
          update: null,
          begin: null,
          loopBegin: null,
          changeBegin: null,
          change: null,
          changeComplete: null,
          timelineChangeComplete: null,
          loopComplete: null,
          complete: null,
          loop: 1,
          direction: "normal",
          autoplay: !0,
          timelineOffset: 0,
          rewind: !0,
        },
        PD = {
          duration: 1e3,
          delay: 0,
          endDelay: 0,
          startOnceDelay: 0,
          pingPongDelayCorrection: 0,
          pingPongEndDelayCorrection: 0,
          easing: "easeOutElastic(1, .5)",
          round: 0,
        },
        PO = [
          "translateX",
          "translateY",
          "translateZ",
          "rotate",
          "rotateX",
          "rotateY",
          "rotateZ",
          "scale",
          "scaleX",
          "scaleY",
          "scaleZ",
          "skew",
          "skewX",
          "skewY",
          "perspective",
          "matrix",
          "matrix3d",
        ],
        PI = { CSS: {}, springs: {} };
      function po(_, I, R) {
        return Math.min(Math.max(_, I), R);
      }
      function hg(_, I) {
        return _.indexOf(I) > -1;
      }
      function dE(_, I) {
        return _.apply(null, I);
      }
      var PR = {
        arr: function (_) {
          return Array.isArray(_);
        },
        obj: function (_) {
          return hg(Object.prototype.toString.call(_), "Object");
        },
        pth: function (_) {
          return PR.obj(_) && _.hasOwnProperty("totalLength");
        },
        svg: function (_) {
          return _ instanceof SVGElement;
        },
        inp: function (_) {
          return _ instanceof HTMLInputElement;
        },
        dom: function (_) {
          return !("isNode" in _) && (_.nodeType || PR.svg(_));
        },
        str: function (_) {
          return "string" == typeof _;
        },
        fnc: function (_) {
          return "function" == typeof _;
        },
        und: function (_) {
          return typeof _ > "u";
        },
        hex: function (_) {
          return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(_);
        },
        rgb: function (_) {
          return /^rgb/.test(_);
        },
        hsl: function (_) {
          return /^hsl/.test(_);
        },
        col: function (_) {
          return PR.hex(_) || PR.rgb(_) || PR.hsl(_);
        },
        key: function (_) {
          return (
            !PP.hasOwnProperty(_) &&
            !PD.hasOwnProperty(_) &&
            "targets" !== _ &&
            "keyframes" !== _
          );
        },
      };
      function PB(_) {
        var I = /\(([^)]+)\)/.exec(_);
        return I
          ? I[1].split(",").map(function (_) {
              return parseFloat(_);
            })
          : [];
      }
      function DB(_, I) {
        var R = PB(_),
          B = po(PR.und(R[0]) ? 1 : R[0], 0.1, 100),
          z = po(PR.und(R[1]) ? 100 : R[1], 0.1, 100),
          k = po(PR.und(R[2]) ? 10 : R[2], 0.1, 100),
          V = po(PR.und(R[3]) ? 0 : R[3], 0.1, 100),
          j = Math.sqrt(z / B),
          G = k / (2 * Math.sqrt(z * B)),
          q = G < 1 ? j * Math.sqrt(1 - G * G) : 0,
          X = G < 1 ? (G * j + -V) / q : -V + j;
        function d(_) {
          var R = I ? (I * _) / 1e3 : _;
          return (
            (R =
              G < 1
                ? Math.exp(-R * G * j) *
                  (1 * Math.cos(q * R) + X * Math.sin(q * R))
                : (1 + X * R) * Math.exp(-R * j)),
            0 === _ || 1 === _ ? _ : 1 - R
          );
        }
        return I
          ? d
          : function () {
              var I = PI.springs[_];
              if (I) return I;
              for (var R = 1 / 6, B = 0, z = 0; ; )
                if (1 === d((B += R))) {
                  if (++z >= 16) break;
                } else z = 0;
              var k = B * R * 1e3;
              return (PI.springs[_] = k), k;
            };
      }
      function WK(_) {
        return (
          void 0 === _ && (_ = 10),
          function (I) {
            return Math.ceil(po(I, 1e-6, 1) * _) * (1 / _);
          }
        );
      }
      var Pz = (function () {
          function s(_, I, R) {
            return (
              (((1 - 3 * R + 3 * I) * _ + (3 * R - 6 * I)) * _ + 3 * I) * _
            );
          }
          function o(_, I, R) {
            return (
              3 * (1 - 3 * R + 3 * I) * _ * _ + 2 * (3 * R - 6 * I) * _ + 3 * I
            );
          }
          return function (_, I, R, B) {
            if (0 <= _ && _ <= 1 && 0 <= R && R <= 1) {
              var z = new Float32Array(11);
              if (_ !== I || R !== B)
                for (var k = 0; k < 11; ++k) z[k] = s(0.1 * k, _, R);
              return function (k) {
                return (_ === I && R === B) || 0 === k || 1 === k
                  ? k
                  : s(
                      (function (I) {
                        for (var B = 0, k = 1; 10 !== k && z[k] <= I; ++k)
                          B += 0.1;
                        var V = B + ((I - z[--k]) / (z[k + 1] - z[k])) * 0.1,
                          j = o(V, _, R);
                        return j >= 0.001
                          ? (function (_, I, R, B) {
                              for (var z = 0; z < 4; ++z) {
                                var k = o(I, R, B);
                                if (0 === k) break;
                                var V = s(I, R, B) - _;
                                I -= V / k;
                              }
                              return I;
                            })(I, V, _, R)
                          : 0 === j
                          ? V
                          : (function (_, I, R, B, z) {
                              var k,
                                V,
                                j = 0;
                              do
                                (k = s((V = I + (R - I) / 2), B, z) - _) > 0
                                  ? (R = V)
                                  : (I = V);
                              while (Math.abs(k) > 1e-7 && ++j < 10);
                              return V;
                            })(I, B, B + 0.1, _, R);
                      })(k),
                      I,
                      B
                    );
              };
            }
          };
        })(),
        PF =
          ((PV = {
            linear: function () {
              return function (_) {
                return _;
              };
            },
          }),
          (Pj = {
            Sine: function () {
              return function (_) {
                return 1 - Math.cos((_ * Math.PI) / 2);
              };
            },
            Circ: function () {
              return function (_) {
                return 1 - Math.sqrt(1 - _ * _);
              };
            },
            Back: function () {
              return function (_) {
                return _ * _ * (3 * _ - 2);
              };
            },
            Bounce: function () {
              return function (_) {
                for (var I, R = 4; _ < ((I = Math.pow(2, --R)) - 1) / 11; );
                return (
                  1 / Math.pow(4, 3 - R) -
                  7.5625 * Math.pow((3 * I - 2) / 22 - _, 2)
                );
              };
            },
            Elastic: function (_, I) {
              void 0 === _ && (_ = 1), void 0 === I && (I = 0.5);
              var R = po(_, 1, 10),
                B = po(I, 0.1, 2);
              return function (_) {
                return 0 === _ || 1 === _
                  ? _
                  : -R *
                      Math.pow(2, 10 * (_ - 1)) *
                      Math.sin(
                        ((_ - 1 - (B / (2 * Math.PI)) * Math.asin(1 / R)) *
                          (2 * Math.PI)) /
                          B
                      );
              };
            },
          }),
          ["Quad", "Cubic", "Quart", "Quint", "Expo"].forEach(function (_, I) {
            Pj[_] = function () {
              return function (_) {
                return Math.pow(_, I + 2);
              };
            };
          }),
          Object.keys(Pj).forEach(function (_) {
            var I = Pj[_];
            (PV["easeIn" + _] = I),
              (PV["easeOut" + _] = function (_, R) {
                return function (B) {
                  return 1 - I(_, R)(1 - B);
                };
              }),
              (PV["easeInOut" + _] = function (_, R) {
                return function (B) {
                  return B < 0.5
                    ? I(_, R)(2 * B) / 2
                    : 1 - I(_, R)(-2 * B + 2) / 2;
                };
              });
          }),
          PV);
      function gE(_, I) {
        if (PR.fnc(_)) return _;
        var R = _.split("(")[0],
          B = PF[R],
          z = PB(_);
        switch (R) {
          case "spring":
            return DB(_, I);
          case "cubicBezier":
            return dE(Pz, z);
          case "steps":
            return dE(WK, z);
          default:
            return dE(B, z);
        }
      }
      function IB(_) {
        try {
          return document.querySelectorAll(_);
        } catch {
          return;
        }
      }
      function yb(_, I) {
        for (
          var R = _.length,
            B = arguments.length >= 2 ? arguments[1] : void 0,
            z = [],
            k = 0;
          k < R;
          k++
        )
          if (k in _) {
            var V = _[k];
            I.call(B, V, k, _) && z.push(V);
          }
        return z;
      }
      function vb(_) {
        return _.reduce(function (_, I) {
          return _.concat(PR.arr(I) ? vb(I) : I);
        }, []);
      }
      function AB(_) {
        return PR.arr(_)
          ? _
          : (PR.str(_) && (_ = IB(_) || _),
            _ instanceof NodeList || _ instanceof HTMLCollection
              ? [].slice.call(_)
              : [_]);
      }
      function yE(_, I) {
        return _.some(function (_) {
          return _ === I;
        });
      }
      function vE(_) {
        var I = {};
        for (var R in _) I[R] = _[R];
        return I;
      }
      function fE(_, I) {
        var R = vE(_);
        for (var B in _) R[B] = I.hasOwnProperty(B) ? I[B] : _[B];
        return R;
      }
      function xb(_, I) {
        var R = vE(_);
        for (var B in I) R[B] = PR.und(_[B]) ? I[B] : _[B];
        return R;
      }
      function Xa(_) {
        var I =
          /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(
            _
          );
        if (I) return I[1];
      }
      function pE(_, I) {
        return PR.fnc(_) ? _(I.target, I.id, I.total) : _;
      }
      function ra(_, I) {
        return _.getAttribute(I);
      }
      function xE(_, I, R) {
        if (yE([R, "deg", "rad", "turn"], Xa(I))) return I;
        var B = PI.CSS[I + R];
        if (!PR.und(B)) return B;
        var z = document.createElement(_.tagName),
          k =
            _.parentNode && _.parentNode !== document
              ? _.parentNode
              : document.body;
        k.appendChild(z),
          (z.style.position = "absolute"),
          (z.style.width = 100 + R);
        var V = 100 / z.offsetWidth;
        k.removeChild(z);
        var j = V * parseFloat(I);
        return (PI.CSS[I + R] = j), j;
      }
      function RB(_, I, R) {
        if (I in _.style) {
          var B = I.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
            z = _.style[I] || getComputedStyle(_).getPropertyValue(B) || "0";
          return R ? xE(_, z, R) : z;
        }
      }
      function bE(_, I) {
        return PR.dom(_) && !PR.inp(_) && (ra(_, I) || (PR.svg(_) && _[I]))
          ? "attribute"
          : PR.dom(_) && yE(PO, I)
          ? "transform"
          : PR.dom(_) && "transform" !== I && RB(_, I)
          ? "css"
          : null != _[I]
          ? "object"
          : void 0;
      }
      function LB(_) {
        if (PR.dom(_)) {
          for (
            var I,
              R = _.style.transform || "",
              B = /(\w+)\(([^)]*)\)/g,
              z = new Map();
            (I = B.exec(R));

          )
            z.set(I[1], I[2]);
          return z;
        }
      }
      function SE(_, I, R, B) {
        switch (bE(_, I)) {
          case "transform":
            var z, k;
            return (
              (z = hg(I, "scale")
                ? 1
                : 0 +
                  (hg(I, "translate") || "perspective" === I
                    ? "px"
                    : hg(I, "rotate") || hg(I, "skew")
                    ? "deg"
                    : void 0)),
              (k = LB(_).get(I) || z),
              B && (B.transforms.list.set(I, k), (B.transforms.last = I)),
              R ? xE(_, k, R) : k
            );
          case "css":
            return RB(_, I, R);
          case "attribute":
            return ra(_, I);
          default:
            return _[I] || 0;
        }
      }
      function wE(_, I) {
        var R = /^(\*=|\+=|-=)/.exec(_);
        if (!R) return _;
        var B = Xa(_) || 0,
          z = parseFloat(I),
          k = parseFloat(_.replace(R[0], ""));
        switch (R[0][0]) {
          case "+":
            return z + k + B;
          case "-":
            return z - k + B;
          case "*":
            return z * k + B;
        }
      }
      function BB(_, I) {
        if (PR.col(_)) {
          var R, B, z, k;
          return (
            (R = _),
            PR.rgb(R)
              ? (B = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(R))
                ? "rgba(" + B[1] + ",1)"
                : R
              : PR.hex(R)
              ? ((z = R.replace(
                  /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
                  function (_, I, R, B) {
                    return I + I + R + R + B + B;
                  }
                )),
                "rgba(" +
                  parseInt(
                    (k = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(
                      z
                    ))[1],
                    16
                  ) +
                  "," +
                  parseInt(k[2], 16) +
                  "," +
                  parseInt(k[3], 16) +
                  ",1)")
              : PR.hsl(R)
              ? (function (_) {
                  var I,
                    R,
                    B,
                    z =
                      /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(_) ||
                      /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(
                        _
                      ),
                    k = parseInt(z[1], 10) / 360,
                    V = parseInt(z[2], 10) / 100,
                    j = parseInt(z[3], 10) / 100,
                    G = z[4] || 1;
                  function o(_, I, R) {
                    return (
                      R < 0 && (R += 1),
                      R > 1 && (R -= 1),
                      R < 1 / 6
                        ? _ + (I - _) * 6 * R
                        : R < 0.5
                        ? I
                        : R < 2 / 3
                        ? _ + (I - _) * (2 / 3 - R) * 6
                        : _
                    );
                  }
                  if (0 == V) I = R = B = j;
                  else {
                    var q = j < 0.5 ? j * (1 + V) : j + V - j * V,
                      X = 2 * j - q;
                    (I = o(X, q, k + 1 / 3)),
                      (R = o(X, q, k)),
                      (B = o(X, q, k - 1 / 3));
                  }
                  return (
                    "rgba(" +
                    255 * I +
                    "," +
                    255 * R +
                    "," +
                    255 * B +
                    "," +
                    G +
                    ")"
                  );
                })(R)
              : void 0
          );
        }
        if (/\s/g.test(_)) return _;
        var V = Xa(_),
          j = V ? _.substr(0, _.length - V.length) : _;
        return I ? j + I : j;
      }
      function AE(_, I) {
        return Math.sqrt(Math.pow(I.x - _.x, 2) + Math.pow(I.y - _.y, 2));
      }
      function NB(_) {
        for (var I, R = _.points, B = 0, z = 0; z < R.numberOfItems; z++) {
          var k = R.getItem(z);
          z > 0 && (B += AE(I, k)), (I = k);
        }
        return B;
      }
      function FB(_) {
        var I;
        if (_.getTotalLength) return _.getTotalLength();
        switch (_.tagName.toLowerCase()) {
          case "circle":
            return 2 * Math.PI * ra(_, "r");
          case "rect":
            return 2 * ra(_, "width") + 2 * ra(_, "height");
          case "line":
            return AE(
              { x: ra(_, "x1"), y: ra(_, "y1") },
              { x: ra(_, "x2"), y: ra(_, "y2") }
            );
          case "polyline":
            return NB(_);
          case "polygon":
            return (
              (I = _.points),
              NB(_) + AE(I.getItem(I.numberOfItems - 1), I.getItem(0))
            );
        }
      }
      function kB(_, I) {
        var R = I || {},
          B =
            R.el ||
            (function (_) {
              for (var I = _.parentNode; PR.svg(I) && PR.svg(I.parentNode); )
                I = I.parentNode;
              return I;
            })(_),
          z = B.getBoundingClientRect(),
          k = ra(B, "viewBox"),
          V = z.width,
          j = z.height,
          G = R.viewBox || (k ? k.split(" ") : [0, 0, V, j]);
        return {
          el: B,
          viewBox: G,
          x: G[0] / 1,
          y: G[1] / 1,
          w: V / G[2],
          h: j / G[3],
        };
      }
      function _B(_, I) {
        var R = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g,
          B = BB(PR.pth(_) ? _.totalLength : _, I) + "";
        return {
          original: B,
          numbers: B.match(R) ? B.match(R).map(Number) : [0],
          strings: PR.str(_) || I ? B.split(R) : [],
        };
      }
      function VB(_) {
        return yb(
          _ ? vb(PR.arr(_) ? _.map(AB) : AB(_)) : [],
          function (_, I, R) {
            return R.indexOf(_) === I;
          }
        );
      }
      function zB(_) {
        var I = VB(_);
        return I.map(function (_, R) {
          return {
            target: _,
            id: R,
            total: I.length,
            transforms: { list: LB(_) },
          };
        });
      }
      var PN = {
        css: function (_, I, R) {
          return (_.style[I] = R);
        },
        attribute: function (_, I, R) {
          return _.setAttribute(I, R);
        },
        object: function (_, I, R) {
          return (_[I] = R);
        },
        transform: function (_, I, R, B, z) {
          if ((B.list.set(I, R), I === B.last || z)) {
            var k = "";
            B.list.forEach(function (_, I) {
              k += I + "(" + _ + ") ";
            }),
              (_.style.transform = k);
          }
        },
      };
      function GB(_, I) {
        zB(_).forEach(function (_) {
          for (var R in I) {
            var B = pE(I[R], _),
              z = _.target,
              k = Xa(B),
              V = SE(z, R, k, _),
              j = wE(BB(B, k || Xa(V)), V);
            PN[bE(z, R)](z, R, j, _.transforms, !0);
          }
        });
      }
      function jB(_, I) {
        var R = _.length,
          r = function (_) {
            return _.timelineOffset ? _.timelineOffset : 0;
          },
          B = {};
        return (
          (B.duration = R
            ? Math.max.apply(
                Math,
                _.map(function (_) {
                  let I = _.startOnceDelay ?? 0,
                    R = _.pingPongDelayCorrection ?? 0,
                    B = _.pingPongEndDelayCorrection ?? 0;
                  return r(_) + I + R + B + _.duration * (_.loop ?? 1);
                })
              )
            : I.duration),
          (B.delay = R
            ? Math.min.apply(
                Math,
                _.map(function (_) {
                  let I = _.startOnceDelay ?? 0,
                    R = _.pingPongDelayCorrection ?? 0;
                  return r(_) + I + R + _.delay;
                })
              )
            : I.delay),
          (B.endDelay = R
            ? B.duration -
              Math.max.apply(
                Math,
                _.map(function (_) {
                  let I = _.startOnceDelay ?? 0,
                    R = _.pingPongDelayCorrection ?? 0,
                    B = _.pingPongEndDelayCorrection ?? 0;
                  return (
                    r(_) + I + R + _.duration * (_.loop ?? 1) - _.endDelay - B
                  );
                })
              )
            : I.endDelay),
          B
        );
      }
      var PV,
        Pj,
        PH,
        PW = 0,
        Pq = [],
        PY = [],
        PX = (function () {
          function n() {
            PH = requestAnimationFrame(t);
          }
          function t(_) {
            var I = Pq.length;
            if (I) {
              for (var R = 0; R < I; ) {
                var B = Pq[R];
                B.paused ? (Pq.splice(R, 1), (I -= 1)) : (B.tick(_), R++);
              }
              n();
            } else PH = cancelAnimationFrame(PH);
          }
          return n;
        })();
      function ui(_) {
        void 0 === _ && (_ = {});
        var I,
          R,
          B,
          z,
          k,
          V,
          j,
          G,
          q,
          X,
          Q = 0,
          $ = 0,
          et = 0,
          er = 0,
          es = null;
        function l(_) {
          var I =
            window.Promise &&
            new Promise(function (_) {
              return (es = _);
            });
          return (_.finished = I), I;
        }
        var ea =
          ((R = fE(PP, (I = _))),
          (z = (function (_, I) {
            var R = [],
              B = I.keyframes;
            for (var z in (B &&
              (I = xb(
                (function (_) {
                  for (
                    var I = yb(
                        vb(
                          _.map(function (_) {
                            return Object.keys(_);
                          })
                        ),
                        function (_) {
                          return PR.key(_);
                        }
                      ).reduce(function (_, I) {
                        return 0 > _.indexOf(I) && _.push(I), _;
                      }, []),
                      R = {},
                      B = 0;
                    B < I.length;
                    B++
                  )
                    !(function (B) {
                      var z = I[B];
                      R[z] = _.map(function (_) {
                        var I = {};
                        for (var R in _)
                          PR.key(R)
                            ? R == z && (I.value = _[R])
                            : (I[R] = _[R]);
                        return I;
                      });
                    })(B);
                  return R;
                })(B),
                I
              )),
            I))
              PR.key(z) &&
                R.push({
                  name: z,
                  tweens: (function (_, I) {
                    var R = vE(I);
                    if (
                      (/^spring/.test(R.easing) && (R.duration = DB(R.easing)),
                      PR.arr(_))
                    ) {
                      var B = _.length;
                      2 !== B || PR.obj(_[0])
                        ? PR.fnc(I.duration) || (R.duration = I.duration / B)
                        : (_ = { value: _ });
                    }
                    var z = PR.arr(_) ? _ : [_];
                    return z
                      .map(function (_, R) {
                        var B = PR.obj(_) && !PR.pth(_) ? _ : { value: _ };
                        return (
                          PR.und(B.delay) && (B.delay = R ? 0 : I.delay),
                          PR.und(B.endDelay) &&
                            (B.endDelay = R === z.length - 1 ? I.endDelay : 0),
                          B
                        );
                      })
                      .map(function (_) {
                        return xb(_, R);
                      });
                  })(I[z], _),
                });
            return R;
          })((B = fE(PD, I)), I)),
          (j = jB(
            (V = yb(
              vb(
                (k = zB(I.targets)).map(function (_) {
                  return z.map(function (I) {
                    return (function (_, I) {
                      var R = bE(_.target, I.name);
                      if (R) {
                        var B,
                          z = I.tweens.map(function (R) {
                            var z = (function (_, I) {
                                var R = {};
                                for (var B in _) {
                                  var z = pE(_[B], I);
                                  PR.arr(z) &&
                                    1 ===
                                      (z = z.map(function (_) {
                                        return pE(_, I);
                                      })).length &&
                                    (z = z[0]),
                                    (R[B] = z);
                                }
                                return (
                                  (R.duration = parseFloat(R.duration)),
                                  (R.delay = parseFloat(R.delay)),
                                  R
                                );
                              })(R, _),
                              k = z.value,
                              V = PR.arr(k) ? k[1] : k,
                              j = Xa(V),
                              G = SE(_.target, I.name, j, _),
                              q = B ? B.to.original : G,
                              X = PR.arr(k) ? k[0] : q,
                              Q = Xa(X) || Xa(G),
                              $ = j || Q;
                            return (
                              PR.und(V) && (V = q),
                              (z.from = _B(X, $)),
                              (z.to = _B(wE(V, X), $)),
                              (z.start = B ? B.end : 0),
                              (z.end =
                                z.start + z.delay + z.duration + z.endDelay),
                              (z.easing = gE(z.easing, z.duration)),
                              (z.isPath = PR.pth(k)),
                              (z.isColor = PR.col(z.from.original)),
                              z.isColor && (z.round = 1),
                              (B = z),
                              z
                            );
                          }),
                          k = z[z.length - 1];
                        return {
                          type: R,
                          property: I.name,
                          animatable: _,
                          tweens: z,
                          duration: k.end,
                          delay: z[0].delay,
                          endDelay: k.endDelay,
                        };
                      }
                    })(_, I);
                  });
                })
              ),
              function (_) {
                return !PR.und(_);
              }
            )),
            B
          )),
          (G = PW),
          PW++,
          xb(R, {
            id: G,
            children: [],
            animatables: k,
            animations: V,
            duration: j.duration,
            delay: j.delay,
            endDelay: j.endDelay,
            startOnceDelay: B.startOnceDelay,
            pingPongDelayCorrection: B.pingPongDelayCorrection,
            pingPongEndDelayCorrection: B.pingPongEndDelayCorrection,
          }));
        function h() {
          var _ = ea.direction;
          "alternate" !== _ &&
            (ea.direction = "normal" !== _ ? "normal" : "reverse"),
            (ea.reversed = !ea.reversed),
            X.forEach(function (_) {
              (1 === _.loop || _.loop % 2 == 0) && (_.reversed = ea.reversed);
            });
        }
        function f(_) {
          return ea.reversed ? ea.duration - _ : _;
        }
        function m(_, I, R = !1) {
          I &&
            (ea.reversed
              ? I.seek(
                  I.duration * I.loop -
                    (_ - I.timelineOffset - I.pingPongDelayCorrection),
                  R
                )
              : I.seek(
                  _ -
                    I.timelineOffset -
                    I.startOnceDelay -
                    I.pingPongDelayCorrection,
                  R
                ));
        }
        function y(_) {
          var I = 0,
            R = ea.animations,
            B = R.length;
          for (
            "alternate" !== ea.direction && ea.parent?.direction === "alternate"
              ? ea.parent?.rewind === !1 &&
                !0 === ea.reversePlayback &&
                !1 === ea.rewind &&
                (_ =
                  ea.parent?.reversed && "alternate" === ea.direction
                    ? ea.duration - ea.delay + ea.endDelay - _
                    : ea.duration + ea.delay - ea.endDelay - _)
              : w(
                  !1,
                  ea.parent?.rewind,
                  ea.rewind,
                  ea.parent?.reversePlayback,
                  ea.reversePlayback
                ) &&
                (_ =
                  ea.parent?.reversed && "alternate" === ea.direction
                    ? ea.duration - ea.delay + ea.endDelay - _
                    : ea.duration + ea.delay - ea.endDelay - _);
            I < B;

          ) {
            let B;
            var z = R[I],
              k = z.animatable,
              V = z.tweens,
              j = V.length - 1,
              G = V[j];
            j &&
              (G =
                yb(V, function (I) {
                  return _ < I.end;
                })[0] || G),
              (B =
                ea.parent?.reversed && "alternate" === ea.direction
                  ? po(_ - G.start - G.endDelay, 0, G.duration) / G.duration
                  : po(_ - G.start - G.delay, 0, G.duration) / G.duration);
            for (
              var q = isNaN(B) ? 1 : G.easing(B),
                X = G.to.strings,
                Q = G.round,
                $ = [],
                et = G.to.numbers.length,
                er = void 0,
                es = 0;
              es < et;
              es++
            ) {
              let _, I;
              var en = void 0;
              "alternate" !== ea.direction
                ? ea.parent?.rewind === !1 &&
                  !0 === ea.reversePlayback &&
                  !1 === ea.rewind
                  ? ((_ = G.to.numbers[es]), (I = G.from.numbers[es] || 0))
                  : ((I = G.to.numbers[es]), (_ = G.from.numbers[es] || 0))
                : w(
                    !0,
                    ea.parent?.rewind,
                    ea.rewind,
                    ea.parent?.reversePlayback,
                    ea.reversePlayback
                  )
                ? ((_ = G.to.numbers[es]), (I = G.from.numbers[es] || 0))
                : ((I = G.to.numbers[es]), (_ = G.from.numbers[es] || 0)),
                (en = G.isPath
                  ? (function (_, I) {
                      function e(R) {
                        void 0 === R && (R = 0);
                        var B = I + R >= 1 ? I + R : 0;
                        return _.el.getPointAtLength(B);
                      }
                      var R = kB(_.el, _.svg),
                        B = e(),
                        z = e(-1),
                        k = e(1);
                      switch (_.property) {
                        case "x":
                          return (B.x - R.x) * R.w;
                        case "y":
                          return (B.y - R.y) * R.h;
                        case "angle":
                          return (
                            (180 * Math.atan2(k.y - z.y, k.x - z.x)) / Math.PI
                          );
                      }
                    })(G.value, q * I)
                  : _ + q * (I - _)),
                Q && ((G.isColor && es > 2) || (en = Math.round(en * Q) / Q)),
                $.push(en);
            }
            var eo = X.length;
            if (eo) {
              er = X[0];
              for (var el = 0; el < eo; el++) {
                X[el];
                var eh = X[el + 1],
                  ec = $[el];
                isNaN(ec) || (eh ? (er += ec + eh) : (er += ec + " "));
              }
            } else er = $[0];
            PN[z.type](k.target, z.property, er, k.transforms),
              (z.currentValue = er),
              I++;
          }
        }
        function v(_) {
          ea[_] && !ea.passThrough && ea[_](ea);
        }
        l(ea);
        let en = {
          0: !1,
          1: !0,
          2: !1,
          3: !0,
          4: !1,
          5: !1,
          6: !1,
          7: !1,
          8: !1,
          9: !0,
          10: !0,
          11: !1,
          12: !1,
          13: !1,
          14: !0,
          15: !0,
          16: !1,
          17: !0,
          18: !0,
          19: !1,
          20: !1,
          21: !1,
          22: !0,
          23: !0,
          24: !1,
          25: !0,
          26: !1,
          27: !0,
          28: !1,
          29: !1,
          30: !1,
          31: !1,
        };
        function w(_, I, R, B, z) {
          return en[(_ << 4) | (I << 3) | (R << 2) | (B << 1) | z];
        }
        function A(_, I = !1) {
          var R = ea.duration;
          let B = ea.delay,
            z = R - ea.endDelay;
          ea.parent?.reversed &&
            "alternate" === ea.direction &&
            ((B = ea.endDelay), (z = R - ea.delay));
          var k = f(_);
          if (
            ((ea.progress = po((k / R) * 100, 0, 100)),
            I || (ea.reversePlayback = k < ea.currentTime),
            er &&
              (function (_, I = !1) {
                if (ea.reversed) for (var R = er; R--; ) m(_, X[R], I);
                else for (var B = 0; B < er; B++) m(_, X[B], I);
              })(k, I),
            !ea.began && ea.currentTime >= 0 && ((ea.began = !0), v("begin")),
            !ea.loopBegan &&
              ea.currentTime > 0 &&
              ((ea.loopBegan = !0), v("loopBegin")),
            (ea.reversed || k >= 0) &&
              k <= B &&
              0 !== ea.currentTime &&
              (y(0), v("change")),
            ((k >= z && ea.currentTime !== R + ea.pingPongDelayCorrection) ||
              !R) &&
              (y(R), v("change")),
            k > B && k < z
              ? (ea.changeBegan ||
                  ((ea.changeBegan = !0),
                  (ea.changeCompleted = !1),
                  v("changeBegin")),
                y(k),
                v("change"))
              : ea.changeBegan
              ? ((ea.changeCompleted = !0),
                (ea.changeBegan = !1),
                v("change"),
                er && v("timelineChangeComplete"))
              : ea.began && k > z && v("changeComplete"),
            (ea.currentTime = po(k, 0, R + ea.pingPongDelayCorrection)),
            ea.began && v("update"),
            _ >= R)
          ) {
            if (
              (ea.remaining && !0 !== ea.remaining && ea.remaining--,
              ea.remaining)
            ) {
              for (let _ of (er
                ? (Q += ea.duration / ui.speed)
                : (Q += ea.duration),
              X))
                _.setStartTime(0), (_.remaining = _.loop);
              v("loopComplete"),
                (ea.loopBegan = !1),
                "alternate" === ea.direction
                  ? h()
                  : er &&
                    ((ea.direction = "normal"),
                    (ea.reversed = !1),
                    X.forEach(function (_) {
                      return (_.reversed = !1);
                    }));
            } else
              (ea.paused = !0),
                ea.completed ||
                  ((ea.completed = !0),
                  v("loopComplete"),
                  v("complete"),
                  !ea.passThrough && "Promise" in window && (es(), l(ea)));
          }
        }
        return (
          (ea.reset = function () {
            var _ = ea.direction;
            (ea.passThrough = !1),
              (ea.currentTime = 0),
              (ea.progress = 0),
              (ea.paused = !0),
              (ea.began = !1),
              (ea.loopBegan = !1),
              (ea.changeBegan = !1),
              (ea.completed = !1),
              (ea.changeCompleted = !1),
              (ea.reversePlayback = !1),
              (ea.reversed = "reverse" === _),
              (ea.remaining = ea.loop),
              (er = (X = ea.children).length);
            for (var I = er; I--; ) ea.children[I].reset();
            y(ea.reversed ? ea.duration : 0);
          }),
          (ea.setStartTime = function (_) {
            Q = _;
          }),
          (ea.set = function (_, I) {
            return GB(_, I), ea;
          }),
          (ea.tick = function (_) {
            (et = _), Q || (Q = et), A((et + ($ - Q)) * ui.speed);
          }),
          (ea.seek = function (_, I = !1) {
            A(_ - Q, I);
          }),
          (ea.pause = function (_) {
            (ea.paused = !0), er && (q = _ ?? performance.now());
          }),
          (ea.play = function (_) {
            !ea.paused ||
              (ea.completed && ea.reset(),
              (ea.paused = !1),
              Pq.push(ea),
              er && void 0 !== q && (Q += (_ ?? performance.now()) - q),
              PH || PX());
          }),
          (ea.reverse = function () {
            h(),
              (ea.completed = !ea.reversed),
              (Q = 0),
              ($ = f(ea.currentTime) * (1 / ui.speed));
          }),
          (ea.restart = function () {
            ea.reset(), ea.play();
          }),
          ea.reset(),
          ea.autoplay && ea.play(),
          ea
        );
      }
      function MB(_, I) {
        for (var R = I.length; R--; )
          yE(_, I[R].animatable.target) && I.splice(R, 1);
      }
      "u" > typeof document &&
        document.addEventListener("visibilitychange", function (_) {
          document.hidden
            ? (Pq.forEach(function (I) {
                return I.pause(_.timeStamp);
              }),
              (PY = Pq.slice(0)),
              (ui.running = Pq = []))
            : PY.forEach(function (I) {
                return I.play(_.timeStamp);
              });
        }),
        (ui.version = "3.2.0"),
        (ui.speed = 1),
        (ui.running = Pq),
        (ui.remove = function (_) {
          for (var I = VB(_), R = Pq.length; R--; ) {
            var B = Pq[R],
              z = B.animations,
              k = B.children;
            MB(I, z);
            for (var V = k.length; V--; ) {
              var j = k[V],
                G = j.animations;
              MB(I, G), G.length || j.children.length || k.splice(V, 1);
            }
            z.length || k.length || B.pause();
          }
        }),
        (ui.get = SE),
        (ui.set = GB),
        (ui.convertPx = xE),
        (ui.path = function (_, I) {
          var R = PR.str(_) ? IB(_)[0] : _,
            B = I || 100;
          return function (_) {
            return {
              property: _,
              el: R,
              svg: kB(R),
              totalLength: FB(R) * (B / 100),
            };
          };
        }),
        (ui.setDashoffset = function (_) {
          var I = FB(_);
          return _.setAttribute("stroke-dasharray", I), I;
        }),
        (ui.stagger = function (_, I) {
          void 0 === I && (I = {});
          var R = I.direction || "normal",
            B = I.easing ? gE(I.easing) : null,
            z = I.grid,
            k = I.axis,
            V = I.from || 0,
            j = "first" === V,
            G = "center" === V,
            q = "last" === V,
            X = PR.arr(_),
            Q = parseFloat(X ? _[0] : _),
            $ = X ? parseFloat(_[1]) : 0,
            et = Xa(X ? _[1] : _) || 0,
            er = I.start || 0 + (X ? Q : 0),
            es = [],
            ea = 0;
          return function (_, I, en) {
            if (
              (j && (V = 0),
              G && (V = (en - 1) / 2),
              q && (V = en - 1),
              !es.length)
            ) {
              for (var eo = 0; eo < en; eo++) {
                if (z) {
                  var el = G ? (z[0] - 1) / 2 : V % z[0],
                    eh = G ? (z[1] - 1) / 2 : Math.floor(V / z[0]),
                    ec = eo % z[0],
                    ed = Math.floor(eo / z[0]),
                    ep = el - ec,
                    ef = eh - ed,
                    em = Math.sqrt(ep * ep + ef * ef);
                  "x" === k && (em = -ep), "y" === k && (em = -ef), es.push(em);
                } else es.push(Math.abs(V - eo));
                ea = Math.max.apply(Math, es);
              }
              B &&
                (es = es.map(function (_) {
                  return B(_ / ea) * ea;
                })),
                "reverse" === R &&
                  (es = es.map(function (_) {
                    return k ? (_ < 0 ? -1 * _ : -_) : Math.abs(ea - _);
                  }));
            }
            return (
              er + (X ? ($ - Q) / ea : Q) * (Math.round(100 * es[I]) / 100) + et
            );
          };
        }),
        (ui.timeline = function (_) {
          void 0 === _ && (_ = {});
          var I = ui(_);
          return (
            (I.duration = 0),
            (I.add = function (R, B) {
              var z = Pq.indexOf(I),
                k = I.children;
              function o(_) {
                _.passThrough = !0;
              }
              z > -1 && Pq.splice(z, 1);
              for (var V = 0; V < k.length; V++) o(k[V]);
              var j = xb(R, fE(PD, _));
              j.targets = j.targets || _.targets;
              var G = I.duration;
              (j.autoplay = !1),
                (j.timelineOffset = PR.und(B) ? G : wE(B, G)),
                o(I);
              var q = ui(j);
              o(q), k.push(q), (q.parent = I);
              var X = jB(k, _);
              return (
                (I.delay = X.delay),
                (I.endDelay = X.endDelay),
                (I.duration = X.duration),
                !0 === q.loop && (I.duration = 1 / 0),
                I.seek(0),
                I.reset(),
                I.autoplay && I.play(),
                I
              );
            }),
            I
          );
        }),
        (ui.easing = gE),
        (ui.penner = PF),
        (ui.random = function (_, I) {
          return Math.floor(Math.random() * (I - _ + 1)) + _;
        });
      var PQ = new rF(),
        PZ = new rF(),
        PK = new rz();
      function ei(_, I, R, B, z, k) {
        let V = R[_] ? R[_] : void 0,
          j = B[_];
        if (null == j) return;
        let G =
            null != V
              ? "string" == typeof V
                ? Number(z.getVariable(V) ?? 0)
                : V
              : I[_],
          q = "string" == typeof j ? Number(z.getVariable(j) ?? 0) : j;
        if (G !== q)
          return {
            update: (R) => {
              let B = rr.lerp(G, q, R);
              k ? (I[_] = Math.trunc(B)) : (I[_] = B);
            },
            start: () => {
              I[_] = G;
            },
            end: () => {
              I[_] = q;
            },
          };
      }
      function fg(_, I, R, B, z, k) {
        let V = R[_] ? R[_] : void 0,
          j = B[_];
        if (!j) return;
        let G = I[_],
          q = [...(V ?? G)].map((_) =>
            "string" == typeof _ ? Number(z.getVariable(_) ?? 0) : _
          ),
          X = [...j].map((_) =>
            "string" == typeof _ ? Number(z.getVariable(_) ?? 0) : _
          );
        if (!(q.length !== X.length || Xp(q, X)))
          return {
            update: (R) => {
              q.forEach((B, z) => {
                let V = rr.lerp(B, X[z], R);
                I[_][z] = k ? Math.trunc(V) : V;
              });
            },
            start: () => {
              Object.assign(I[_], q);
            },
            end: () => {
              Object.assign(I[_], X);
            },
          };
      }
      function dg(_, I, R) {
        return (
          I.forEach((I, B) => {
            _.setComponent(
              B,
              "string" == typeof I ? Number(R.getVariable(I) ?? 0) : I
            );
          }),
          _
        );
      }
      function _E(_, I, R, B, z) {
        let k = R[_] ? R[_] : void 0,
          V = B[_];
        if (!V) return;
        let j = I[_],
          G = k ? dg(new rF(), k, z) : j.clone(),
          q = dg(new rF(), V, z);
        if (!G.equals(q))
          return {
            update: (_) => {
              j.lerpVectors(G, q, _);
            },
            start: () => {
              j.copy(G);
            },
            end: () => {
              j.copy(q);
            },
          };
      }
      function YB(_, I, R) {
        return (
          I.forEach((I, B) => {
            _.setComponent(
              B,
              "string" == typeof I ? Number(R.getVariable(I) ?? 0) : I
            );
          }),
          _
        );
      }
      function Yf(_, I, R, B, z) {
        let k = R[_] ? R[_] : void 0,
          V = B[_];
        if (!V) return;
        let j = I[_],
          G = !(j instanceof rs),
          q = j instanceof rs ? j : new rs().fromArray(j),
          X = k ? YB(new rs(), k, z) : q.clone(),
          Q = YB(new rs(), V, z);
        if (!X.equals(Q))
          return {
            update: (R) => {
              q.lerpVectors(X, Q, R), G && (I[_] = q.toArray());
            },
            start: () => {
              q.copy(X), G && (I[_] = q.toArray());
            },
            end: () => {
              q.copy(Q), G && (I[_] = q.toArray());
            },
          };
      }
      function pg(_, I, R, B, z) {
        let k = R[_] ? R[_] : void 0,
          V = B[_];
        if (!V) return;
        let j = I[_],
          G = new wA(j.r, j.g, j.b, j.a),
          q = k
            ? "string" == typeof k
              ? z.getColor(k).clone()
              : new wA(k.r, k.g, k.b, k.a)
            : G.clone(),
          X =
            "string" == typeof V
              ? z.getColor(V).clone()
              : new wA(V.r, V.g, V.b, V.a);
        if (!q.equals(X))
          return {
            update: (R) => {
              G.lerpColors(q, X, R);
              let B = rr.lerp(q.a, X.a, R);
              (G.a = B), (I[_] = { r: G.r, g: G.g, b: G.b, a: G.a });
            },
            start: () => {
              G.copy(q);
            },
            end: () => {
              G.copy(X);
            },
          };
      }
      function ia(_, I, R, B, z) {
        return "number" == typeof I[_]
          ? ei(_, I, R ?? {}, B, z)
          : Array.isArray(I[_])
          ? fg(_, I, R ?? {}, B, z)
          : void 0;
      }
      function eN(_, I, R, B) {
        let z = [],
          k = eu(R, B) || (!!I.layers && eu(I, B));
        for (let V of (z.push({
          update: () => {
            _.transparent = k;
          },
        }),
        _.layers)) {
          let _ = I.layers?.data(V.uuid),
            k = R.layers.data(V.uuid);
          if (
            k &&
            ("light" === V.type || ((V.visible ?? !0) && (k.visible ?? !0)))
          )
            for (let I of V.getNames().filter(
              (_) => !mY.some((I) => _.includes(I))
            ))
              try {
                let R = V.getValue(I),
                  j;
                if ("colors" === I)
                  j = (function (_, I, R, B = "colors") {
                    if (!_.hasValue(B) || !(B in R)) return;
                    let z = [],
                      k = _.getValue(B),
                      V = I ? I[B] : k.map((_) => _.toArray()),
                      j = R[B];
                    for (let _ = 0; _ < k.length; ++_) {
                      let I = [...V[_]],
                        R = [...j[_]];
                      mg.isEqual(I, R) ||
                        z.push({
                          update: (B) => {
                            k[_].fromArray(mg.lerp(I, R, B));
                          },
                          start: () => {
                            k[_].fromArray(I);
                          },
                          end: () => {
                            k[_].fromArray(R);
                          },
                        });
                    }
                    return z.length ? z : void 0;
                  })(V, _, k, I);
                else if (Array.isArray(R))
                  "steps" === I &&
                    (j = (function (_, I, R, B = "steps") {
                      if (!_.hasValue(B) || !(B in R)) return;
                      let z = [],
                        k = _.getValue(B),
                        V = I ? I[B] : k,
                        j = R[B];
                      for (let _ = 0; _ < k.length; ++_) {
                        let I = V[_],
                          R = j[_];
                        I !== R &&
                          z.push({
                            update: (B) => {
                              k[_] = rr.lerp(I, R, B);
                            },
                            start: () => {
                              k[_] = I;
                            },
                            end: () => {
                              k[_] = R;
                            },
                          });
                      }
                      return z.length ? z : void 0;
                    })(V, _, k, I));
                else if ("number" == typeof R)
                  j = (function (_, I, R, B, z) {
                    if (!_.hasValue(B) || !(B in R)) return;
                    let k = I ? I[B] : _.getValue(B),
                      V = R[B],
                      j =
                        "string" == typeof k
                          ? Number(z.getVariable(k) ?? 0)
                          : k,
                      G =
                        "string" == typeof V
                          ? Number(z.getVariable(V) ?? 0)
                          : V;
                    if (j !== G)
                      return {
                        update: (I) => {
                          _.setValue(B, rr.lerp(j, G, I));
                        },
                        start: () => {
                          _.setValue(B, j);
                        },
                        end: () => {
                          _.setValue(B, G);
                        },
                      };
                  })(V, _, k, I, B);
                else {
                  if ("boolean" == typeof R) continue;
                  R instanceof rs
                    ? (j = (function (_, I, R, B) {
                        if (!_.hasValue(B) || !(B in R)) return;
                        let z = _.getValue(B),
                          k = I ? new rs().fromArray(I[B]) : z.clone(),
                          V = new rs().fromArray(R[B]);
                        if (!k.equals(V))
                          return {
                            update: (_) => {
                              z.lerpVectors(k, V, _);
                            },
                            start: () => {
                              z.copy(k);
                            },
                            end: () => {
                              z.copy(V);
                            },
                          };
                      })(V, _, k, I))
                    : R instanceof rF
                    ? (j = (function (_, I, R, B, z) {
                        if (!_.hasValue(B) || !(B in R)) return;
                        let k = _.getValue(B),
                          V = I ? I[B] : void 0,
                          j = R[B],
                          G = V ? dg(new rF(), V, z) : k.clone(),
                          q = dg(new rF(), j, z);
                        if (!G.equals(q))
                          return {
                            update: (_) => {
                              k.lerpVectors(G, q, _);
                            },
                            start: () => {
                              k.copy(G);
                            },
                            end: () => {
                              k.copy(q);
                            },
                          };
                      })(V, _, k, I, B))
                    : R instanceof wA
                    ? (j = (function (_, I, R, B, z) {
                        if (!_.hasValue(B) || !(B in R)) return;
                        let k = I ? I[B] : void 0,
                          V = R[B],
                          j = _.getValue(B),
                          G = k
                            ? "string" == typeof k
                              ? z.getColor(k).clone()
                              : new ry().setRGB(k.r, k.g, k.b)
                            : j.clone(),
                          q =
                            "string" == typeof V
                              ? z.getColor(V).clone()
                              : new wA(V.r, V.g, V.b, V.a);
                        if (G.equals(q)) return;
                        let X = j.clone();
                        return {
                          update: (I) => {
                            _.getValue(B) !== X && _.setValue(B, X),
                              X.lerpColors(G, q, I);
                          },
                          start: () => {
                            X.copy(G);
                          },
                          end: () => {
                            X.copy(q);
                          },
                        };
                      })(V, _, k, I, B))
                    : R instanceof ry
                    ? (j = (function (_, I, R, B, z) {
                        if (!_.hasValue(B) || !(B in R)) return;
                        let k = I ? I[B] : void 0,
                          V = R[B],
                          j = _.getValue(B),
                          G = k
                            ? "string" == typeof k
                              ? z.getColor(k).clone()
                              : new ry().setRGB(k.r, k.g, k.b)
                            : j.clone(),
                          q =
                            "string" == typeof V
                              ? z.getColor(V).clone()
                              : new ry().setRGB(V.r, V.g, V.b);
                        if (G.equals(q)) return;
                        let X = j.clone();
                        return {
                          update: (I) => {
                            _.getValue(B) !== X && _.setValue(B, X),
                              X.lerpColors(G, q, I);
                          },
                          start: () => {
                            X.copy(G);
                          },
                          end: () => {
                            X.copy(q);
                          },
                        };
                      })(V, _, k, I, B))
                    : "isTexture" in R &&
                      (j = (function (_, I, R, B = "texture") {
                        if (!_.hasValue(B) || !(B in R)) return;
                        let z = _.getNode("mat");
                        if (!z) return;
                        let k = I ? I[B] : z,
                          V = R[B],
                          j = [...k.repeat],
                          G = [...k.offset],
                          q = [...V.repeat],
                          X = [...V.offset];
                        if (!mu.isEqual(j, q) || !mu.isEqual(G, X))
                          return {
                            update: (_) => {
                              (z.repeat = mu.lerp(j, q, _)),
                                (z.offset = mu.lerp(G, X, _)),
                                z.updateMatrix();
                            },
                            start: () => {
                              (z.repeat = [...j]),
                                (z.offset = [...G]),
                                z.updateMatrix();
                            },
                            end: () => {
                              (z.repeat = [...q]),
                                (z.offset = [...X]),
                                z.updateMatrix();
                            },
                          };
                      })(V, _, k, I));
                }
                j && (Array.isArray(j) ? z.push(...j) : z.push(j));
              } catch (_) {
                console.error(
                  `lerpMaterial: unexpected material layer for ${I}`,
                  _
                );
              }
        }
        return z;
      }
      var PJ = new rF(),
        P$ = new sg();
      function TE(_, I, R, B, z) {
        let k = [];
        return (
          _.data.visible &&
            k.push(
              ...(function (_, I, R, B, z) {
                let k = [],
                  V,
                  j,
                  G,
                  q,
                  X,
                  Q,
                  $,
                  et;
                if (
                  (_ instanceof CD
                    ? ((V = Yf("position", _, I, R, z)) && k.push(V),
                      (G = ei("rotation", _, I, R, z)) && k.push(G),
                      (q = Yf("shear", _, I, R, z)) && k.push(q))
                    : ((Q = ei(
                        "slide",
                        (et = {
                          slide:
                            I.pathSnapping?.slide ??
                            _.updatedPathSnapping?.slide ??
                            _.dataPatched.pathSnapping?.slide ??
                            0,
                          offset:
                            I.pathSnapping?.offset ??
                            _.updatedPathSnapping?.offset ??
                            _.dataPatched.pathSnapping?.offset ??
                            0,
                        }),
                        I.pathSnapping ??
                          _.updatedPathSnapping ??
                          _.dataPatched.pathSnapping,
                        R.pathSnapping ?? _.dataPatched.pathSnapping,
                        z
                      )) && k.push(Q),
                      ($ = ei(
                        "offset",
                        et,
                        I.pathSnapping ??
                          _.updatedPathSnapping ??
                          _.dataPatched.pathSnapping,
                        R.pathSnapping ?? _.dataPatched.pathSnapping,
                        z
                      )) && k.push($),
                      !Q &&
                        !$ &&
                        ((V = _E("position", _, I, R, z)) && k.push(V),
                        (j = _E("scale", _, I, R, z)) && k.push(j),
                        (G = (function (_, I, R, B, z) {
                          let k = I?.rotation
                              ? I.rotation.map(
                                  (_) =>
                                    ("string" == typeof _
                                      ? Number(z.getVariable(_) ?? 0)
                                      : _) * rr.DEG2RAD
                                )
                              : void 0,
                            V = R.rotation?.map(
                              (_) =>
                                ("string" == typeof _
                                  ? Number(z.getVariable(_) ?? 0)
                                  : _) * rr.DEG2RAD
                            );
                          if (!V) return;
                          let j = k
                              ? new rF().fromArray(k)
                              : new rF().setFromEuler(_.rotation),
                            G = new rF().fromArray(V);
                          if (j.equals(G)) return;
                          let q = PJ.subVectors(G, j);
                          if (
                            !(
                              B &&
                              q
                                .toArray()
                                .every((_) => Math.abs(_) < 2 * Math.PI)
                            )
                          )
                            return {
                              update: (I) => {
                                PJ.lerpVectors(j, G, I),
                                  _.rotation.setFromVector3(PJ);
                              },
                              start: () => {
                                _.rotation.setFromVector3(j);
                              },
                              end: () => {
                                _.rotation.setFromVector3(G);
                              },
                            };
                          {
                            let I = new rz().setFromEuler(P$.setFromVector3(j)),
                              R = new rz().setFromEuler(P$.setFromVector3(G));
                            return {
                              update: (B) => {
                                !(function (_, I, R, B) {
                                  if (0 === B) return R.copy(_);
                                  if (1 === B) return R.copy(I);
                                  let z =
                                    _.w * I.w +
                                    _.x * I.x +
                                    _.y * I.y +
                                    _.z * I.z;
                                  if (z >= 1) return R.copy(_);
                                  let k = 1 - z * z;
                                  if (k <= Number.EPSILON) {
                                    let z = 1 - B;
                                    return (
                                      (R.w = z * _.w + B * I.w),
                                      (R.x = z * _.x + B * I.x),
                                      (R.y = z * _.y + B * I.y),
                                      (R.z = z * _.z + B * I.z),
                                      R.normalize()
                                    );
                                  }
                                  let V = Math.sqrt(k),
                                    j = Math.atan2(V, z),
                                    G = Math.sin((1 - B) * j) / V,
                                    q = Math.sin(B * j) / V;
                                  (R.w = _.w * G + I.w * q),
                                    (R.x = _.x * G + I.x * q),
                                    (R.y = _.y * G + I.y * q),
                                    (R.z = _.z * G + I.z * q);
                                })(I, R, _.quaternion, B);
                              },
                              start: () => {
                                _.rotation.setFromVector3(j);
                              },
                              end: () => {
                                _.rotation.setFromVector3(G);
                              },
                            };
                          }
                        })(_, I, R, B, z)) && k.push(G),
                        (X = (function (_, I, R, B) {
                          let z = R[_] ? R[_] : void 0,
                            k = B[_];
                          if (!k) return;
                          let V = I[_],
                            j = z ? new sa().fromArray(z) : V.clone(),
                            G = new rF(),
                            q = new rz(),
                            X = new rF();
                          j.decompose(G, q, X);
                          let Q = new sa().fromArray(k),
                            $ = new rF(),
                            et = new rz(),
                            er = new rF();
                          if ((Q.decompose($, et, er), !j.equals(Q)))
                            return {
                              update: (_) => {
                                PK.slerpQuaternions(q, et, _),
                                  PQ.lerpVectors(G, $, _),
                                  PZ.lerpVectors(X, er, _),
                                  V.compose(PQ, PK, PZ);
                              },
                              start: () => {
                                V.compose(G, q, X);
                              },
                              end: () => {
                                V.compose($, et, er);
                              },
                            };
                        })("hiddenMatrix", _, I, R)) && k.push(X))),
                  V || j || G || X || Q || $)
                ) {
                  let R =
                    _ instanceof CD
                      ? () => {
                          _.updateWorldMatrix(!0);
                        }
                      : () => {
                          _.updateMatrix(),
                            _.hasNonUniformScale &&
                              (_.updateMatrixWorld(), _.updateMatrixWorldSVD()),
                            _.parent?.matrixWorldFusedFalse &&
                              (_.matrixWorld.multiplyMatrices(
                                _.parent.matrixWorldFusedFalse,
                                _.matrix
                              ),
                              (_.matrixWorldNeedsUpdate = !1)),
                            mn(_) &&
                              Rn(_.parent) &&
                              _.invalidateDownstreamBooleanData(!0),
                            _.updatePathSnapping(
                              Object.assign({}, I.pathSnapping, et)
                            );
                        };
                  k.push({ update: R, start: R, end: R });
                }
                return k;
              })(_, I, R, z, B)
            ),
          _ instanceof CD
            ? k.push(
                ...(function (_, I, R, B, z) {
                  let k = [],
                    V,
                    j,
                    G,
                    q,
                    X,
                    Q,
                    $,
                    et,
                    er,
                    es,
                    ea,
                    en,
                    eo,
                    el,
                    eh;
                  if (
                    ("width" in _ && (V = ei("width", _, I, R, z)) && k.push(V),
                    "height" in _ &&
                      (j = ei("height", _, I, R, z)) &&
                      k.push(j),
                    _ instanceof CX || _ instanceof C$)
                  ) {
                    let B = { ...I.fill },
                      V = { ...R.fill };
                    void 0 !== B.enabled &&
                      B.enabled !== V.enabled &&
                      (k.push({
                        update: () => {
                          _ instanceof CX && (_.fill.enabled = !0);
                        },
                      }),
                      B.enabled ||
                        Object.assign(B, {
                          enabled: !0,
                          color: { ...B.color, a: 0 },
                        }),
                      V.enabled ||
                        Object.assign(V, {
                          enabled: !0,
                          color: { ...V.color, a: 0 },
                        })),
                      (G = pg("color", _.fill, B, V, z)) && k.push(G);
                  }
                  if (_ instanceof CX) {
                    let B = { ...I.stroke },
                      V = { ...R.stroke };
                    (B.enabled || V.enabled) &&
                      (k.push({
                        update: () => {
                          _ instanceof CX && (_.stroke.enabled = !0);
                        },
                      }),
                      B.enabled ||
                        Object.assign(B, {
                          enabled: !0,
                          color: { ...B.color, a: 0 },
                        }),
                      V.enabled ||
                        Object.assign(V, {
                          enabled: !0,
                          color: { ...V.color, a: 0 },
                        })),
                      (q = pg("color", _.stroke, B, V, z)) && k.push(q),
                      (X = ei("thickness", _.stroke, B, V, z)) && k.push(X);
                  }
                  if (_ instanceof CX) {
                    let B = { ...I.dropShadow },
                      V = { ...R.dropShadow };
                    (B.enabled || V.enabled) &&
                      (k.push({
                        update: () => {
                          _ instanceof CX && (_.dropShadow.enabled = !0);
                        },
                      }),
                      B.enabled ||
                        Object.assign(B, {
                          enabled: !0,
                          color: { ...B.color, a: 0 },
                        }),
                      V.enabled ||
                        Object.assign(V, {
                          enabled: !0,
                          color: { ...V.color, a: 0 },
                        })),
                      (Q = pg("color", _.dropShadow, B, V, z)) && k.push(Q),
                      ($ = ei("blurRadius", _.dropShadow, B, V, z)) &&
                        k.push($),
                      (er = ei("spread", _.dropShadow, B, V, z)) && k.push(er),
                      (et = Yf("offset", _.dropShadow, B, V, z)) && k.push(et);
                  }
                  if (_ instanceof CX) {
                    let B = { ...I.innerShadow },
                      V = { ...R.innerShadow };
                    (B.enabled || V.enabled) &&
                      (k.push({
                        update: () => {
                          _ instanceof CX && (_.innerShadow.enabled = !0);
                        },
                      }),
                      B.enabled ||
                        Object.assign(B, {
                          enabled: !0,
                          color: { ...B.color, a: 0 },
                        }),
                      V.enabled ||
                        Object.assign(V, {
                          enabled: !0,
                          color: { ...V.color, a: 0 },
                        })),
                      (es = pg("color", _.innerShadow, B, V, z)) && k.push(es),
                      (ea = ei("blurRadius", _.innerShadow, B, V, z)) &&
                        k.push(ea),
                      (eo = ei("spread", _.innerShadow, B, V, z)) && k.push(eo),
                      (en = Yf("offset", _.innerShadow, B, V, z)) && k.push(en);
                  }
                  if (_ instanceof CX || _ instanceof C$) {
                    let B = { ...I.backgroundBlur },
                      V = { ...R.backgroundBlur };
                    (B.enabled || V.enabled) &&
                      (k.push({
                        update: () => {
                          _ instanceof CX && (_.backgroundBlur.enabled = !0);
                        },
                      }),
                      B.enabled || Object.assign(B, { enabled: !0, radius: 0 }),
                      V.enabled ||
                        Object.assign(V, { enabled: !0, radius: 0 })),
                      (el = ei("radius", _.backgroundBlur, B, V, z)) &&
                        k.push(el);
                  }
                  if (_ instanceof CX) {
                    let B = { ...I.layerBlur },
                      V = { ...R.layerBlur };
                    (B.enabled || V.enabled) &&
                      (k.push({
                        update: () => {
                          _ instanceof CX && (_.layerBlur.enabled = !0);
                        },
                      }),
                      B.enabled || Object.assign(B, { enabled: !0, radius: 0 }),
                      V.enabled ||
                        Object.assign(V, { enabled: !0, radius: 0 })),
                      (eh = ei("radius", _.layerBlur, B, V, z)) && k.push(eh);
                  }
                  if (_ instanceof C$ || _ instanceof CZ) {
                    let B = fg("cornerRadius", _, I, R, z);
                    B && k.push(B);
                  }
                  return k;
                })(_, I, R, 0, B)
              )
            : (_.data.visible &&
                k.push(
                  ...(function (_, I, R, B) {
                    let z = [];
                    if (!("cloner" in R) || !_.cloner) return z;
                    let k = _.cloner,
                      V = "cloner" in I ? I.cloner : {},
                      j = R.cloner;
                    fw.forEach((_) => {
                      let I;
                      (I =
                        "count" === _
                          ? ei("count", k.parameters, V, j, B, !0)
                          : ia(_, k.parameters, V ?? {}, j, B)) && z.push(I);
                    });
                    let G = (function (_, I, R, B) {
                      if ("radial" !== _.parameters.type) return;
                      let z = I.radial,
                        k = R.radial;
                      if (!k) return;
                      let V = _.parameters.radial,
                        j = [];
                      return (
                        f_.forEach((_) => {
                          let I = ia(_, V, z ?? {}, k, B);
                          I && j.push(I);
                        }),
                        j
                      );
                    })(k, V, j, B);
                    G?.length && z.push(...G);
                    let q = (function (_, I, R, B) {
                      if ("linear" !== _.parameters.type) return;
                      let z = I.linear,
                        k = R.linear;
                      if (!k) return;
                      let V = [],
                        j = _.parameters.linear;
                      return (
                        fS.forEach((_) => {
                          let I = ia(_, j, z ?? {}, k, B);
                          I && V.push(I);
                        }),
                        V
                      );
                    })(k, V, j, B);
                    q?.length && z.push(...q);
                    let X = (function (_, I, R, B) {
                      if ("grid" !== _.parameters.type) return;
                      let z = I.grid,
                        k = R.grid;
                      if (!k) return;
                      let V = [],
                        j = _.parameters.grid;
                      return (
                        fC.forEach((_) => {
                          let I;
                          (I =
                            "count" === _
                              ? fg(_, j, z ?? {}, k, B, !0)
                              : ia(_, j, z ?? {}, k, B)) && V.push(I);
                        }),
                        V
                      );
                    })(k, V, j, B);
                    X?.length && z.push(...X);
                    let Q = (function (_, I, R, B) {
                      if ("toObject" !== _.parameters.type) return;
                      let z = I.toObject,
                        k = R.toObject;
                      if (!k) return;
                      let V = [],
                        j = _.parameters.toObject;
                      return (
                        fT.forEach((_) => {
                          let I;
                          (I =
                            "count" === _
                              ? ei(_, j, z ?? {}, k, B, !0)
                              : ia(_, j, z ?? {}, k, B)) && V.push(I);
                        }),
                        V
                      );
                    })(k, V, j, B);
                    Q?.length && z.push(...Q);
                    let $ = (function (_, I, R, B) {
                      if (!_.parameters.randomness) return;
                      let z = I.randomnessObject,
                        k = R.randomnessObject;
                      if (!k) return;
                      let V = [],
                        j = _.parameters.randomnessObject;
                      return (
                        fP.forEach((_) => {
                          let I = ia(_, j, z ?? {}, k, B);
                          I && V.push(I);
                        }),
                        V
                      );
                    })(k, V, j, B);
                    return (
                      $?.length && z.push(...$),
                      z.length &&
                        z.push({
                          update: () => {
                            k.update();
                          },
                        }),
                      z
                    );
                  })(_, I, R, B)
                ),
              mn(_)
                ? (_ instanceof S2 &&
                    _.data.visible &&
                    k.push(
                      ...(function (_, I, R, B) {
                        let z = [];
                        if (!("geometry" in R)) return z;
                        let k = _.geometry.userData.parameters,
                          V = "geometry" in I ? I.geometry : {},
                          j = R.geometry;
                        if (_ instanceof S5) {
                          let I = (function (_, I, R, B) {
                            if (void 0 === R.scaleBaked) return;
                            let z = (
                                I.scaleBaked ?? _.data.geometry.scaleBaked
                              ).map((_) =>
                                "string" == typeof _
                                  ? Number(B.getVariable(_) ?? 0)
                                  : _
                              ),
                              k = R.scaleBaked.map((_) =>
                                "string" == typeof _
                                  ? Number(B.getVariable(_) ?? 0)
                                  : _
                              );
                            if (mp.isEqual(z, k)) return;
                            let V = [];
                            return (
                              V.push({
                                update: (I) => {
                                  _.updateGeometryInteractions(
                                    {
                                      scaleBaked: [
                                        rr.lerp(z[0], k[0], I),
                                        rr.lerp(z[1], k[1], I),
                                        rr.lerp(z[2], k[2], I),
                                      ],
                                    },
                                    B
                                  ),
                                    _.invalidateDownstreamBooleanData();
                                },
                                start: () => {
                                  _.updateGeometryInteractions(
                                    { scaleBaked: z },
                                    B
                                  ),
                                    _.invalidateDownstreamBooleanData();
                                },
                                end: () => {
                                  _.updateGeometryInteractions(
                                    { scaleBaked: k },
                                    B
                                  ),
                                    _.invalidateDownstreamBooleanData();
                                },
                              }),
                              V
                            );
                          })(_, V, j, B);
                          I && z.push(...I);
                        } else {
                          let I = {};
                          if (
                            (Object.assign(I, uo(k, mJ)),
                            mJ.forEach((_) => {
                              let R = ia(_, I, V, j, B);
                              R && z.push(R);
                            }),
                            _ instanceof C7)
                          ) {
                            Object.assign(I, { extrusion: { ...k.extrusion } });
                            let _ = (function (_, I, R, B) {
                              if (!R.extrusion) return;
                              let z = _.extrusion,
                                k = I.extrusion ?? {},
                                V = R.extrusion,
                                j = [];
                              return (
                                mK.forEach((_) => {
                                  let I = ia(_, z, k, V, B);
                                  I && j.push(I);
                                }),
                                j
                              );
                            })(I, V, j, B);
                            _ && z.push(..._);
                          }
                          z.length &&
                            z.push({
                              update: (R) => {
                                _.updateGeometryInteractions(I, B),
                                  _.updateGeometryGroupsIfNeeded();
                              },
                              start: (R) => {
                                _.updateGeometryInteractions(I, B),
                                  _.updateGeometryGroupsIfNeeded();
                              },
                              end: (R) => {
                                _.updateGeometryInteractions(I, B),
                                  _.updateGeometryGroupsIfNeeded();
                              },
                            });
                        }
                        return z;
                      })(_, I, R, B)
                    ),
                  _.data.visible &&
                    k.push(
                      ...(function (_, I, R, B) {
                        let z = [];
                        if (Array.isArray(_.material)) {
                          if (!("materials" in R && R.materials)) return z;
                          let k =
                              "materials" in I && I.materials
                                ? I.materials
                                : [],
                            V = R.materials;
                          _.material.forEach((_, I) => {
                            if (!V[I]) return;
                            let R = k[I] ?? {},
                              j = V[I];
                            "string" == typeof R ||
                              "string" == typeof j ||
                              z.push(...eN(_, R, j, B));
                          });
                        } else {
                          if (!("material" in R && R.material)) return z;
                          let k =
                              "material" in I && I.material ? I.material : {},
                            V = R.material;
                          if ("string" == typeof k || "string" == typeof V)
                            return z;
                          z.push(...eN(_.material, k, V, B));
                        }
                        return z;
                      })(_, I, R, B)
                    ))
                : XR(_)
                ? _.data.visible &&
                  k.push(
                    ...(function (_, I, R, B) {
                      let z = [];
                      if (void 0 !== R.intensity) {
                        let k = ei("intensity", _, I, R, B);
                        k && z.push(k);
                      }
                      if (void 0 !== R.color) {
                        let k = (function (_, I, R, B, z) {
                          let k = R[_] ? R[_] : void 0,
                            V = B[_];
                          if (!V) return;
                          let j = I[_],
                            G = k
                              ? "string" == typeof k
                                ? z.getColor(k).clone()
                                : new ry().setRGB(k.r, k.g, k.b)
                              : j.clone(),
                            q =
                              "string" == typeof V
                                ? z.getColor(V).clone()
                                : new ry().setRGB(V.r, V.g, V.b);
                          if (G.equals(q)) return;
                          let X = j.clone();
                          return (
                            (I[_] = X),
                            {
                              update: (_) => {
                                X.lerpColors(G, q, _);
                              },
                              start: () => {
                                X.copy(G);
                              },
                              end: () => {
                                X.copy(q);
                              },
                            }
                          );
                        })("color", _, I, R, B);
                        k && z.push(k);
                      }
                      return z;
                    })(_, I, R, B)
                  )
                : YR(_) &&
                  k.push(
                    ...(function (_, I, R, B) {
                      let z = [],
                        k =
                          "OrthographicCamera" === _.cameraType
                            ? I.orthographic?.zoom
                            : I.perspective?.zoom,
                        V =
                          "OrthographicCamera" === _.cameraType
                            ? R.orthographic?.zoom
                            : R.perspective?.zoom;
                      if (void 0 !== V) {
                        let I = k ?? _.zoom;
                        I !== V &&
                          z.push({
                            update: (R) => {
                              (_.zoom = rr.lerp(I, V, R)),
                                _.updateProjectionMatrix();
                            },
                            start: () => {
                              (_.zoom = I), _.updateProjectionMatrix();
                            },
                            end: () => {
                              (_.zoom = V), _.updateProjectionMatrix();
                            },
                          });
                      }
                      if (void 0 !== R.targetOffset) {
                        let k = ei("targetOffset", _, I, R, B);
                        k && z.push(k);
                      }
                      return z;
                    })(_, I, R, B)
                  )),
          k.length
            ? {
                update: (_) => {
                  k.forEach((I) => I.update(_));
                },
                start: (_) => {
                  k.forEach((I) => I.start?.(_));
                },
                end: (_) => {
                  k.forEach((I) => I.end?.(_));
                },
              }
            : void 0
        );
      }
      var P1 = new rF();
      function qf(_, I, R = !1) {
        let B = [],
          i = (R) => {
            let B = R.data;
            for (let _ of (delete R.states,
            (R.currentState = null),
            (R.reversibleToState = null),
            (R.currentTransitionEvent = null),
            B.states)) {
              let I = { ..._.data };
              R.states || (R.states = {}), (R.states[_.id] = vY.patch(B, I));
            }
            lN(
              _.scene,
              R,
              null,
              I,
              void 0 !==
                B.events.find(
                  (_) => "Follow" === _.data.type || "LookAt" === _.data.type
                )
            ),
              aN(_);
          };
        _.scene.traverse2D(i),
          _.traverseChildren((z) => {
            if (
              (R &&
                (z.rigidBody?.setTranslation(z.position0, !0),
                z.rigidBody?.setRotation(z.rotation0, !0),
                z.rigidBody?.setLinvel(P1, !0),
                z.rigidBody?.setAngvel(P1, !0)),
              !bG.is(z))
            )
              return;
            let k = z.uuid,
              V = z.data;
            if ((delete z.states, z.uuid === fx)) return;
            let j = !1;
            for (let I of (B.some((I) => _.scene.find(k)?.isDescendantOf(I))
              ? (j = !0)
              : V.physics?.fusedBody === !0 &&
                "dynamic" === V.physics.rigidBody &&
                B.push(k),
            (z.data = V),
            (z.currentState = null),
            (z.reversibleToState = null),
            (z.currentTransitionEvent = null),
            V.states)) {
              let R = { ...I.data };
              !0 === _.data.globalPhysics.usePhysics &&
                V.physics &&
                ("dynamic" === V.physics.rigidBody || j) &&
                (void 0 !== I.data.position && delete R.position,
                void 0 !== I.data.rotation && delete R.rotation,
                void 0 !== I.data.hiddenMatrix && delete R.hiddenMatrix),
                z.states || (z.states = {}),
                (z.states[I.id] = vm.patch(V, R));
            }
            lN(
              _.scene,
              z,
              null,
              I,
              void 0 !==
                V.events.find(
                  (_) => "Follow" === _.data.type || "LookAt" === _.data.type
                )
            ),
              aN(_),
              z instanceof Ti &&
                z.frame &&
                (z.frame.traverse((_) => i(_)), z.uiCanvas?.applySize());
          }),
          _.frame && (_.frame.traverse((_) => i(_)), _.uiCanvas?.applySize());
      }
      function aN(_) {
        _.traverseEntity((I) => {
          for (let R of I.data.events) {
            let I = [];
            switch (R.data.type) {
              case "Follow":
              case "MouseHover":
              case "Scroll":
              case "MouseDown":
              case "MouseUp":
              case "MousePress":
              case "KeyUp":
              case "KeyDown":
              case "KeyPress":
              case "Collision":
                I.push(...R.data.actions);
                break;
              case "GameControl":
                for (let _ of Object.values(R.data.gameActions)) I.push(..._);
                break;
              case "DragDrop":
                I.push(
                  ...R.data.dragDropActions.drag,
                  ...R.data.dragDropActions.drop
                );
                break;
              case "Conditional":
                I.push(...R.data.inActions, ...R.data.outActions);
            }
            for (let R of I)
              if ("Create" === R.data.type && "Yes" === R.data.hideBase) {
                let I = _.scene.find(R.data.object);
                I && (I.visible = !1);
              }
          }
        });
      }
      function lN(_, I, R, B, z = !1) {
        if (
          (I instanceof S2 && I.removeInteractionGeometry(B),
          I instanceof CD
            ? I.changeSelectedState(R, { shared: B }, z)
            : I.changeSelectedState(R, { scene: _, shared: B }, z),
          I instanceof S2 && I.updateGeometryGroupsIfNeeded(),
          I instanceof AK &&
            I.updateCameraState(I.dataPatched, { scene: _, shared: B }),
          !(I instanceof CD))
        ) {
          if (I.cloner)
            for (let _ of I.cloner.children) _.playModeVisible = void 0;
          I.updateVisible(_);
        }
      }
      function CE(_) {
        let I;
        if (5 === _.easing) {
          let { control1: R, control2: B } = _;
          I = `cubicBezier(
			${R[0]}, ${R[1]}, ${B[0]}, ${B[1]}
		)`;
        } else if (6 === _.easing) {
          let { mass: R, stiffness: B, damping: z, velocity: k } = _;
          I = `spring( ${R}, ${B}, ${z}, ${k} )`;
        } else {
          let R;
          switch (_.easing) {
            case 0:
            default:
              R = mT.linear;
              break;
            case 1:
              R = mT.ease;
              break;
            case 2:
              R = mT.easeIn;
              break;
            case 3:
              R = mT.easeOut;
              break;
            case 4:
              R = mT.easeInOut;
          }
          let [B, z, k, V] = R;
          I = `cubicBezier( ${B}, ${z}, ${k}, ${V} )`;
        }
        return { duration: Math.max(_.duration, 1e-4), easing: I };
      }
      function ME(_) {
        let I = { delay: 0, loop: -1 === _.repeat || _.repeat + 1 };
        if (0 === _.repeat) (I.direction = "normal"), (I.rewind = !1);
        else
          switch (_.direction) {
            case "pingpong":
              (I.direction = "alternate"), (I.rewind = !1);
              break;
            case "pingpong-rewind":
              (I.direction = "alternate"), (I.rewind = !0);
              break;
            default:
              (I.direction = "normal"), (I.rewind = !1);
          }
        switch (
          ((I.delay = 0),
          (I.endDelay = 0),
          (I.startOnceDelay = 0),
          (I.pingPongDelayCorrection = 0),
          (I.pingPongEndDelayCorrection = 0),
          _.delayDirection)
        ) {
          case "start-once":
            I.startOnceDelay = _.delay;
            break;
          case "start":
            I.delay = _.delay;
            break;
          case "end":
            I.endDelay = _.delay;
            break;
          case "start-end":
          case void 0:
            (I.delay = _.delay), (I.endDelay = _.delay);
        }
        return (
          "alternate" === I.direction &&
            ((I.delay /= 2),
            (I.endDelay /= 2),
            "start" === _.delayDirection
              ? ((I.pingPongDelayCorrection = I.delay),
                "number" == typeof I.loop &&
                  I.loop % 2 == 0 &&
                  (I.pingPongEndDelayCorrection = I.delay))
              : "end" === _.delayDirection
              ? "number" == typeof I.loop &&
                I.loop % 2 != 0 &&
                (I.pingPongEndDelayCorrection = I.endDelay)
              : "start-end" === _.delayDirection &&
                ((I.pingPongDelayCorrection = I.delay),
                (I.pingPongEndDelayCorrection = I.endDelay))),
          I
        );
      }
      var P2 = { type: "beginState" },
        P4 = { type: "completeState", isfromEntity: !1 },
        P5 = class {
          constructor(_, I, R, B, z, k) {
            if (
              ((this.object = _),
              (this.data = B),
              (this.sharedAssets = z),
              (this.allowSlerp = k),
              (this.targets = { t: 0 }),
              (this.firstLoop = !0),
              (this._changeBegan = !1),
              (this._changeCompleted = !0),
              (this.onChange = () => {
                this.callback &&
                  (this.callback.update(this.targets.t),
                  this.object.requestRender()),
                  0 === this.targets.t || 1 === this.targets.t
                    ? this._changeCompleted ||
                      ((this._changeCompleted = !0),
                      (this._changeBegan = !1),
                      this.onChangeComplete())
                    : (this._changeCompleted && (this._changeCompleted = !1),
                      this._changeBegan ||
                        ((this._changeBegan = !0), this.onChangeBegin()));
              }),
              (this.onChangeBegin = () => {
                this.object.reversibleToState = this.to.id;
                let _ = this.targets.t > 0.5 ? this.from.id : this.to.id;
                this.object.prevState !== this.object.currentState &&
                  (this.object.prevState = this.object.currentState),
                  (this.object.currentState = _),
                  this.object.dispatchEvent({ type: "beginState", state: _ }),
                  this.object instanceof CD ||
                    this.object.traverseEntity((_) => {
                      _ !== this.object &&
                        _ instanceof AK &&
                        _.dispatchEvent(P2);
                    });
              }),
              (this.onChangeComplete = () => {
                this.firstLoop && (this.onFirstLoop(), (this.firstLoop = !1)),
                  (this.object.reversibleToState = this.to.id);
                let _ = this.targets.t < 0.5 ? this.from.id : this.to.id;
                this.object.prevState !== this.object.currentState &&
                  (this.object.prevState = this.object.currentState),
                  (this.object.currentState = _),
                  this.object.dispatchEvent({
                    type: "completeState",
                    state: _,
                  }),
                  this.object instanceof CD ||
                    this.object.traverseEntity((_) => {
                      _ !== this.object &&
                        _ instanceof AK &&
                        _.dispatchEvent(P4);
                    });
              }),
              (this.onFirstLoop = () => {
                this.useCurrentState &&
                  (this.callback = TE(
                    this.object,
                    this.from.data,
                    this.to.data,
                    this.sharedAssets,
                    this.allowSlerp
                  ));
              }),
              void 0 === I)
            ) {
              let _ = Sb(
                this.object,
                this.object.currentState === R
                  ? this.object.prevState
                  : this.object.currentState
              );
              if (!_) throw Error("Missing property");
              this.from = _;
            } else {
              let _ = Sb(this.object, I);
              if (!_) throw Error("Missing property");
              this.from = _;
            }
            if (void 0 === R) throw Error("Missing property");
            {
              let _ = Sb(this.object, R);
              if (!_) throw Error("Missing property");
              this.to = _;
            }
            (this.useCurrentState = void 0 === I || void 0 === R),
              (this.params = {
                targets: this.targets,
                t: 1,
                autoplay: !1,
                ...ME(B),
                ...CE(B),
                change: this.onChange,
              }),
              (this.callback = TE(
                this.object,
                void 0 === I ? {} : this.from.data,
                void 0 === R ? {} : this.to.data,
                this.sharedAssets,
                this.allowSlerp
              ));
          }
          get changeBegan() {
            return this._changeBegan;
          }
          get changeCompleted() {
            return this._changeCompleted;
          }
        },
        P6 = class extends i8 {
          constructor(_, I, R, B) {
            if (
              (super(),
              (this.data = _),
              (this.page = I),
              (this.shared = R),
              (this.condition = B),
              (this.toggleIsForward = !1),
              (this.timelineNeedsRebuild = !1),
              (this.useToggle = !1),
              (this.onTimelineChangeComplete = () => {
                "normal" !== this.data.tweens[0].data.direction &&
                  (this.toggleIsForward = !this.toggleIsForward),
                  !1 !== this.timelineNeedsRebuild &&
                    (this.timeline?.pause(),
                    this.buildTimeline({
                      isForward: this.toggleIsForward,
                      needsRebuild: !1,
                      isRebuild: !0,
                    }),
                    this.timeline.play());
              }),
              !_.object)
            )
              throw Error("Missing property");
            let z =
              this.page.scene.find(_.object) ??
              this.page.uiCanvas?.find(_.object) ??
              this.page.scene.find2DInUIObjects(_.object);
            if (!z || !z.states || ((this.object = z), _.tweens.length < 2))
              throw Error("Missing property");
            (this.tweens = Array(this.data.tweens.length - 1)),
              (this.startOnceDelay =
                "start-once" === _.tweens[0].data.delayDirection
                  ? _.tweens[0].data.delay
                  : 0),
              this.init();
          }
          get playing() {
            return this.timeline?.paused === !1;
          }
          get changeBegan() {
            return this.tweens.some((_) => _.changeBegan) ?? !1;
          }
          init() {
            (this.initialCurrentState = Sb(
              this.object,
              this.object.currentState
            ).id),
              (this.toggleIsForward = !1);
          }
          get currentState() {
            return this.useToggle
              ? this.initialCurrentState
              : this.object.currentState;
          }
          buildTimeline({
            isForward: _ = !0,
            needsRebuild: I = !1,
            isRebuild: R = !1,
          } = {}) {
            try {
              let B = ME(this.data.tweens[0].data);
              R && "number" == typeof B.loop && B.loop--,
                this.timeline?.pause(),
                (this.timeline = ui.timeline({
                  autoplay: !1,
                  ...B,
                  ...(!0 === B.loop || B.loop > 1
                    ? { timelineChangeComplete: this.onTimelineChangeComplete }
                    : {}),
                }));
              let z = this.tweens.findIndex((_) => _?.changeBegan);
              if ((!0 === I && (this.timelineNeedsRebuild = !0), _)) {
                let _ = -1 === z ? 0 : z;
                for (let I = _; I < this.data.tweens.length - 1; I++) {
                  let R = this.data.tweens[I],
                    k = this.data.tweens[I + 1],
                    V;
                  I === _ &&
                  (!0 === this.object.wasMovedByUser ||
                    this.object.previousAction?.changeBegan === !0)
                    ? ((V = void 0),
                      this.object instanceof AK &&
                        (this.object.wasMovedByUser = !1))
                    : (V =
                        void 0 === R.data.state
                          ? this.currentState
                          : R.data.state);
                  let j = new P5(
                    this.object,
                    V,
                    void 0 === k.data.state ? this.currentState : k.data.state,
                    k.data,
                    this.shared,
                    this.data.allowSlerp ?? !1
                  );
                  -1 !== z &&
                    I === _ &&
                    Object.assign(j.params, { startOnceDelay: 0 }),
                    (this.tweens[I] = j),
                    this.timeline.add(
                      j.params,
                      this.timeline.duration + (I === _ ? B.delay : 0)
                    );
                }
                this.timeline.duration += B.endDelay;
              } else {
                let _ = -1 === z ? this.data.tweens.length - 1 : z + 1;
                for (let I = _; I > 0; I--) {
                  let R = this.data.tweens[I],
                    k = this.data.tweens[I - 1],
                    V;
                  I === _ &&
                  (!0 === this.object.wasMovedByUser ||
                    this.object.previousAction?.changeBegan === !0)
                    ? ((V = void 0),
                      this.object instanceof AK &&
                        (this.object.wasMovedByUser = !1))
                    : (V =
                        void 0 === R.data.state
                          ? this.currentState
                          : R.data.state);
                  let j = new P5(
                    this.object,
                    V,
                    void 0 === k.data.state ? this.currentState : k.data.state,
                    R.data,
                    this.shared,
                    this.data.allowSlerp ?? !1
                  );
                  -1 !== z &&
                    I === _ &&
                    Object.assign(j.params, { startOnceDelay: 0 }),
                    (this.tweens[I - 1] = j),
                    this.timeline.add(
                      j.params,
                      this.timeline.duration + (I === _ ? B.endDelay : 0)
                    );
                }
                this.timeline.duration += B.delay;
              }
            } catch (_) {
              _ instanceof Error && console.error(_.message);
            }
            this.object.previousAction?.playing === !0 &&
              this.object.previousAction.pause(),
              (this.object.previousAction = this);
          }
          play() {
            if (!1 === Ut(this.shared, this.condition) || this.playing)
              return !1;
            clearTimeout(this.timeoutId);
            let _ = ME(this.data.tweens[0].data).pingPongDelayCorrection;
            this.timeoutId = window.setTimeout(() => {
              try {
                this.buildTimeline(), this.timeline.play();
              } catch (_) {
                _ instanceof Error && console.error(_.message);
              }
            }, this.startOnceDelay + _);
          }
          pause() {
            this.timeline?.pause(),
              clearTimeout(this.timeoutId),
              (this.tweens = Array(this.data.tweens.length - 1)),
              delete this.timeoutId;
          }
          stop() {
            this.pause();
            let _ =
              void 0 === this.data.tweens[0].data.state
                ? this.initialCurrentState
                : this.data.tweens[0].data.state;
            this.object instanceof CD
              ? this.object.changeSelectedState(_, { shared: this.shared })
              : this.object.changeSelectedState(_, {
                  scene: this.page.scene,
                  shared: this.shared,
                }),
              (this.object.currentState = _);
          }
          seek(_) {
            void 0 === this.timeline && this.buildTimeline(),
              this.timeline?.seek(_ * this.timeline.duration, !0);
          }
          toggle(_) {
            if (!1 === Ut(this.shared, this.condition)) return !1;
            (this.useToggle = !0),
              clearTimeout(this.timeoutId),
              (this.toggleIsForward = _ ?? !this.toggleIsForward),
              this.playing
                ? (this.timeline?.pause(),
                  this.buildTimeline({
                    isForward: this.toggleIsForward,
                    needsRebuild: !0,
                  }),
                  this.timeline.play())
                : (this.timeoutId = window.setTimeout(() => {
                    this.timeline?.pause(),
                      this.buildTimeline({ isForward: this.toggleIsForward }),
                      this.timeline.play();
                  }, this.startOnceDelay));
          }
          playFromCurrent() {
            this.toggle(!0);
          }
          reverseFromCurrent() {
            this.toggle(!1);
          }
          dispose() {
            this.pause();
          }
        };
      function Sb(_, I) {
        let R, B;
        if (
          ("string" == typeof I
            ? ((R = I), (B = _.states?.[R]))
            : null === I && ((R = null), (B = _.data)),
          !(void 0 === R || void 0 === B))
        )
          return { id: R, data: B };
      }
      var P8 = { type: "beginState" },
        P9 = { type: "completeState", isfromEntity: !1 },
        P7 = { type: "requestRender" },
        De = class extends i8 {
          constructor(_, I, R, B) {
            super(),
              (this.data = _),
              (this.page = I),
              (this.shared = R),
              (this.condition = B),
              (this.toggleIsForward = !1),
              (this.useToggle = !1),
              (this.posStart = new rF()),
              (this.posEnd = new rF()),
              (this.qStart = new rz()),
              (this.qEnd = new rz()),
              (this.zoomStart = 1),
              (this.zoomEnd = 1);
          }
          init() {}
          get playing() {
            return (
              this.animation &&
              this.animation.began &&
              !this.animation.completed
            );
          }
          buildAnimation(_ = !1) {
            if (!this.data.animate) return;
            let I = this.page.scene.find(this.data.targetCamera);
            if (!I || !I.visible)
              throw ReferenceError("Target camera not founded or not visible");
            let R = { t: 0 };
            this.posStart.copy(this.page.activeCamera.position),
              this.qStart.copy(this.page.activeCamera.quaternion),
              (this.zoomStart = this.page.activeCamera.zoom),
              (this.animation = ui({
                targets: R,
                t: 1,
                ...CE(this.data),
                update: () => {
                  0 === R.t &&
                    (this.useToggle && !this.toggleIsForward
                      ? (this.posEnd.copy(this.fromCamera.position),
                        this.qEnd.copy(this.fromCamera.quaternion),
                        (this.zoomEnd = this.fromCamera.zoom),
                        this.switchCamera(this.fromCamera.uuid))
                      : (this.posEnd.copy(I.position),
                        this.qEnd.copy(I.quaternion),
                        (this.zoomEnd = I.zoom),
                        (this.fromCamera = this.page.activeCamera),
                        this.switchCamera(I.uuid)),
                    this.page.activeCamera.dispatchEvent(P8));
                  let _ = this.page.activeCamera;
                  _.position.lerpVectors(this.posStart, this.posEnd, R.t),
                    _.quaternion.slerpQuaternions(this.qStart, this.qEnd, R.t),
                    (_.zoom =
                      this.zoomStart + (this.zoomEnd - this.zoomStart) * R.t),
                    (_.wasMovedBySwitchCameraAction = !0),
                    _.updateMatrix(),
                    _.updateMatrixWorld(),
                    _.updateProjectionMatrix(),
                    _.dispatchEvent(P7),
                    1 === R.t && _.dispatchEvent(P9);
                },
              }));
          }
          switchCamera(_) {
            let I = this.page.activeCamera,
              R = this.page.scene.find(_);
            if (!R || !R.visible)
              throw ReferenceError("Target camera not founded or not visible");
            this.page.switchActiveCamera(R),
              I.dispatchEvent({ type: "cameraChange", camera: R });
          }
          play() {
            if (!1 === Ut(this.shared, this.condition)) return !1;
            if (
              !this.playing &&
              this.page.activeCamera.uuid !== this.data.targetCamera
            )
              try {
                clearTimeout(this.timeoutId),
                  (this.timeoutId = window.setTimeout(() => {
                    delete this.timeoutId,
                      this.data.animate
                        ? (this.buildAnimation(), this.animation?.play())
                        : this.switchCamera(this.data.targetCamera);
                  }, 1e3 * this.data.delay));
              } catch {}
          }
          pause() {
            this.animation?.pause(),
              clearTimeout(this.timeoutId),
              delete this.timeoutId;
          }
          toggle(_) {
            if (!1 === Ut(this.shared, this.condition)) return !1;
            (this.useToggle = !0),
              clearTimeout(this.timeoutId),
              (this.toggleIsForward = _ ?? !this.toggleIsForward);
            try {
              this.playing
                ? (this.animation?.pause(),
                  this.buildAnimation(!0),
                  this.animation?.play())
                : (this.timeoutId = window.setTimeout(() => {
                    delete this.timeoutId,
                      this.data.animate
                        ? (this.animation?.pause(),
                          this.buildAnimation(),
                          this.animation?.play())
                        : (this.toggleIsForward
                            ? ((this.fromCamera = this.page.activeCamera),
                              this.switchCamera(this.data.targetCamera))
                            : this.switchCamera(this.fromCamera.uuid),
                          this.page.activeCamera.dispatchEvent(P9),
                          this.page.activeCamera.dispatchEvent(P7));
                  }, 1e3 * this.data.delay));
            } catch {}
          }
          playFromCurrent() {
            this.toggle(!0);
          }
          reverseFromCurrent() {
            this.toggle(!1);
          }
          dispose() {
            this.pause(), (this.toggleIsForward = !1);
          }
        },
        Dt = class extends i8 {
          constructor(_, I, R, B, z) {
            super(),
              (this.page = I),
              (this.animationControls = R),
              (this.shared = B),
              (this.condition = z),
              (this.startOnceDelay = 0),
              (this.toggleIsForward = !1);
            let k = _.object,
              V = I.scene.find(_.object);
            V && Array.isArray(V.identity) && (k = V.identity[0]),
              (this.data = { ..._, object: k });
            let j = this.animationControls.clipIdToAction[_.clipId + "/" + k];
            this.duration = j?.getClip()?.duration ?? 1;
            let G = j?.getClip()?.tracks[0]?.times.length ?? 1 / 0;
            (this.leftFrameTime = (this.data.crop[0] / G) * this.duration),
              (this.rightFrameTime = (this.data.crop[1] / G) * this.duration),
              (this.startOnceDelay = _.delay);
          }
          get playing() {
            return this.threeAnimAction?.isRunning() ?? !1;
          }
          play(_ = !1) {
            if (!1 === Ut(this.shared, this.condition)) return !1;
            window.clearTimeout(this.timeoutId),
              (this.timeoutId = window.setTimeout(() => {
                if (
                  ((this.threeAnimAction = this.animationControls.play(
                    this.data
                  )),
                  !this.threeAnimAction)
                )
                  return;
                this.threeAnimAction.reset(),
                  (this.threeAnimAction.time = this.leftFrameTime),
                  (this.threeAnimAction._clip.start = this.leftFrameTime),
                  (this.threeAnimAction._clip.duration = this.rightFrameTime);
                let I = this.data.object;
                Object.entries(this.animationControls.clipIdToAction).forEach(
                  ([R, B]) => {
                    let z = R.split("/")[1];
                    this.threeAnimAction !== B &&
                      z === I &&
                      B.isRunning() &&
                      (_ ? B.fadeOut(0.2) : B.stop());
                  }
                ),
                  _ && this.threeAnimAction?.fadeIn(0.2);
              }, this.startOnceDelay));
          }
          pause() {
            this.threeAnimAction && (this.threeAnimAction.paused = !0),
              window.clearTimeout(this.timeoutId),
              delete this.timeoutId;
          }
          stop() {
            this.threeAnimAction?.fadeOut(0.2);
          }
          seek(_) {
            (this.threeAnimAction = this.animationControls.play(this.data)),
              this.threeAnimAction &&
                ((this.threeAnimAction.paused = !0),
                (this.threeAnimAction.time = rr.clamp(
                  this.threeAnimAction.time + (1 / 60) * _,
                  this.leftFrameTime,
                  this.rightFrameTime - 16e-5
                )),
                (this.animationControls.needsUpdate = !0),
                this.animationControls.requestRender());
          }
          toggle(_, I = !1) {
            if (!1 === Ut(this.shared, this.condition)) return !1;
            (this.toggleIsForward = _ ?? !this.toggleIsForward),
              this.threeAnimAction && (this.threeAnimAction._loopCount = 0),
              this.playing
                ? this.threeAnimAction &&
                  ((this.threeAnimAction.timeScale = this.toggleIsForward
                    ? 1
                    : -1),
                  this.toggleIsForward
                    ? ((this.threeAnimAction._clip.start = this.leftFrameTime),
                      (this.threeAnimAction._clip.duration =
                        this.rightFrameTime))
                    : ((this.threeAnimAction._clip.start = this.rightFrameTime),
                      (this.threeAnimAction._clip.duration =
                        this.leftFrameTime)))
                : (this.timeoutId = window.setTimeout(() => {
                    if (
                      ((this.threeAnimAction = this.animationControls.play(
                        this.data
                      )),
                      this.threeAnimAction)
                    ) {
                      this.toggleIsForward
                        ? ((this.threeAnimAction.time = this.leftFrameTime),
                          (this.threeAnimAction._clip.start =
                            this.leftFrameTime),
                          (this.threeAnimAction._clip.duration =
                            this.rightFrameTime))
                        : ((this.threeAnimAction.time = this.rightFrameTime),
                          (this.threeAnimAction._clip.start =
                            this.rightFrameTime),
                          (this.threeAnimAction._clip.duration =
                            this.leftFrameTime)),
                        (this.threeAnimAction.paused = !1),
                        (this.threeAnimAction.timeScale = this.toggleIsForward
                          ? 1
                          : -1);
                      let _ = this.data.clipId.split("/")[1];
                      Object.entries(
                        this.animationControls.clipIdToAction
                      ).forEach(([R, B]) => {
                        let z = R.split("/")[1];
                        this.threeAnimAction !== B &&
                          z === _ &&
                          B.isRunning() &&
                          (I ? B.fadeOut(0.2) : B.stop());
                      }),
                        I && this.threeAnimAction?.fadeIn(0.2);
                    }
                  }, this.startOnceDelay));
          }
          playFromCurrent() {
            this.toggle(!0);
          }
          reverseFromCurrent() {
            this.toggle(!1);
          }
          dispose() {
            let _ =
              this.animationControls.clipIdToAction[
                this.data.clipId + "/" + this.data.object
              ]?.getClip();
            _ && (_.duration = this.duration), this.pause();
          }
        },
        Di = class {
          constructor(_, I, R, B, z) {
            (this.data = _),
              (this.page = I),
              (this.eventManager = R),
              (this.shared = B),
              (this.condition = z),
              (this.timeOutId = -1),
              (this.scene = I.scene);
          }
          dispatch() {
            if (!1 === Ut(this.shared, this.condition)) return !1;
            this.data.target !== this.page.uuid &&
              (window.clearTimeout(this.timeOutId),
              (this.timeOutId = window.setTimeout(() => {
                this.play();
              }, 1e3 * this.data.delay)));
          }
          dispose() {
            window.clearTimeout(this.timeOutId);
          }
          play() {
            if (this.scene.children.every((_) => _.uuid !== this.data.target))
              return;
            "fade" === this.data.transition &&
              this.data.duration > 0 &&
              this.eventManager.eventContext.renderer.renderFromSceneForSceneTransitionPass(
                this.scene,
                this.scene.activeCamera,
                1e3 * this.data.duration
              ),
              this.eventManager.deactivate(),
              this.eventManager.controlsManager.deactivate();
            let _ = this.scene.activeCamera;
            this.scene.updatePage(this.data.target),
              this.scene.traverseVisibleEntity((_) => {
                "ParticleSystem" === _.type &&
                  (_.sleep(),
                  _.wakeUp(),
                  _.data.autoPlay ? _.start() : _.stop());
              }),
              this.scene.activePage.switchToPlayCamera(),
              this.scene.activeCamera.copyViewPlaneSize(_),
              qf(this.scene.activePage, this.shared),
              this.eventManager.activate(),
              this.eventManager.controlsManager.activate(this.eventManager);
          }
        },
        Dr = class {
          constructor(_, I, R, B) {
            (this.data = _),
              (this.page = I),
              (this.shared = R),
              (this.condition = B),
              (this.evaluatedCondition = !1);
          }
          checkConditions() {
            this.evaluatedCondition = Ut(this.shared, this.condition);
          }
          dispatch() {
            if (!1 === this.evaluatedCondition) return !1;
            let _ = this.shared.getVariable(this.data.variableId),
              I = j0(this.data.expression, this.shared, vR.typeOfVariable(_));
            void 0 !== I &&
              this.shared.updateVariable(
                this.data.variableId,
                "string" == typeof I ? { textValue: I } : I
              );
          }
          dispose() {}
        },
        Ds = class {
          constructor(_, I, R, B) {
            (this.data = _),
              (this.page = I),
              (this.shared = R),
              (this.condition = B),
              (this.timeoutId = null);
          }
          dispatchInner() {
            if (!1 === Ut(this.shared, this.condition)) return !1;
            let _ = this.shared.getDynamicVariablePlayState(
              this.data.variableId
            );
            if ("PlayPause" === this.data.mode)
              void 0 ===
                this.shared.getDynamicVariableToggleIsForward(
                  this.data.variableId
                ) &&
                this.shared.setDynamicVariableToggleIsForward(
                  this.data.variableId,
                  !0
                ),
                this.shared.setDynamicVariablePlayState(
                  this.data.variableId,
                  "Playing" === _ ? "Paused" : "Playing"
                );
            else if ("Play" === this.data.mode && "Playing" !== _)
              void 0 ===
                this.shared.getDynamicVariableToggleIsForward(
                  this.data.variableId
                ) &&
                this.shared.setDynamicVariableToggleIsForward(
                  this.data.variableId,
                  !0
                ),
                this.shared.setDynamicVariablePlayState(
                  this.data.variableId,
                  "Playing"
                );
            else if ("Stop" === this.data.mode && "Stopped" !== _)
              this.shared.setDynamicVariablePlayState(
                this.data.variableId,
                "Stopped"
              );
            else if ("Pause" === this.data.mode && "Paused" !== _)
              this.shared.setDynamicVariablePlayState(
                this.data.variableId,
                "Paused"
              );
            else if ("Restart" === this.data.mode)
              this.shared.setDynamicVariablePlayState(
                this.data.variableId,
                "Restarted"
              );
            else if ("Toggle" === this.data.mode) {
              let I = this.shared.getDynamicVariableToggleIsForward(
                this.data.variableId
              );
              "Playing" === _
                ? this.shared.setDynamicVariableToggleIsForward(
                    this.data.variableId,
                    void 0 !== I && !I
                  )
                : (this.shared.setDynamicVariableToggleIsForward(
                    this.data.variableId,
                    !I
                  ),
                  this.shared.setDynamicVariablePlayState(
                    this.data.variableId,
                    "Playing"
                  ));
            }
          }
          dispatch() {
            let _ = this.data.delay,
              I = this.shared.getDynamicVariablePlayState(this.data.variableId);
            "PlayPause" === this.data.mode &&
              "Playing" === I &&
              (_ = this.data.pauseDelay),
              0 !== _
                ? (this.timeoutId && window.clearTimeout(this.timeoutId),
                  (this.timeoutId = window.setTimeout(() => {
                    (this.timeoutId = null), this.dispatchInner();
                  }, _)))
                : this.dispatchInner();
          }
          dispose() {
            this.timeoutId && window.clearTimeout(this.timeoutId);
          }
        };
      function Ut(_, I) {
        if (void 0 === I) return !0;
        if (0 === I.expression.length) return !1;
        let R = j0(I.expression, _, "boolean");
        return I.negate ? !R : !!R;
      }
      function Mr(_, I, R, B, z, k) {
        let V = {
            Audio: [],
            Video: [],
            Particles: [],
            Link: [],
            Destroy: [],
            Create: [],
            Reset: [],
            Transition: [],
            SwitchCamera: [],
            Animation: [],
            SceneTransition: [],
            SetVariable: [],
            DynamicVariablePlay: [],
          },
          a =
            (I) =>
            ({ id: j, data: G }) => {
              try {
                "Audio" === G.type
                  ? fy[_.type].includes("Audio") &&
                    V.Audio.push(new P_(j, G, k, B, I))
                  : "Video" !== G.type || k instanceof CD
                  ? "Particles" === G.type
                    ? fy[_.type].includes("Particles") &&
                      V.Particles.push(new PS(G, R, B, I))
                    : "Link" === G.type
                    ? fy[_.type].includes("Link") &&
                      V.Link.push(new PA(G, z.controlsManager, B, I))
                    : "Create" === G.type
                    ? fy[_.type].includes("Create") &&
                      V.Create.push(new Dg(G, R, z.controlsManager, B, I))
                    : "Destroy" === G.type
                    ? fy[_.type].includes("Destroy") &&
                      V.Destroy.push(new PE(G, R, z.controlsManager, B, I))
                    : "Reset" === G.type
                    ? fy[_.type].includes("Reset") &&
                      V.Reset.push(new PT(G, R, B, z, I))
                    : "Transition" === G.type
                    ? fy[_.type].includes("Transition") &&
                      V.Transition.push(new P6(G, R, B, I))
                    : "SwitchCamera" === G.type
                    ? fy[_.type].includes("SwitchCamera") &&
                      V.SwitchCamera.push(new De(G, R, B, I))
                    : "SceneTransition" === G.type
                    ? fy[_.type].includes("SceneTransition") &&
                      V.SceneTransition.push(new Di(G, R, z, B, I))
                    : "Animation" === G.type
                    ? fy[_.type].includes("Animation") &&
                      V.Animation.push(new Dt(G, R, z.animationControls, B, I))
                    : "SetVariable" === G.type
                    ? fy[_.type].includes("SetVariable") &&
                      V.SetVariable.push(new Dr(G, R, B, I))
                    : "DynamicVariablePlay" === G.type
                    ? fy[_.type].includes("DynamicVariablePlay") &&
                      V.DynamicVariablePlay.push(new Ds(G, R, B, I))
                    : "Conditional" === G.type &&
                      fy[_.type].includes("Conditional") &&
                      (G.ifActions.forEach(
                        a({ expression: G.condition, negate: !1 })
                      ),
                      G.elseActions.forEach(
                        a({ expression: G.condition, negate: !0 })
                      ))
                  : fy[_.type].includes("Video") &&
                    V.Video.push(new Dd(j, G, k, B, I));
              } catch (_) {}
            };
        return I.forEach(a()), V;
      }
      function dr(_) {
        Object.values(_).forEach((_) => {
          _.forEach((_) => {
            (_ instanceof P_ ||
              _ instanceof Dd ||
              _ instanceof PS ||
              _ instanceof Dt ||
              _ instanceof P6 ||
              _ instanceof Dg ||
              _ instanceof PE ||
              _ instanceof De ||
              _ instanceof Di ||
              _ instanceof PT ||
              _ instanceof Dr ||
              _ instanceof Ds) &&
              _.dispose();
          });
        });
      }
      var Da = new Map(),
        Dn = new Map(),
        Do = class {
          constructor(_, I, R) {
            (this.data = I), (this.delay = 0), (this.status = "stopped");
            let { layerId: B, loop: z, volume: k, delay: V } = I;
            if (((this.object = R), void 0 === B))
              throw Error("Missing property");
            let j = (function (_, I) {
              let R;
              if (
                ("material" in _ &&
                  (R = Array.isArray(_.material)
                    ? _.material[0].layers.find((_) => _.uuid === I)
                    : _.material.layers.find((_) => _.uuid === I)),
                R)
              )
                return R.color.texture.image.img instanceof HTMLVideoElement
                  ? R.color.texture.image.img
                  : void 0;
            })(R, B);
            j &&
              ((this.videoElement = j),
              (this.videoElement.loop = z === 1 / 0),
              uc && (this.videoElement.autoplay = !0),
              void 0 !== k && (this.videoElement.volume = k)),
              void 0 !== V && (this.delay = V),
              Dn.has(R.uuid)
                ? Dn.get(R.uuid).push(this)
                : Dn.set(R.uuid, [this]),
              Da.set(_, this),
              this.pause();
          }
          mute() {
            this.videoElement && (this.videoElement.muted = !0);
          }
          unMute() {
            this.videoElement && (this.videoElement.muted = !1);
          }
          play(_) {
            if (!this.videoElement) return;
            let I =
              /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                navigator.userAgent
              );
            _
              ? (this.mute(), (this.delay += 150))
              : I
              ? (this.mute(),
                window.setTimeout(() => {
                  this.unMute();
                }, 100))
              : this.unMute(),
              (this.delayTimerId = window.setTimeout(() => {
                if (!this.videoElement) return;
                let _ = this.videoElement.play();
                void 0 !== _ &&
                  _.then((_) => {}).catch((_) => {
                    this.play();
                  }),
                  this.clearDelay();
              }, this.delay)),
              (this.status = "playing");
          }
          clearDelay() {
            this.delayTimerId &&
              (clearTimeout(this.delayTimerId), delete this.delayTimerId);
          }
          pause() {
            this.videoElement &&
              (this.videoElement.pause(), (this.status = "paused"));
          }
          stop() {
            this.videoElement &&
              (this.videoElement.pause(),
              (this.videoElement.currentTime = 0),
              (this.status = "stopped"),
              this.clearDelay());
          }
          playByToggle() {
            "stop" === this.data.toggle
              ? "playing" === this.status
                ? this.stop()
                : (this.stop(), this.play())
              : "pause" === this.data.toggle
              ? "playing" === this.status
                ? this.pause()
                : this.play()
              : (this.stop(), this.play());
          }
          dispose() {
            this.videoElement && (this.stop(), (this.videoElement.muted = !0));
          }
        },
        Dl = class {
          constructor(_) {
            this.data = _;
          }
          dispatch() {
            this.data.playVideo
              ? this.pauseVideo(this.data.playVideo)
              : this.data.object
              ? this.pauseAllVideosFromObject(this.data.object)
              : this.pauseAllVideos();
          }
          pauseVideo(_) {
            let I = Da.get(_);
            I &&
              (this.data.delay > 0
                ? (this.disposeDelay(),
                  (this.timeoutId = window.setTimeout(() => {
                    I[this.data.interaction](), this.disposeDelay();
                  }, this.data.delay)))
                : I[this.data.interaction]());
          }
          pauseAllVideosFromObject(_) {
            let I = Dn.get(_);
            I?.length &&
              (this.data.delay > 0
                ? (this.disposeDelay(),
                  (this.timeoutId = window.setTimeout(() => {
                    I.forEach((_) => _[this.data.interaction]()),
                      this.disposeDelay();
                  }, this.data.delay)))
                : I.forEach((_) => _[this.data.interaction]()));
          }
          pauseAllVideos() {
            let _ = [...Dn.values()];
            _.length &&
              (this.data.delay > 0
                ? (this.disposeDelay(),
                  (this.timeoutId = window.setTimeout(() => {
                    _.forEach((_) => {
                      _.forEach((_) => {
                        _[this.data.interaction]();
                      });
                    }),
                      this.disposeDelay();
                  }, this.data.delay)))
                : _.forEach((_) => {
                    _.forEach((_) => {
                      _[this.data.interaction]();
                    });
                  }));
          }
          disposeDelay() {
            clearTimeout(this.timeoutId), delete this.timeoutId;
          }
          dispose() {
            clearTimeout(this.timeoutId), delete this.timeoutId;
          }
        },
        Dd = class {
          constructor(_, I, R, B, z) {
            if (
              ((this.data = I),
              (this.shared = B),
              (this.condition = z),
              "play" === I.interaction)
            )
              this.interaction = new Do(_, I, R);
            else if ("pause" === I.interaction || "stop" === I.interaction)
              this.interaction = new Dl(I);
            else throw Error("Missing property");
          }
          dispatchBasic() {
            if (!1 === Ut(this.shared, this.condition)) return !1;
            this.interaction instanceof Do
              ? this.interaction.playByToggle()
              : this.interaction.dispatch();
          }
          dispatchConditional() {
            if (!1 === Ut(this.shared, this.condition)) return !1;
            this.interaction instanceof Do
              ? this.interaction.play()
              : this.interaction.dispatch();
          }
          dispose() {
            this.interaction.dispose();
          }
        },
        Du = (() => {
          let _, I, R, B;
          function i(R) {
            !_ &&
              !pN() &&
              I?.sharedGameControlGlobals.createdObjects.length > 0 &&
              (_ = requestAnimationFrame(s)),
              R && ((I = R), (B = R.requestRender));
          }
          function s(z) {
            let k = R ? z - R : 0,
              V = I.sharedGameControlGlobals.createdObjects,
              j = I.sharedGameControlGlobals.nCreatedPerAction,
              G = V.length,
              q = 0;
            for (; q < G; ) {
              let _ = V[q];
              void 0 === _.userData.createdTime && (_.userData.createdTime = z),
                (void 0 === _.userData.lifetime &&
                  void 0 === _.userData.quantity) ||
                (_.userData.lifetime &&
                  z - _.userData.createdTime < _.userData.lifetime) ||
                (_.userData.quantity &&
                  j[_.userData.actionId] <= _.userData.quantity)
                  ? (_.userData.velocity &&
                      (_.position.addScaledVector(_.userData.velocity, k / 1e3),
                      _.updateMatrix(),
                      B()),
                    q++)
                  : (j[_.userData.actionId] > _.userData.quantity &&
                      j[_.userData.actionId]--,
                    V.splice(q, 1),
                    _.removeFromParent(),
                    I.sharedGameControlGlobals.rapierWorld && _.rigidBody
                      ? (I.sharedGameControlGlobals.colliderToEntity.delete(
                          _.rigidBody.collider(0).handle
                        ),
                        I.sharedGameControlGlobals.rapierWorld.removeRigidBody(
                          _.rigidBody
                        ))
                      : ((_.bvhGeometry = void 0),
                        (I.sharedGameControlGlobals.entitiesWithTransformAnim =
                          I.sharedGameControlGlobals.entitiesWithTransformAnim.filter(
                            (_) => void 0 !== _.bvhGeometry
                          ))),
                    G--,
                    B());
            }
            (_ = q > 0 ? requestAnimationFrame(s) : void 0),
              (R = q > 0 ? z : void 0);
          }
          return (
            "u" > typeof document &&
              document.addEventListener("visibilitychange", function () {
                pN()
                  ? _ && (cancelAnimationFrame(_), (_ = void 0), (R = void 0))
                  : i();
              }),
            i
          );
        })();
      function pN() {
        return !!document && document.hidden;
      }
      var Dp = new rz(),
        Df = new rF(),
        Dm = new rF(),
        Dg = class {
          constructor(_, I, R, B, z) {
            (this.data = _),
              (this.page = I),
              (this.controlsManager = R),
              (this.shared = B),
              (this.condition = z),
              (this.intervalId = null),
              (this.timeoutIdQueue = []),
              (this.uniqueId = rr.generateUUID()),
              (this.dispatch = () => {
                if (!1 === Ut(this.shared, this.condition)) return !1;
                this.data.delay
                  ? this.timeoutIdQueue.push(
                      window.setTimeout(
                        this.dispatchInner,
                        1e3 * this.data.delay
                      )
                    )
                  : this.dispatchInner();
              }),
              (this.dispatchFromStart = () => {
                if (!1 === Ut(this.shared, this.condition)) return !1;
                this.timeoutIdQueue.push(
                  window.setTimeout(this.dispatchInner, 1e3 * this.data.delay)
                );
              }),
              (this.dispatchThrottled = Kw(
                this.dispatch,
                1e3 / this.data.creationSpeed
              )),
              (this.dispatchStart = () => {
                null === this.intervalId &&
                  (this.intervalId = window.setInterval(
                    this.dispatch,
                    1e3 / this.data.creationSpeed
                  ));
              }),
              (this.dispatchStop = () => {
                null !== this.intervalId &&
                  (window.clearInterval(this.intervalId),
                  (this.intervalId = null));
              }),
              (this.dispatchInner = () => {
                this.timeoutIdQueue.shift();
                let _ = new yj(this.object);
                if (
                  ((_.playModeVisible = !0),
                  _.expand(),
                  "world" !== this.data.coordinateSystem)
                ) {
                  let I = this.data.coordinateSystem,
                    R = this.page.scene.find(I);
                  R &&
                    (R.updateMatrixWorldSVD(),
                    _.hiddenMatrix.copy(R.matrixWorldRigid));
                }
                _.position.fromArray(this.data.position),
                  _.rotation.fromArray(this.data.rotation),
                  _.updateMatrix(),
                  this.page.add(_);
                let I = this.controlsManager.sharedGameControlGlobals;
                I.createdObjects.push(_),
                  void 0 === I.nCreatedPerAction[this.uniqueId]
                    ? (I.nCreatedPerAction[this.uniqueId] = 1)
                    : I.nCreatedPerAction[this.uniqueId]++,
                  _.updateWorldMatrix(!0, !0),
                  _.traverseObject(this.traverseObjectCB),
                  Du(),
                  this.controlsManager.requestRender();
              }),
              (this.traverseObjectCB = (_) => {
                let I;
                if (
                  (_.hasNonUniformScale && _.updateMatrixWorldSVD(),
                  this.controlsManager.sharedGameControlGlobals.rapierWorld)
                ) {
                  if (_ instanceof AI) {
                    if (!_.objectForSample)
                      return (
                        (!0 === _.object.dataPatched.physics.fusedBody &&
                          "dynamic" ===
                            _.object.dataPatched.physics.rigidBody) ||
                        void 0
                      );
                    if (_.objectForSample.dataPatched.physics.fusedBody) return;
                    I = _.object;
                  } else if (_ instanceof yj) I = _.object;
                  else if (((I = _), I.dataPatched.cloner?.hideBase)) return !0;
                } else {
                  if (_ instanceof AI) return;
                  I = _ instanceof yj ? _.object : _;
                }
                "Time" === this.data.destroy
                  ? (_.userData.lifetime = 1e3 * this.data.lifetime)
                  : "Quantity" === this.data.destroy &&
                    ((_.userData.quantity = this.data.destroyAfterQuantity),
                    (_.userData.actionId = this.uniqueId));
                let R = new rF().fromArray(this.data.velocity),
                  B = I.dataPatched;
                if (
                  !("visibility" === B.physics.enabled
                    ? !B.visible
                    : !B.physics.enabled) &&
                  (this.controlsManager.sharedGameControlGlobals.rapierWorld
                    ? (this.controlsManager.addRigidBody(_, I, {
                        fromCreate: !0,
                        dynamic: this.data.dynamic,
                      }),
                      "Collision" === this.data.destroy &&
                        (_.rigidBody?.collider(0).setActiveEvents(1),
                        (_.userData.hasCollisionDestroy = !0)),
                      _.matrixWorld.decompose(Df, Dp, Dm),
                      R.applyQuaternion(Dp),
                      this.data.velocity.some((_) => 0 !== _) &&
                        this.data.dynamic &&
                        _.rigidBody?.setLinvel(
                          R.divideScalar(this.controlsManager.pixelsPerMeter),
                          !0
                        ))
                    : ("geometry" in _.object &&
                        this.controlsManager.addBoundsTree(_),
                      this.data.velocity.some((_) => 0 !== _) &&
                        this.data.dynamic &&
                        (_.userData.velocity = R)),
                  I.dataPatched.physics?.fusedBody === !0)
                )
                  return !0;
              });
            let k = this.page.scene.find(this.data.object);
            if (
              !k ||
              ((this.object = k),
              "world" !== this.data.coordinateSystem &&
                !this.page.scene.find(this.data.coordinateSystem))
            )
              throw Error("Missing Property");
            Du(R);
          }
          dispose() {
            null !== this.intervalId &&
              (window.clearInterval(this.intervalId), (this.intervalId = null)),
              this.timeoutIdQueue.forEach((_) => window.clearTimeout(_)),
              this.dispatchThrottled.cancel(),
              this.page.remove(
                ...this.controlsManager.sharedGameControlGlobals.createdObjects
              ),
              (this.controlsManager.sharedGameControlGlobals.createdObjects =
                []);
          }
        };
      new rF();
      var Dv = new rF(),
        Dy = new rF(),
        Dx = new rF(),
        Db = new rF(),
        D_ = new rF(),
        DS = new rF(),
        DM = new sa(),
        DE = new sa(),
        DT = new sa(),
        DP = (new sa(), new rz()),
        DD = new rz(),
        DO = new sg(0, 0, 0, "YXZ"),
        DI = new rF(1, 0, 0),
        DR = new rF(0, 1, 0),
        DL = new rF(0, 0, 1),
        Dz = new rF(1, 1, 1),
        DF = (new r5(), new lX()),
        DN = new rU(),
        Dk = { type: "requestRender" },
        DV = { type: "updateMatrix" },
        Dj = Math.PI / 6,
        DG = class extends i8 {
          constructor(_, I, R, B, z, k, V, j, G) {
            super(),
              (this.object = _),
              (this.domElement = I),
              (this.data = R),
              (this.gloabalPhysics = B),
              (this.controlsManager = z),
              (this.cameraFollow = k),
              (this.camera = V),
              (this.page = j),
              (this.sharedAssets = G),
              (this.enableDamping = !0),
              (this.hiddenMatrix0 = new sa()),
              (this.target0 = new rF()),
              (this.zoom0 = 1),
              (this.rotForce = 1),
              (this.moveForce = 1),
              (this.pixelsPerMeter = 200),
              (this.euler0 = new sg(0, 0, 0, "YXZ")),
              (this.position0Cam = new rF()),
              (this.quat0Cam = new rz()),
              (this.scale0Cam = new rF()),
              (this.hiddenMatrix0Cam = new sa()),
              (this.threshEndTranslate = 0.01),
              (this.threshEndRotate = 1e-8),
              (this.threshEndRotVel = 0.005),
              (this.collider = {
                type: "capsule",
                radius: 40,
                segment: new lX(new rF(0, -40, 0), new rF(0, 40, 0)),
                matrix: new sa(),
                position: new rF(),
                rotation: new rz(),
              }),
              (this.euler = new sg(0, 0, 0, "YXZ")),
              (this.eulerDelta = new rF()),
              (this.lastPosition = new rF()),
              (this.lastCameraQuaternion = new rz()),
              (this.lastCameraPosition = new rF()),
              (this.PI_2 = Math.PI / 2),
              (this.prevMouse = new rs()),
              (this.velocityTarget = new rF()),
              (this.velocity = new rF()),
              (this.directionXZ = new rF()),
              (this.rotVelocityStick = new rF()),
              (this.rotVelocityTarget = new rF()),
              (this.rotVelocity = new rF()),
              (this.rotDirection = new rF()),
              (this.nonColliderRotOffset = new sa()),
              (this.nonColliderPosOffset = new sa()),
              (this.firstPointerId = -1),
              (this.rot = new rF()),
              (this.path = []),
              (this.movementState = {
                moveNegZ: 0,
                movePosZ: 0,
                moveNegX: 0,
                movePosX: 0,
                moveNegY: 0,
                movePosY: 0,
                rotPosX: 0,
                rotNegX: 0,
                rotPosY: 0,
                rotNegY: 0,
                jump: 0,
                run: 0,
              }),
              (this.vrEulerYOffset = 0),
              (this.onObject = !1),
              (this.actionState = {}),
              (this.keyAssignments = [
                ["moveNegZ", "W"],
                ["moveNegX", "A"],
                ["movePosZ", "S"],
                ["movePosX", "D"],
                ["rotPosX", "ArrowUp"],
                ["rotPosY", "ArrowLeft"],
                ["rotNegX", "ArrowDown"],
                ["rotNegY", "ArrowRight"],
                ["jump", " "],
              ]),
              (this.collisionEnabled = !0),
              (this.offsetMatrix = new sa()),
              (this.objectToTarget = new rF()),
              (this.objectToTarget0 = new rF()),
              (this.objectToCamXZ = new rF()),
              (this.objectToCamXZ0 = new rF()),
              (this.targetToCamera = new rF()),
              (this.targetToCamera0 = new rF()),
              (this.cameraPolarAxis0 = new rF()),
              (this.targetPos = new rF()),
              (this.targetQuat = new rz()),
              (this.lerpFactorPos = new rF().setScalar(0.3)),
              (this.lerpFactorPosStart = 0.3),
              (this.lerpFactorPosEnd = 0.3),
              (this.lerpFactorRotStart = 0.3),
              (this.lerpFactorRotEnd = 0.3),
              (this.lerpFactorPosCamera = 0.3),
              (this.lerpFactorRotCamera = 0.3),
              (this.objXZQuat = new rz()),
              (this.objXZQuatInv = new rz()),
              (this.objXZRotMat = new sa()),
              (this.isFirstPerson = !1),
              (this.didHit = !1),
              (this.groundVelocity = new rF()),
              (this.pushedVelocity = new rF()),
              (this.groundYRotation = 0),
              (this.objectRealQuat = new rz()),
              (this.colliderWorldQuat = new rz()),
              (this.groundNormal = new rF()),
              (this.groundTilt = new rz()),
              (this.groundTiltInv = new rz()),
              (this.lastHitObj = null),
              (this.isFirstFrame = !0),
              (this.rotationAccumWhenOrientWithCamera = 0),
              (this.navMeshPathDest = null),
              (this.position = new rF()),
              (this.quaternion = new rz()),
              (this.scale = new rF()),
              (this.initialAction = !0),
              (this.onPointerDown = (_) => {
                _.target !== this.domElement ||
                  -1 !== this.firstPointerId ||
                  ((this.firstPointerId = _.pointerId),
                  this.domElement.ownerDocument.addEventListener(
                    "pointermove",
                    this.onPointerMove
                  ),
                  this.domElement.ownerDocument.addEventListener(
                    "pointerup",
                    this.onPointerUp
                  ),
                  "keys" === this.rotBy ||
                    uu ||
                    (up && !(uf >= 15.5)) ||
                    this.domElement.requestPointerLock(),
                  this.prevMouse.set(_.clientX, _.clientY));
              }),
              (this.onPointerUp = (_) => {
                (this.firstPointerId = -1),
                  this.domElement.ownerDocument.removeEventListener(
                    "pointermove",
                    this.onPointerMove
                  ),
                  this.domElement.ownerDocument.removeEventListener(
                    "pointerup",
                    this.onPointerUp
                  ),
                  "mouse" === _.pointerType &&
                    this.domElement.ownerDocument.exitPointerLock();
              }),
              (this.onPointerMove = (_) => {
                if (_.pointerId !== this.firstPointerId) return;
                let I = _.clientX - this.prevMouse.x,
                  R = _.clientY - this.prevMouse.y;
                this.prevMouse.set(_.clientX, _.clientY),
                  "mouse" === _.pointerType &&
                    "keys" !== this.rotBy &&
                    (up && uf < 15.5 && !uu
                      ? ((this.eulerDelta.y = -I * this.mouseOrbitSensitivity),
                        (this.eulerDelta.x = -R * this.mouseOrbitSensitivity))
                      : ((this.eulerDelta.y =
                          -_.movementX * this.mouseOrbitSensitivity),
                        (this.eulerDelta.x =
                          -_.movementY * this.mouseOrbitSensitivity))),
                  "mouse" !== _.pointerType &&
                    "drag" === this.rotByTouch &&
                    ((this.eulerDelta.y = -I * this.mouseOrbitSensitivity * 5),
                    (this.eulerDelta.x = -R * this.mouseOrbitSensitivity * 5)),
                  this.controlsManager.requestRender();
              }),
              (this.onPointerlockChange = (_) => {
                this.domElement.ownerDocument.pointerLockElement ===
                this.domElement
                  ? (DG.isLocked = !0)
                  : (DG.isLocked = !1);
              }),
              (this.onPointerlockError = () => {
                console.error(
                  "SPE.GameControls: Unable to use Pointer Lock API"
                );
              }),
              (this.handleVisibilityChange = () => {
                if (document?.hidden)
                  for (let _ in this.movementState) this.movementState[_] = 0;
              }),
              (this.onKeyDown = (_) => {
                for (let I of (_.target instanceof HTMLInputElement ||
                  ("ArrowLeft" !== _.code &&
                    "ArrowUp" !== _.code &&
                    "ArrowRight" !== _.code &&
                    "ArrowDown" !== _.code &&
                    "Space" !== _.code) ||
                  _.preventDefault(),
                this.keyAssignments))
                  if (_.key.toUpperCase() === I[1] || _.key === I[1]) {
                    this.movementState[I[0]] = 1;
                    break;
                  }
                this.controlsManager.requestRender();
              }),
              (this.onKeyUp = (_) => {
                for (let I of this.keyAssignments)
                  if (
                    _.key.toUpperCase() === I[1] ||
                    _.key === I[1] ||
                    _.code.slice(3, _.code.length).toUpperCase() === I[1]
                  ) {
                    this.movementState[I[0]] = 0;
                    break;
                  }
              }),
              (this.copyVRGamePadValues = (_, I) => {
                for (let R = 2; R < 4; R++) {
                  let B = _.axes[R];
                  0 === I
                    ? 2 === R
                      ? (this.movementState.movePosX = B)
                      : (this.movementState.movePosZ = B)
                    : (_.buttons[3].pressed
                        ? (this.movementState.jump = 1)
                        : (this.movementState.jump = 0),
                      2 === R
                        ? (0.3 > Math.abs(this.movementState.rotPosY) &&
                            Math.abs(B) >= 0.3 &&
                            (this.vrEulerYOffset += B < 0 ? 1 : -1),
                          (this.movementState.rotPosY = B))
                        : "fly" === this.moveMode &&
                          (this.movementState.moveNegY = B));
                }
              }),
              (this.sharedGameControlGlobals = z.sharedGameControlGlobals),
              _ === V && (this.isFirstPerson = !0),
              this.hiddenMatrix0.copy(this.object.hiddenMatrix),
              this.object.parent
                ? this.object.hiddenMatrix
                    .copy(this.object.parent.matrixWorld)
                    .invert()
                : this.object.hiddenMatrix.identity(),
              this.object.matrix.copy(this.object.matrixWorld),
              this.object.matrix.decompose(
                this.position,
                this.quaternion,
                this.scale
              ),
              this.euler0.setFromQuaternion(this.quaternion, "YXZ");
            let q = this.euler0.clone(),
              X = q.y;
            if (
              (this.objectRealQuat.copy(this.quaternion),
              (q.y = 0),
              this.quaternion.setFromEuler(q),
              this.objXZQuat.copy(this.quaternion),
              this.objXZQuatInv.copy(this.objXZQuat).invert(),
              this.objXZRotMat.makeRotationFromQuaternion(this.quaternion),
              q.set(0, X, 0),
              this.quaternion.setFromEuler(q),
              this.rot.setFromEuler(q),
              (this.object.matrixAutoUpdate = !1),
              (this.isFirstPerson || !0 === this.cameraFollow) &&
                (this.target0.copy(this.camera.getTarget()),
                (this.zoom0 = this.camera.zoom)),
              !0 === this.cameraFollow)
            ) {
              let _, I;
              this.position0Cam.copy(this.camera.position),
                this.quat0Cam.copy(this.camera.quaternion),
                this.scale0Cam.copy(this.camera.scale),
                this.hiddenMatrix0Cam.copy(this.camera.hiddenMatrix),
                this.camera.parent
                  ? (this.camera.hiddenMatrix.copy(
                      this.camera?.parent.matrixWorld
                    ),
                    this.camera.matrix.copy(this.camera.matrixWorld))
                  : this.camera.hiddenMatrix.identity(),
                this.camera.matrix.copy(this.camera.matrixWorld),
                this.camera.matrix.decompose(
                  this.camera.position,
                  this.camera.quaternion,
                  this.camera.scale
                ),
                (this.camera.matrixAutoUpdate = !1),
                this.offsetMatrix
                  .copy(this.object.matrix)
                  .invert()
                  .multiply(this.camera.matrix);
              let R = new rF(0, 0, -1).applyQuaternion(this.camera.quaternion),
                B = new rF().subVectors(this.position, this.camera.position);
              this.objectToCamXZ.copy(B),
                (this.objectToCamXZ.y = 0),
                this.objectToCamXZ0.copy(this.objectToCamXZ),
                1e-6 > Math.abs(R.y)
                  ? ((B.y = 0), (R.y = 0), (I = B.projectOnVector(R)))
                  : (I =
                      B.y / R.y > 0
                        ? R.multiplyScalar(B.y / R.y)
                        : R.multiplyScalar(B.length())),
                this.targetToCamera0.copy(I).negate(),
                (_ = this.camera.position.clone().add(I)),
                this.objectToTarget0.subVectors(_, this.position);
              let z = new sg().setFromQuaternion(this.camera.quaternion, "YXZ");
              (this.cameraPolarOffset = -z.x),
                (z.x = 0),
                (z.z = 0),
                (z.y -= Math.PI / 2),
                this.cameraPolarAxis0.set(0, 0, -1).applyEuler(z);
            }
            if (
              (this.object instanceof AK && (this.object.matrixAutoUpdate = !1),
              this.euler.setFromQuaternion(this.quaternion, "YXZ"),
              (this.rotByTouch = R.rotByTouch ?? "joystick"),
              (this.rotBy = R.rotBy ?? "keys"),
              (this.rotationMode = R.rotationMode ?? "normal"),
              (this.moveMode = R.moveMode ?? "walk"),
              (this.collisionEnabled = R.collisionEnabled),
              (this.speedTranslate = (R.speedTranslate ?? 250) * 1),
              (this.speedOrbit = (R.speedRotate ?? 100) * 0.025),
              (this.mouseOrbitSensitivity = (R.speedRotate ?? 100) * 16e-6),
              (this.keyAssignments = R.keyAssignments.map((_) => {
                let I = [_[0], _[1]];
                return (
                  "" === I[1]
                    ? (I[1] = "ArrowUp")
                    : "" === I[1]
                    ? (I[1] = "ArrowLeft")
                    : "" === I[1]
                    ? (I[1] = "ArrowDown")
                    : "" === I[1]
                    ? (I[1] = "ArrowRight")
                    : "" === I[1]
                    ? (I[1] = "Shift")
                    : "" === I[1]
                    ? (I[1] = "Enter")
                    : "Space" === I[1]
                    ? (I[1] = " ")
                    : "" === I[1]
                    ? (I[1] = "Meta")
                    : "Ctrl" === I[1]
                    ? (I[1] = "Control")
                    : "Esc" === I[1] && (I[1] = "Escape"),
                  I
                );
              })),
              "mouse" === R.rotBy)
            ) {
              let _;
              -1 !==
                (_ = this.keyAssignments.findIndex(
                  (_) => "rotNegX" === _[0]
                )) && (this.keyAssignments[_][1] = ""),
                -1 !==
                  (_ = this.keyAssignments.findIndex(
                    (_) => "rotPosX" === _[0]
                  )) && (this.keyAssignments[_][1] = ""),
                -1 !==
                  (_ = this.keyAssignments.findIndex(
                    (_) => "rotPosY" === _[0]
                  )) && (this.keyAssignments[_][1] = ""),
                -1 !==
                  (_ = this.keyAssignments.findIndex(
                    (_) => "rotNegY" === _[0]
                  )) && (this.keyAssignments[_][1] = "");
            }
            (this.lerpFactorPosStart =
              1 - 0.02 ** (1 / ((R.delayPos[0] ?? 0.3) * 60))),
              (this.lerpFactorPosEnd =
                1 - 0.02 ** (1 / ((R.delayPos[1] ?? 0.3) * 60))),
              this.lerpFactorPos.setScalar(this.lerpFactorPosStart),
              (this.lerpFactorRotStart =
                1 - 0.02 ** (1 / ((R.delayRot[0] ?? 0.3) * 60))),
              (this.lerpFactorRotEnd =
                1 - 0.02 ** (1 / ((R.delayRot[1] ?? 0.3) * 60))),
              (this.lerpFactorPosCamera =
                1 - 0.02 ** (1 / ((R.delayPosCamera ?? 0.3) * 60))),
              (this.lerpFactorRotCamera =
                1 - 0.02 ** (1 / ((R.delayRotCamera ?? 0.3) * 60))),
              (this.gravity =
                (this.gloabalPhysics.gravity ?? g3.defaultData.gravity) * 12),
              (this.usePhysics =
                this.gloabalPhysics.usePhysics ?? g3.defaultData.usePhysics),
              (this.jumpPower = 20 * R.jumpPower),
              (this.resetYPosition =
                this.position.y +
                Math.abs(R.resetYPosition) * (this.gravity > 0 ? 1 : -1)),
              (this.alignToGround = R.alignToGround ?? !1),
              (this.orientMode = R.autoOrientMove ? R.orientMode : "none"),
              (this.orientWith =
                R.orientWith ?? vV.defaultDataThirdPerson.orientWith),
              (this.slopeThresh = (65 * Math.PI) / 180),
              "capsule" === R.collider.type
                ? ((this.collider.radius = R.collider.radius),
                  (this.collider.segment.start.y =
                    R.collider.height / 2 - R.collider.radius),
                  (this.collider.segment.end.y =
                    -this.collider.segment.start.y),
                  (this.offset =
                    (0.02 * R.collider.height) / this.pixelsPerMeter),
                  (this.stepThresh =
                    (0.3 * R.collider.height) / this.pixelsPerMeter),
                  (this.colliderHeight = R.collider.height))
                : "sphere" === R.collider.type
                ? ((this.collider.radius = R.collider.radius),
                  (this.collider.segment.start.y = 0),
                  (this.collider.segment.end.y = 0),
                  (this.offset =
                    (2 * R.collider.radius * 0.02) / this.pixelsPerMeter),
                  (this.stepThresh =
                    (2 * R.collider.radius * 0.3) / this.pixelsPerMeter),
                  (this.colliderHeight = 2 * R.collider.radius))
                : ((this.offset =
                    (0.02 * R.collider.height) / this.pixelsPerMeter),
                  (this.stepThresh =
                    (0.3 * R.collider.height) / this.pixelsPerMeter),
                  (this.colliderHeight = R.collider.height)),
              (this.collider.type = R.collider.type);
            let Q = new rF().fromArray(R.collider.position),
              $ = new rz().setFromEuler(
                new sg().fromArray([...R.collider.rotation, "XYZ"])
              );
            this.collider.position.copy(Q).multiply(this.scale),
              this.collider.rotation.copy($),
              this.collider.matrix.compose(Q, $, Dz),
              void 0 !== R.cameraXAxis &&
                ((this.cameraXAxis = R.cameraXAxis),
                (this.cameraYAxis = R.cameraYAxis),
                (this.minPolarAngle = R.cameraRotXLimits[0]),
                (this.maxPolarAngle = R.cameraRotXLimits[1]),
                (this.minAzimuthAngleRel = R.cameraRotYLimits[0]),
                (this.maxAzimuthAngleRel = R.cameraRotYLimits[1])),
              (this.forwardDir = R.forwardDirection ?? "-z"),
              this.isFirstPerson && (this.forwardDir = "-z"),
              (this.runMultiplier = R.runMultiplier ?? 2);
            let et = 2 * R.navmesh.destinationHelperRadius;
            if (et > 0) {
              let _ = new uN();
              _.push({
                fi: 0,
                data: { ...mq.defaultData("light", "phong"), alpha: 0 },
                id: "layer1",
              }),
                _.push({
                  fi: 0,
                  data: {
                    ...mq.defaultData("color"),
                    color: R.navmesh.destinationHelperColor,
                    alpha: R.navmesh.destinationHelperColor.a,
                  },
                  id: "layer2",
                });
              let I = new SO(
                { layers: _ },
                { scene: this.page.scene, shared: this.sharedAssets }
              );
              (this.navMeshPathDest = new aw(
                y4.create({
                  parameters: { width: et, height: et / 10, hollow: 0.7 },
                }),
                I
              )),
                (this.navMeshPathDest.material.userData.opacity0 =
                  R.navmesh.destinationHelperColor.a);
            }
            this.activate();
          }
          reset(_ = !1) {
            if ((this.object.hiddenMatrix.copy(this.hiddenMatrix0), _)) {
              this.object.updateMatrix(),
                this.object.updateMatrixWorld(),
                this.object.matrix.copy(this.object.matrixWorld),
                this.object.matrix.decompose(
                  this.position,
                  this.quaternion,
                  this.scale
                ),
                this.object.parent
                  ? this.object.hiddenMatrix
                      .copy(this.object.parent.matrixWorld)
                      .invert()
                  : this.object.hiddenMatrix.identity();
              let _ = new sg().setFromQuaternion(this.quaternion, "YXZ"),
                I = _.y;
              this.objectRealQuat.copy(this.quaternion),
                (_.y = 0),
                this.quaternion.setFromEuler(_),
                this.objXZQuat.copy(this.quaternion),
                this.objXZQuatInv.copy(this.objXZQuat).invert(),
                this.objXZRotMat.makeRotationFromQuaternion(this.quaternion),
                _.set(0, I, 0),
                this.quaternion.setFromEuler(_),
                this.rot.setFromEuler(_),
                this.euler.setFromQuaternion(this.quaternion, "YXZ"),
                this.velocityTarget.set(0, 0, 0),
                this.velocity.set(0, 0, 0);
            } else
              this.object instanceof AK
                ? (this.object.matrixAutoUpdate = !0)
                : this.object.updateMatrix();
            !0 === this.cameraFollow &&
              (this.camera.quaternion.copy(this.quat0Cam),
              this.camera.position.copy(this.position0Cam),
              this.camera.scale.copy(this.scale0Cam),
              this.camera.hiddenMatrix.copy(this.hiddenMatrix0Cam),
              (this.camera.matrixAutoUpdate = !0)),
              this.controlsManager.requestRender();
          }
          activate() {
            this.instantiateActions(),
              this.domElement.ownerDocument.addEventListener(
                "pointerdown",
                this.onPointerDown
              ),
              this.domElement.ownerDocument.addEventListener(
                "keydown",
                this.onKeyDown
              ),
              this.domElement.ownerDocument.addEventListener(
                "keyup",
                this.onKeyUp
              ),
              this.domElement.ownerDocument.addEventListener(
                "pointerlockchange",
                this.onPointerlockChange
              ),
              this.domElement.ownerDocument.addEventListener(
                "pointerlockerror",
                this.onPointerlockError
              ),
              this.domElement.ownerDocument.addEventListener(
                "visibilitychange",
                this.handleVisibilityChange
              );
          }
          deactivate() {
            this.disposeActions(),
              this.domElement.ownerDocument.removeEventListener(
                "pointerdown",
                this.onPointerDown
              ),
              this.domElement.ownerDocument.removeEventListener(
                "keydown",
                this.onKeyDown
              ),
              this.domElement.ownerDocument.removeEventListener(
                "keyup",
                this.onKeyUp
              ),
              this.domElement.ownerDocument.removeEventListener(
                "pointerlockchange",
                this.onPointerlockChange
              ),
              this.domElement.ownerDocument.removeEventListener(
                "pointerlockerror",
                this.onPointerlockError
              ),
              this.domElement.ownerDocument.removeEventListener(
                "visibilitychange",
                this.handleVisibilityChange
              );
          }
          dispose() {
            this.deactivate(),
              this.navMeshPathDest?.parent &&
                this.page.remove(this.navMeshPathDest);
          }
          instantiateActions() {
            let _ = this.data,
              I = this.sharedAssets;
            void 0 !== _.gameActions &&
              ((this.actions = {}),
              vk.list.forEach((R) => {
                this.actions[R] = Mr(
                  { ..._, disabled: !1, type: "GameControl" },
                  _.gameActions[R],
                  this.page,
                  I,
                  this.controlsManager.eventManager,
                  this.object
                );
              })),
              this.dispatchStopEvent("move"),
              this.dispatchStopEvent("run"),
              this.dispatchStopEvent("jump"),
              this.dispatchStartEvent("idle"),
              this.initialAction && (this.initialAction = !1);
          }
          disposeActions() {
            (this.initialAction = !1),
              this.dispatchStopEvent("idle"),
              this.dispatchStopEvent("move"),
              this.dispatchStopEvent("run"),
              this.dispatchStopEvent("jump"),
              dr(this.actions.idle),
              dr(this.actions.move),
              dr(this.actions.run),
              dr(this.actions.jump);
          }
          dispatchStartEvent(_) {
            void 0 !== this.actions[_] &&
              (this.actionState[_] ||
                ((this.actionState[_] = !0),
                this.actions[_].Transition.forEach((_) => {
                  _.play();
                }),
                this.actions[_].Animation.forEach((_) => {
                  _.play(!1 === this.initialAction);
                }),
                this.actions[_].Create.forEach((_) => {
                  _.dispatchStart();
                }),
                this.actions[_].Audio.forEach((_) => {
                  _.dispatchGameControl("start");
                }),
                this.actions[_].Particles.forEach((_) => {
                  _.dispatchGameControl("start");
                })));
          }
          dispatchStopEvent(_) {
            void 0 === this.actions[_] ||
              (this.actionState[_] &&
                ((this.actionState[_] = !1),
                this.actions[_].Transition.forEach((_) => {
                  _.stop(),
                    null !== _.object.currentState &&
                      _.object.changeSelectedState(null, {
                        scene: this.page.scene,
                        shared: this.sharedAssets,
                      });
                }),
                this.actions[_].Create.forEach((_) => {
                  _.dispatchStop();
                }),
                this.actions[_].Audio.forEach((_) => {
                  _.dispatchGameControl("stop");
                }),
                this.actions[_].Particles.forEach((_) => {
                  _.dispatchGameControl("stop");
                })));
          }
          get colliderWorldPosition() {
            return Db.copy(this.collider.position)
              .applyQuaternion(this.objectRealQuat)
              .add(this.position);
          }
          update(_, I, R) {
            if (
              this.gravity < 0
                ? this.position.y < this.resetYPosition
                : this.position.y > this.resetYPosition
            )
              return this.reset(!0), !0;
            this.sharedGameControlGlobals.gamePads.forEach(
              this.copyVRGamePadValues
            );
            let B = (this.isFirstFrame ? 16.6 : _) / 1e3;
            this.isFirstFrame && (this.isFirstFrame = !1);
            let z = 60 * B,
              k = !1;
            if (this.usePhysics && this.collisionEnabled) {
              let _ = D_.set(
                  0,
                  (0 === this.velocity.y
                    ? this.pixelsPerMeter *
                      Math.max(Math.abs(this.gravity) / 120, 1) *
                      (this.gravity > 0 ? 1 : -1)
                    : this.velocity.y) * B,
                  0
                ).divideScalar(this.pixelsPerMeter),
                I = this.sharedGameControlGlobals.rapierWorld.castShape(
                  this.colliderWorldPosition.divideScalar(this.pixelsPerMeter),
                  this.colliderWorldQuat,
                  _,
                  this.object.rigidBody?.collider(0).shape,
                  1,
                  !1,
                  16,
                  void 0,
                  void 0,
                  this.object.rigidBody
                );
              if (I) {
                (this.onObject = !0),
                  this.groundNormal
                    .set(I.normal2.x, I.normal2.y, I.normal2.z)
                    .applyQuaternion(this.colliderWorldQuat)
                    .negate(),
                  this.alignToGround &&
                    this.groundTiltAdjustment(this.groundNormal),
                  Math.acos(this.groundNormal.y) < this.slopeThresh && (k = !0),
                  I.collider.parent()?.bodyType() === 0 &&
                    Math.acos(this.groundNormal.y) * (180 / Math.PI) > 45 &&
                    (this.onObject = !1);
                let _ = I.collider.parent();
                for (let I of ((this.groundYRotation = 0),
                this.groundVelocity.set(0, 0, 0),
                this.sharedGameControlGlobals.entitiesWithTransformAnim))
                  if (
                    I.rigidBody === _ &&
                    I.userData.isFollowingObj !== this.object.uuid
                  ) {
                    (I.hasNonUniformScale
                      ? I.matrixWorldRigid
                      : I.matrixWorld
                    ).decompose(Db, DD, D_),
                      this.groundVelocity.subVectors(Db, I.prevT),
                      this.object
                        .getWorldPosition(D_)
                        .add(this.collider.position)
                        .sub(Db),
                      (this.groundYRotation =
                        DO.setFromQuaternion(DD).y - I.prevR.y),
                      DS.copy(D_).applyAxisAngle(DR, this.groundYRotation),
                      this.groundVelocity.add(DS.sub(D_)).divideScalar(B);
                    break;
                  }
              } else this.onObject = !1;
            }
            if (
              ("walk" === this.moveMode &&
                this.collisionEnabled &&
                (1 === this.movementState.jump &&
                  this.onObject &&
                  ((this.velocityTarget.y = this.jumpPower),
                  (this.movementState.jump = 0),
                  this.dispatchStopEvent("idle"),
                  this.dispatchStopEvent("move"),
                  this.dispatchStopEvent("run"),
                  this.dispatchStopEvent("jump"),
                  this.dispatchStartEvent("jump"),
                  (this.onObject = !1)),
                this.onObject
                  ? (this.velocityTarget.y /= 2)
                  : (this.velocityTarget.y += this.gravity * z)),
              "fly" === this.moveMode &&
                (this.velocityTarget.y =
                  (this.movementState.movePosY - this.movementState.moveNegY) *
                  this.speedTranslate),
              (this.directionXZ.z =
                this.movementState.movePosZ - this.movementState.moveNegZ),
              (this.directionXZ.x =
                this.movementState.movePosX - this.movementState.moveNegX),
              "+z" === this.forwardDir && this.directionXZ.multiplyScalar(-1),
              this.directionXZ.manhattanLength() > 0 && (this.path = []),
              this.navMeshPathDest)
            ) {
              let _ = this.navMeshPathDest.material;
              if ("walk" === this.moveMode && this.path.length > 1) {
                this.navMeshPathDest.position.copy(
                  this.path[this.path.length - 1]
                ),
                  this.navMeshPathDest.parent ||
                    this.page.add(this.navMeshPathDest);
                let I = Db.subVectors(this.path[1], this.position),
                  R = D_.subVectors(this.path[1], this.path[0]);
                0 > I.dot(R)
                  ? this.path.shift()
                  : ((this.directionXZ.x = R.x), (this.directionXZ.z = R.z)),
                  (_.opacity = _.userData.opacity0);
              } else
                (_.opacity -= 0.05 * _.userData.opacity0),
                  this.navMeshPathDest.material.opacity <= 0 &&
                    this.navMeshPathDest.parent &&
                    this.page.remove(this.navMeshPathDest);
            }
            this.directionXZ.normalize(),
              this.movementState.run
                ? (this.moveForce = this.runMultiplier)
                : (this.moveForce = 1),
              (this.velocityTarget.z =
                this.directionXZ.z * this.speedTranslate * this.moveForce),
              (this.velocityTarget.x =
                this.directionXZ.x * this.speedTranslate * this.moveForce),
              (
                "walk" === this.moveMode
                  ? this.velocityTarget.x + this.velocityTarget.z === 0
                  : 0 === this.velocityTarget.manhattanLength()
              )
                ? this.lerpFactorPos.setScalar(this.lerpFactorPosEnd)
                : this.lerpFactorPos.setScalar(this.lerpFactorPosStart),
              "walk" === this.moveMode && (this.lerpFactorPos.y = 1),
              (!1 === this.didHit &&
                0 === this.pushedVelocity.manhattanLength()) ||
              !1 === this.usePhysics
                ? ((this.velocity.x +=
                    (this.velocityTarget.x - this.velocity.x) *
                    (1 - (1 - this.lerpFactorPos.x) ** z)),
                  (this.velocity.y +=
                    (this.velocityTarget.y - this.velocity.y) *
                    (1 - (1 - this.lerpFactorPos.y) ** z)),
                  (this.velocity.z +=
                    (this.velocityTarget.z - this.velocity.z) *
                    (1 - (1 - this.lerpFactorPos.z) ** z)))
                : this.velocity.copy(this.velocityTarget),
              (
                "walk" === this.moveMode
                  ? this.velocity.x ** 2 + this.velocity.z ** 2 <
                    this.speedTranslate
                  : this.velocity.lengthSq() < this.speedTranslate
              )
                ? (this.dispatchStopEvent("move"),
                  this.dispatchStopEvent("run"),
                  this.onObject &&
                    (this.dispatchStopEvent("jump"),
                    this.dispatchStartEvent("idle")))
                : (this.dispatchStopEvent("idle"),
                  this.onObject &&
                    (this.dispatchStopEvent("jump"),
                    this.movementState.run
                      ? (this.dispatchStopEvent("move"),
                        this.dispatchStartEvent("run"))
                      : (this.dispatchStopEvent("run"),
                        this.dispatchStartEvent("move"))));
            let V = Dx.copy(this.velocity);
            if ("none" !== this.orientMode && !1 === this.isFirstPerson) {
              let _ = D_.copy(V);
              (_.y = 0),
                V.set(0, V.y, _.length() * ("+z" === this.forwardDir ? 1 : -1));
            }
            if (
              this.directionXZ.manhattanLength() > 0 &&
              "none" !== this.orientMode &&
              !1 === this.isFirstPerson
            ) {
              if ("camera" === this.orientWith && this.path.length <= 1) {
                this.camera.getWorldDirection(Db);
                let _ = DS.copy(DR).multiplyScalar(Db.dot(DR));
                Db.sub(_);
                let I = D_.copy(this.directionXZ);
                (I.x *= -1),
                  (this.rot.y =
                    Db.angleTo(I) * (Db.cross(I).y > 0 ? -1 : 1) +
                    this.rotationAccumWhenOrientWithCamera);
              } else
                this.rot.y =
                  (this.path.length > 1 ? 0 : this.euler.y) +
                  Math.atan2(-this.directionXZ.z, this.directionXZ.x) +
                  (Math.PI / 2) * ("+z" === this.forwardDir ? 1 : -1);
            }
            if (
              (DO.setFromVector3(this.rot),
              "walk" === this.moveMode && (DO.x = 0),
              V.applyEuler(DO),
              k &&
                (DD.setFromUnitVectors(DR, this.groundNormal),
                V.applyQuaternion(DD)),
              R)
            ) {
              let _ = DO.set(0, this.vrEulerYOffset * Dj, 0);
              R.applyEuler(_),
                (V.x += R.x),
                (V.z += R.z),
                (this.nonColliderPosOffset.elements[13] += R.y * B);
            }
            if (!0 === this.usePhysics) {
              for (let _ of (this.pushedVelocity.set(0, 0, 0),
              this.sharedGameControlGlobals.entitiesWithTransformAnim)) {
                let I = DS.setFromMatrixPosition(_.matrixWorld)
                    .sub(_.prevT)
                    .divideScalar(B)
                    .divideScalar(this.pixelsPerMeter),
                  R = _.rigidBody
                    .collider(0)
                    .castCollider(
                      I,
                      this.object.rigidBody.collider(0),
                      Db.copy(V).divideScalar(this.pixelsPerMeter),
                      B,
                      !1
                    );
                I.multiplyScalar(this.pixelsPerMeter);
                let z = bG.is(_) ? _ : _.object;
                if (null !== R && this.lastHitObj !== z) {
                  let I;
                  _ instanceof yj && (I = _);
                  let R =
                    this.sharedGameControlGlobals.entityToCollisionEvents[
                      z.uuid
                    ];
                  if (R)
                    for (let _ of R)
                      "character" === _.data.target &&
                        (_.dispatch(I), z.dispatchEvent(IJ));
                  this.lastHitObj = z;
                }
                if (null !== R) {
                  this.pushedVelocity.copy(I),
                    D_.copy(R.normal1).applyQuaternion(_.quaternion);
                  break;
                }
              }
              if (0 !== this.pushedVelocity.manhattanLength()) {
                let _ = D_.dot(V);
                _ < 0 && V.addScaledVector(D_, -_), V.add(this.pushedVelocity);
              } else V.add(this.groundVelocity);
            }
            if (
              ((this.rotDirection.y =
                Number(this.movementState.rotPosY) -
                Number(this.movementState.rotNegY)),
              (this.rotDirection.x =
                Number(this.movementState.rotPosX) -
                Number(this.movementState.rotNegX)),
              this.rotDirection.normalize(),
              ("normal" === this.rotationMode &&
                (this.movementState.rotPosX || this.movementState.rotNegX)) ||
              ("steer" === this.rotationMode &&
                (this.movementState.rotPosX || this.movementState.rotNegX) &&
                (this.movementState.movePosZ ||
                  this.movementState.moveNegZ ||
                  "walk" === this.moveMode))
                ? (this.rotVelocityStick.x =
                    -this.rotDirection.x * this.speedOrbit * this.rotForce)
                : (this.rotVelocityStick.x = 0),
              ("normal" === this.rotationMode &&
                (this.movementState.rotPosY || this.movementState.rotNegY)) ||
              ("steer" === this.rotationMode &&
                (this.movementState.rotPosY || this.movementState.rotNegY) &&
                (this.movementState.movePosZ || this.movementState.moveNegZ))
                ? (this.rotVelocityStick.y =
                    -this.rotDirection.y * this.speedOrbit * this.rotForce)
                : (this.rotVelocityStick.y = 0),
              this.rotVelocityTarget.subVectors(
                this.eulerDelta.divideScalar(B),
                this.rotVelocityStick
              ),
              0 === this.rotVelocityTarget.manhattanLength()
                ? this.rotVelocity.lerp(
                    this.rotVelocityTarget,
                    1 - (1 - this.lerpFactorRotEnd) ** z
                  )
                : this.rotVelocity.lerp(
                    this.rotVelocityTarget,
                    1 - (1 - this.lerpFactorRotStart) ** z
                  ),
              (this.euler.x += this.rotVelocity.x * B),
              (this.euler.y += this.rotVelocity.y * B + this.groundYRotation),
              0 === this.rotVelocityTarget.y &&
              0 === this.directionXZ.manhattanLength()
                ? (this.rotationAccumWhenOrientWithCamera = 0)
                : (!1 === this.cameraFollow || "Locked" === this.cameraYAxis) &&
                  (this.rotationAccumWhenOrientWithCamera +=
                    this.rotVelocity.y * B),
              !1 === this.isFirstPerson &&
                "none" !== this.orientMode &&
                this.directionXZ.manhattanLength() > 0)
            ) {
              if ("radial" === this.orientMode) {
                this.objectToCamXZ
                  .copy(this.objectToCamXZ0)
                  .applyAxisAngle(DR, this.euler.y - this.euler0.y);
                let _ = D_.copy(this.objectToCamXZ).normalize(),
                  I = DS.copy(V).multiplyScalar(B);
                I.y = 0;
                let R = I.sub(Db.copy(_).multiplyScalar(I.dot(_))).cross(_).y;
                this.euler.y -= Math.atan2(R, this.objectToCamXZ.length());
              }
            } else
              (this.rot.y += this.rotVelocity.y * B + this.groundYRotation),
                0 !== this.rotVelocityTarget.y &&
                  (!1 === this.cameraFollow || "Locked" === this.cameraYAxis) &&
                  (this.euler.y = this.rot.y);
            if (
              (!0 === this.cameraFollow &&
                ("walk" === this.moveMode
                  ? "Limit" === this.cameraXAxis
                    ? (this.euler.x = rr.clamp(
                        this.euler.x,
                        -this.maxPolarAngle + this.cameraPolarOffset + 1e-6,
                        -this.minPolarAngle + this.cameraPolarOffset - 1e-6
                      ))
                    : (this.euler.x = rr.clamp(
                        this.euler.x,
                        -this.PI_2 + this.cameraPolarOffset,
                        this.PI_2 + this.cameraPolarOffset
                      ))
                  : "Limit" === this.cameraXAxis &&
                    (this.euler.x = rr.clamp(
                      this.euler.x,
                      -this.PI_2,
                      this.PI_2
                    ))),
              "fly" === this.moveMode
                ? (this.rot.x = this.euler.x)
                : this.isFirstPerson &&
                  (I ? DO.copy(I) : DO.copy(this.euler),
                  (DO.y = 0),
                  this.nonColliderRotOffset.makeRotationFromEuler(DO)),
              I &&
                ("walk" === this.moveMode
                  ? ((this.rot.y = I.y), (this.rot.x = 0), (this.rot.z = 0))
                  : this.rot.setFromEuler(I),
                (this.rot.y += this.vrEulerYOffset * Dj)),
              DP.setFromAxisAngle(DI, this.rot.x),
              DD.setFromAxisAngle(DR, this.rot.y),
              DD.multiply(DP),
              DP.setFromAxisAngle(DL, this.rot.z),
              DD.multiply(DP),
              this.quaternion.copy(DD),
              this.objectRealQuat.multiplyQuaternions(
                this.quaternion,
                this.objXZQuat
              ),
              this.colliderWorldQuat
                .copy(this.objectRealQuat)
                .multiply(this.collider.rotation),
              this.collisionEnabled)
            ) {
              if (this.usePhysics) {
                let _ = D_.copy(V).multiplyScalar(B / this.pixelsPerMeter),
                  I = null;
                this.didHit = !1;
                let R = new rF();
                for (let B = 0; B < 5; B++) {
                  let z = _.length(),
                    k = DS.copy(_).normalize();
                  if (
                    null !==
                    (I = this.sharedGameControlGlobals.rapierWorld.castShape(
                      this.colliderWorldPosition
                        .divideScalar(this.pixelsPerMeter)
                        .add(R),
                      this.colliderWorldQuat,
                      k,
                      this.object.rigidBody?.collider(0).shape,
                      z,
                      !1,
                      24,
                      void 0,
                      void 0,
                      this.object.rigidBody
                    ))
                  ) {
                    this.didHit = !0;
                    let V = this.sharedGameControlGlobals.colliderToEntity.get(
                      I.collider.handle
                    );
                    if (V !== this.lastHitObj && 0 === B) {
                      this.lastHitObj = V;
                      let _ =
                        this.sharedGameControlGlobals.entityToCollisionEvents[
                          V?.uuid
                        ];
                      if (_) {
                        for (let R of _)
                          if ("character" === R.data.target) {
                            let _ =
                                this.sharedGameControlGlobals.rapierWorld?.getCollider(
                                  I.collider.handle
                                )._parent,
                              B;
                            if (V.cloner) {
                              for (let I of V.cloner.children)
                                if (I.rigidBody === _) {
                                  B = I;
                                  break;
                                }
                            }
                            R.dispatch(B), V.dispatchEvent(IJ);
                          }
                      }
                    }
                    let j = Dv.set(
                        I.normal2.x,
                        I.normal2.y,
                        I.normal2.z
                      ).applyQuaternion(this.colliderWorldQuat),
                      G = Dy.copy(k).multiplyScalar(I.toi).dot(j),
                      q = I.toi;
                    if (
                      (0 === q &&
                        (this.position.y += this.offset * this.pixelsPerMeter),
                      G > this.offset &&
                        ((q = (I.toi * (G - this.offset)) / G),
                        R.addScaledVector(k, q)),
                      _.copy(k).multiplyScalar(z - q),
                      Math.acos(-j.y) > this.slopeThresh)
                    ) {
                      let B = this.colliderWorldPosition
                          .divideScalar(this.pixelsPerMeter)
                          .add(R),
                        z = DS.copy(I.witness2).applyQuaternion(
                          this.colliderWorldQuat
                        );
                      z.y = 0;
                      let k = B.add(z);
                      k.y += this.stepThresh;
                      let V =
                        this.sharedGameControlGlobals.rapierWorld.castShape(
                          k,
                          this.colliderWorldQuat,
                          _,
                          this.object.rigidBody?.collider(0).shape,
                          1,
                          !1,
                          24,
                          void 0,
                          void 0,
                          this.object.rigidBody
                        );
                      null !== V && 0 === V.toi && ((j.y = 0), j.normalize());
                    }
                    _.addScaledVector(j, -_.dot(j));
                  } else {
                    0 === B &&
                      0 !== this.directionXZ.manhattanLength() &&
                      (this.lastHitObj = null),
                      R.add(_);
                    break;
                  }
                }
                this.position.addScaledVector(R, this.pixelsPerMeter),
                  this.object.rigidBody?.setTranslation(
                    Db.copy(this.position).divideScalar(this.pixelsPerMeter),
                    !0
                  ),
                  this.object.rigidBody?.setRotation(
                    DP.copy(this.quaternion)
                      .premultiply(this.groundTilt)
                      .multiply(this.objXZQuat),
                    !0
                  );
              } else {
                let _ = this.onObject ? 1 : 5,
                  I = V.multiplyScalar(B / _);
                for (let R = 0; R < _; R++)
                  this.position.add(I), this.collisionAdjustment(B / _);
              }
            } else this.position.addScaledVector(V, B);
            if (
              ("walk" === this.moveMode &&
                this.onObject &&
                ((this.velocityTarget.y = 0), (this.velocity.y = 0)),
              this.quaternion
                .premultiply(this.groundTilt)
                .multiply(this.objXZQuat),
              this.object.matrix.compose(
                this.position,
                this.quaternion,
                this.scale
              ),
              (this.object.matrixWorldNeedsUpdate = !0),
              this.object.matrix
                .multiply(this.nonColliderPosOffset)
                .multiply(this.nonColliderRotOffset),
              this.quaternion
                .premultiply(this.groundTiltInv)
                .multiply(this.objXZQuatInv),
              !0 === this.cameraFollow)
            ) {
              this.updateFollowArms();
              let _ = this.objectToTarget.add(this.position),
                I = this.targetToCamera.add(_);
              DM.lookAt(I, _, DR).setPosition(I),
                DM.decompose(this.targetPos, this.targetQuat, Db),
                this.camera.quaternion.slerp(
                  this.targetQuat,
                  1 - (1 - this.lerpFactorRotCamera) ** z
                ),
                this.camera.position.lerp(
                  this.targetPos,
                  1 - (1 - this.lerpFactorPosCamera) ** z
                ),
                this.camera.updateMatrix(),
                this.camera.updateMatrixWorld(),
                "Limit" === this.cameraYAxis &&
                  "cartesian" === this.orientMode &&
                  (this.euler.y = rr.clamp(
                    this.euler.y,
                    this.minAzimuthAngleRel,
                    this.maxAzimuthAngleRel
                  )),
                (this.euler.x = rr.clamp(
                  this.euler.x,
                  -this.PI_2 +
                    (this.cameraPolarOffset < 0 ? this.cameraPolarOffset : 0),
                  this.PI_2 +
                    (this.cameraPolarOffset > 0 ? this.cameraPolarOffset : 0)
                ));
            }
            return (
              this.eulerDelta.set(0, 0, 0),
              this.object.dispatchEvent(DV),
              !(
                this.path.length < 2 &&
                this.lastPosition.distanceToSquared(this.position) <
                  this.threshEndTranslate &&
                Math.abs(this.rotVelocity.x) < this.threshEndRotVel &&
                Math.abs(this.rotVelocity.y) < this.threshEndRotVel &&
                (void 0 === this.camera ||
                  this.isFirstPerson ||
                  (this.lastCameraPosition.distanceToSquared(
                    this.camera.position
                  ) < this.threshEndTranslate &&
                    8 *
                      (1 -
                        this.lastCameraQuaternion.dot(this.camera.quaternion)) <
                      this.threshEndRotate)) &&
                ("fly" === this.moveMode ||
                  !0 === this.onObject ||
                  !1 === this.collisionEnabled) &&
                (null === this.navMeshPathDest ||
                  this.navMeshPathDest.material.opacity <
                    -0.04 * this.navMeshPathDest?.material?.userData.opacity0)
              ) &&
                (this.camera &&
                  (this.lastCameraPosition.copy(this.camera.position),
                  this.lastCameraQuaternion.copy(this.camera.quaternion)),
                this.lastPosition.copy(this.position),
                this.object.dispatchEvent(Dk),
                !0)
            );
          }
          updateFollowArms() {
            let _;
            this.objectToTarget.copy(this.objectToTarget0),
              this.targetToCamera.copy(this.targetToCamera0);
            let I = DP.setFromAxisAngle(
              DR,
              "Limit" === this.cameraYAxis && "radial" !== this.orientMode
                ? rr.clamp(
                    this.euler.y - this.euler0.y,
                    this.minAzimuthAngleRel,
                    this.maxAzimuthAngleRel
                  )
                : this.euler.y - this.euler0.y
            );
            ("Locked" !== this.cameraYAxis || "radial" === this.orientMode) &&
              this.objectToTarget.applyQuaternion(I),
              (_ =
                "Limit" === this.cameraXAxis
                  ? rr.clamp(
                      this.euler.x,
                      -this.maxPolarAngle + this.cameraPolarOffset + 1e-6,
                      -this.minPolarAngle + this.cameraPolarOffset - 1e-6
                    )
                  : rr.clamp(
                      this.euler.x,
                      -this.PI_2 + this.cameraPolarOffset + 1e-6,
                      this.PI_2 + this.cameraPolarOffset - 1e-6
                    ));
            let R = Db.copy(this.cameraPolarAxis0);
            ("Locked" !== this.cameraYAxis || "radial" === this.orientMode) &&
              R.applyQuaternion(I);
            let B = DD.setFromAxisAngle(R, _);
            "Locked" !== this.cameraYAxis &&
              this.targetToCamera.applyQuaternion(I),
              "Locked" !== this.cameraXAxis &&
                this.targetToCamera.applyQuaternion(B);
          }
          groundTiltAdjustment(_) {
            (180 * DR.angleTo(_)) / Math.PI < 15 ||
            (180 * DR.angleTo(_)) / Math.PI > 85
              ? DP.identity()
              : DP.setFromUnitVectors(DR, _),
              this.groundTilt.slerp(DP, 0.06),
              this.groundTiltInv.copy(this.groundTilt).invert();
          }
          collisionAdjustment(_) {
            let I = Dy.set(0, 0, 0);
            this.object.matrix.compose(
              this.position,
              this.quaternion,
              this.scale
            );
            let R = DM.multiplyMatrices(this.object.matrix, this.objXZRotMat)
              .multiply(this.collider.matrix)
              .decompose(Db, DP, D_)
              .compose(Db, DP, Dz);
            this.sharedGameControlGlobals.entitiesWithTransformAnim.forEach(
              (_) => {
                if (_ === this.object || _.isDescendantOf(this.object)) return;
                DN.makeEmpty(), _.updateMatrixWorldSVD();
                let B = _.matrixWorldRigid,
                  z = DE.copy(B).invert(),
                  k = DT.copy(DE).multiply(R);
                DF.copy(this.collider.segment),
                  DF.start.applyMatrix4(k),
                  DF.end.applyMatrix4(k);
                let V = Dv.copy(this.position).applyMatrix4(z);
                DN.expandByPoint(DF.start),
                  DN.expandByPoint(DF.end),
                  DN.min.addScalar(-this.collider.radius),
                  DN.max.addScalar(this.collider.radius),
                  _.bvhGeometry.boundsTree.shapecast({
                    traverseBoundsOrder: (_) => _.distanceToPoint(DF.end),
                    intersectsBounds: (_) => _.intersectsBox(DN),
                    intersectsTriangle: (_) => {
                      let R = _.closestPointToSegment(DF, Db, D_);
                      if (R < this.collider.radius) {
                        let _ = this.collider.radius - R,
                          z = D_.sub(Db).normalize(),
                          k = DS.copy(V);
                        k.addScaledVector(z, _);
                        let j = k.applyMatrix4(B).sub(this.position);
                        I.add(j),
                          DF.start.addScaledVector(z, _),
                          DF.end.addScaledVector(z, _);
                      }
                    },
                  });
              }
            ),
              DN.makeEmpty(),
              DF.copy(this.collider.segment),
              DF.start.applyMatrix4(R),
              DF.end.applyMatrix4(R),
              DN.expandByPoint(DF.start),
              DN.expandByPoint(DF.end),
              DN.min.addScalar(-this.collider.radius),
              DN.max.addScalar(this.collider.radius),
              this.sharedGameControlGlobals.staticMeshBVH?.shapecast({
                traverseBoundsOrder: (_) => _.distanceToPoint(DF.end),
                intersectsBounds: (_) => _.intersectsBox(DN),
                intersectsTriangle: (_) => {
                  let R = _.closestPointToSegment(DF, Db, D_);
                  if (R < this.collider.radius) {
                    let _ = this.collider.radius - R,
                      B = D_.sub(Db).normalize();
                    this.alignToGround && this.groundTiltAdjustment(B),
                      I.addScaledVector(B, _),
                      DF.start.addScaledVector(B, _),
                      DF.end.addScaledVector(B, _);
                  }
                },
              }),
              (this.onObject =
                Math.abs(I.y) > Math.abs(_ * this.velocity.y * 0.25)),
              this.onObject && this.dispatchStopEvent("jump");
            let B = Math.max(0, I.length() - 1e-5);
            I.normalize().multiplyScalar(B), this.position.add(I);
          }
        };
      DG.isLocked = !1;
      var DH = pi(iN());
      function yo(_, I) {
        let R = new ai();
        if (!_.getAttribute("position"))
          return R.setAttribute("position", new s4([], 3)), R.setIndex([]), R;
        let { positions: B, triIndices: z } = Xc(
          _.getAttribute("position"),
          _.getIndex()
        );
        return (
          R.setAttribute("position", new s4(B, 3)),
          R.setIndex(z),
          I && R.applyMatrix4(I),
          R
        );
      }
      var DW = new sa(),
        Dq = new sa(),
        DY = [
          [0, 0, 0],
          [0, 0, 0],
          [0, 0, 0],
        ];
      function RE(_) {
        let I = _.elements;
        (DY[0][0] = I[0]),
          (DY[0][1] = I[4]),
          (DY[0][2] = I[8]),
          (DY[1][0] = I[1]),
          (DY[1][1] = I[5]),
          (DY[1][2] = I[9]),
          (DY[2][0] = I[2]),
          (DY[2][1] = I[6]),
          (DY[2][2] = I[10]);
        let { u: R, v: B } = (0, DH.SVD)(DY),
          z = DW.set(
            R[0][0],
            R[0][1],
            R[0][2],
            0,
            R[1][0],
            R[1][1],
            R[1][2],
            0,
            R[2][0],
            R[2][1],
            R[2][2],
            0,
            0,
            0,
            0,
            1
          ),
          k = Dq.set(
            B[0][0],
            B[0][1],
            B[0][2],
            0,
            B[1][0],
            B[1][1],
            B[1][2],
            0,
            B[2][0],
            B[2][1],
            B[2][2],
            0,
            0,
            0,
            0,
            1
          );
        return z.multiply(k.transpose());
      }
      var DX = class extends lV {
          constructor() {
            super(), this.layers.enable(3), this.layers.enable(8);
          }
          setFromCamera(_, I) {
            I.isOrthographicCamera
              ? (this.ray.origin.set(_.x, _.y, -1).unproject(I),
                this.ray.direction
                  .set(0, 0, -1)
                  .transformDirection(I.matrixWorld),
                (this.camera = I))
              : I.isPerspectiveCamera
              ? (this.ray.origin.set(_.x, _.y, -1).unproject(I),
                this.ray.direction
                  .set(_.x, _.y, 0.5)
                  .unproject(I)
                  .sub(this.ray.origin)
                  .normalize(),
                (this.camera = I))
              : console.error("Raycaster: Unsupported camera type.");
          }
          intersectVisibleObjects(_, I = !0, R = []) {
            return (
              _.forEach((_) => {
                _.visible && this.intersectObject(_, I, R);
              }),
              R
            );
          }
          createRaycastLineHelper() {
            let _ = new n$({ color: 65280, linewidth: 10 }),
              I = new rF(
                this.ray.origin.x,
                this.ray.origin.y,
                this.ray.origin.z
              ),
              R = new rF(
                this.ray.direction.x,
                this.ray.direction.y,
                this.ray.direction.z
              ),
              B = this.camera.far - this.camera.near,
              z = new rF().addVectors(I, R.multiplyScalar(B)),
              k = new ai();
            return k.setFromPoints([I, z]), new n6(k, _);
          }
        },
        AN = (_) => _ instanceof A3 || _ instanceof Te;
      function aJ(_, I) {
        return _.distance - I.distance;
      }
      function Qf(_, I, R, B = !1) {
        if (!B && !R.some((I) => void 0 !== Kf(_, I))) return [];
        let z = [];
        return (
          I.children.forEach((I) =>
            (function _N(_, I, R) {
              if (!(!Uo(I) || !I.visible))
                for (let B of (mn(I) && I.raycast(_, R), I.children))
                  _N(_, B, R);
            })(_, I, z)
          ),
          z.sort(aJ),
          z
        );
      }
      function Eg(_) {
        let I = [];
        if (_.length) {
          let R = _[0].object;
          Uo(R) && I.push(R);
          let B = R.parent;
          for (; B; ) AN(B) && I.push(B), (B = B.parent);
        }
        return I;
      }
      function vo(_, I, R, B) {
        let z = _.frame;
        if (z) {
          let _ = I[0] * z.width,
            k = (1 - I[1]) * z.height;
          for (let I of R) {
            let R = I === z.uuid ? z : z.find(I);
            if (R?.intersects(_, k)) return B(R), !0;
          }
        }
        return !1;
      }
      function Kf(_, I) {
        if (mn(I)) {
          if (I.visible) {
            let R = [];
            return I.raycast(_, R), R.length ? R[0] : void 0;
          }
        } else if (AN(I))
          return (function EN(_, I) {
            if (!(!Uo(I) || !I.visible)) {
              if (mn(I)) {
                let R = [];
                if ((I.raycast(_, R), R.length)) return R[0];
              }
              for (let R of I.children) {
                let I = EN(_, R);
                if (I) return I;
              }
            }
          })(_, I);
      }
      var DQ = class {
          constructor(_, I, R, B, z, k, V, j) {
            (this.renderer = _),
              (this.publish = I),
              (this.scene = R),
              (this.getCamera = B),
              (this.sharedAssets = z),
              (this.requestRender = k),
              (this.isExport = V),
              (this.frame = j),
              (this.raycaster = new DX()),
              (this._useWindowEvents = !1),
              (this.pointerWorld = { x: 0, y: 0 }),
              (this.pointerScreen = { x: 0, y: 0 }),
              (this._useWindowEvents = "window" === I.mouseEventTarget),
              (this.domElement = _.domElement),
              (this.eventElement = this._useWindowEvents
                ? window
                : _.domElement),
              (this._domRect = this.domElement.getBoundingClientRect());
          }
          get stopRaycast() {
            return this.publish.stopRaycast;
          }
          get page() {
            return this.scene.activePage;
          }
          set useWindowEvents(_) {
            (this._useWindowEvents = _),
              (this.eventElement = _ ? window : this.renderer.domElement);
          }
          get useWindowEvents() {
            return this._useWindowEvents;
          }
          set domRect(_) {
            this._domRect = _;
          }
          get domRect() {
            return this._domRect;
          }
          updateRaycaster(_) {
            var I, R;
            let { pageX: B, pageY: z } =
              _.touches?.length > 0 ? _.touches[0] : _;
            (this.pointerWorld = {
              x:
                ((B - ((I = this._domRect).left + window.scrollX)) / I.width) *
                  2 -
                1,
              y: -(2 * ((z - (I.top + window.scrollY)) / I.height)) + 1,
            }),
              (this.pointerScreen = {
                x: (B - ((R = this._domRect).left + window.scrollX)) / R.width,
                y: 1 - (z - (R.top + window.scrollY)) / R.height,
              }),
              this.raycaster.setFromCamera(this.pointerWorld, this.getCamera());
          }
        },
        DZ = class {
          constructor(_) {
            (this.eventContext = _),
              (this.domEventsNeeded = new Set()),
              (this.hasVideoAction = !1);
          }
          connect() {}
          disconnect() {}
        },
        DK = [
          ["start", "Start"],
          ["keyDown", "KeyDown"],
          ["keyUp", "KeyUp"],
          ["mouseDown", "MouseDown"],
          ["mouseUp", "MouseUp"],
          ["mouseHover", "MouseHover"],
          ["collision", "Collision"],
          ["lookAt", "LookAt"],
          ["follow", "Follow"],
          ["scroll", "Scroll"],
        ],
        TN = (_) => DK.find(([I, R]) => R === _)?.[0],
        oa = (_) => DK.find(([I]) => I === _)?.[1],
        uJ = (_, I) => {
          let R = TN(_);
          if (R) {
            let _ = new CustomEvent(R, { bubbles: !0 });
            return (
              Object.defineProperty(_, "target", { writable: !1, value: I }), _
            );
          }
        },
        DJ = class extends DZ {
          constructor(_) {
            super(_),
              (this.objectsPerEvents = new Map()),
              (this.splineEvents = {}),
              (this.onBeginEvent = (_) => {
                if (!_.eventName || !_.target || "Scroll" === _.eventName)
                  return;
                let I = this.splineEvents[TN(_.eventName)]?.[_.target.uuid];
                if (!I) return;
                "Scroll" === _.eventName &&
                  void 0 !== _.deltaY &&
                  Object.assign(I, { deltaY: _.deltaY });
                let { domElement: R } = this.eventContext;
                R.dispatchEvent(I);
              });
            let { page: I } = this.eventContext;
            I.traverseEntity((_) => {
              if (_.data?.events.length) {
                for (let [I, R] of DK)
                  if (
                    _.data.events.some(
                      (_) => _.data.type === R && !_.data.disabled
                    )
                  ) {
                    this.objectsPerEvents.has(I)
                      ? this.objectsPerEvents.get(I)?.push(_)
                      : this.objectsPerEvents.set(I, [_]);
                    let B = uJ(R, { id: _.uuid, name: _.name }),
                      z = this.splineEvents[I];
                    z
                      ? (z[_.uuid] = B)
                      : (this.splineEvents[I] = { [_.uuid]: B });
                  }
              }
            });
          }
          connect() {
            this.objectsPerEvents.forEach((_) => {
              _.forEach((_) => {
                _.addEventListener("beginEvent", this.onBeginEvent);
              });
            });
          }
          disconnect() {
            this.objectsPerEvents.forEach((_) => {
              _.forEach((_) => {
                _.removeEventListener("beginEvent", this.onBeginEvent);
              });
            });
          }
        },
        D$ = class {
          constructor(_, I, R, B, z, k) {
            if (
              ((this.id = _),
              (this.data = I),
              (this.object = R),
              (this.entered = !1),
              (this.alreadyPlayedNonTogglingActions = new Set()),
              (this.useToggle = "Toggle" === I.runMode),
              ("KeyDown" === I.type ||
                "KeyUp" === I.type ||
                "KeyPress" === I.type) &&
                !I.key)
            )
              throw Error("Missing property");
            this.actions = Mr(I, I.actions, B, z, k, R);
          }
          disconnect() {
            dr(this.actions);
          }
          dispatchHeld(_) {
            this.actions.Create.forEach((I) => {
              _ && I.dispatchThrottled.cancel(), I.dispatchThrottled();
            });
          }
          dispatch(_ = !1) {
            this.actions.Transition.forEach((_) => {
              _.object.currentTransitionEvent !== this
                ? ((_.object.currentTransitionEvent = this), _.init())
                : "Once" === this.data.runMode &&
                  this.alreadyPlayedNonTogglingActions.add(_);
            }),
              this.useToggle
                ? (this.actions.Transition.forEach((_) => {
                    _.toggle();
                  }),
                  this.actions.Animation.forEach((_) => {
                    _.toggle();
                  }),
                  this.actions.SwitchCamera.forEach((_) => {
                    _.toggle();
                  }))
                : "MousePress" === this.data.type ||
                  "KeyPress" === this.data.type
                ? this.entered ||
                  ((this.entered = !0),
                  this.actions.Transition.forEach((_) => _.playFromCurrent()),
                  this.actions.Animation.forEach((_) => _.playFromCurrent()),
                  this.actions.SwitchCamera.forEach((_) => _.playFromCurrent()),
                  this.actions.Create.forEach((_) => _.dispatchStart()))
                : (this.actions.Transition.some((_) => _.playing) ||
                    this.actions.Transition.forEach((_) => {
                      !1 === this.alreadyPlayedNonTogglingActions.has(_) &&
                        _.play();
                    }),
                  this.actions.SwitchCamera.some((_) => _.playing) ||
                    this.actions.SwitchCamera.forEach((_) => {
                      _.play();
                    }),
                  this.actions.Animation.forEach((_) => {
                    _.play();
                  })),
              this.actions.Link.forEach((_) => {
                _.dispatch();
              }),
              this.actions.SceneTransition.forEach((_) => {
                _.dispatch();
              }),
              !1 === _ &&
                this.actions.Create.forEach((_) => {
                  _.dispatch();
                }),
              this.actions.Destroy.forEach((_) => {
                _.dispatch();
              }),
              this.actions.Reset.forEach((_) => {
                _.dispatch();
              }),
              this.actions.Audio.forEach((_) => {
                _.dispatchBasic();
              }),
              this.actions.Video.forEach((_) => {
                _.dispatchBasic();
              }),
              this.actions.Particles.forEach((_) => {
                _.dispatchBasic();
              }),
              this.actions.SetVariable.forEach((_) => _.checkConditions()),
              this.actions.SetVariable.forEach((_) => _.dispatch()),
              this.actions.DynamicVariablePlay.forEach((_) => _.dispatch());
          }
          dispatchRelease() {
            this.entered &&
              ((this.entered = !1),
              this.actions.Transition.forEach((_) => _.reverseFromCurrent()),
              this.actions.Particles.forEach((_) => _.reverseFromCurrent()),
              this.actions.Animation.forEach((_) => _.reverseFromCurrent()),
              this.actions.SwitchCamera.forEach((_) => _.reverseFromCurrent()),
              this.actions.Create.forEach((_) => _.dispatchStop()));
          }
          dispatchUserEvent(_) {
            this.actions.Transition.forEach((_) => {
              _.object.currentTransitionEvent !== this &&
                ((_.object.currentTransitionEvent = this), _.init());
            }),
              _
                ? (this.actions.Transition.forEach((_) =>
                    _.reverseFromCurrent()
                  ),
                  this.actions.Animation.forEach((_) => _.reverseFromCurrent()),
                  this.actions.SwitchCamera.forEach((_) =>
                    _.reverseFromCurrent()
                  ))
                : (this.actions.Transition.forEach((_) => _.playFromCurrent()),
                  this.actions.Animation.forEach((_) => _.playFromCurrent()),
                  this.actions.SwitchCamera.forEach((_) =>
                    _.playFromCurrent()
                  )),
              this.actions.Link.forEach((_) => {
                _.dispatch();
              }),
              this.actions.SceneTransition.forEach((_) => {
                _.dispatch();
              }),
              this.actions.Create.forEach((_) => {
                _.dispatch();
              }),
              this.actions.Destroy.forEach((_) => {
                _.dispatch();
              }),
              this.actions.Reset.forEach((_) => {
                _.dispatch();
              }),
              this.actions.Audio.forEach((_) => {
                _.dispatchBasic();
              }),
              this.actions.Video.forEach((_) => {
                _.dispatchBasic();
              }),
              this.actions.Particles.forEach((_) => {
                _.dispatchBasic();
              }),
              this.actions.SetVariable.forEach((_) => _.checkConditions()),
              this.actions.SetVariable.forEach((_) => _.dispatch()),
              this.actions.DynamicVariablePlay.forEach((_) => _.dispatch());
          }
        },
        D0 = class extends DZ {
          constructor(_, I, R) {
            super(_),
              (this.useForRaycastProperty = R),
              (this.objectsPerTypes = {
                MouseDown: [],
                MouseUp: [],
                MousePress: [],
                KeyDown: [],
                KeyUp: [],
                KeyPress: [],
              }),
              (this.canvasMouseEvents = []),
              (this.eventsPerObjects = {
                MouseDown: {},
                MouseUp: {},
                MousePress: {},
                KeyDown: {},
                KeyUp: {},
                KeyPress: {},
              }),
              (this.heldKeys = {}),
              (this.heldKeysPress = {}),
              (this._prevObjects = []),
              (this.sceneInterects = null),
              (this.onCanvasRaycast = (_) => {
                if (
                  !0 === this.useForRaycastProperty &&
                  null === this.sceneInterects
                ) {
                  this.eventContext.updateRaycaster(_);
                  let { raycaster: I, page: R } = this.eventContext,
                    B = Qf(I, R, [], !0);
                  (this.sceneInterects = B),
                    B.length &&
                      (this.eventContext.sharedAssets.raycastProperty = {
                        x: B[0].point.x,
                        y: B[0].point.y,
                        z: B[0].point.z,
                        objX: B[0].object.matrixWorld.elements[12],
                        objY: B[0].object.matrixWorld.elements[13],
                        objZ: B[0].object.matrixWorld.elements[14],
                      });
                }
              }),
              (this.onCanvasMouseDown = (_) => {
                (_.target === this.eventContext.domElement ||
                  "SPLINE-VIEWER" === _.target.tagName) &&
                  this.canvasMouseEvents.forEach((I) => {
                    ("MouseDown" === I.data.type ||
                      "MousePress" === I.data.type) &&
                      (this.onCanvasRaycast(_), I.dispatch());
                  });
              }),
              (this.onCanvasMouseUp = (_) => {
                (_.target === this.eventContext.domElement ||
                  "SPLINE-VIEWER" === _.target.tagName) &&
                  this.canvasMouseEvents.forEach((I) => {
                    "MouseUp" === I.data.type
                      ? (this.onCanvasRaycast(_), I.dispatch())
                      : "MousePress" === I.data.type && I.dispatchRelease();
                  });
              }),
              (this.onMouseDown = (_) => {
                um.length > 1 ||
                  (this.eventContext.updateRaycaster(_),
                  this.handleMouseEvent("MouseDown"));
              }),
              (this.onMouseUp = (_) => {
                um.length > 1 ||
                  (this.eventContext.updateRaycaster(_),
                  this.handleMouseEvent("MouseUp"));
              }),
              (this.onMousePressDown = (_) => {
                um.length > 1 ||
                  (this.eventContext.updateRaycaster(_),
                  this.handleMousePressEvent());
              }),
              (this.onMousePressRelease = (_) => {
                um.length > 1 ||
                  (this.eventContext.updateRaycaster(_),
                  this.handleMousePressEvent(!0));
              }),
              (this.onKeyDown = (_) => {
                this.heldKeys[_.key] ||
                  (this.handleKeyEvent(_, "KeyDown"),
                  this.handleKeyEventHeld(_, "KeyDown", !0)),
                  (this.heldKeys[_.key] = !0);
              }),
              (this.onKeyUp = (_) => {
                this.handleKeyEvent(_, "KeyUp"),
                  this.handleKeyEventHeld(_, "KeyUp", !0);
              }),
              (this.onKeyPressDown = (_) => {
                this.heldKeysPress[_.key]
                  ? this.handleKeyEventHeld(_, "KeyPress")
                  : (this.handleKeyEvent(_, "KeyPress"),
                    this.handleKeyEventHeld(_, "KeyPress", !0)),
                  (this.heldKeysPress[_.key] = !0);
              }),
              (this.onKeyPressUp = (_) => {
                this.handleKeyEvent(_, "KeyPress", !0);
              }),
              (this.releaseHeldKey = (_) => {
                delete this.heldKeys[_.key];
              }),
              (this.releaseHeldKeyPress = (_) => {
                delete this.heldKeysPress[_.key];
              }),
              (this._onUserEvent = ({
                eventName: _,
                target: I,
                reverse: R,
              }) => {
                if (!_ || !I) return;
                let B = oa(_);
                B &&
                  ("MouseDown" === B || "MouseUp" === B || "MousePress" === B
                    ? (I.dispatchEvent({ type: "beginEvent", eventName: B }),
                      this.eventsPerObjects[B]?.[I.uuid]?.forEach((_) => {
                        _.dispatchUserEvent(R);
                      }))
                    : ("KeyDown" === B || "KeyUp" === B || "KeyPress" === B) &&
                      (I.dispatchEvent({ type: "beginEvent", eventName: B }),
                      this.eventsPerObjects[B]?.[I.uuid]?.forEach((_) => {
                        _.dispatchUserEvent();
                      })));
              });
            let { page: B, sharedAssets: z } = this.eventContext,
              a = (_, R) => {
                if (_.data?.events.length)
                  for (let k of [
                    "MouseDown",
                    "MouseUp",
                    "MousePress",
                    "KeyDown",
                    "KeyUp",
                    "KeyPress",
                  ]) {
                    let V = this.eventsPerObjects[k];
                    _.data.events
                      .filter(
                        ({ data: _ }) => _.type === k && !0 !== _.disabled
                      )
                      .forEach(({ id: R, data: k }) => {
                        try {
                          let j = new D$(R, k, _, B, z, I);
                          j.actions.Video.length && (this.hasVideoAction = !0),
                            ("MouseDown" === k.type ||
                              "MouseUp" === k.type ||
                              "MousePress" === k.type) &&
                            ("Canvas" === k.mode || "Window" === k.mode)
                              ? this.canvasMouseEvents.push(j)
                              : V[_.uuid]
                              ? V[_.uuid].some((_) => _.id === j.id) ||
                                V[_.uuid].push(j)
                              : (V[_.uuid] = [j]);
                        } catch (_) {}
                      }),
                      V[_.uuid]?.length &&
                        this.objectsPerTypes[k].push(
                          _ instanceof CD &&
                            ("MouseDown" === k ||
                              "MouseUp" === k ||
                              "MousePress" === k)
                            ? R
                            : _
                        );
                  }
              };
            B.traverseEntity((_) => {
              (_ instanceof Ti || _ instanceof C6) &&
                _.frame?.traverse((I) => {
                  a(I, _);
                }),
                a(_);
            });
          }
          connect() {
            let { domElement: _ } = this.eventContext;
            (this.heldKeys = {}),
              (this.heldKeysPress = {}),
              this.domEventsNeeded.clear(),
              _.addEventListener("pointerdown", this.onCanvasMouseDown),
              _.addEventListener("pointerup", this.onCanvasMouseUp),
              (this.objectsPerTypes.MouseDown?.length ||
                this.useForRaycastProperty) &&
                (this.domEventsNeeded.add("pointerdown"),
                _.addEventListener("pointerdown", this.onMouseDown)),
              this.objectsPerTypes.MouseUp?.length &&
                (this.domEventsNeeded.add("pointerup"),
                _.addEventListener("pointerup", this.onMouseUp)),
              this.objectsPerTypes.MousePress?.length &&
                (this.domEventsNeeded.add("pointerdown"),
                _.addEventListener("pointerdown", this.onMousePressDown),
                this.domEventsNeeded.add("pointerup"),
                _.addEventListener("pointerup", this.onMousePressRelease)),
              this.objectsPerTypes.KeyDown?.length &&
                (this.domEventsNeeded.add("keydown"),
                document.addEventListener("keydown", this.onKeyDown),
                document.addEventListener("keyup", this.releaseHeldKey)),
              this.objectsPerTypes.KeyUp?.length &&
                (this.domEventsNeeded.add("keyup"),
                document.addEventListener("keyup", this.onKeyUp)),
              this.objectsPerTypes.KeyPress?.length &&
                (this.domEventsNeeded.add("keydown"),
                document.addEventListener("keydown", this.onKeyPressDown),
                document.addEventListener("keyup", this.releaseHeldKeyPress),
                this.domEventsNeeded.add("keyup"),
                document.addEventListener("keyup", this.onKeyPressUp)),
              Object.entries(this.objectsPerTypes).forEach(([_, I]) => {
                I.forEach((_) => {
                  _.addEventListener("userEvent", this._onUserEvent);
                });
              });
          }
          disconnect() {
            let { domElement: _ } = this.eventContext;
            this.domEventsNeeded.clear(),
              (this.heldKeys = {}),
              (this.heldKeysPress = {}),
              _.removeEventListener("pointerdown", this.onCanvasMouseDown),
              _.removeEventListener("pointerup", this.onCanvasMouseUp),
              _.removeEventListener("pointerdown", this.onMouseDown),
              _.removeEventListener("pointerdown", this.onMousePressDown),
              _.removeEventListener("pointerup", this.onMouseUp),
              _.removeEventListener("pointerup", this.onMousePressRelease),
              document.removeEventListener("keydown", this.onKeyDown),
              document.removeEventListener("keyup", this.onKeyUp),
              document.removeEventListener("keydown", this.onKeyPressDown),
              document.removeEventListener("keyup", this.onKeyPressUp),
              document.removeEventListener("keyup", this.releaseHeldKey),
              Object.values(this.eventsPerObjects).forEach((_) => {
                Object.values(_).forEach((_) => {
                  _.forEach((_) => {
                    _.disconnect();
                  });
                });
              }),
              this.canvasMouseEvents.forEach((_) => {
                _.disconnect();
              }),
              Object.entries(this.objectsPerTypes).forEach(([_, I]) => {
                I.forEach((_) => {
                  _.removeEventListener("userEvent", this._onUserEvent);
                });
              });
          }
          handleMouseEvent(_) {
            let {
                stopRaycast: I,
                raycaster: R,
                page: B,
                pointerScreen: z,
              } = this.eventContext,
              k = this.objectsPerTypes[_],
              V = k.filter((_) => !(_ instanceof CD));
            if (
              !(!k.length && !this.useForRaycastProperty) &&
              !(
                B.uiCanvas &&
                vo(
                  B,
                  [z.x, z.y],
                  Object.keys(this.eventsPerObjects[_]),
                  (I) => {
                    this.handleObjectMouseEventDispatch(I, _);
                  }
                )
              )
            ) {
              if (I || this.useForRaycastProperty) {
                let z;
                if (
                  (null === this.sceneInterects
                    ? (z = Qf(R, B, V, this.useForRaycastProperty))
                    : ((z = this.sceneInterects), (this.sceneInterects = null)),
                  this.useForRaycastProperty &&
                    z.length &&
                    (this.eventContext.sharedAssets.raycastProperty = {
                      x: z[0].point.x,
                      y: z[0].point.y,
                      z: z[0].point.z,
                      objX: z[0].object.matrixWorld.elements[12],
                      objY: z[0].object.matrixWorld.elements[13],
                      objZ: z[0].object.matrixWorld.elements[14],
                    }),
                  I)
                ) {
                  let I = [z[0]?.uv?.x ?? 0, z[0]?.uv?.y ?? 0];
                  Eg(z).forEach((R) => {
                    R instanceof Ti &&
                      vo(R, I, Object.keys(this.eventsPerObjects[_]), (I) => {
                        this.handleObjectMouseEventDispatch(I, _);
                      }),
                      this.eventsPerObjects[_][R.uuid] &&
                        this.handleObjectMouseEventDispatch(R, _);
                  });
                }
              }
              I ||
                V.forEach((I) => {
                  let B = Kf(R, I);
                  B &&
                    (this.handleObjectMouseEventDispatch(I, _),
                    I instanceof Ti &&
                      vo(
                        I,
                        [B?.uv?.x ?? 0, B?.uv?.y ?? 0],
                        Object.keys(this.eventsPerObjects[_]),
                        (I) => {
                          this.handleObjectMouseEventDispatch(I, _);
                        }
                      ));
                });
            }
          }
          handleMousePressEvent(_ = !1) {
            let I = "MousePress",
              R = this.objectsPerTypes[I],
              B = R.filter((_) => !(_ instanceof CD)),
              z = [];
            if (R.length) {
              if (!_) {
                let {
                    stopRaycast: _,
                    raycaster: R,
                    page: k,
                    pointerScreen: V,
                  } = this.eventContext,
                  j = !1;
                if (
                  (k.uiCanvas &&
                    (j = vo(
                      k,
                      [V.x, V.y],
                      Object.keys(this.eventsPerObjects[I]),
                      (_) => {
                        z.push(_);
                      }
                    )),
                  _ && !j)
                ) {
                  let _ = Qf(R, k, B);
                  (z = Eg(_)),
                    _.forEach((_) => {
                      _.object instanceof Ti &&
                        vo(
                          _.object,
                          [_?.uv?.x ?? 0, _?.uv?.y ?? 0],
                          Object.keys(this.eventsPerObjects[I]),
                          (_) => {
                            z.push(_);
                          }
                        );
                    });
                } else
                  B.forEach((_) => {
                    let B = Kf(R, _);
                    B &&
                      (z.push(_),
                      _ instanceof Ti &&
                        vo(
                          _,
                          [B?.uv?.x ?? 0, B?.uv?.y ?? 0],
                          Object.keys(this.eventsPerObjects[I]),
                          (_) => {
                            z.push(_);
                          }
                        ));
                  });
              }
              this._prevObjects.length &&
                this._prevObjects.forEach((_) => {
                  z.includes(_) ||
                    this.handleObjectMouseEventDispatchRelease(_, I);
                }),
                z.length &&
                  z.forEach((_) => {
                    this.handleObjectMouseEventDispatch(_, I);
                  }),
                (this._prevObjects = z);
            }
          }
          handleObjectMouseEventDispatch(_, I) {
            _.dispatchEvent({ type: "beginEvent", eventName: I }),
              this.eventsPerObjects[I]?.[_.uuid]?.forEach((_) => {
                _.dispatch();
              });
          }
          handleObjectMouseEventDispatchRelease(_, I) {
            _.dispatchEvent({ type: "beginEvent", eventName: I }),
              this.eventsPerObjects[I]?.[_.uuid]?.forEach((_) => {
                _.dispatchRelease();
              });
          }
          handleKeyEvent(_, I, R = !1) {
            this.objectsPerTypes[I].forEach((B) => {
              let z = this.eventsPerObjects[I][B.uuid];
              z.some(({ data: I }) => "key" in I && I.key === _.key) &&
                B.dispatchEvent({ type: "beginEvent", eventName: I }),
                z.forEach((I) => {
                  "key" in I.data &&
                    I.data.key === _.key &&
                    (R ? I.dispatchRelease() : I.dispatch(!0));
                });
            });
          }
          handleKeyEventHeld(_, I, R = !1) {
            this.objectsPerTypes[I].forEach((B) => {
              this.eventsPerObjects[I][B.uuid].forEach((I) => {
                "key" in I.data && I.data.key === _.key && I.dispatchHeld(R);
              });
            });
          }
        },
        D1 = new rF(),
        D3 = new rF(),
        D4 = class {
          constructor(_, I, R, B, z) {
            (this.actionsIn = Mr(_, _.inActions, R, B, z, I)),
              (this.actionsOut = Mr(_, _.outActions, R, B, z, I));
          }
          disconnect() {
            dr(this.actionsIn), dr(this.actionsOut);
          }
        },
        D5 = class extends D4 {
          constructor(_, I, R, B, z, k) {
            super(I, R, B, z, k),
              (this.id = _),
              (this.data = I),
              (this.object = R),
              (this.stage = "out"),
              (this.objects = []),
              (this.onUpdateMatrixWorld = () => {
                for (let _ of this.objects) if (!_.visible) return;
                let _ = D1.setFromMatrixPosition(this.objects[0].matrixWorld),
                  I = D3.setFromMatrixPosition(this.objects[1].matrixWorld),
                  R = _.distanceTo(I) <= this.distance ? "in" : "out";
                if (this.stage !== R) {
                  this.stage = R;
                  let _ = "in" === R ? this.actionsIn : this.actionsOut;
                  _.Audio.forEach((_) => _.dispatchConditional()),
                    _.Particles.forEach((_) => _.dispatchConditional()),
                    _.Video.forEach((_) => _.dispatchConditional()),
                    _.Link.forEach((_) => _.dispatch()),
                    _.Create.forEach((_) => _.dispatch()),
                    _.Destroy.forEach((_) => _.dispatch()),
                    _.Reset.forEach((_) => _.dispatch()),
                    _.Transition.forEach((_) => {
                      _.object.currentTransitionEvent !== this &&
                        (_.object.currentTransitionEvent = this),
                        _.init();
                    }),
                    _.Transition.forEach((_) => _.play()),
                    _.Animation.forEach((_) => _.play()),
                    _.SwitchCamera.forEach((_) => _.play()),
                    _.SceneTransition.forEach((_) => _.dispatch()),
                    _.SetVariable.forEach((_) => _.checkConditions()),
                    _.SetVariable.forEach((_) => _.dispatch()),
                    _.DynamicVariablePlay.forEach((_) => _.dispatch());
                }
              });
            let { distance: V, fromObject: j, toObject: G } = I.condition;
            for (let _ of ((this.distance = V), [j, G])) {
              if (!_) throw Error("Missing property");
              let I = B.find(_);
              if (!I) throw Error("Missing property");
              this.objects.push(I);
            }
          }
          connect() {
            window.setTimeout(() => {
              this.objects.forEach((_) => {
                _.addEventListener(
                  "updateMatrixWorld",
                  this.onUpdateMatrixWorld
                );
              }),
                this.onUpdateMatrixWorld();
            }, 0);
          }
          disconnect() {
            super.disconnect(),
              (this.stage = "out"),
              this.objects.forEach((_) => {
                _.removeEventListener(
                  "updateMatrixWorld",
                  this.onUpdateMatrixWorld
                );
              });
          }
        },
        D6 = class extends D4 {
          constructor(_, I, R, B, z, k) {
            super(I, R, B, z, k),
              (this.id = _),
              (this.data = I),
              (this.object = R),
              (this.onBegin = ({ target: _, state: I }) => {
                this.toState !== I &&
                  (this.actionsOut.Audio.forEach((_) =>
                    _.dispatchConditional()
                  ),
                  this.actionsOut.Particles.forEach((_) =>
                    _.dispatchConditional()
                  ),
                  this.actionsOut.Video.forEach((_) => _.dispatchConditional()),
                  this.actionsOut.Link.forEach((_) => _.dispatch()),
                  this.actionsOut.Create.forEach((_) => _.dispatch()),
                  this.actionsOut.Destroy.forEach((_) => _.dispatch()),
                  this.actionsOut.Reset.forEach((_) => _.dispatch()),
                  this.actionsIn.Transition.forEach((_) => _.pause()),
                  (this.object.currentTransitionEvent = this),
                  this.actionsOut.Transition.forEach((_) => _.play()),
                  this.actionsOut.Animation.forEach((_) => _.play()),
                  this.actionsIn.SwitchCamera.forEach((_) => _.pause()),
                  this.actionsOut.SwitchCamera.forEach((_) => _.play()),
                  this.actionsOut.SceneTransition.forEach((_) => _.dispatch()),
                  this.actionsOut.SetVariable.forEach((_) =>
                    _.checkConditions()
                  ),
                  this.actionsOut.SetVariable.forEach((_) => _.dispatch()),
                  this.actionsOut.DynamicVariablePlay.forEach((_) =>
                    _.dispatch()
                  ));
              }),
              (this.onComplete = ({ target: _, state: I }) => {
                this.toState === I &&
                  (this.actionsIn.Audio.forEach((_) => _.dispatchConditional()),
                  this.actionsIn.Particles.forEach((_) =>
                    _.dispatchConditional()
                  ),
                  this.actionsIn.Video.forEach((_) => _.dispatchConditional()),
                  this.actionsIn.Link.forEach((_) => _.dispatch()),
                  this.actionsIn.Create.forEach((_) => _.dispatch()),
                  this.actionsIn.Destroy.forEach((_) => _.dispatch()),
                  this.actionsIn.Reset.forEach((_) => _.dispatch()),
                  this.actionsOut.Transition.forEach((_) => _.pause()),
                  this.actionsOut.Transition.forEach((_) => _.pause()),
                  (this.object.currentTransitionEvent = this),
                  this.actionsIn.Transition.forEach((_) => _.play()),
                  this.actionsIn.Animation.forEach((_) => _.play()),
                  this.actionsOut.SwitchCamera.forEach((_) => _.pause()),
                  this.actionsIn.SwitchCamera.forEach((_) => _.play()),
                  this.actionsIn.SceneTransition.forEach((_) => _.dispatch()),
                  this.actionsIn.SetVariable.forEach((_) =>
                    _.checkConditions()
                  ),
                  this.actionsIn.SetVariable.forEach((_) => _.dispatch()),
                  this.actionsIn.DynamicVariablePlay.forEach((_) =>
                    _.dispatch()
                  ));
              });
            let { condition: V } = I;
            if (!V.object) throw Error("Missing property");
            let j = B.find(V.object) ?? B.scene.find2D(V.object);
            if (
              !j ||
              ((this.toObject = j), V.state && !this.toObject.states?.[V.state])
            )
              throw Error("Missing property");
            this.toState = V.state;
          }
          connect() {
            bs(this.actionsOut).forEach((_) => {
              this.actionsOut[_]?.length &&
                this.toObject.addEventListener("beginState", this.onBegin);
            }),
              bs(this.actionsIn).forEach((_) => {
                this.actionsIn[_]?.length &&
                  this.toObject.addEventListener(
                    "completeState",
                    this.onComplete
                  );
              });
          }
          disconnect() {
            super.disconnect(),
              bs(this.actionsOut).forEach((_) => {
                this.actionsIn[_]?.length &&
                  this.toObject.removeEventListener("beginState", this.onBegin);
              }),
              bs(this.actionsIn).forEach((_) => {
                this.actionsIn[_]?.length &&
                  this.toObject.removeEventListener(
                    "completeState",
                    this.onComplete
                  );
              });
          }
        },
        D8 = class extends DZ {
          constructor(_, I) {
            super(_),
              (this.eventsPerConditions = {
                Comparison: [],
                Distance: [],
                State: [],
              }),
              (this.hasVideoAction = !1);
            let { page: R, sharedAssets: B } = this.eventContext;
            R.traverseEntity((_) => {
              if (_.data?.events.length) {
                for (let { id: z, data: k } of _.data.events)
                  if (!k.disabled && "Conditional" === k.type)
                    try {
                      let V;
                      "Comparison" === k.condition.type ||
                        ("Distance" === k.condition.type
                          ? (V = new D5(z, k, _, R, B, I))
                          : "State" === k.condition.type &&
                            (V = new D6(z, k, _, R, B, I))),
                        V &&
                          (this.eventsPerConditions[k.condition.type].push(V),
                          (V.actionsIn.Video.length ||
                            V.actionsOut.Video.length) &&
                            (this.hasVideoAction = !0));
                    } catch (_) {}
              }
            });
          }
          connect() {
            super.connect(),
              Object.values(this.eventsPerConditions).forEach((_) =>
                _.forEach((_) => _.connect())
              );
          }
          disconnect() {
            super.disconnect(),
              Object.values(this.eventsPerConditions).forEach((_) =>
                _.forEach((_) => _.disconnect())
              );
          }
        },
        D9 = new rF(),
        D7 = new rF(),
        Ot = new rF(),
        Oi = new aV(),
        Or = new rF(),
        Os = new rF(),
        Oa = new rF(),
        On = new rz(),
        Oo = new sg(),
        Ol = new sa(),
        Oc = new ro(),
        Od = new rF(),
        Ou = new rF();
      function zE(_, I) {
        !I ||
          (I[0] < I[1] && (_.x = Math.min(Math.max(_.x, I[0]), I[1])),
          I[2] < I[3] && (_.y = Math.min(Math.max(_.y, I[2]), I[3])),
          I[4] < I[5] && (_.z = Math.min(Math.max(_.z, I[4]), I[5])));
      }
      var Of =
          ((ip = new sa()),
          (_, I, R) => {
            let B = _.obj;
            ip.copy(B.hiddenMatrix),
              null !== B.parent && ip.premultiply(B.parent.matrixWorld),
              ip.invert(),
              B.position.copy(I),
              "global" === _.reference && zE(B.position, _.limits),
              B.position.applyMatrix4(ip),
              "parent" === _.reference
                ? zE(B.position, _.limits)
                : "local" === _.reference &&
                  (On.copy(_.quat0).invert(),
                  B.position.sub(_.position0),
                  B.position.applyQuaternion(On),
                  zE(B.position, _.limits),
                  On.invert(),
                  B.position.applyQuaternion(On),
                  B.position.add(_.position0)),
              ip.multiply(R ?? B.matrixWorld).decompose(Or, B.quaternion, Os),
              B.updateMatrix(),
              B.hasNonUniformScale &&
                (B.updateMatrixWorld(), B.updateMatrixWorldSVD()),
              B instanceof wp &&
                Rn(B.parent) &&
                B.invalidateDownstreamBooleanData(!0);
          }),
        Om = class {
          constructor(_, I, R, B, z, k) {
            (this.object = _),
              (this.data = I),
              (this.dropDestIds = []),
              (this.activeIdx = null),
              (this.wasDragEventTriggered = !1),
              (this.resetDampingFactor =
                0 === this.data.resetSpeed ? 1 : 8 / this.data.resetSpeed + 1),
              (this.snapDampingFactor =
                0 === this.data.snapSpeed ? 1 : 8 / this.data.snapSpeed + 1),
              (this.actionsDrag = Mr(
                I,
                I.dragDropActions.drag,
                R,
                B,
                z,
                this.object
              )),
              (this.actionsDrop = Mr(
                I,
                I.dragDropActions.drop,
                R,
                B,
                z,
                this.object
              ));
            let V = [];
            this.data.objects.forEach((_) => {
              let I = R.find(_);
              !I ||
                (!1 !== I.data.visible &&
                  (V.push(I),
                  k[I.uuid] &&
                    k[I.uuid].forEach((_) => {
                      let I = R.find(_);
                      I && !1 !== I.data.visible && V.push(I);
                    })));
            }),
              this.data.dropDestinations.forEach((_) => {
                let I = R.find(_);
                !I ||
                  (!1 !== I.data.visible &&
                    (this.dropDestIds.push(I.uuid),
                    k[I.uuid] &&
                      k[I.uuid].forEach((_) => {
                        let I = R.find(_);
                        I &&
                          !1 !== I.data.visible &&
                          this.dropDestIds.push(I.uuid);
                      })));
              }),
              (this.dragItems = V.map(
                (_) => (
                  "locked" === this.data.planeMode &&
                    (_.userData.lockedPlane = !0),
                  (_.userData.worldPosition0 = new rF().setFromMatrixPosition(
                    _.matrixWorld
                  )),
                  {
                    obj: _,
                    fromPosition: new rF().setFromMatrixPosition(_.matrixWorld),
                    pointStart: new rF(),
                    pointEnd: new rF(),
                    paused: !0,
                    currentDampingFactor: this.data.dampingFactor,
                    reset: !1,
                    position0: new rF().copy(_.position),
                    quat0: new rz().copy(_.quaternion),
                    snapped: !1,
                    orientationMatrix: new sa(),
                    limits: this.data.limits,
                    reference: this.data.referenceFrame,
                  }
                )
              ));
          }
          get activeDragItem() {
            return null !== this.activeIdx
              ? this.dragItems[this.activeIdx]
              : null;
          }
          dispose() {
            dr(this.actionsDrag),
              dr(this.actionsDrop),
              this.dragItems.forEach((_) => {
                _.fromPosition.copy(_.obj.userData.worldPosition0),
                  _.pointStart.copy(_.fromPosition),
                  _.pointEnd.copy(_.pointStart),
                  (_.obj.recursiveBBoxNeedsUpdate = !0),
                  (_.obj.userData.lockedPlane = void 0),
                  _.obj.position.copy(_.position0),
                  _.obj.quaternion.copy(_.quat0),
                  _.obj.updateMatrix();
              });
          }
        },
        Oy = class extends DZ {
          constructor(_, I) {
            super(_),
              (this.eventManager = I),
              (this.events = []),
              (this.lastDropDestination = null),
              (this.dragTimeout = null),
              (this.onPointerDown = (_) => {
                if (um.length > 1) return;
                this.eventContext.updateRaycaster(_);
                let { raycaster: I, page: R } = this.eventContext,
                  B = R.raycastWithClones(I);
                if (((this.lastDropDestination = null), 0 === B.length)) {
                  this.activeEvent = null;
                  return;
                }
                for (let _ of this.events) {
                  let I = 0;
                  for (let {
                    obj: R,
                    pointEnd: z,
                    pointStart: k,
                  } of _.dragItems) {
                    if (
                      R === B[0].object ||
                      R === B[0].object.object ||
                      (bG.is(R) && R.isAncestorOf(B[0].object.uuid))
                    ) {
                      if (
                        ((_.activeIdx = I),
                        (_.activeDragItem.reset = !1),
                        (_.activeDragItem.currentDampingFactor =
                          _.data.dampingFactor),
                        (_.activeDragItem.snapped = !1),
                        "hand" === _.data.cursor && this.setCursor("grabbing"),
                        this.eventManager.controlsManager.usePhysics)
                      ) {
                        _.activeDragItem.obj.rigidBody &&
                          _.activeDragItem.obj.rigidBody.setBodyType(2, !0);
                        let I = _.activeDragItem.obj;
                        R.hasNonUniformScale && R.updateMatrixWorldSVD(),
                          (I.hasNonUniformScale
                            ? I.matrixWorldRigid
                            : I.matrixWorld
                          ).decompose(Or, On, Os),
                          Oo.setFromQuaternion(On),
                          void 0 === I.prevR
                            ? ((I.prevR = Oo.clone()), (I.prevT = Or.clone()))
                            : (I.prevR.copy(Oo), I.prevT.copy(Or)),
                          this.eventManager.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim.push(
                            _.activeDragItem.obj
                          );
                      }
                      this.calcPlaneIntersectPos(
                        R,
                        k,
                        _.data.plane,
                        _.data.referenceFrame
                      ),
                        z.copy(k),
                        ((this.eventManager.controlsManager.usePhysics &&
                          R.data.physics?.rigidBody === "dynamic") ||
                          !1 === _.data.drop ||
                          !1 === _.data.resetOnSnapFail) &&
                          _.activeDragItem.fromPosition.setFromMatrixPosition(
                            _.activeDragItem.obj.matrixWorld
                          ),
                        (this.activeEvent = _),
                        this.eventManager.controlsManager.orbitControls &&
                          (this.eventManager.controlsManager.orbitControls.enabled =
                            !1);
                      return;
                    }
                    I++;
                  }
                }
                this.activeEvent = null;
              }),
              (this.onPointerMove = (_) => {
                if (um.length > 1) return;
                this.eventContext.updateRaycaster(_);
                let { raycaster: I, page: R } = this.eventContext,
                  B = R.raycastWithClones(I);
                if (0 === um.length) {
                  let _ = !1;
                  for (let I of this.events) {
                    for (let { obj: R } of I.dragItems)
                      if (
                        R === B[0]?.object ||
                        R === B[0]?.object?.object ||
                        (bG.is(R) && R.isAncestorOf(B[0]?.object.uuid))
                      ) {
                        switch (((_ = !0), I.data.cursor)) {
                          case "hand":
                            this.setCursor("grab");
                            break;
                          case "move":
                            this.setCursor("move");
                        }
                        break;
                      }
                    if (_) break;
                  }
                  _ || this.setCursor("default");
                  return;
                }
                if (this.activeEvent && this.activeEvent.activeDragItem) {
                  let _,
                    I = this.activeEvent.activeDragItem;
                  if (
                    ((I.snapped = !1),
                    this.activeEvent.data.drop &&
                      (_ = B.filter(
                        (_) =>
                          I.obj !== _.object &&
                          !I.obj.isAncestorOf(_.object.uuid) &&
                          !(_.object instanceof A3) &&
                          ("all" === this.activeEvent.data.dropOn ||
                            this.activeEvent.dropDestIds.some(
                              (I) =>
                                I === _.object.uuid ||
                                R.scene.find(I).isAncestorOf(_.object.uuid)
                            ))
                      )[0]),
                    _)
                  ) {
                    let R = Oa.copy(_.face.normal).applyMatrix3(
                      Oc.getNormalMatrix(_.object.matrixWorld)
                    );
                    if ("center" === this.activeEvent.data.snapTo)
                      I.fromPosition.setFromMatrixPosition(
                        _.object.matrixWorld
                      );
                    else if ("surface" === this.activeEvent.data.snapTo) {
                      if (
                        (I.fromPosition.copy(_.point),
                        "bbox" === this.activeEvent.data.snapSurfaceMode)
                      ) {
                        Or.copy(R).applyMatrix3(
                          Oc.setFromMatrix4(I.obj.matrixWorld).transpose()
                        );
                        let _ = I.obj;
                        Or.x > 0.2
                          ? (Os.x = -_.recursiveBBox.min.x)
                          : Or.x < -0.2 && (Os.x = -_.recursiveBBox.max.x),
                          Or.y > 0.2
                            ? (Os.y = -_.recursiveBBox.min.y)
                            : Or.y < -0.2 && (Os.y = -_.recursiveBBox.max.y),
                          Or.z > 0.2
                            ? (Os.z = -_.recursiveBBox.min.z)
                            : Or.z < -0.2 && (Os.z = -_.recursiveBBox.max.z),
                          Os.applyMatrix3(Oc.invert());
                      } else
                        Os.copy(R).multiplyScalar(
                          this.activeEvent.data.snapSurfaceOffset
                        );
                      I.fromPosition.add(Os);
                    }
                    this.activeEvent.data.autoOrient &&
                      (Or.set(0, 1, 0).cross(R),
                      1e-4 > Or.length() && Or.set(-1, 0, 0).cross(R),
                      Os.crossVectors(Oa, Or),
                      I.orientationMatrix.makeBasis(Or, Os, R)),
                      I.pointStart.copy(I.fromPosition),
                      I.pointEnd.copy(I.pointStart),
                      (I.currentDampingFactor =
                        this.activeEvent.snapDampingFactor),
                      (I.snapped = !0),
                      this.lastDropDestination !== _.object &&
                        ((this.lastDropDestination = _.object),
                        this.activeEvent.actionsDrop.Transition.forEach((_) => {
                          _.play();
                        }),
                        this.activeEvent.actionsDrop.Animation.forEach((_) => {
                          _.play();
                        }),
                        this.activeEvent.actionsDrop.Audio.forEach((_) => {
                          _.dispatchGameControl("start");
                        }),
                        this.activeEvent.actionsDrop.Particles.forEach((_) => {
                          _.dispatchGameControl("start");
                        }),
                        this.activeEvent.actionsDrop.Create.forEach((_) => {
                          _.dispatchThrottled();
                        }));
                  } else
                    I.orientationMatrix.makeRotationFromQuaternion(I.quat0),
                      (this.lastDropDestination = null),
                      (I.currentDampingFactor =
                        this.activeEvent.data.dampingFactor),
                      this.calcPlaneIntersectPos(
                        I.obj,
                        I.pointEnd,
                        this.activeEvent.data.plane,
                        this.activeEvent.data.referenceFrame
                      ),
                      this.activeEvent.actionsDrop.Transition.forEach((_) => {
                        _.stop(),
                          null !== _.object.currentState &&
                            _.object.changeSelectedState(null, {
                              scene: this.eventContext.page.scene,
                              shared: this.eventContext.sharedAssets,
                            });
                      }),
                      this.activeEvent.actionsDrop.Animation.forEach((_) => {
                        _.stop();
                      }),
                      this.activeEvent.actionsDrop.Audio.forEach((_) => {
                        _.dispatchGameControl("stop");
                      }),
                      this.activeEvent.actionsDrop.Particles.forEach((_) => {
                        _.dispatchGameControl("stop");
                      });
                  this.activeEvent.actionsDrag.Create.forEach((_) => {
                    _.dispatchThrottled();
                  }),
                    this.activeEvent.actionsDrag.SetVariable.forEach((_) =>
                      _.checkConditions()
                    ),
                    this.activeEvent.actionsDrag.SetVariable.forEach((_) =>
                      _.dispatch()
                    ),
                    this.activeEvent.actionsDrag.DynamicVariablePlay.forEach(
                      (_) => _.dispatch()
                    ),
                    !1 === this.activeEvent.wasDragEventTriggered &&
                      ((this.activeEvent.wasDragEventTriggered = !0),
                      this.activeEvent.actionsDrag.Transition.forEach((_) => {
                        _.play();
                      }),
                      this.activeEvent.actionsDrag.Animation.forEach((_) => {
                        _.play();
                      }),
                      this.activeEvent.actionsDrag.Audio.forEach((_) => {
                        _.dispatchGameControl("start");
                      }),
                      this.activeEvent.actionsDrag.Particles.forEach((_) => {
                        _.dispatchGameControl("start");
                      })),
                    this.dragTimeout && window.clearTimeout(this.dragTimeout),
                    (this.dragTimeout = window.setTimeout(() => {
                      this.activeEvent &&
                        ((this.activeEvent.wasDragEventTriggered = !1),
                        this.activeEvent.actionsDrag.Audio.forEach((_) => {
                          _.dispatchGameControl("stop");
                        }),
                        this.activeEvent.actionsDrag.Particles.forEach((_) => {
                          _.dispatchGameControl("stop");
                        }),
                        this.activeEvent.actionsDrag.Transition.forEach((_) => {
                          _.stop(),
                            null !== _.object.currentState &&
                              _.object.changeSelectedState(null, {
                                scene: this.eventContext.page.scene,
                                shared: this.eventContext.sharedAssets,
                              });
                        }),
                        this.activeEvent.actionsDrag.Animation.forEach((_) => {
                          _.stop();
                        }));
                    }, 500)),
                    this.updateDragItem(I),
                    I.obj.dispatchEvent({ type: "requestRender" });
                }
              }),
              (this.onPointerUp = (_) => {
                if (this.activeEvent && this.activeEvent.activeDragItem) {
                  "hand" === this.activeEvent.data.cursor &&
                    this.setCursor("grab");
                  let _ =
                    this.activeEvent.activeDragItem.obj.data.physics
                      ?.rigidBody === "dynamic";
                  !1 === this.activeEvent.activeDragItem.snapped &&
                    this.activeEvent.data.drop &&
                    this.activeEvent.data.resetOnSnapFail &&
                    (!1 === this.eventManager.controlsManager.usePhysics ||
                      !_) &&
                    ((this.activeEvent.activeDragItem.reset =
                      this.activeEvent.data.resetOnSnapFail),
                    (this.activeEvent.activeDragItem.paused = !1),
                    (this.activeEvent.activeDragItem.currentDampingFactor =
                      this.activeEvent.resetDampingFactor)),
                    this.eventManager.controlsManager.usePhysics &&
                      _ &&
                      (this.eventManager.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim.pop(),
                      this.activeEvent.activeDragItem.obj.rigidBody.setBodyType(
                        0,
                        !0
                      ),
                      (this.activeEvent.activeDragItem.paused = !0)),
                    !0 === this.activeEvent.wasDragEventTriggered &&
                      ((this.activeEvent.wasDragEventTriggered = !1),
                      this.activeEvent.actionsDrag.Transition.forEach((_) => {
                        _.stop(),
                          null !== _.object.currentState &&
                            _.object.changeSelectedState(null, {
                              scene: this.eventContext.page.scene,
                              shared: this.eventContext.sharedAssets,
                            });
                      }),
                      this.activeEvent.actionsDrag.Animation.forEach((_) => {
                        _.stop();
                      }),
                      this.activeEvent.actionsDrag.Audio.forEach((_) => {
                        _.dispatchGameControl("stop");
                      }),
                      this.activeEvent.actionsDrag.Particles.forEach((_) => {
                        _.dispatchGameControl("stop");
                      }),
                      this.activeEvent.actionsDrop.SetVariable.forEach((_) =>
                        _.checkConditions()
                      ),
                      this.activeEvent.actionsDrop.SetVariable.forEach((_) =>
                        _.dispatch()
                      ),
                      this.activeEvent.actionsDrop.DynamicVariablePlay.forEach(
                        (_) => _.dispatch()
                      )),
                    this.eventManager.controlsManager.orbitControls &&
                      (this.eventManager.controlsManager.orbitControls.enabled =
                        !0);
                }
              });
            let R = {};
            _.page.traverseEntity((_) => {
              _.component &&
                (R[_.component.uuid]
                  ? R[_.component.uuid].push(_.uuid)
                  : (R[_.component.uuid] = [_.uuid]));
            }),
              _.page.traverseEntity((B) => {
                B.data?.events
                  .filter((_) => "DragDrop" === _.data.type && !_.data.disabled)
                  .forEach((z) => {
                    this.events.push(
                      new Om(B, z.data, _.page, _.sharedAssets, I, R)
                    );
                  });
              });
          }
          connect() {
            if (!this.events.length) return;
            this.domEventsNeeded.clear(),
              this.domEventsNeeded.add("pointerdown");
            let _ = this.eventContext.domElement;
            _.addEventListener("pointerdown", this.onPointerDown),
              _.addEventListener("pointermove", this.onPointerMove),
              _.addEventListener("pointerup", this.onPointerUp),
              this.domEventsNeeded.add("pointermove");
          }
          disconnect() {
            if (!this.events.length) return;
            this.domEventsNeeded.clear();
            let _ = this.eventContext.domElement;
            _.removeEventListener("pointerdown", this.onPointerDown),
              _.removeEventListener("pointermove", this.onPointerMove),
              _.removeEventListener("pointerup", this.onPointerUp),
              this.events.forEach((_) => _.dispose());
          }
          setCursor(_) {
            this.eventContext.domElement.style.cursor = _;
          }
          onAnimationFrameDamping() {
            for (let _ of this.events)
              for (let I of _.dragItems) I.paused || this.updateDragItem(I, !0);
          }
          calcPlaneIntersectPos(_, I, R, B) {
            let { getCamera: z, raycaster: k } = this.eventContext;
            z().getWorldDirection(D7), D7.negate();
            let V = On.identity();
            switch (
              ("parent" === B
                ? Ol.multiplyMatrices(
                    _.parent.matrixWorld,
                    _.hiddenMatrix
                  ).decompose(Or, V, Os)
                : "local" === B && _.matrixWorld.decompose(Or, V, Os),
              R)
            ) {
              case "x":
                Or.set(1, 0, 0).applyQuaternion(V),
                  Od.copy(D7).cross(Or),
                  Ou.copy(Or).cross(Od);
                break;
              case "y":
                Or.set(0, 1, 0).applyQuaternion(V),
                  Od.copy(D7).cross(Or),
                  Ou.copy(Or).cross(Od);
                break;
              case "z":
                Or.set(0, 0, 1).applyQuaternion(V),
                  Od.copy(D7).cross(Or),
                  Ou.copy(Or).cross(Od);
                break;
              case "xy":
                Ou.set(0, 0, 1).applyQuaternion(V);
                break;
              case "yz":
                Ou.set(1, 0, 0).applyQuaternion(V);
                break;
              case "xz":
                Ou.set(0, 1, 0).applyQuaternion(V);
                break;
              case "adaptive":
                D7.angleTo(Os.set(0, 1, 0)) > Math.PI / 6
                  ? (Or.crossVectors(Os.set(0, 1, 0), D7),
                    Ou.crossVectors(Or, Os))
                  : Ou.set(0, 1, 0);
                break;
              default:
                Ou.copy(D7);
            }
            Ot.setFromMatrixPosition(_.matrixWorld);
            let j = _.userData.lockedPlane ? _.userData.worldPosition0 : Ot;
            if (
              (Oi.setFromNormalAndCoplanarPoint(Ou, j),
              k.ray.intersectPlane(Oi, I) &&
                ("x" === R || "y" === R || "z" === R))
            ) {
              let _ = Os.subVectors(I, j).dot(Or);
              I.copy(j).addScaledVector(Or, _);
            }
          }
          updateDragItem(_, I = !1) {
            Ot.setFromMatrixPosition(_.obj.matrixWorld),
              "current" === _.reset
                ? D9.subVectors(_.fromPosition, Ot).divideScalar(
                    _.currentDampingFactor
                  )
                : "original" === _.reset
                ? (D9.subVectors(
                    _.obj.userData.worldPosition0,
                    Ot
                  ).divideScalar(_.currentDampingFactor),
                  _.fromPosition.copy(_.obj.userData.worldPosition0),
                  _.pointStart.copy(_.fromPosition),
                  _.pointEnd.copy(_.pointStart))
                : D9.subVectors(_.pointEnd, _.pointStart)
                    .add(_.fromPosition)
                    .sub(Ot)
                    .divideScalar(_.currentDampingFactor),
              (_.paused = !(_.currentDampingFactor > 1) || 0.01 > D9.length()),
              ((this.activeEvent &&
                1 === this.activeEvent.data.dampingFactor) ||
                I) &&
                Of(
                  _,
                  D9.add(Ot),
                  this.activeEvent?.data.drop &&
                    this.activeEvent?.data.autoOrient
                    ? _.orientationMatrix
                    : null
                ),
              _.obj.dispatchEvent({
                type: "beginEvent",
                eventName: "DragDrop",
              }),
              this.eventManager.requestRender();
          }
        },
        Ox = new rF(),
        Ob = new rF(),
        O_ = new rF(),
        OS = new rF(),
        OM = new aV(),
        OE = { type: "requestRender" },
        OC =
          ((im = new rF()),
          (iy = new rF()),
          (_, I, R) =>
            R > 0
              ? (im.subVectors(_, I),
                im.length() <= R
                  ? _
                  : iy.copy(I).add(im.normalize().multiplyScalar(R)))
              : I),
        OT =
          ((ix = new sa()),
          (_, I) => {
            _.position.copy(I),
              null !== _.parent &&
                (ix.copy(_.parent.matrixWorld).invert(),
                _.position.applyMatrix4(ix)),
              ix.copy(_.hiddenMatrix).invert(),
              _.position.applyMatrix4(ix),
              _.updateMatrix(),
              _.hasNonUniformScale &&
                (_.updateMatrixWorld(), _.updateMatrixWorldSVD()),
              _ instanceof wp &&
                Rn(_.parent) &&
                _.invalidateDownstreamBooleanData(!0);
          }),
        OP = class {
          constructor(_, I, R, B, z) {
            (this.data = _),
              (this.object = I),
              (this.paused = !1),
              (this.currentDampingFactor = 1),
              (this.snapComplete = !1),
              (this.isReset = !1),
              (this.worldPosition0 = new rF()),
              (this.timeoutId = null),
              (this.delayFinished = !0),
              (this.wasOutside = !1),
              (this.data = {
                ...me.defaultData,
                ..._,
                ...(void 0 === _.resetOnPointerLeave && {
                  resetOnPointerLeave: !1,
                }),
              }),
              void 0 === _.target ||
                "cursor" === _.target ||
                (this.target = R.find(_.target)),
              this.data.dampingFactor &&
                (this.currentDampingFactor = this.data.dampingFactor),
              (this.resetDampingFactor = 80 / this.data.resetSpeed + 1),
              this.object.getWorldPosition(this.worldPosition0),
              (this.actions = Mr(_, _.actions, R, B, z, I));
          }
        },
        OD = class extends DZ {
          constructor(_, I) {
            super(_),
              (this.events = []),
              (this.pairOfEventListeners = []),
              (this.onMouseMove = (_) => {
                if (!(um.length > 1))
                  for (let I of (this.eventContext.updateRaycaster(_),
                  this.events))
                    void 0 === I.target && this.updateSingleEvent(I);
              }),
              (this.onMouseEnter = (_) => {
                for (let _ of this.events)
                  void 0 === _.target &&
                    ((_.isReset = !1),
                    (_.currentDampingFactor = _.data.dampingFactor));
              }),
              (this.onMouseLeave = (_) => {
                for (let _ of this.events)
                  void 0 === _.target &&
                    (_.data.resetOnPointerLeave &&
                      ((_.isReset = !0),
                      (_.currentDampingFactor = _.resetDampingFactor)),
                    this.updateSingleEvent(_));
              }),
              (this.onTargetChange = (_) => () => {
                this.updateSingleEvent(_);
              });
            let { page: R } = this.eventContext;
            R.traverseEntity((B) => {
              let z = B.data?.events.find(
                (_) => "Follow" === _.data.type && !_.data.disabled
              );
              z &&
                (!R.data.globalPhysics.usePhysics ||
                  B.dataPatched.physics?.rigidBody !== "dynamic") &&
                this.events.push(new OP(z.data, B, R, _.sharedAssets, I));
            });
          }
          connect() {
            if (!this.events.length) return;
            let { domElement: _, eventElement: I } = this.eventContext;
            for (let R of (this.domEventsNeeded.clear(),
            uu &&
              (this.domEventsNeeded.add("pointerdown"),
              _.addEventListener("pointerdown", this.onMouseMove)),
            this.domEventsNeeded.add("pointermove"),
            I.addEventListener("pointermove", this.onMouseMove),
            this.eventContext.useWindowEvents ||
              (_.addEventListener("pointerenter", this.onMouseEnter),
              _.addEventListener("pointerleave", this.onMouseLeave)),
            this.events))
              if (void 0 !== R.target) {
                let _ = R.target,
                  I = this.onTargetChange(R);
                this.pairOfEventListeners.push([_, I]),
                  _.addEventListener("requestRender", I);
              }
          }
          disconnect() {
            if (!this.events.length) return;
            let { domElement: _, eventElement: I } = this.eventContext;
            for (let [R, B] of (this.domEventsNeeded.clear(),
            uu && _.removeEventListener("pointerdown", this.onMouseMove),
            I.removeEventListener("pointermove", this.onMouseMove),
            _.removeEventListener("pointerenter", this.onMouseEnter),
            _.removeEventListener("pointerleave", this.onMouseLeave),
            this.pairOfEventListeners))
              R.removeEventListener("requestRender", B);
            for (let _ of this.events)
              (_.paused = !0), (_.isReset = !1), dr(_.actions);
          }
          onAnimationFrameDamping() {
            for (let _ of this.events)
              _.paused || this.updateSingleEvent(_, !0);
          }
          updateSingleEvent(_, I = !1) {
            this.events.forEach((_) => {
              _.actions.Create.forEach((_) => {
                _.dispatchThrottled();
              });
            });
            let {
              plane: R,
              limitDistance: B,
              limitDistanceEnabled: z,
            } = _.data;
            if ((_.object.getWorldPosition(O_), _.isReset))
              OS.copy(_.worldPosition0);
            else if (_.target) _.target.getWorldPosition(OS);
            else {
              let { getCamera: _, raycaster: I } = this.eventContext;
              if (
                ("custom" === R
                  ? (_().getWorldDirection(Ob), Ob.negate(), Ox.copy(Ob))
                  : "xy" === R
                  ? Ox.set(0, 0, 1)
                  : "xz" === R
                  ? Ox.set(0, 1, 0)
                  : "yz" === R && Ox.set(1, 0, 0),
                OM.setFromNormalAndCoplanarPoint(Ox, O_),
                !I.ray.intersectPlane(OM, OS))
              )
                return;
            }
            if (!_.isReset) {
              if (OS.distanceTo(_.worldPosition0) > B && z && _.target) {
                if (
                  ((_.snapComplete = !1),
                  _.data.snapDelay &&
                    ((_.delayFinished = !1),
                    "u" > typeof window &&
                      null !== _.timeoutId &&
                      (window.clearTimeout(_.timeoutId), (_.timeoutId = null))),
                  (_.wasOutside = !0),
                  !_.data.resetAfterDistanceLimit)
                )
                  return;
                OS.copy(_.worldPosition0),
                  (_.currentDampingFactor = _.resetDampingFactor);
              } else if (
                (_.wasOutside &&
                  (_.data.snapDelay &&
                    "u" > typeof window &&
                    (_.timeoutId = window.setTimeout(() => {
                      (_.delayFinished = !0),
                        (_.paused = !1),
                        this.updateSingleEvent(_);
                    }, 1e3 * _.data.snapDelay)),
                  (_.currentDampingFactor = _.data.dampingFactor),
                  (_.wasOutside = !1)),
                !1 === _.delayFinished)
              )
                return;
            }
            !1 === _.data.enabledTranslation[0] && (OS.x = O_.x),
              !1 === _.data.enabledTranslation[1] && (OS.y = O_.y),
              !1 === _.data.enabledTranslation[2] && (OS.z = O_.z);
            let k = OC(O_, OS, _.wasOutside ? 0 : _.data.maxDelta);
            if (_.currentDampingFactor > 1) {
              let R = Ox.subVectors(k, O_).divideScalar(_.currentDampingFactor);
              O_.add(R), I && OT(_.object, O_), (_.paused = 0.01 > R.length());
            } else OT(_.object, k), (_.paused = !0);
            _.object?.dispatchEvent({
              type: "beginEvent",
              eventName: "Follow",
            }),
              _.object.dispatchEvent(OE);
          }
        },
        OR = new rF(),
        OB = new rF(),
        OL = new sa(),
        Oz = new rz(),
        OF = new rz(),
        ON = new rF(),
        Ok = new rF(),
        OV = new rF(),
        Oj = new rF(),
        OH = new aV(),
        OW = { type: "requestRender" },
        Oq = { type: "changeRotation" },
        OY =
          ((ib = new sa()),
          function (_, I) {
            null !== _.parent
              ? ib.multiplyMatrices(_.parent.matrixWorld, _.hiddenMatrix)
              : ib.copy(_.hiddenMatrix),
              I.premultiply(RE(ib).invert()),
              _.rotation.setFromRotationMatrix(I),
              _.updateMatrix(),
              _ instanceof wp &&
                Rn(_.parent) &&
                _.invalidateDownstreamBooleanData(!0);
          }),
        OX = class {
          constructor(_, I, R) {
            (this.object = I),
              (this.paused = !1),
              (this.currentDampingFactor = 1),
              (this.isReset = !1),
              (this.worldQuaternion0 = new rz()),
              (this.timeoutId = null),
              (this.delayFinished = !0),
              (this.wasOutside = !1),
              (this.data = {
                ...mt.defaultData,
                ..._,
                ...(void 0 === _.resetOnPointerLeave && {
                  resetOnPointerLeave: !1,
                }),
              }),
              void 0 === _.target ||
                "cursor" === _.target ||
                (this.target = R.find(_.target)),
              this.data.dampingFactor &&
                (this.currentDampingFactor = this.data.dampingFactor),
              this.object.getWorldQuaternion(this.worldQuaternion0),
              (this.resetDampingFactor = 80 / this.data.resetSpeed + 1);
          }
        },
        OQ = class extends DZ {
          constructor(_) {
            super(_),
              (this.events = []),
              (this.pairOfEventListeners = []),
              (this.pairOfUserEventListeners = []),
              (this.onMouseMove = (_) => {
                if (!(um.length > 1))
                  for (let I of ((this._lastMouseEvent = _),
                  this.eventContext.updateRaycaster(_),
                  this.events))
                    void 0 === I.target && this.updateSingleEvent(I);
              }),
              (this.onMouseEnter = (_) => {
                for (let _ of this.events)
                  void 0 === _.target &&
                    ((_.isReset = !1),
                    (_.currentDampingFactor = _.data.dampingFactor));
              }),
              (this.onMouseLeave = (_) => {
                for (let _ of this.events)
                  void 0 === _.target &&
                    (_.data.resetOnPointerLeave &&
                      ((_.isReset = !0),
                      (_.currentDampingFactor = _.resetDampingFactor)),
                    this.updateSingleEvent(_));
              }),
              (this.onScroll = (_) => {
                if (this._lastMouseEvent) {
                  let _ = new PointerEvent("pointermove", {
                    clientX: this._lastMouseEvent.clientX,
                    clientY: this._lastMouseEvent.clientY,
                    bubbles: !0,
                    cancelable: !0,
                    view: window,
                  });
                  this.eventContext.eventElement.dispatchEvent(_);
                }
              }),
              (this.onTargetChange = (_) => () => {
                this.updateSingleEvent(_);
              }),
              (this.createUserEventListener =
                (_) =>
                ({ eventName: I, target: R }) => {
                  if (!I || !R) return;
                  let B = oa(I);
                  B && "LookAt" === B && this.updateSingleEvent(_);
                });
            let { page: I } = this.eventContext;
            I.traverseEntity((_) => {
              let R = _.data?.events.find(
                (_) => "LookAt" === _.data.type && !_.data.disabled
              );
              R &&
                (!I.data.globalPhysics.usePhysics ||
                  _.dataPatched.physics?.rigidBody !== "dynamic") &&
                this.events.push(new OX(R.data, _, I));
            });
          }
          connect() {
            if (!this.events.length) return;
            let { domElement: _, eventElement: I } = this.eventContext;
            for (let R of (this.domEventsNeeded.clear(),
            uu &&
              (this.domEventsNeeded.add("pointerdown"),
              _.addEventListener("pointerdown", this.onMouseMove)),
            this.domEventsNeeded.add("pointermove"),
            I.addEventListener("pointermove", this.onMouseMove),
            this.eventContext.useWindowEvents
              ? I.addEventListener("scroll", this.onScroll)
              : (_.addEventListener("pointerenter", this.onMouseEnter),
                _.addEventListener("pointerleave", this.onMouseLeave)),
            this.events)) {
              if (void 0 !== R.target) {
                let _ = this.onTargetChange(R),
                  I = R.target;
                this.pairOfEventListeners.push([I, _]),
                  I.addEventListener("requestRender", _);
              }
              let _ = this.createUserEventListener(R),
                I = R.object;
              this.pairOfUserEventListeners.push([I, _]),
                I.addEventListener("userEvent", _);
            }
          }
          disconnect() {
            if (!this.events.length) return;
            let { domElement: _, eventElement: I } = this.eventContext;
            for (let [R, B] of (this.domEventsNeeded.clear(),
            uu && _.removeEventListener("pointerdown", this.onMouseMove),
            I.removeEventListener("pointermove", this.onMouseMove),
            _.removeEventListener("pointerenter", this.onMouseEnter),
            _.removeEventListener("pointerleave", this.onMouseLeave),
            I.removeEventListener("scroll", this.onScroll),
            this.pairOfEventListeners))
              R.removeEventListener("requestRender", B);
            for (let [_, I] of this.pairOfUserEventListeners)
              _.removeEventListener("userEvent", I);
            for (let _ of this.events) (_.paused = !0), (_.isReset = !1);
          }
          onAnimationFrameDamping() {
            for (let _ of this.events) _.paused || this.updateSingleEvent(_);
          }
          updateSingleEvent(_) {
            let {
                tilt: I,
                axis: R,
                distance: B,
                plane: z,
                limitDistance: k,
                enabledRotation: V,
                limitDistanceEnabled: j,
              } = _.data,
              { getCamera: G, raycaster: q } = this.eventContext,
              { object: X, target: Q } = _;
            if ((X.getWorldPosition(ON), !_.isReset)) {
              if (_.target) _.target.getWorldPosition(Ok);
              else {
                if (
                  ("custom" === z
                    ? (G().getWorldDirection(OB),
                      OB.negate(),
                      OH.setFromNormalAndCoplanarPoint(OB, ON))
                    : ("xy" === z
                        ? OR.set(0, 0, 1)
                        : "xz" === z
                        ? OR.set(0, 1, 0)
                        : "yz" === z && OR.set(1, 0, 0),
                      OH.setFromNormalAndCoplanarPoint(OR, ON)),
                  !q.ray.intersectPlane(OH, Ok))
                )
                  return;
                B > 0 &&
                  ("custom" === z || void 0 === z) &&
                  Ok.addScaledVector(OB, B);
              }
            }
            if (
              (_.isReset ||
                (Q
                  ? "target" === I
                    ? OV.copy(Q.up)
                        .applyMatrix4(OL.extractRotation(Q.matrixWorld))
                        .normalize()
                    : V.some((_) => !1 === _)
                    ? ("x" === R
                        ? (Oj.set(0, 0, 1), !1 === V[2] && Oj.set(0, 1, 0))
                        : "y" === R
                        ? (Oj.set(1, 0, 0), !1 === V[0] && Oj.set(0, 0, 1))
                        : (Oj.set(0, 1, 0), !1 === V[1] && Oj.set(1, 0, 0)),
                      OV.copy(Oj)
                        .applyQuaternion(_.worldQuaternion0)
                        .normalize())
                    : OV.set(0, 1, 0)
                  : "custom" === z
                  ? OV.set(0, 1, 0)
                  : OV.copy(OR)),
              _.isReset)
            )
              OF.copy(_.worldQuaternion0);
            else if (ON.distanceTo(Ok) > k && j && Q) {
              if (
                (_.data.snapDelay &&
                  ((_.delayFinished = !1),
                  "u" > typeof window &&
                    null !== _.timeoutId &&
                    (window.clearTimeout(_.timeoutId), (_.timeoutId = null))),
                (_.wasOutside = !0),
                !_.data.resetAfterDistanceLimit)
              )
                return;
              OF.copy(_.worldQuaternion0),
                (_.currentDampingFactor = _.resetDampingFactor);
            } else {
              let B;
              if (
                (_.wasOutside &&
                  (_.data.snapDelay &&
                    "u" > typeof window &&
                    (_.timeoutId = window.setTimeout(() => {
                      (_.delayFinished = !0),
                        (_.paused = !1),
                        this.updateSingleEvent(_);
                    }, 1e3 * _.data.snapDelay)),
                  (_.currentDampingFactor = _.data.dampingFactor),
                  (_.wasOutside = !1)),
                !1 === _.delayFinished)
              )
                return;
              (B = OL.elements),
                OJ.subVectors(Ok, ON),
                0 === OJ.lengthSq() && (OJ.z = 1),
                OJ.normalize(),
                OK.crossVectors(OV, OJ),
                0 === OK.lengthSq() &&
                  (1 === Math.abs(OV.z) ? (OJ.x += 1e-4) : (OJ.z += 1e-4),
                  OJ.normalize(),
                  OK.crossVectors(OV, OJ)),
                OK.normalize(),
                OZ.crossVectors(OJ, OK),
                "x" === R
                  ? 1 === Oj.z
                    ? ([OK, OZ, OJ] = [OJ, OK, OZ])
                    : (OK.negate(), ([OK, OJ] = [OJ, OK]))
                  : "y" === R
                  ? 1 === Oj.x
                    ? ([OK, OZ, OJ] = [OZ, OJ, OK])
                    : (OK.negate(), ([OZ, OJ] = [OJ, OZ]))
                  : 1 === Oj.x && (OK.negate(), ([OK, OZ] = [OZ, OK])),
                (B[0] = OK.x),
                (B[4] = OZ.x),
                (B[8] = OJ.x),
                (B[1] = OK.y),
                (B[5] = OZ.y),
                (B[9] = OJ.y),
                (B[2] = OK.z),
                (B[6] = OZ.z),
                (B[10] = OJ.z),
                OF.setFromRotationMatrix(OL),
                Oz.setFromUnitVectors(Oj.applyQuaternion(OF), OV),
                V.some((_) => !1 === _) &&
                  "target" !== I &&
                  OF.premultiply(Oz).normalize();
            }
            _.currentDampingFactor > 1
              ? (X.updateWorldMatrix(!0, !1),
                Oz.setFromRotationMatrix(RE(X.matrixWorld)),
                Oz.slerp(OF, 1 / _.currentDampingFactor),
                OY(X, OL.makeRotationFromQuaternion(Oz)),
                (_.paused = 8 * (1 - Oz.dot(OF)) < 1e-6))
              : (OY(X, OL.makeRotationFromQuaternion(OF)), (_.paused = !0)),
              _.object?.dispatchEvent({
                type: "beginEvent",
                eventName: "LookAt",
              }),
              X.dispatchEvent(OW),
              X.dispatchEvent(Oq);
          }
        },
        OZ = new rF(),
        OK = new rF(),
        OJ = new rF(),
        O$ = class {
          constructor(_, I, R, B, z, k) {
            (this.id = _),
              (this.data = I),
              (this.object = R),
              (this.entered = !1),
              (this.actions = Mr(I, I.actions, B, z, k, R));
          }
          disconnect() {
            dr(this.actions);
          }
          dispatchEnter() {
            this.actions.Transition.forEach((_) => {
              _.object.currentTransitionEvent !== this &&
                ((_.object.currentTransitionEvent = this), _.init());
            }),
              this.entered ||
                ((this.entered = !0),
                this.actions.Transition.forEach((_) => _.playFromCurrent()),
                this.actions.Animation.forEach((_) => _.play()),
                this.actions.Create.forEach((_) => _.dispatch()),
                this.actions.Particles.forEach((_) => _.dispatchBasic()),
                this.actions.Destroy.forEach((_) => _.dispatch()),
                this.actions.SwitchCamera.forEach((_) => _.playFromCurrent()),
                this.actions.SceneTransition.forEach((_) => _.dispatch()),
                this.actions.SetVariable.forEach((_) => _.checkConditions()),
                this.actions.SetVariable.forEach((_) => _.dispatch()),
                this.actions.DynamicVariablePlay.forEach((_) => _.dispatch()));
          }
          dispatchLeave() {
            this.actions.Transition.forEach((_) => {
              _.object.currentTransitionEvent !== this &&
                ((_.object.currentTransitionEvent = this), _.init());
            }),
              this.entered &&
                ((this.entered = !1),
                this.actions.Transition.forEach((_) => _.reverseFromCurrent()),
                this.actions.Particles.forEach((_) => _.reverseFromCurrent()),
                this.actions.SwitchCamera.forEach((_) =>
                  _.reverseFromCurrent()
                ));
          }
          dispatchUserEvent(_) {
            this.actions.Transition.forEach((_) => {
              _.object.currentTransitionEvent !== this &&
                ((_.object.currentTransitionEvent = this), _.init());
            }),
              _
                ? (this.actions.Transition.forEach((_) =>
                    _.reverseFromCurrent()
                  ),
                  this.actions.Particles.forEach((_) => _.reverseFromCurrent()),
                  this.actions.Animation.forEach((_) => _.reverseFromCurrent()),
                  this.actions.SwitchCamera.forEach((_) =>
                    _.reverseFromCurrent()
                  ))
                : (this.actions.Transition.forEach((_) => _.playFromCurrent()),
                  this.actions.Animation.forEach((_) => _.playFromCurrent()),
                  this.actions.Create.forEach((_) => _.dispatch()),
                  this.actions.Particles.forEach((_) => _.dispatchBasic()),
                  this.actions.Destroy.forEach((_) => _.dispatch()),
                  this.actions.SwitchCamera.forEach((_) =>
                    _.playFromCurrent()
                  )),
              this.actions.SceneTransition.forEach((_) => _.dispatch()),
              this.actions.SetVariable.forEach((_) => _.checkConditions()),
              this.actions.SetVariable.forEach((_) => _.dispatch()),
              this.actions.DynamicVariablePlay.forEach((_) => _.dispatch());
          }
        },
        O0 = class extends DZ {
          constructor(_, I) {
            super(_),
              (this.eventsPerObjects = {}),
              (this.objects = []),
              (this.objects2D = []),
              (this._prevObjects = []),
              (this.onMouseDown = (_) => {
                um.length > 1 ||
                  (this.eventContext.updateRaycaster(_),
                  this.handleMouseHoverEvent());
              }),
              (this.onMouseUp = (_) => {
                um.length > 1 || this.handleMouseHoverEvent(!0);
              }),
              (this.onMouseMove = (_) => {
                um.length > 1 ||
                  (this.eventContext.updateRaycaster(_),
                  this.handleMouseHoverEvent());
              }),
              (this.onUserEvent = ({ eventName: _, target: I, reverse: R }) => {
                if (!_ || !I) return;
                let B = oa(_);
                B &&
                  "MouseHover" === B &&
                  (I.dispatchEvent({
                    type: "beginEvent",
                    eventName: "MouseHover",
                  }),
                  this.eventsPerObjects[I.uuid]?.forEach((_) =>
                    _.dispatchUserEvent(R)
                  ));
              });
            let { page: R, sharedAssets: B } = this.eventContext,
              o = (_, z) => {
                if (!(!_.visible || !_.data?.events.length)) {
                  for (let { id: z, data: k } of _.data.events)
                    if (!k.disabled && "MouseHover" === k.type)
                      try {
                        let V = new O$(z, k, _, R, B, I);
                        this.eventsPerObjects[_.uuid]
                          ? this.eventsPerObjects[_.uuid].push(V)
                          : (this.eventsPerObjects[_.uuid] = [V]);
                      } catch (_) {}
                  this.eventsPerObjects[_.uuid]?.length &&
                    this.objects.push(_ instanceof CD ? z : _);
                }
              };
            R.traverseEntity((_) => {
              (_ instanceof Ti || _ instanceof C6) &&
                _.frame?.traverse((I) => {
                  o(I, _);
                }),
                o(_);
            });
          }
          connect() {
            if (!this.objects.length) return;
            let { domElement: _ } = this.eventContext;
            this.domEventsNeeded.clear(),
              uu &&
                (this.domEventsNeeded.add("pointerdown"),
                _.addEventListener("pointerdown", this.onMouseDown),
                this.domEventsNeeded.add("pointerup"),
                _.addEventListener("pointerup", this.onMouseUp)),
              this.domEventsNeeded.add("pointermove"),
              _.addEventListener("pointermove", this.onMouseMove),
              this.objects.forEach((_) => {
                _.addEventListener("userEvent", this.onUserEvent);
              });
          }
          disconnect() {
            if (!this.objects.length) return;
            let { domElement: _ } = this.eventContext;
            this.domEventsNeeded.clear(),
              uu &&
                (_.removeEventListener("pointerdown", this.onMouseDown),
                _.removeEventListener("pointerup", this.onMouseUp)),
              _.removeEventListener("pointermove", this.onMouseMove),
              Object.values(this.eventsPerObjects).forEach((_) => {
                _.forEach((_) => {
                  _.disconnect();
                });
              }),
              this.objects.forEach((_) => {
                _.removeEventListener("userEvent", this.onUserEvent);
              });
          }
          handleMouseHoverEvent(_ = !1) {
            let I = [];
            if (!_) {
              let {
                  stopRaycast: _,
                  raycaster: R,
                  page: B,
                  pointerScreen: z,
                } = this.eventContext,
                k = !1;
              if (
                (B.uiCanvas &&
                  (k = vo(
                    B,
                    [z.x, z.y],
                    Object.keys(this.eventsPerObjects),
                    (_) => {
                      I.push(_);
                    }
                  )),
                _ && !k)
              ) {
                let _ = Qf(R, B, this.objects);
                (I = Eg(_)),
                  _.forEach((_) => {
                    _.object instanceof Ti &&
                      vo(
                        _.object,
                        [_?.uv?.x ?? 0, _?.uv?.y ?? 0],
                        Object.keys(this.eventsPerObjects),
                        (_) => {
                          I.push(_);
                        }
                      );
                  });
              } else
                this.objects.forEach((_) => {
                  let B = Kf(R, _);
                  B &&
                    (I.push(_),
                    _ instanceof Ti &&
                      vo(
                        _,
                        [B?.uv?.x ?? 0, B?.uv?.y ?? 0],
                        Object.keys(this.eventsPerObjects),
                        (_) => {
                          I.push(_);
                        }
                      ));
                });
            }
            this._prevObjects.length &&
              this._prevObjects.forEach((_) => {
                I.includes(_) ||
                  (_.dispatchEvent({
                    type: "beginEvent",
                    eventName: "MouseHover",
                  }),
                  this.eventsPerObjects[_.uuid]?.forEach((_) =>
                    _.dispatchLeave()
                  ));
              }),
              I.length &&
                I.forEach((_) => {
                  _.dispatchEvent({
                    type: "beginEvent",
                    eventName: "MouseHover",
                  }),
                    this.eventsPerObjects[_.uuid]?.forEach((_) =>
                      _.dispatchEnter()
                    );
                }),
              (this._prevObjects = I);
          }
        },
        O1 = class {
          constructor(_, I, R, B, z, k) {
            (this.id = _),
              (this.data = I),
              (this.object = R),
              (this.scrollCounter = 0),
              (this.actions = Mr(I, I.actions, B, z, k, R));
          }
          connect() {
            this.scrollCounter = 0;
          }
          disconnect() {
            dr(this.actions);
          }
          dispatch(_) {
            this.actions.Transition.forEach((_) => {
              _.object.currentTransitionEvent !== this &&
                ((_.object.currentTransitionEvent = this), _.init());
            });
            let I = _ > 0 ? 1 : -1;
            (this.scrollCounter += I),
              (this.scrollCounter = Math.min(
                Math.max(this.scrollCounter, 0),
                this.data.steps
              ));
            let R = this.scrollCounter / this.data.steps;
            this.actions.Transition.forEach((_) => _.seek(R)),
              this.actions.Animation.forEach((_) => _.seek(I)),
              this.actions.Create.forEach((_) => _.dispatchThrottled()),
              this.actions.SetVariable.forEach((_) => _.checkConditions()),
              this.actions.SetVariable.forEach((_) => _.dispatch()),
              this.actions.DynamicVariablePlay.forEach((_) => _.dispatch());
          }
          dispatchUserEvent(_) {
            this.actions.Transition.forEach((_) => {
              _.object.currentTransitionEvent !== this &&
                ((_.object.currentTransitionEvent = this), _.init());
            }),
              _
                ? (this.actions.Transition.forEach((_) =>
                    _.reverseFromCurrent()
                  ),
                  this.actions.Animation.forEach((_) => _.reverseFromCurrent()))
                : (this.actions.Transition.forEach((_) => {
                    _.playFromCurrent();
                  }),
                  this.actions.Animation.forEach((_) => {
                    _.playFromCurrent();
                  })),
              this.actions.Create.forEach((_) => _.dispatchThrottled()),
              this.actions.SetVariable.forEach((_) => _.checkConditions()),
              this.actions.SetVariable.forEach((_) => _.dispatch()),
              this.actions.DynamicVariablePlay.forEach((_) => _.dispatch());
          }
        },
        O2 = class {
          constructor(_, I, R, B, z, k, V) {
            (this.id = _),
              (this.data = I),
              (this.object = R),
              (this.domElement = k),
              (this.eventManager = V),
              (this.scrollStart = 0),
              (this.scrollEnd = 0),
              (this.actions = Mr(I, I.actions, B, z, V, R));
          }
          computeScrollBounds() {
            let _ = this.domElement.getBoundingClientRect(),
              I = document.body,
              R = document.documentElement,
              B = window.pageYOffset || R.scrollTop || I.scrollTop,
              z = R.clientTop || I.clientTop || 0,
              k = Math.round(_.top + B - z);
            if ("enter" === this.data.startFrom) {
              let I = window.innerHeight,
                R = _.height,
                B = this.data.enterAnchor;
              this.scrollStart =
                k - ("top" === B ? I : "bottom" === B ? I - R : I - 0.5 * R);
            } else this.scrollStart = 0;
            (this.scrollStart += this.data.startOffset ?? 0),
              (this.scrollEnd = this.scrollStart + (this.data.endAfter ?? 400)),
              (this.box = _),
              this.computeScroll({ x: window.scrollX, y: window.scrollY });
          }
          connect() {
            this.computeScrollBounds();
          }
          disconnect() {
            dr(this.actions);
          }
          handleResize() {
            this.computeScrollBounds();
          }
          get isInvalidBox() {
            return (
              void 0 === this.box ||
              (0 === this.box.width &&
                0 === this.box.height &&
                0 === this.box.top &&
                0 === this.box.bottom)
            );
          }
          computeScroll({ x: _, y: I }) {
            this.actions.Transition.forEach((_) => {
              _.object.currentTransitionEvent !== this &&
                ((_.object.currentTransitionEvent = this), _.init());
            });
            let R = this.scrollEnd - this.scrollStart,
              B = Math.min(1, Math.max(0, (I - this.scrollStart) / R));
            this.actions.Transition.forEach((_) => _.seek(B)),
              this.actions.Animation.forEach((_) => _.seek(B)),
              this.actions.Create.forEach((_) => _.dispatchThrottled()),
              this.actions.SetVariable.forEach((_) => _.checkConditions()),
              this.actions.SetVariable.forEach((_) => _.dispatch()),
              this.actions.DynamicVariablePlay.forEach((_) => _.dispatch());
          }
          dispatch(_) {
            this.isInvalidBox && this.computeScrollBounds(),
              this.computeScroll(_);
          }
          dispatchUserEvent(_) {
            this.actions.Transition.forEach((_) => {
              _.object.currentTransitionEvent !== this &&
                ((_.object.currentTransitionEvent = this), _.init());
            }),
              _
                ? (this.actions.Transition.forEach((_) =>
                    _.reverseFromCurrent()
                  ),
                  this.actions.Animation.forEach((_) => _.reverseFromCurrent()))
                : (this.actions.Transition.forEach((_) => {
                    _.playFromCurrent();
                  }),
                  this.actions.Animation.forEach((_) => {
                    _.playFromCurrent();
                  })),
              this.actions.Create.forEach((_) => _.dispatchThrottled()),
              this.actions.SetVariable.forEach((_) => _.checkConditions()),
              this.actions.SetVariable.forEach((_) => _.dispatch()),
              this.actions.DynamicVariablePlay.forEach((_) => _.dispatch());
          }
        },
        O3 = class extends DZ {
          constructor(_, I) {
            super(_),
              (this.wheelEventsPerObject = new Map()),
              (this.scrollEventsPerObject = new Map()),
              (this.isInview = !0),
              (this.handleResize = () => {
                [...this.scrollEventsPerObject.entries()].forEach(([_, I]) => {
                  I.forEach((_) => _.handleResize());
                });
              }),
              (this.onScroll = (_) => {
                if (!this.isInview) return;
                let I = { y: window.scrollY, x: window.scrollX };
                [...this.scrollEventsPerObject.entries()].forEach(([_, R]) => {
                  _.dispatchEvent({
                    type: "beginEvent",
                    eventName: "Scroll",
                    scroll: I,
                  }),
                    R.forEach((_) => _.dispatch(I));
                });
              }),
              (this.onWheel = (_) => {
                !this.isInview ||
                  _.ctrlKey ||
                  [...this.wheelEventsPerObject.entries()].forEach(([I, R]) => {
                    I.dispatchEvent({
                      type: "beginEvent",
                      eventName: "Scroll",
                      deltaY: _.deltaY,
                    }),
                      R.forEach((I) => I.dispatch(_.deltaY));
                  });
              }),
              (this.onUserEvent = ({ eventName: _, target: I, reverse: R }) => {
                if (!_ || !I) return;
                let B = oa(_);
                B &&
                  "Scroll" === B &&
                  (I.dispatchEvent({ type: "beginEvent", eventName: "Scroll" }),
                  this.wheelEventsPerObject.get(I)?.forEach((_) => {
                    _.dispatchUserEvent(R);
                  }));
              });
            let {
                page: R,
                sharedAssets: B,
                domElement: z,
                isExport: k,
              } = this.eventContext,
              l = (_) => {
                if (_.data?.events.length) {
                  for (let { id: V, data: j } of _.data.events)
                    if (!j.disabled && "Scroll" === j.type) {
                      if ("load" !== j.trigger && k) {
                        let k = new O2(V, j, _, R, B, z, I);
                        this.scrollEventsPerObject.has(_)
                          ? this.scrollEventsPerObject.get(_)?.push(k)
                          : this.scrollEventsPerObject.set(_, [k]);
                      } else {
                        let z = new O1(V, j, _, R, B, I);
                        this.wheelEventsPerObject.has(_)
                          ? this.wheelEventsPerObject.get(_)?.push(z)
                          : this.wheelEventsPerObject.set(_, [z]);
                      }
                    }
                }
              };
            R.traverseEntity((_) => {
              (_ instanceof Ti || _ instanceof C6) &&
                _.frame?.traverse((_) => {
                  l(_);
                }),
                l(_);
            }),
              (this.intersectionObserver = new IntersectionObserver(
                (_) => {
                  let I = _[0];
                  I && (this.isInview = I.isIntersecting);
                },
                { root: null }
              ));
          }
          connect() {
            this.intersectionObserver.observe(this.eventContext.domElement),
              [...this.wheelEventsPerObject.entries()].forEach(([_, I]) => {
                I.forEach((_) => _.connect()),
                  _.addEventListener("userEvent", this.onUserEvent);
              }),
              [...this.scrollEventsPerObject.entries()].forEach(([_, I]) => {
                I.forEach((_) => _.connect()),
                  _.addEventListener("userEvent", this.onUserEvent);
              }),
              [...this.wheelEventsPerObject.values()].some((_) => _.length) &&
                (this.domEventsNeeded.add("wheel"),
                window.addEventListener("wheel", this.onWheel)),
              [...this.scrollEventsPerObject.values()].some((_) => _.length) &&
                (this.domEventsNeeded.add("scroll"),
                window.addEventListener("scroll", this.onScroll),
                window.addEventListener("resize", this.handleResize));
          }
          disconnect() {
            window.removeEventListener("wheel", this.onWheel),
              window.removeEventListener("scroll", this.onScroll),
              window.removeEventListener("resize", this.handleResize),
              this.intersectionObserver.unobserve(this.eventContext.domElement),
              this.domEventsNeeded.clear(),
              [...this.wheelEventsPerObject.entries()].forEach(([_, I]) => {
                I.forEach((_) => _.disconnect()),
                  _.removeEventListener("userEvent", this.onUserEvent);
              }),
              [...this.scrollEventsPerObject.entries()].forEach(([_, I]) => {
                I.forEach((_) => _.disconnect()),
                  _.removeEventListener("userEvent", this.onUserEvent);
              });
          }
        },
        O4 = class {
          constructor(_, I, R, B, z, k) {
            (this.id = _),
              (this.data = I),
              (this.object = R),
              (this.actions = Mr(I, I.actions, B, z, k, R));
          }
          disconnect() {
            dr(this.actions);
          }
          dispatch() {
            this.actions.Transition.forEach((_) => {
              _.play();
            }),
              this.actions.Animation.forEach((_) => {
                _.play();
              }),
              this.actions.SwitchCamera.forEach((_) => {
                _.play();
              }),
              this.actions.SceneTransition.forEach((_) => {
                _.dispatch();
              }),
              this.actions.Reset.forEach((_) => _.dispatch()),
              this.actions.SetVariable.forEach((_) => _.checkConditions()),
              this.actions.SetVariable.forEach((_) => _.dispatch()),
              this.actions.DynamicVariablePlay.forEach((_) => _.dispatch()),
              this.actions.Create.forEach((_) => {
                _.dispatchFromStart();
              }),
              this.actions.Destroy.forEach((_) => {
                _.dispatchFromStart();
              });
          }
          dispatchAfter(_) {
            this.actions.Audio.forEach((I) => {
              (I.interaction.data.triggerAfter ?? "any") === _ &&
                (I.interaction instanceof Px
                  ? I.interaction.audioPlayer.play()
                  : I.interaction instanceof Pb && I.interaction.dispatch());
            }),
              this.actions.Video.forEach((I) => {
                let R = I.interaction.data.triggerAfter ?? "autoplay";
                R === _ &&
                  (I.interaction instanceof Do
                    ? I.interaction.play("autoplay" === R)
                    : I.interaction instanceof Dl && I.interaction.dispatch());
              }),
              this.actions.Particles.forEach((I) => {
                (I.data.triggerAfter ?? "any") === _ && I.dispatchBasic();
              });
          }
          dispatchUserEvent(_) {
            this.actions.Transition.forEach((_) => {
              _.object.currentTransitionEvent !== this &&
                ((_.object.currentTransitionEvent = this), _.init());
            }),
              _
                ? (this.actions.Transition.forEach((_) =>
                    _.reverseFromCurrent()
                  ),
                  this.actions.Animation.forEach((_) => _.reverseFromCurrent()),
                  this.actions.SwitchCamera.forEach((_) =>
                    _.reverseFromCurrent()
                  ))
                : (this.actions.Transition.forEach((_) => _.playFromCurrent()),
                  this.actions.Animation.forEach((_) => _.playFromCurrent()),
                  this.actions.SwitchCamera.forEach((_) =>
                    _.playFromCurrent()
                  )),
              this.actions.SceneTransition.forEach((_) => _.dispatch()),
              this.actions.Reset.forEach((_) => _.dispatch()),
              this.actions.SetVariable.forEach((_) => _.checkConditions()),
              this.actions.SetVariable.forEach((_) => _.dispatch()),
              this.actions.DynamicVariablePlay.forEach((_) => _.dispatch()),
              this.actions.Create.forEach((_) => {
                _.dispatch();
              }),
              this.actions.Destroy.forEach((_) => {
                _.dispatch();
              }),
              this.actions.Audio.forEach((_) => {
                _.interaction instanceof Px
                  ? _.interaction.audioPlayer.play()
                  : _.interaction instanceof Pb && _.interaction.dispatch();
              }),
              this.actions.Video.forEach((_) => {
                _.interaction instanceof Do
                  ? _.interaction.play()
                  : _.interaction instanceof Dl && _.interaction.dispatch();
              }),
              this.actions.Particles.forEach((_) => {
                _.dispatchBasic();
              });
          }
        },
        O5 = class extends DZ {
          constructor(_, I) {
            super(_),
              (this.eventManager = I),
              (this.eventsPerObject = new Map()),
              (this.eventsAfterPerObject = new Map()),
              (this.onMouseDown = () => {
                [...this.eventsAfterPerObject.entries()].forEach(([_, I]) => {
                  _.dispatchEvent({ type: "beginEvent", eventName: "Start" }),
                    I.forEach((_) => {
                      _.dispatchAfter("mouseDown");
                    });
                });
              }),
              (this.onKeyDown = () => {
                [...this.eventsAfterPerObject.entries()].forEach(([_, I]) => {
                  _.dispatchEvent({ type: "beginEvent", eventName: "Start" }),
                    I.forEach((_) => {
                      _.dispatchAfter("keyDown");
                    });
                });
              }),
              (this.onAny = () => {
                let { domElement: _, isExport: I } = this.eventContext;
                (I ? document : _).removeEventListener(
                  "pointerdown",
                  this.onAny
                ),
                  document.removeEventListener("keydown", this.onAny),
                  [...this.eventsAfterPerObject.entries()].forEach(([_, I]) => {
                    _.dispatchEvent({ type: "beginEvent", eventName: "Start" }),
                      I.forEach((_) => {
                        _.dispatchAfter("any");
                      });
                  });
              }),
              (this.onSceneTransitionAudioVideoPlay = () => {
                [...this.eventsAfterPerObject.entries()].forEach(([_, I]) => {
                  _.dispatchEvent({ type: "beginEvent", eventName: "Start" }),
                    I.forEach((_) => {
                      _.actions.Audio.forEach((_) => {
                        _.interaction instanceof Px &&
                          _.interaction.audioPlayer.play();
                      }),
                        _.actions.Video.forEach((_) => {
                          let I = _.interaction.data.triggerAfter ?? "autoplay";
                          _.interaction instanceof Do &&
                            _.interaction.play("autoplay" === I);
                        }),
                        _.actions.Particles.forEach((_) => {
                          _.dispatchBasic();
                        });
                    });
                });
              }),
              (this.onPlay = () => {
                [...this.eventsAfterPerObject.entries()].forEach(([_, I]) => {
                  _.dispatchEvent({ type: "beginEvent", eventName: "Start" }),
                    I.forEach((_) => {
                      _.dispatchAfter("autoplay");
                    });
                });
              }),
              (this.onUserEvent = ({ eventName: _, target: I, reverse: R }) => {
                if (!_ || !I) return;
                let B = oa(_);
                B &&
                  "Start" === B &&
                  (I instanceof CD ||
                    I.dispatchEvent({ type: "beginEvent", eventName: "Start" }),
                  this.eventsPerObject.get(I)?.forEach((_) => {
                    _.dispatchUserEvent(R);
                  }),
                  this.eventsAfterPerObject.get(I)?.forEach((_) => {
                    _.dispatchUserEvent(R);
                  }));
              });
          }
          connect() {
            let { sharedAssets: _, page: I } = this.eventContext,
              i = (R) => {
                if (R.data?.events.length)
                  for (let { id: B, data: z } of R.data.events) {
                    if (z.disabled || "Start" !== z.type) continue;
                    let k = new O4(B, z, R, I, _, this.eventManager);
                    (k.actions.Transition.length ||
                      k.actions.Animation.length ||
                      k.actions.SwitchCamera.length ||
                      k.actions.Create.length ||
                      k.actions.Destroy.length ||
                      k.actions.SceneTransition.length ||
                      k.actions.Reset.length ||
                      k.actions.SetVariable.length ||
                      k.actions.DynamicVariablePlay.length) &&
                      (this.eventsPerObject.has(R)
                        ? this.eventsPerObject.get(R)?.push(k)
                        : this.eventsPerObject.set(R, [k])),
                      k.actions.Audio.length &&
                        (this.eventsAfterPerObject.has(R)
                          ? this.eventsAfterPerObject.get(R)?.push(k)
                          : this.eventsAfterPerObject.set(R, [k])),
                      k.actions.Video.length &&
                        ((this.hasVideoAction = !0),
                        this.eventsAfterPerObject.has(R)
                          ? this.eventsAfterPerObject.get(R)?.push(k)
                          : this.eventsAfterPerObject.set(R, [k])),
                      k.actions.Particles.length &&
                        (this.eventsAfterPerObject.has(R)
                          ? this.eventsAfterPerObject.get(R)?.push(k)
                          : this.eventsAfterPerObject.set(R, [k]));
                  }
              };
            if (
              (I.traverseEntity((_) => {
                (_ instanceof Ti || _ instanceof C6) &&
                  _.frame?.traverse((_) => {
                    i(_);
                  }),
                  i(_);
              }),
              [...this.eventsAfterPerObject.values()].some((_) => _.length))
            ) {
              if (0 === this.eventManager.activateCount) {
                let { domElement: _, isExport: I } = this.eventContext,
                  R = I ? document : _;
                R.addEventListener("pointerdown", this.onMouseDown, {
                  once: !0,
                }),
                  R.addEventListener("mousedown", this.onMouseDown, {
                    once: !0,
                  }),
                  document.addEventListener("keydown", this.onKeyDown, {
                    once: !0,
                  }),
                  R.addEventListener("pointerdown", this.onAny),
                  R.addEventListener("mousedown", this.onAny),
                  document.addEventListener("keydown", this.onAny),
                  [...this.eventsAfterPerObject.entries()].forEach(([_, I]) => {
                    _.addEventListener("userEvent", this.onUserEvent);
                  });
              } else this.onSceneTransitionAudioVideoPlay();
              this.onPlay();
            }
            [...this.eventsPerObject.entries()].forEach(([_, I]) => {
              _.dispatchEvent({ type: "beginEvent", eventName: "Start" }),
                I.forEach((_) => _.dispatch()),
                _.addEventListener("userEvent", this.onUserEvent);
            });
          }
          disconnect() {
            if ([...this.eventsAfterPerObject.values()].some((_) => _.length)) {
              let { domElement: _, isExport: I } = this.eventContext,
                R = I ? document : _;
              R.removeEventListener("pointerdown", this.onMouseDown),
                R.removeEventListener("mousedown", this.onMouseDown),
                document.removeEventListener("keydown", this.onKeyDown),
                R.removeEventListener("pointerdown", this.onAny),
                R.removeEventListener("mousedown", this.onAny),
                document.removeEventListener("keydown", this.onAny),
                [...this.eventsAfterPerObject.entries()].forEach(([_, I]) => {
                  _.removeEventListener("userEvent", this.onUserEvent),
                    I.forEach((_) => _.disconnect());
                });
            }
            [...this.eventsPerObject.entries()].forEach(([_, I]) => {
              _.removeEventListener("userEvent", this.onUserEvent),
                I.forEach((_) => _.disconnect());
            }),
              this.eventsPerObject.clear(),
              this.eventsAfterPerObject.clear();
          }
        },
        O6 = class {
          constructor(_, I, R, B, z, k) {
            (this.id = _),
              (this.data = I),
              (this.object = R),
              (this.disabled = !1),
              (this.alreadyPlayedNonTogglingActions = new Set()),
              (this.actions = Mr(I, I.actions, B, z, k, R)),
              (this.target = I.target),
              (this.useToggle = "Toggle" === I.runMode);
          }
          disconnect() {
            dr(this.actions);
          }
          dispatch(_) {
            this.disabled ||
              (this.actions.Transition.forEach((_) => {
                _.object.currentTransitionEvent !== this
                  ? ((_.object.currentTransitionEvent = this), _.init())
                  : "Once" === this.data.runMode &&
                    this.alreadyPlayedNonTogglingActions.add(_);
              }),
              this.object.dispatchEvent({
                type: "beginEvent",
                eventName: "Collision",
              }),
              this.useToggle
                ? (this.actions.Transition.forEach((_) => {
                    _.toggle();
                  }),
                  this.actions.Animation.forEach((_) => {
                    _.toggle();
                  }))
                : (this.actions.Transition.forEach((_) => {
                    !1 === this.alreadyPlayedNonTogglingActions.has(_) &&
                      _.play();
                  }),
                  this.actions.Animation.forEach((_) => {
                    _.play();
                  })),
              this.actions.Reset.forEach((_) => {
                _.dispatch();
              }),
              this.actions.Link.forEach((_) => {
                _.dispatch();
              }),
              this.actions.Reset.forEach((_) => {
                _.dispatch();
              }),
              this.actions.Create.forEach((_) => {
                _.dispatch();
              }),
              this.actions.Destroy.forEach((I) => {
                I.dispatch(_ ?? !1);
              }),
              this.actions.SetVariable.forEach((_) => _.checkConditions()),
              this.actions.SetVariable.forEach((_) => _.dispatch()),
              this.actions.DynamicVariablePlay.forEach((_) => _.dispatch()),
              this.actions.Audio.forEach((_) => {
                _.dispatchBasic();
              }),
              this.actions.Particles.forEach((_) => {
                _.dispatchBasic();
              }),
              this.actions.Video.forEach((_) => {
                _.dispatchBasic();
              }));
          }
        },
        O8 = class extends DZ {
          constructor(_, I, R, B, z) {
            super(_),
              (this.sharedVariables = I),
              (this.eventManager = R),
              (this.needsMouse = B),
              (this.needsRaycast = z),
              (this.dynamicVars = []),
              (this.variablesToWatch = []),
              (this.prevMouseProperty = null),
              (this.prevRaycastProperty = null),
              (this.pauseTime = 0),
              (this.events = []),
              (this.onFrame = (_) => {
                this.rafId = window.requestAnimationFrame(this.onFrame);
                let I = new Date(),
                  R = [],
                  B = [];
                for (let _ = 0; _ < this.propertiesToWatch.length; _++) {
                  let {
                      objectId: I,
                      property: R,
                      prevValue: z,
                    } = this.propertiesToWatch[_],
                    k = this.eventContext.scene.find(I),
                    V = md.propertyPaths[R];
                  if ("width" === V[0] || "height" === V[0] || "depth" === V[0])
                    k = k.geometry.userData.parameters[V[0]];
                  else for (let _ = 0; _ < V.length; _++) k = k[V[_]];
                  null === z
                    ? (this.propertiesToWatch[_].prevValue =
                        k instanceof rF ? k.clone() : k)
                    : (k instanceof rF ? k.equals(z) : z === k) ||
                      (B.push({ objId: I, property: R }),
                      k instanceof rF
                        ? this.propertiesToWatch[_].prevValue.copy(k)
                        : (this.propertiesToWatch[_].prevValue = k));
                }
                for (let _ = 0; _ < this.variablesToWatch.length; _++) {
                  let { id: I, prevValue: B } = this.variablesToWatch[_],
                    z = this.shared.getVariable(I);
                  z !== B &&
                    (R.push(I), (this.variablesToWatch[_].prevValue = z));
                }
                for (let B = 0; B < this.dynamicVars.length; B++) {
                  let {
                      id: z,
                      expectedTime: k,
                      last: V,
                      data: j,
                      timerSeconds: G,
                      startValue: q,
                    } = this.dynamicVars[B],
                    X = 1e3;
                  if (
                    (("timer" === j.dynamicVariableType ||
                      "stopwatch" === j.dynamicVariableType) &&
                    "number3decimal" === j.format
                      ? (X = 1)
                      : "counter" === j.dynamicVariableType
                      ? (X = j.updateInterval)
                      : "random" === j.dynamicVariableType &&
                        (X = j.isStatic ? 1 / 0 : j.updateInterval),
                    -1 === k)
                  ) {
                    (this.dynamicVars[B].last = _),
                      (this.dynamicVars[B].expectedTime = _ + X);
                    continue;
                  }
                  if (
                    !(
                      ("Stopped" ===
                        this.shared.getDynamicVariablePlayState(z) ||
                        "Restarted" ===
                          this.shared.getDynamicVariablePlayState(z)) &&
                      ((this.dynamicVars[B].last = _),
                      (this.dynamicVars[B].expectedTime = _ + X),
                      "counter" === j.dynamicVariableType &&
                        this.shared.getVariable(z) !== q &&
                        (this.shared.updateVariable(z, q),
                        this.eventManager.requestRender()),
                      ("timer" === j.dynamicVariableType ||
                        "stopwatch" === j.dynamicVariableType) &&
                        this.dynamicVars[B].timerSeconds !== q &&
                        ((this.dynamicVars[B].timerSeconds = q),
                        this.shared.updateVariable(
                          z,
                          vN.getFormattedTimerTime(q, j)
                        ),
                        this.eventManager.requestRender()),
                      "Restarted" ===
                        this.shared.getDynamicVariablePlayState(z) &&
                        this.shared.setDynamicVariablePlayState(z, "Playing"),
                      "Stopped" === this.shared.getDynamicVariablePlayState(z))
                    )
                  ) {
                    if (
                      "Paused" === this.shared.getDynamicVariablePlayState(z)
                    ) {
                      void 0 === this.dynamicVars[B].deltaToExpectedTime &&
                        (this.dynamicVars[B].deltaToExpectedTime = Math.max(
                          this.dynamicVars[B].expectedTime - _,
                          0
                        )),
                        (this.dynamicVars[B].last =
                          _ - (X - this.dynamicVars[B].deltaToExpectedTime)),
                        (this.dynamicVars[B].expectedTime =
                          _ + this.dynamicVars[B].deltaToExpectedTime);
                      continue;
                    }
                    if (
                      ((this.dynamicVars[B].deltaToExpectedTime = void 0),
                      _ >= k)
                    ) {
                      if (
                        ((this.dynamicVars[B].last = _),
                        (this.dynamicVars[B].expectedTime += X),
                        "random" === j.dynamicVariableType)
                      ) {
                        let _ = j.min + Math.random() * (j.max - j.min),
                          I = j.decimals;
                        (_ = Math.round(_ * Math.pow(10, I)) / Math.pow(10, I)),
                          this.shared.updateVariable(z, _),
                          R.push(z),
                          this.eventManager.requestRender();
                      } else if ("counter" === j.dynamicVariableType) {
                        if (0 === j.increment) continue;
                        let _ = this.shared.getVariable(z),
                          I =
                            this.shared.getDynamicVariableToggleIsForward(z) ??
                            !0,
                          B =
                            this.shared.getVariable(z) +
                            j.increment * (I ? 1 : -1);
                        j.hasEnd &&
                          ((B =
                            j.increment > 0
                              ? rr.clamp(B, q, j.endValue)
                              : rr.clamp(B, j.endValue, q)) === q &&
                            this.shared.setDynamicVariableToggleIsForward(
                              z,
                              void 0
                            ),
                          j.repeat
                            ? B === j.endValue && (B = q)
                            : (B === q || B === j.endValue) &&
                              this.shared.setDynamicVariablePlayState(
                                z,
                                "Paused"
                              )),
                          B !== _ &&
                            (R.push(z),
                            this.shared.updateVariable(z, B),
                            this.eventManager.requestRender());
                      } else if ("time" === j.dynamicVariableType)
                        this.shared.updateVariable(z, d_(I, j)),
                          R.push(z),
                          this.eventManager.requestRender();
                      else {
                        let I = vR.isTextValue(j.endValue)
                            ? IN(j.endValue.textValue)
                            : j.endValue,
                          k =
                            this.shared.getDynamicVariableToggleIsForward(z) ??
                            !0,
                          X =
                            G +
                            ((_ - V) / 1e3) *
                              ("timer" === j.dynamicVariableType ? -1 : 1) *
                              (k ? 1 : -1);
                        (X = Math.max(X, 0)),
                          j.hasEnd &&
                            ((X =
                              "stopwatch" === j.dynamicVariableType
                                ? rr.clamp(X, q, I)
                                : rr.clamp(X, I, q)) === q &&
                              this.shared.setDynamicVariableToggleIsForward(
                                z,
                                void 0
                              ),
                            j.repeat
                              ? Math.abs(X - I) <
                                  ("number3decimal" === j.format
                                    ? 1e-4
                                    : 0.1) && (X = q)
                              : (Math.abs(X - q) <
                                  ("number3decimal" === j.format
                                    ? 1e-4
                                    : 0.1) ||
                                  Math.abs(X - I) <
                                    ("number3decimal" === j.format
                                      ? 1e-4
                                      : 0.1)) &&
                                this.shared.setDynamicVariablePlayState(
                                  z,
                                  "Paused"
                                )),
                          X !== G &&
                            (R.push(z),
                            (this.dynamicVars[B].timerSeconds = X),
                            this.shared.updateVariable(
                              z,
                              vN.getFormattedTimerTime(X, j)
                            ),
                            this.eventManager.requestRender());
                      }
                    }
                  }
                }
                this.needsMouse &&
                  this.shared.mouseProperty !== this.prevMouseProperty &&
                  ((this.prevMouseProperty = this.shared.mouseProperty),
                  this.events.forEach((_) => {
                    "mouseProperty" === _.data.variableId &&
                      (_.dispatch(), this.eventManager.requestRender());
                  }));
                let z = !1;
                this.shared.mouseProperty !== this.prevMouseProperty &&
                  ((this.prevMouseProperty = this.shared.mouseProperty),
                  (z = !0));
                let k = !1;
                this.shared.raycastProperty !== this.prevRaycastProperty &&
                  ((this.prevRaycastProperty = this.shared.raycastProperty),
                  (k = !0)),
                  this.events.forEach((_) => {
                    (R.includes(_.data.variableId) ||
                      B.find(
                        (I) =>
                          I.objId === _.data.objectId &&
                          I.property === _.data.property
                      ) ||
                      ("mouseProperty" === _.data.variableId && z) ||
                      ("raycastProperty" === _.data.variableId && k)) &&
                      (_.dispatch(), this.eventManager.requestRender());
                  });
              }),
              (this.onBlur = () => {
                this.pause();
              }),
              (this.onFocus = () => {
                this.resume();
              }),
              _.page.traverseEntity((I) => {
                I.data?.events
                  .filter(
                    (_) => "VariableChange" === _.data.type && !_.data.disabled
                  )
                  .forEach((B) => {
                    this.events.push(
                      new O9(I.uuid, B.data, I, _.page, _.sharedAssets, R)
                    );
                  });
              }),
              (this.propertiesToWatch = this.events
                .filter(
                  (_) =>
                    "objectProperty" === _.data.variableId &&
                    null !== _.data.objectId
                )
                .map((_) => ({
                  objectId: _.data.objectId,
                  property: _.data.property,
                  prevValue: null,
                }))),
              (this.shared = _.sharedAssets),
              this.sharedVariables.forEach(({ id: _, data: I }) => {
                let R;
                if (!("dynamicVariableType" in I)) {
                  this.events.find((I) => I.data.variableId === _) &&
                    this.variablesToWatch.push({
                      id: _,
                      prevValue: this.shared.getVariable(_),
                    });
                  return;
                }
                if (
                  "timer" === I.dynamicVariableType ||
                  "stopwatch" === I.dynamicVariableType
                ) {
                  let B;
                  if (
                    vR.isTextValue(I.value) &&
                    Array.isArray(I.value.textValue)
                  ) {
                    let _ = I.value.textValue;
                    B =
                      3 === _.length
                        ? _[2] + 60 * _[1] + 3600 * _[0]
                        : _[1] + 60 * _[0];
                  } else B = I.value;
                  (R = B),
                    this.dynamicVars.push({
                      id: _,
                      last: -1,
                      expectedTime: -1,
                      data: I,
                      timerSeconds: B,
                      startValue: R,
                    });
                } else
                  "time" === I.dynamicVariableType &&
                    this.shared.updateVariable(_, d_(new Date(), I)),
                    "counter" === I.dynamicVariableType &&
                      (R = vR.isTextValue(I.value)
                        ? IN(I.value.textValue)
                        : I.value),
                    this.dynamicVars.push({
                      id: _,
                      last: -1,
                      expectedTime: -1,
                      data: I,
                      startValue: R,
                    });
              });
          }
          pause() {
            this.pauseTime = Date.now();
          }
          resume() {
            let _ = Date.now() - this.pauseTime;
            for (let I = 0; I < this.dynamicVars.length; I++)
              (this.dynamicVars[I].last += _),
                (this.dynamicVars[I].expectedTime += _);
          }
          connect() {
            (this.rafId = window.requestAnimationFrame(this.onFrame)),
              window.addEventListener("blur", this.onBlur),
              window.addEventListener("focus", this.onFocus);
          }
          disconnect() {
            window.removeEventListener("blur", this.onBlur),
              window.removeEventListener("focus", this.onFocus),
              this.rafId &&
                (window.cancelAnimationFrame(this.rafId),
                (this.rafId = void 0)),
              this.events.forEach((_) => _.dispose());
          }
        },
        O9 = class {
          constructor(_, I, R, B, z, k) {
            (this.id = _),
              (this.data = I),
              (this.object = R),
              (this.actions = Mr(I, I.actions, B, z, k, R));
          }
          dispatch() {
            let _ = this.actions;
            _.Audio.forEach((_) => _.dispatchConditional()),
              _.Particles.forEach((_) => _.dispatchConditional()),
              _.Video.forEach((_) => _.dispatchConditional()),
              _.Create.forEach((_) => _.dispatch()),
              _.Destroy.forEach((_) => _.dispatch()),
              _.Reset.forEach((_) => _.dispatch()),
              _.Transition.forEach((_) => {
                _.object.currentTransitionEvent !== this &&
                  (_.object.currentTransitionEvent = this),
                  _.init();
              }),
              _.Transition.forEach((_) => _.play()),
              _.Animation.forEach((_) => _.play()),
              _.SwitchCamera.forEach((_) => _.play()),
              _.SceneTransition.forEach((_) => _.dispatch()),
              _.SetVariable.forEach((_) => _.checkConditions()),
              _.SetVariable.forEach((_) => _.dispatch()),
              _.DynamicVariablePlay.forEach((_) => _.dispatch());
          }
          dispose() {
            dr(this.actions);
          }
        };
      function IN(_) {
        return 3 === _.length
          ? _[2] + 60 * _[1] + 3600 * _[0]
          : _[1] + 60 * _[0];
      }
      var O7,
        Ii,
        Ir,
        Ia = `
(async function() {
	const [wasmImport, wasmBinary] = await Promise.all([
		import('https://unpkg.com/@splinetool/runtime@1.0.53/build/' + 'navmesh.js'),
		fetch('https://unpkg.com/@splinetool/navmesh-wasm@1.0.53/build/' + 'navmesh.wasm').then((res) => res.arrayBuffer()),
	]);
	const wasmModule = wasmImport.default;
	self.module = await wasmModule({ wasmBinary });
	postMessage('ready');
})();
`,
        In = `
(async function() {
	const [wasmImport, wasmBinary] = await Promise.all([
		import(self.location.origin + '/_libraries/navmesh.js'),
		fetch(self.location.origin + '/_libraries/navmesh.wasm').then((res) => res.arrayBuffer()),
	]);
	const wasmModule = wasmImport.default;
	self.module = await wasmModule({ wasmBinary });
	postMessage('ready');
})();
`,
        Io = `

onmessage = function(messageEvent) {
	const meshData = messageEvent.data;
	const positions = meshData[0];
	const offset = meshData[1];
	const indices = meshData[2];
	const indicesLength = meshData[3];
	const parameters = meshData[4];

	const module = self.module;
	const rc = new module.rcConfig();
	rc.cs = parameters.cs;
	rc.ch = parameters.ch;
	rc.borderSize = parameters.borderSize ? parameters.borderSize : 0;
	rc.tileSize = parameters.tileSize ? parameters.tileSize : 0;
	rc.walkableSlopeAngle = parameters.walkableSlopeAngle;
	rc.walkableHeight = parameters.walkableHeight;
	rc.walkableClimb = parameters.walkableClimb;
	rc.walkableRadius = parameters.walkableRadius;
	rc.maxEdgeLen = parameters.maxEdgeLen;
	rc.maxSimplificationError = parameters.maxSimplificationError;
	rc.minRegionArea = parameters.minRegionArea;
	rc.mergeRegionArea = parameters.mergeRegionArea;
	rc.maxVertsPerPoly = parameters.maxVertsPerPoly;
	rc.detailSampleDist = parameters.detailSampleDist;
	rc.detailSampleMaxError = parameters.detailSampleMaxError;

	if (!self.navMesh) {
		self.navMesh = new module.NavMesh();
	}
	self.navMesh.build(positions, offset, indices, indicesLength, rc);

	const navmeshData = navMesh.getNavmeshData();
	const arrView = new Uint8Array(module.HEAPU8.buffer, navmeshData.dataPointer, navmeshData.size);
	const ret = new Uint8Array(navmeshData.size);
	ret.set(arrView);
	navMesh.freeNavmeshData(navmeshData);

	postMessage(ret);
}
`,
        Il = {
          cs: 6,
          ch: 2,
          walkableSlopeAngle: 90,
          walkableHeight: 20,
          walkableClimb: 5,
          walkableRadius: 0,
          maxEdgeLen: 12,
          maxSimplificationError: 1.3,
          minRegionArea: 8,
          mergeRegionArea: 20,
          maxVertsPerPoly: 6,
          detailSampleDist: 6,
          detailSampleMaxError: 1,
        };
      uI.then((_) => {
        (O7 = _), (Ii = new _.Vec3()), (Ir = new _.Vec3());
      });
      var Ih = new rF(),
        Iu = class {
          constructor(_ = !1, I = !1) {
            (this.usePhysics = _),
              (this.isExport = I),
              (this.onPointerDown = (_) => {
                if (1 !== um.length) return;
                let { raycaster: I, page: R } = this.eventContext;
                this.eventContext.updateRaycaster(_);
                let B = R.raycastWithClones(I);
                if (0 !== B.length) {
                  if (this.gameControl) {
                    let _ = Ih.copy(this.gameControl.colliderWorldPosition);
                    (_.y -= this.gameControl.colliderHeight / 2),
                      (this.gameControl.path = this.computePath(_, B[0].point));
                  }
                  this.eventContext.requestRender();
                }
              }),
              (this.traverseWithPhysics = (_, I) => (R) => {
                let B;
                if (R instanceof AI) {
                  if (!R.objectForSample)
                    return (
                      (!0 === R.object.dataPatched.physics.fusedBody &&
                        "dynamic" === R.object.dataPatched.physics.rigidBody) ||
                      void 0
                    );
                  if (R.objectForSample.dataPatched.physics.fusedBody) return;
                  B = R.object;
                } else if (R instanceof yj) B = R.object;
                else if (
                  ((B = R),
                  B.dataPatched.cloner?.disabled === !1 &&
                    B.dataPatched.cloner?.hideBase &&
                    B.dataPatched.physics?.fusedBody !== !0)
                )
                  return !0;
                if (I && !B.userData.navmesh) return;
                let z = B.dataPatched;
                if (!z.visible && z.physics?.enabled !== !0) return !0;
                R.updateMatrixWorldSVD();
                let k = Og(z),
                  V = B.userData.hasDestroy,
                  j = B.userData.hasDrag,
                  G = !1,
                  q = !1;
                for (let _ of z.events)
                  !0 !== _.data.disabled &&
                    ("GameControl" === _.data.type
                      ? (G = !0)
                      : "Follow" === _.data.type && (q = !0));
                if (G || k || q || V || j) return !0;
                if (this.usePhysics && z.physics?.rigidBody === "dynamic") {
                  if (this.usePhysics && z.physics?.fusedBody) return !0;
                } else if (
                  ("geometry" in R &&
                    R.geometry &&
                    _.push(yo(R.geometry, R.matrixWorld)),
                  this.usePhysics && z.physics?.fusedBody)
                )
                  return (
                    R.traverseObject((I, R) => {
                      let B;
                      if (0 === R) return;
                      if (I instanceof AI) {
                        if (!I.objectForSample)
                          return (
                            (!0 === I.object.dataPatched.physics.fusedBody &&
                              "dynamic" ===
                                I.object.dataPatched.physics.rigidBody) ||
                            void 0
                          );
                        if (I.objectForSample.dataPatched.physics.fusedBody)
                          return;
                        B = I.object;
                      } else if (I instanceof yj) B = I.object;
                      else if (((B = I), I.dataPatched.cloner?.hideBase))
                        return !0;
                      let z = B.dataPatched;
                      if (!z.visible && z.physics?.enabled !== !0) return !0;
                      "geometry" in I &&
                        I.geometry &&
                        _.push(yo(I.geometry, I.matrixWorld));
                    }),
                    !0
                  );
              }),
              (this.traverseNoPhysics = (_, I) => (R) => {
                let B;
                if (R instanceof AI) return;
                let z = (B = R instanceof yj ? R.object : R).dataPatched;
                if (
                  "visibility" === z.physics.enabled
                    ? !z.visible
                    : !z.physics.enabled
                )
                  return !0;
                if (I && !B.userData.navmesh) return;
                let k = R.geometry,
                  V = !0 === B.userData.hasDestroy,
                  j = !0 === B.userData.hasDrag;
                if (
                  Og(z) ||
                  V ||
                  j ||
                  B.dataPatched.events.some(
                    (_) =>
                      !0 !== _.data.disabled && "GameControl" === _.data.type
                  )
                )
                  return !0;
                k && _.push(yo(k, R.matrixWorld));
              }),
              (this.navmeshWasm = O7),
              (this.navMesh = new this.navmeshWasm.NavMesh()),
              (this._workerURL = URL.createObjectURL(
                new Blob([(I ? Ia : In) + Io])
              )),
              (this._worker = new Worker(this._workerURL));
          }
          init(_, I, R) {
            (this.gameControl = I),
              (this.eventContext = R),
              (this.resolution = _.ch),
              this.setDefaultQueryExtent(
                new rF().setScalar(_.ch * _.walkableRadius * 1.2)
              ),
              (this._worker.onmessage = () => {
                this.createNavMesh(R.page, _, (_) => {
                  this.buildFromNavmeshData(_.data);
                });
              }),
              this.eventContext.renderer.domElement.addEventListener(
                "pointerdown",
                this.onPointerDown
              );
          }
          createNavMesh(_, I, R) {
            I.objects.forEach((I) => {
              let R = _.scene.find(I);
              R.traverseEntity((_) => {
                _.userData.navmesh = !0;
              }),
                R.cloner?.traverseObject((_) => {
                  _.userData.navmesh = !0;
                });
            });
            let B = [],
              z = (
                this.usePhysics
                  ? this.traverseWithPhysics
                  : this.traverseNoPhysics
              )(B, "custom" === I.zones);
            if (
              (_.traverseChildren(z),
              I.objects.forEach((I) => {
                let R = _.scene.find(I);
                R.traverseEntity((_) => {
                  _.userData.navmesh = void 0;
                }),
                  R.cloner?.traverseObject((_) => {
                    _.userData.navmesh = void 0;
                  });
              }),
              0 === B.length)
            )
              return !1;
            let k = $s(B),
              { positions: V, triIndices: j } = Xc(
                k.getAttribute("position"),
                k.getIndex()
              );
            return (
              this._worker.postMessage([
                V,
                V.length / 3,
                j,
                j.length,
                { ...Il, ...I },
              ]),
              (this._worker.onmessage = R),
              !0
            );
          }
          createDebugNavGeometry() {
            let _,
              I,
              R = this.navMesh.getDebugNavMesh(),
              B = R.getTriangleCount(),
              z = new Uint32Array(3 * B),
              k = new Float32Array(9 * B);
            for (_ = 0; _ < 3 * B; _++) z[_] = _;
            for (_ = 0; _ < B; _++)
              for (I = 0; I < 3; I++) {
                let B = R.getTriangle(_).getPoint(I);
                (k[9 * _ + 3 * I + 0] = B.x),
                  (k[9 * _ + 3 * I + 1] = B.y),
                  (k[9 * _ + 3 * I + 2] = B.z);
              }
            let V = new ai();
            return (
              V.setIndex(new s0(z, 1)),
              V.setAttribute("position", new s0(k, 3)),
              V
            );
          }
          getClosestPoint(_) {
            return (
              (Ii.x = _.x),
              (Ii.y = _.y),
              (Ii.z = _.z),
              this.navMesh.getClosestPoint(Ii)
            );
          }
          getClosestPointToRef(_, I) {
            (Ii.x = _.x), (Ii.y = _.y), (Ii.z = _.z);
            let R = this.navMesh.getClosestPoint(Ii);
            I.set(R.x, R.y, R.z);
          }
          getRandomPointAround(_, I) {
            return (
              (Ii.x = _.x),
              (Ii.y = _.y),
              (Ii.z = _.z),
              this.navMesh.getRandomPointAround(Ii, I)
            );
          }
          getRandomPointAroundToRef(_, I, R) {
            (Ii.x = _.x), (Ii.y = _.y), (Ii.z = _.z);
            let B = this.navMesh.getRandomPointAround(Ii, I);
            R.set(B.x, B.y, B.z);
          }
          moveAlong(_, I) {
            return (
              (Ii.x = _.x),
              (Ii.y = _.y),
              (Ii.z = _.z),
              (Ir.x = I.x),
              (Ir.y = I.y),
              (Ir.z = I.z),
              this.navMesh.moveAlong(Ii, Ir)
            );
          }
          moveAlongToRef(_, I, R) {
            return (
              (Ii.x = _.x),
              (Ii.y = _.y),
              (Ii.z = _.z),
              (Ir.x = I.x),
              (Ir.y = I.y),
              (Ir.z = I.z),
              this.navMesh.moveAlong(Ii, Ir)
            );
          }
          computePath(_, I) {
            let R = this.getClosestPoint(I);
            (Ir.x = R.x), (Ir.y = R.y), (Ir.z = R.z), this.getClosestPoint(_);
            let B = this.navMesh.computePath(Ii, Ir),
              z = B.getPointCount(),
              k = [];
            for (let _ = 0; _ < z; _++) {
              let I = B.getPoint(_);
              k.push(new rF(I.x, I.y, I.z));
            }
            return k;
          }
          createCrowd(_, I) {
            return new If(this, _, I);
          }
          setDefaultQueryExtent(_) {
            (Ii.x = _.x),
              (Ii.y = _.y),
              (Ii.z = _.z),
              this.navMesh.setDefaultQueryExtent(Ii);
          }
          getDefaultQueryExtent() {
            return this.navMesh.getDefaultQueryExtent();
          }
          buildFromNavmeshData(_) {
            let I = _.length * _.BYTES_PER_ELEMENT,
              R = this.navmeshWasm._malloc(I),
              B = new Uint8Array(this.navmeshWasm.HEAPU8.buffer, R, I);
            B.set(_);
            let z = new this.navmeshWasm.NavmeshData();
            (z.dataPointer = B.byteOffset),
              (z.size = _.length),
              this.navMesh.buildFromNavmeshData(z),
              this.navmeshWasm._free(B.byteOffset);
          }
          getNavmeshData() {
            let _ = this.navMesh.getNavmeshData(),
              I = new Uint8Array(
                this.navmeshWasm.HEAPU8.buffer,
                _.dataPointer,
                _.size
              ),
              R = new Uint8Array(_.size);
            return R.set(I), this.navMesh.freeNavmeshData(_), R;
          }
          getDefaultQueryExtentToRef(_) {
            let I = this.navMesh.getDefaultQueryExtent();
            _.set(I.x, I.y, I.z);
          }
          dispose() {
            this.navMesh.destroy(),
              this._worker.terminate(),
              URL.revokeObjectURL(this._workerURL),
              this.eventContext?.renderer.domElement.removeEventListener(
                "pointerdown",
                this.onPointerDown
              );
          }
          addCylinderObstacle(_, I, R) {
            return (
              (Ii.x = _.x),
              (Ii.y = _.y),
              (Ii.z = _.z),
              this.navMesh.addCylinderObstacle(Ii, I, R)
            );
          }
          addBoxObstacle(_, I, R) {
            return (
              (Ii.x = _.x),
              (Ii.y = _.y),
              (Ii.z = _.z),
              (Ir.x = I.x),
              (Ir.y = I.y),
              (Ir.z = I.z),
              this.navMesh.addBoxObstacle(Ii, Ir, R)
            );
          }
          removeObstacle(_) {
            this.navMesh.removeObstacle(_);
          }
          isSupported() {
            return void 0 !== this.navmeshWasm;
          }
        },
        If = class {
          constructor(_, I, R) {
            (this.navmeshWasmWrapper = _),
              (this.transforms = []),
              (this.agents = []),
              (this.reachRadii = []),
              (this._agentDestinationArmed = []),
              (this._agentDestination = []),
              (this.crowd = new this.navmeshWasmWrapper.navmeshWasm.Crowd(
                I,
                R,
                this.navmeshWasmWrapper.navMesh.getNavMesh()
              ));
          }
          onReachTarget(_, I) {}
          addAgent(_, I, R) {
            let B =
              new this.navmeshWasmWrapper.navmeshWasm.dtCrowdAgentParams();
            (B.radius = I.radius),
              (B.height = I.height),
              (B.maxAcceleration = I.maxAcceleration),
              (B.maxSpeed = I.maxSpeed),
              (B.collisionQueryRange = I.collisionQueryRange),
              (B.pathOptimizationRange = I.pathOptimizationRange),
              (B.separationWeight = I.separationWeight),
              (B.updateFlags = 7),
              (B.obstacleAvoidanceType = 0),
              (B.queryFilterType = 0),
              (B.userData = 0);
            let z = this.crowd.addAgent(
              new this.navmeshWasmWrapper.navmeshWasm.Vec3(_.x, _.y, _.z),
              B
            );
            return (
              this.transforms.push(R),
              this.agents.push(z),
              this.reachRadii.push(I.reachRadius ? I.reachRadius : I.radius),
              this._agentDestinationArmed.push(!1),
              this._agentDestination.push(new rF(0, 0, 0)),
              z
            );
          }
          getAgentPosition(_) {
            return this.crowd.getAgentPosition(_);
          }
          getAgentPositionToRef(_, I) {
            let R = this.crowd.getAgentPosition(_);
            I.set(R.x, R.y, R.z);
          }
          getAgentVelocity(_) {
            return this.crowd.getAgentVelocity(_);
          }
          getAgentVelocityToRef(_, I) {
            let R = this.crowd.getAgentVelocity(_);
            I.set(R.x, R.y, R.z);
          }
          getAgentNextTargetPath(_) {
            return this.crowd.getAgentNextTargetPath(_);
          }
          getAgentNextTargetPathToRef(_, I) {
            let R = this.crowd.getAgentNextTargetPath(_);
            I.set(R.x, R.y, R.z);
          }
          getAgentState(_) {
            return this.crowd.getAgentState(_);
          }
          overOffmeshConnection(_) {
            return this.crowd.overOffmeshConnection(_);
          }
          agentGoto(_, I) {
            this.crowd.agentGoto(
              _,
              new this.navmeshWasmWrapper.navmeshWasm.Vec3(I.x, I.y, I.z)
            );
            let R = this.agents.indexOf(_);
            R > -1 &&
              ((this._agentDestinationArmed[R] = !0),
              this._agentDestination[R].set(I.x, I.y, I.z));
          }
          agentTeleport(_, I) {
            this.crowd.agentTeleport(
              _,
              new this.navmeshWasmWrapper.navmeshWasm.Vec3(I.x, I.y, I.z)
            );
          }
          updateAgentParameters(_, I) {
            let R = this.crowd.getAgentParameters(_);
            void 0 !== I.radius && (R.radius = I.radius),
              void 0 !== I.height && (R.height = I.height),
              void 0 !== I.maxAcceleration &&
                (R.maxAcceleration = I.maxAcceleration),
              void 0 !== I.maxSpeed && (R.maxSpeed = I.maxSpeed),
              void 0 !== I.collisionQueryRange &&
                (R.collisionQueryRange = I.collisionQueryRange),
              void 0 !== I.pathOptimizationRange &&
                (R.pathOptimizationRange = I.pathOptimizationRange),
              void 0 !== I.separationWeight &&
                (R.separationWeight = I.separationWeight),
              this.crowd.setAgentParameters(_, R);
          }
          removeAgent(_) {
            this.crowd.removeAgent(_);
            let I = this.agents.indexOf(_);
            I > -1 &&
              (this.agents.splice(I, 1),
              this.transforms.splice(I, 1),
              this.reachRadii.splice(I, 1),
              this._agentDestinationArmed.splice(I, 1),
              this._agentDestination.splice(I, 1));
          }
          getAgents() {
            return this.agents;
          }
          update(_) {
            if ((this.navmeshWasmWrapper.navMesh.update(), !(_ <= 0.001))) {
              if (1 / 60 <= 0.001) this.crowd.update(_);
              else {
                let I = Math.floor(_ / (1 / 60));
                I > 10 && (I = 10), I < 1 && (I = 1);
                let R = _ / I;
                for (let _ = 0; _ < I; _++) this.crowd.update(R);
              }
              for (let _ = 0; _ < this.agents.length; _++) {
                let I = this.agents[_],
                  R = this.getAgentPosition(I);
                if (
                  (this.transforms[_].copy(R), this._agentDestinationArmed[_])
                ) {
                  let B = R.x - this._agentDestination[_].x,
                    z = R.z - this._agentDestination[_].z,
                    k = this.reachRadii[_],
                    V = this._agentDestination[_].y - this.reachRadii[_],
                    j = this._agentDestination[_].y + this.reachRadii[_],
                    G = B * B + z * z;
                  R.y > V &&
                    R.y < j &&
                    G < k * k &&
                    (this.onReachTarget(I, this._agentDestination[_]),
                    (this._agentDestinationArmed[_] = !1));
                }
              }
            }
          }
          setDefaultQueryExtent(_) {
            let I = new this.navmeshWasmWrapper.navmeshWasm.Vec3(_.x, _.y, _.z);
            this.crowd.setDefaultQueryExtent(I);
          }
          getDefaultQueryExtent() {
            return this.crowd.getDefaultQueryExtent();
          }
          getDefaultQueryExtentToRef(_) {
            let I = this.crowd.getDefaultQueryExtent();
            _.set(I.x, I.y, I.z);
          }
          getCorners(_) {
            let I,
              R = this.crowd.getCorners(_),
              B = R.getPointCount(),
              z = [];
            for (I = 0; I < B; I++) {
              let _ = R.getPoint(I);
              z.push(new rF(_.x, _.y, _.z));
            }
            return z;
          }
          dispose() {
            this.crowd.destroy();
          }
        },
        Im = { type: "change" },
        Ig = { type: "changeZoom" },
        Iv = { type: "changePan" },
        Iy = { type: "start" },
        Ix = { type: "end", changed: !0 },
        Ib = { type: "end", changed: !1 },
        Iw = new rz(),
        IS = new rs(),
        IM = 2 * Math.PI,
        IE = new rF(),
        IC = new rs(),
        IT = new rF(),
        IP = new rz(),
        ID = new sa(),
        IO = { type: "requestRender" },
        II = class extends i8 {
          constructor(_, I, R = { isPlayMode: !1, isExport: !1 }) {
            super(),
              (this.object = _),
              (this.domElement = I),
              (this.options = R),
              (this.enabled = !0),
              (this.useKeyEvents = !0),
              (this.enableDamping = !1),
              (this.enableZoom = !0),
              (this.enableRotate = !0),
              (this.enablePan = !0),
              (this.autoRotate = !1),
              (this.rotationLimitsMode = 0),
              (this.panLimitsMode = 0),
              (this.rotationSoftLimit = 2),
              (this.panSoftLimit = 2),
              (this.hoverRotatePanMode = 0),
              (this.zoomLimitsEnabled = !1),
              (this.mouseButtons = [0, 5]),
              (this.mouseButtonsPlay = [3, 4, 5]),
              (this.touches = [null, i3.DOLLY_ROTATE, i3.PAN]),
              (this.offset = new rF()),
              (this.eye = new rF()),
              (this.lastPosition = new rF()),
              (this.lastQuaternion = new rz()),
              (this.current = new rs()),
              (this.overShoot = new rs()),
              (this.overRatio = new rs()),
              (this.spherical = new lj()),
              (this.sphericalDelta = new lj()),
              (this.panOffset = new rF()),
              (this.panLeftV = new rF()),
              (this.panUpV = new rF()),
              (this.panV = new rF()),
              (this.rotateStart = new rs()),
              (this.rotateEnd = new rs()),
              (this.rotateDelta = new rs()),
              (this.panStart = new rs()),
              (this.panEnd = new rs()),
              (this.panDelta = new rs()),
              (this.dollyStart = new rs()),
              (this.dollyEnd = new rs()),
              (this.dollyDelta = new rs()),
              (this.rotationRangeFactor = new rs()),
              (this.panRangeFactor = new rs()),
              (this.state = -1),
              (this.zoomChanged = !1),
              (this.isPointerDown = !1),
              (this.isThetaFlipped = !1),
              (this.prevScale = 0),
              (this.scale = 1),
              (this.gesture = !1),
              (this.timer = -1),
              (this.timerHover = -1),
              (this.minDistance = 0),
              (this.maxDistance = 1 / 0),
              (this.minZoom = 0),
              (this.maxZoom = 1 / 0),
              (this.minPhi = 0),
              (this.maxPhi = Math.PI),
              (this.minTheta = -1 / 0),
              (this.maxTheta = 1 / 0),
              (this.minH = 0),
              (this.maxH = Math.PI),
              (this.minV = -1 / 0),
              (this.maxV = 1 / 0),
              (this.autoRotateClockwise = !0),
              (this.isPanOverShoot = !1),
              (this.isRotateOverShoot = !1),
              (this.resetHoverEffectOnPointerLeave = !1),
              (this.hasChange = !1),
              (this.useWindowEvents = !1),
              (this.isTouchZoom = !0),
              (this.autoRotateSpeed = 2),
              (this.dampingFactor = 0.125),
              (this.zoomSpeed = 2),
              (this.rotateSpeed = 1),
              (this.panSpeed = 1),
              (this.hoverRotatePanStrength = 0.1),
              (this.hoverRotateDamping = this.dampingFactor),
              (this.thetaIsFree = !1),
              (this.phiIsFree = !1),
              (this.needsUpdate = !0),
              (this.onCameraChange = (_) => {
                this.object.removeEventListener(
                  "beginState",
                  this.onBeginState
                ),
                  this.object.removeEventListener(
                    "completeState",
                    this.onCompleteState
                  ),
                  this.object.removeEventListener(
                    "cameraChange",
                    this.onCameraChange
                  ),
                  (this.object = _.camera),
                  this.object.addEventListener("beginState", this.onBeginState),
                  this.object.addEventListener(
                    "completeState",
                    this.onCompleteState
                  ),
                  this.object.addEventListener(
                    "cameraChange",
                    this.onCameraChange
                  );
              }),
              (this.update = () => {
                this.object.updateWorldMatrix(!0, !1),
                  this.object.matrixWorld.decompose(IT, IP, IE),
                  this.offset.copy(IT).sub(this.target),
                  this.spherical.setFromVector3(this.offset),
                  this.object.isUpVectorFlipped &&
                    ((this.spherical.phi *= -1),
                    (this.spherical.theta -= Math.PI)),
                  this.autoRotate &&
                    -1 === this.state &&
                    this.rotateLeft(
                      (!0 === this.autoRotateClockwise ? 1 : -1) *
                        this.getAutoRotationAngle()
                    ),
                  0 !== this.rotationLimitsMode &&
                    this.applyLimits(
                      this.sphericalDelta,
                      this.rotationLimitsMode,
                      this.rotationSoftLimit,
                      this.maxTheta,
                      this.minTheta,
                      this.maxPhi,
                      this.minPhi,
                      this.rotationRangeFactor
                    ),
                  2 !== this.rotationLimitsMode &&
                    (this.spherical.phi += this.sphericalDelta.phi),
                  (1 !== this.rotationLimitsMode || !0 === this.autoRotate) &&
                    (this.spherical.theta += this.sphericalDelta.theta),
                  (this.spherical.radius *= this.scale),
                  this.zoomLimitsEnabled &&
                    (this.spherical.radius = Math.max(
                      this.minDistance,
                      Math.min(this.maxDistance, this.spherical.radius)
                    )),
                  0 !== this.panLimitsMode &&
                    (this.target.applyQuaternion(Iw.copy(IP).invert()),
                    this.panOffset.applyQuaternion(Iw),
                    this.applyLimits(
                      this.panOffset,
                      this.panLimitsMode,
                      this.panSoftLimit,
                      this.maxH,
                      this.minH,
                      this.maxV,
                      this.minV,
                      this.panRangeFactor
                    ),
                    this.target.applyQuaternion(IP),
                    this.panOffset.applyQuaternion(IP)),
                  2 === this.panLimitsMode && (this.panOffset.y = 0),
                  1 === this.panLimitsMode && (this.panOffset.x = 0),
                  -1 !== this.state || this.gesture
                    ? (this.target.add(this.panOffset),
                      this.panOffset.set(0, 0, 0))
                    : (this.panOffset.multiplyScalar(1 - this.dampingFactor),
                      this.target.add(this.panOffset)),
                  this.offset.setFromSpherical(this.spherical),
                  IT.copy(this.target).add(this.offset),
                  this.object.position.copy(this.target).add(this.offset),
                  this.object.parent &&
                    (ID.copy(this.object.parent.matrixWorld).invert(),
                    this.object.position.applyMatrix4(ID));
                let _ = this.spherical.phi % IM;
                if (
                  (this.eye.copy(this.offset).normalize(),
                  this.object.up
                    .copy(sL.DEFAULT_UP)
                    .applyAxisAngle(this.eye, this.object.angleOffsetFromUp),
                  (_ > 0 && _ > Math.PI) || (_ < 0 && _ > -Math.PI)
                    ? (this.object.up.negate(),
                      this.object.lookAt(this.target),
                      (this.object.isUpVectorFlipped = !0))
                    : (this.object.lookAt(this.target),
                      (this.object.isUpVectorFlipped = !1)),
                  -1 === this.state || !0 === this.enableDamping)
                ) {
                  let _ =
                    1 === this.hoverRotatePanMode
                      ? this.hoverRotateDamping
                      : this.dampingFactor;
                  (this.sphericalDelta.theta *= 1 - _),
                    (this.sphericalDelta.phi *= 1 - _);
                } else this.sphericalDelta.set(0, 0, 0);
                return (
                  (this.scale = 1),
                  this.zoomChanged ||
                  this.lastPosition.distanceToSquared(this.object.position) >
                    0.01 ||
                  8 * (1 - this.lastQuaternion.dot(this.object.quaternion)) >
                    1e-8
                    ? (this.dispatchEvent(Im),
                      this.object.dispatchEvent(IO),
                      this.lastPosition.copy(this.object.position),
                      this.lastQuaternion.copy(this.object.quaternion),
                      (this.zoomChanged = !1),
                      !0)
                    : ((this.isPanOverShoot = !1),
                      (this.isRotateOverShoot = !1),
                      (this.object.wasMovedBySwitchCameraAction = !1),
                      this.sphericalDelta.set(0, 0, 0),
                      this.panOffset.set(0, 0, 0),
                      !1)
                );
              }),
              (this.onPointerDown = (_) => {
                !1 !== this.enabled &&
                  ("touch" === _.pointerType || ("pen" === _.pointerType && uu)
                    ? this.onPointerDownTouch(_)
                    : this.onPointerDownMouse(_),
                  -1 !== this.state &&
                    ((this.isPointerDown = !0),
                    this.dispatchEvent(Iy),
                    this.domElement.addEventListener(
                      "pointermove",
                      this.onPointerMove
                    ),
                    this.domElement.addEventListener(
                      "pointerup",
                      this.onPointerUp
                    ),
                    _.stopPropagation(),
                    "touch" === _.pointerType ||
                      ("pen" === _.pointerType && uu) ||
                      this.domElement.setPointerCapture(_.pointerId)));
              }),
              (this.onPointerLeave = (_) => {
                this.resetHoverEffectOnPointerLeave && !this.useWindowEvents
                  ? (1 === this.hoverRotatePanMode
                      ? ((this.sphericalDelta.theta = -this.spherical.theta),
                        (this.sphericalDelta.phi = -this.spherical.phi),
                        IE.subVectors(this.position0, this.target0),
                        this.spherical.setFromVector3(IE),
                        (this.sphericalDelta.theta += this.spherical.theta),
                        (this.sphericalDelta.phi += this.spherical.phi),
                        (this.sphericalDelta.theta /= 8),
                        (this.sphericalDelta.phi /= 8))
                      : 2 === this.hoverRotatePanMode &&
                        this.panOffset
                          .subVectors(this.target0, this.target)
                          .divideScalar(8),
                    this.update())
                  : (this.pointerLeaveEvent = _);
              }),
              (this.onPointerEnter = (_) => {
                this.resetHoverEffectOnPointerLeave ||
                void 0 === this.pointerLeaveEvent
                  ? IC.set(
                      _.clientX - this.domElement.clientWidth / 2,
                      _.clientY - this.domElement.clientHeight / 2
                    )
                  : IC.set(
                      _.clientX - this.pointerLeaveEvent.clientX,
                      _.clientY - this.pointerLeaveEvent.clientY
                    ),
                  1 === this.hoverRotatePanMode
                    ? (this.rotateDelta
                        .copy(IC)
                        .multiplyScalar(
                          this.rotateSpeed * this.hoverRotatePanStrength
                        )
                        .rotateAround(IS, -this.object.angleOffsetFromUp),
                      this.rotateLeft(
                        (2 * Math.PI * this.rotateDelta.x) /
                          this.domElement.clientHeight
                      ),
                      this.rotateUp(
                        (2 * Math.PI * this.rotateDelta.y) /
                          this.domElement.clientHeight
                      ),
                      this.rotateStart.set(_.clientX, _.clientY))
                    : 2 === this.hoverRotatePanMode &&
                      (this.panDelta
                        .copy(IC)
                        .multiplyScalar(
                          this.panSpeed * this.hoverRotatePanStrength
                        ),
                      this.pan(this.panDelta.x, this.panDelta.y),
                      this.panStart.set(_.clientX, _.clientY)),
                  this.update();
              }),
              (this.onPointerMove = (_) => {
                !1 !== this.enabled &&
                  (this.checkRaycastLock() ||
                    ("touch" === _.pointerType ||
                    ("pen" === _.pointerType && uu)
                      ? this.onPointerMoveTouch(_)
                      : this.onPointerMoveMouse(_),
                    _.stopPropagation()));
              }),
              (this.onPointerUp = (_) => {
                (this.isPointerDown = !1),
                  0 === um.length &&
                    (this.domElement.removeEventListener(
                      "pointermove",
                      this.onPointerMove
                    ),
                    this.domElement.removeEventListener(
                      "pointerup",
                      this.onPointerUp
                    )),
                  um.length > 1 && _.preventDefault(),
                  this.hasChange
                    ? this.dispatchEvent(Ix)
                    : this.dispatchEvent(Ib),
                  (this.state = -1),
                  _ &&
                    (_.stopPropagation(),
                    "touch" === _.pointerType ||
                      ("pen" === _.pointerType && uu) ||
                      this.domElement.releasePointerCapture(_.pointerId));
              }),
              (this.onPointerDownMouse = (_) => {
                switch (
                  this.useKeyEvents
                    ? this.mouseButtons[_.button]
                    : this.mouseButtonsPlay[_.button]
                ) {
                  case 0:
                    if (!0 !== _.altKey || _.shiftKey || Qp(_)) {
                      if (" " === this.key) {
                        if (!1 === this.enablePan) return;
                        this.handleMouseDownPan(_), (this.state = 2);
                      }
                    } else {
                      if (!1 === this.enableRotate) return;
                      this.handleMouseDownRotate(_), (this.state = 0);
                    }
                    break;
                  case 4:
                    if (!1 === this.enablePan) return;
                    this.handleMouseDownPan(_), (this.state = 2);
                    break;
                  case 3:
                    if (Qp(_) || _.shiftKey) {
                      if (!1 === this.enablePan) return;
                      this.handleMouseDownPan(_), (this.state = 2);
                    } else {
                      if (!1 === this.enableRotate) return;
                      this.handleMouseDownRotate(_), (this.state = 0);
                    }
                    break;
                  case 5:
                    if (Qp(_) || _.shiftKey) {
                      if (!1 === this.enableRotate) return;
                      this.handleMouseDownRotate(_), (this.state = 0);
                    } else {
                      if (!1 === this.enablePan) return;
                      this.handleMouseDownPan(_), (this.state = 2);
                    }
                    break;
                  default:
                    this.state = -1;
                }
              }),
              (this.onPointerMoveMouse = (_) => {
                switch (this.state) {
                  case 0:
                    if (!1 === this.enableRotate) return;
                    this.handleMouseMoveRotate(_);
                    break;
                  case 1:
                    if (!1 === this.enableZoom) return;
                    this.handleMouseMoveDolly(_);
                    break;
                  case 2:
                    if (!1 === this.enablePan) return;
                    this.handleMouseMovePan(_);
                }
                this.object.wasMovedByUser = !0;
              }),
              (this.onPointerDownTouch = (_) => {
                switch (
                  (um.length > 1 && _.preventDefault(),
                  this.touches[um.length - 1])
                ) {
                  case i3.ROTATE:
                    if (!1 === this.enableRotate) {
                      this.state = -1;
                      return;
                    }
                    this.handleTouchStartRotate(), (this.state = 3);
                    break;
                  case i3.PAN:
                    if (!1 === this.enablePan) {
                      this.state = -1;
                      return;
                    }
                    this.handleTouchStartPan(), (this.state = 4);
                    break;
                  case i3.DOLLY_PAN:
                    if (!1 === this.enableZoom && !1 === this.enablePan) return;
                    this.handleTouchStartDollyPan(), (this.state = 5);
                    break;
                  case i3.DOLLY_ROTATE:
                    if (!1 === this.enableZoom && !1 === this.enableRotate)
                      return;
                    this.handleTouchStartDollyRotate(), (this.state = 6);
                    break;
                  default:
                    this.state = -1;
                }
              }),
              (this.onPointerMoveTouch = (_) => {
                switch ((um.length > 1 && _.preventDefault(), this.state)) {
                  case 3:
                    if (!1 === this.enableRotate) return;
                    this.handleTouchMoveRotate(_), this.update();
                    break;
                  case 4:
                    if (!1 === this.enablePan) return;
                    this.handleTouchMovePan(_), this.update();
                    break;
                  case 5:
                    if (!1 === this.enableZoom && !1 === this.enablePan) return;
                    this.handleTouchMoveDollyPan(_), this.update();
                    break;
                  case 6:
                    if (!1 === this.enableZoom && !1 === this.enableRotate)
                      return;
                    this.handleTouchMoveDollyRotate(_), this.update();
                    break;
                  default:
                    this.state = -1;
                }
                this.object.wasMovedByUser = !0;
              }),
              (this.dispatchEndDebounced = Nc(
                () => this.dispatchEvent(Ix),
                33
              )),
              (this.onMouseWheel = (_) => {
                !1 === this.enabled ||
                  (!1 === this.enableZoom && !1 === this.enablePan) ||
                  this.checkRaycastLock() ||
                  (this.options.isExport ||
                    this.domElement.clientHeight !==
                      document.body.clientHeight ||
                    this.domElement.clientWidth !== document.body.clientWidth ||
                    _.preventDefault(),
                  this.dispatchEvent(Iy),
                  this.handleMouseWheel(_),
                  this.dispatchEndDebounced(),
                  (this.object.wasMovedByUser = !0));
              }),
              (this.onGesture = (_) => {
                _.preventDefault(),
                  !1 === this.enabled ||
                    this.checkRaycastLock() ||
                    uc ||
                    ("gesturechange" === _.type
                      ? !1 !== this.enableZoom &&
                        !1 !== this.isTouchZoom &&
                        (this.dispatchEvent(Iy),
                        _.scale > this.prevScale
                          ? this.dollyIn(this.getZoomScale())
                          : _.scale < this.prevScale &&
                            this.dollyOut(this.getZoomScale()),
                        (this.prevScale = _.scale),
                        this.update(),
                        (this.object.wasMovedByUser = !0))
                      : this.dispatchEvent(Ix));
              }),
              (this.onContextMenu = (_) => {
                _.preventDefault();
              }),
              (this.onTouchEnd = (_) => {
                _.preventDefault();
              }),
              (this.onKeyDown = (_) => {
                !1 !== this.enabled &&
                  ((this.key = _.key), " " === _.key && this.dispatchEvent(Iy));
              }),
              (this.onKeyUp = (_) => {
                !1 !== this.enabled &&
                  ((this.key = void 0),
                  -1 !== this.state &&
                    "Alt" === _.key &&
                    this.onPointerUp(um[0]),
                  " " === _.key && this.dispatchEvent(Ix));
              }),
              (this.onPointerHover = (_) => {
                "mouse" !== _.pointerType ||
                  !1 === this.enabled ||
                  -1 !== this.state ||
                  (2 === this.hoverRotatePanMode && this.isPanOverShoot) ||
                  (1 === this.hoverRotatePanMode && this.isRotateOverShoot) ||
                  ((this.isPointerDown = !0),
                  2 === this.hoverRotatePanMode
                    ? this.handleMouseMovePan(_, this.hoverRotatePanStrength)
                    : 1 === this.hoverRotatePanMode &&
                      this.handleMouseMoveRotate(
                        _,
                        this.hoverRotatePanStrength
                      ));
              }),
              (this.onBeginState = () => {
                (this.enabled = !1), (this.needsUpdate = !1);
              }),
              (this.onCompleteState = (_) => {
                (_.isfromEntity && this.options.isPlayMode) ||
                  ((this.enabled = !0),
                  (this.needsUpdate = !0),
                  this.object.updateUp(),
                  this.object.getTarget(this.target));
              }),
              (this.target = this.object.getTarget()),
              (this.target0 = this.target.clone()),
              (this.position0 = this.object.position.clone()),
              (this.zoom0 = this.object.zoom),
              (this.quat0 = this.object.quaternion.clone()),
              (this.isUpVectorFlipped0 = this.object.isUpVectorFlipped),
              this.offset.copy(this.object.position).sub(this.target),
              this.spherical.setFromVector3(this.offset),
              this.object.isUpVectorFlipped &&
                ((this.spherical.phi *= -1), (this.spherical.theta -= Math.PI)),
              this.addEventListenersToCamera();
          }
          dispatchEvent(_) {
            "start" === _.type ? (this.hasChange = !1) : (this.hasChange = !0),
              super.dispatchEvent(_);
          }
          addEventListenersToCamera() {
            this.object.addEventListener("beginState", this.onBeginState),
              this.object.addEventListener(
                "completeState",
                this.onCompleteState
              ),
              this.object.addEventListener("cameraChange", this.onCameraChange);
          }
          removeEventListenersFromCamera() {
            this.object.removeEventListener("beginState", this.onBeginState),
              this.object.removeEventListener(
                "completeState",
                this.onCompleteState
              ),
              this.object.removeEventListener(
                "cameraChange",
                this.onCameraChange
              );
          }
          updateUseWindowEvents(_) {
            if (
              (window.removeEventListener("pointermove", this.onPointerHover),
              this.domElement.removeEventListener(
                "pointermove",
                this.onPointerHover
              ),
              (this.useWindowEvents = _),
              0 !== this.hoverRotatePanMode &&
                (this.useWindowEvents
                  ? window.addEventListener("pointermove", this.onPointerHover)
                  : this.domElement.addEventListener(
                      "pointermove",
                      this.onPointerHover
                    )),
              this.domElement.removeEventListener(
                "pointerleave",
                this.onPointerLeave
              ),
              this.domElement.removeEventListener(
                "pointerenter",
                this.onPointerEnter
              ),
              window.removeEventListener("pointerleave", this.onPointerLeave),
              window.removeEventListener("pointerenter", this.onPointerEnter),
              0 !== this.hoverRotatePanMode && !this.useWindowEvents)
            ) {
              let _ = this.useWindowEvents ? window : this.domElement;
              _.addEventListener("pointerleave", this.onPointerLeave),
                _.addEventListener("pointerenter", this.onPointerEnter);
            }
          }
          fromJSON(_, I) {
            this.setEnableDampingSpeed(_.enableDamping),
              (this.enablePan = _.enablePan),
              (this.enableZoom = _.enableZoom),
              (this.enableRotate = _.enableRotate),
              (this.rotationLimitsMode = _.rotationLimitsMode),
              (this.thetaIsFree =
                _.rotationHorizontalOffset.min ===
                  _.rotationHorizontalOffset.max &&
                _.rotationHorizontalOffset.min === Math.PI),
              (this.phiIsFree =
                _.rotationVerticalOffset.min === _.rotationVerticalOffset.max &&
                _.rotationVerticalOffset.min === Math.PI),
              (this.panLimitsMode = _.panLimitsMode),
              (this.panSoftLimit = _.panSoftLimit),
              (this.rotationSoftLimit = _.rotationSoftLimit),
              (this.hoverRotatePanMode = _.hoverRotatePanMode),
              (this.hoverRotateDamping =
                _.hoverRotateDamping ?? this.dampingFactor),
              (this.useWindowEvents = "window" === I),
              0 !== this.hoverRotatePanMode &&
                (this.useWindowEvents
                  ? window.addEventListener("pointermove", this.onPointerHover)
                  : this.domElement.addEventListener(
                      "pointermove",
                      this.onPointerHover
                    ));
            let R = _.hoverRotatePanStrength / 100;
            (this.hoverRotatePanStrength = R ** 2),
              (this.zoomLimitsEnabled = _.zoomLimitsEnabled),
              (this.minZoom = _.zoomLimits.min),
              (this.maxZoom = Math.max(_.zoomLimits.min, _.zoomLimits.max)),
              (this.minDistance = 1e3 / _.zoomLimits.max),
              (this.maxDistance = Math.max(
                this.minDistance,
                1e3 / _.zoomLimits.min
              )),
              (this.autoRotate = _.autoRotate),
              (this.autoRotateSpeed = _.autoRotateSpeed),
              (this.autoRotateClockwise = _.autoRotateClockwise);
            let B = this.object
              .getTarget()
              .applyQuaternion(Iw.copy(this.object.quaternion).invert());
            (this.minV = -_.panVerticalOffset.min + B.y),
              (this.maxV = _.panVerticalOffset.max + B.y),
              (this.minH = -_.panHorizontalOffset.min + B.x),
              (this.maxH = _.panHorizontalOffset.max + B.x),
              this.panRangeFactor
                .set(this.maxH - this.minH, this.maxV - this.minV)
                .divideScalar(2),
              this.rotationRangeFactor.setScalar(Math.PI).divideScalar(4),
              (this.minPhi = la(
                this.spherical.phi - _.rotationVerticalOffset.min
              )),
              (this.maxPhi = la(
                this.spherical.phi + _.rotationVerticalOffset.max
              )),
              (this.minTheta = la(
                la(this.spherical.theta) - _.rotationHorizontalOffset.min
              )),
              (this.maxTheta = la(
                la(this.spherical.theta) + _.rotationHorizontalOffset.max
              )),
              (this.isThetaFlipped = this.minTheta > this.maxTheta),
              1 === _.orbitTouches && (this.touches[0] = i3.ROTATE),
              1 === _.panTouches && (this.touches[0] = i3.PAN),
              2 === _.orbitTouches && (this.touches[1] = i3.DOLLY_ROTATE),
              2 === _.panTouches && (this.touches[1] = i3.DOLLY_PAN),
              3 === _.orbitTouches && (this.touches[2] = i3.ROTATE),
              3 === _.panTouches && (this.touches[2] = i3.PAN),
              (this.isTouchZoom = _.isTouchZoom),
              (this.resetHoverEffectOnPointerLeave =
                _.resetHoverEffectOnPointerLeave ?? !1);
          }
          connect() {
            if (
              (this.domElement.addEventListener(
                "contextmenu",
                this.onContextMenu
              ),
              this.domElement.addEventListener(
                "pointerdown",
                this.onPointerDown
              ),
              this.domElement.addEventListener("wheel", this.onMouseWheel),
              window.addEventListener("keydown", this.onKeyDown, !1),
              window.addEventListener("keyup", this.onKeyUp, !1),
              this.domElement.addEventListener("gesturestart", this.onGesture),
              this.domElement.addEventListener("gesturechange", this.onGesture),
              this.domElement.addEventListener("gestureend", this.onGesture),
              this.domElement.addEventListener("touchend", this.onTouchEnd),
              0 !== this.hoverRotatePanMode && !this.useWindowEvents)
            ) {
              let _ = this.useWindowEvents ? window : this.domElement;
              _.addEventListener("pointerleave", this.onPointerLeave),
                _.addEventListener("pointerenter", this.onPointerEnter);
            }
            this.pointerLeaveEvent = void 0;
          }
          dispose() {
            this.removeEventListenersFromCamera(),
              this.domElement.removeEventListener(
                "contextmenu",
                this.onContextMenu
              ),
              this.domElement.removeEventListener(
                "pointerdown",
                this.onPointerDown
              ),
              this.domElement.removeEventListener("wheel", this.onMouseWheel),
              window.removeEventListener("keydown", this.onKeyDown, !1),
              window.removeEventListener("keyup", this.onKeyUp, !1),
              this.domElement.removeEventListener(
                "pointermove",
                this.onPointerHover
              ),
              window.removeEventListener("pointermove", this.onPointerHover),
              this.domElement.removeEventListener(
                "gesturestart",
                this.onGesture
              ),
              this.domElement.removeEventListener(
                "gesturechange",
                this.onGesture
              ),
              this.domElement.removeEventListener("gestureend", this.onGesture),
              this.domElement.removeEventListener("touchend", this.onTouchEnd),
              this.domElement.removeEventListener(
                "pointerleave",
                this.onPointerLeave
              ),
              this.domElement.removeEventListener(
                "pointerenter",
                this.onPointerEnter
              ),
              window.removeEventListener("pointerleave", this.onPointerLeave),
              window.removeEventListener("pointerenter", this.onPointerEnter),
              this.domElement.removeEventListener(
                "pointermove",
                this.onPointerMove
              ),
              this.domElement.removeEventListener(
                "pointerup",
                this.onPointerUp
              );
          }
          applyLimits(_, I, R, B, z, k, V, j) {
            let G, q, X;
            this.overShoot.set(0, 0),
              _ instanceof rF
                ? ((G = _.x),
                  (q = _.y),
                  this.current.set(this.target.x, this.target.y),
                  (X = !0))
                : ((G = _.theta),
                  (q = _.phi),
                  this.current.set(
                    la(this.spherical.theta),
                    la(this.spherical.phi)
                  ),
                  (X = !1)),
              0 === R && ((this.current.x += G), (this.current.y += q)),
              (3 === I || 2 === I) &&
                (!X && this.isThetaFlipped
                  ? this.current.x > B && this.current.x < 0
                    ? (this.overShoot.x = B - this.current.x)
                    : this.current.x < z &&
                      this.current.x > 0 &&
                      (this.overShoot.x = z - this.current.x)
                  : this.current.x > B
                  ? (this.overShoot.x = B - this.current.x)
                  : this.current.x < z &&
                    (this.overShoot.x = z - this.current.x)),
              (3 === I || 1 === I) &&
                (this.current.y > k
                  ? (this.overShoot.y = k - this.current.y)
                  : this.current.y < V &&
                    (this.overShoot.y = V - this.current.y)),
              X ||
                ((this.overShoot.x = la(this.overShoot.x)),
                (this.overShoot.y = la(this.overShoot.y))),
              0 !== R
                ? (this.overRatio.copy(this.overShoot).divide(j),
                  (this.overRatio.x = Math.min(Math.abs(this.overRatio.x), 1)),
                  (this.overRatio.y = Math.min(Math.abs(this.overRatio.y), 1)),
                  1 === R &&
                    ((this.overRatio.x = VN(Math.abs(this.overRatio.x))),
                    (this.overRatio.y = VN(Math.abs(this.overRatio.y)))),
                  this.isPointerDown || 1 === R
                    ? 2 === R &&
                      ((this.overRatio.x > 0.9 && !this.thetaIsFree) ||
                        (this.overRatio.y > 0.9 && !this.phiIsFree))
                      ? (this.isPointerDown = !1)
                      : (G * this.overShoot.x < 0 &&
                          !this.thetaIsFree &&
                          (G *= 1 - this.overRatio.x),
                        q * this.overShoot.y < 0 &&
                          !this.phiIsFree &&
                          (q *= 1 - this.overRatio.y))
                    : 2 === R &&
                      ((!X &&
                        ((this.overRatio.x > 0.002 && !this.thetaIsFree) ||
                          (this.overRatio.y > 0.002 && !this.phiIsFree))) ||
                      (X &&
                        (Math.abs(this.overShoot.x) > 2 ||
                          Math.abs(this.overShoot.y) > 2))
                        ? (this.thetaIsFree || (G = 0.05 * this.overShoot.x),
                          this.phiIsFree || (q = 0.05 * this.overShoot.y),
                          X
                            ? (this.isPanOverShoot = !0)
                            : (this.isRotateOverShoot = !0))
                        : X
                        ? (this.isPanOverShoot = !1)
                        : (this.isRotateOverShoot = !1)))
                : ((G += this.overShoot.x), (q += this.overShoot.y)),
              _ instanceof rF
                ? ((_.x = G), (_.y = q))
                : (this.thetaIsFree || (_.theta = G),
                  this.phiIsFree || (_.phi = q));
          }
          setEnableDampingSpeed(_) {
            (this.enableDamping = _), (this.rotateSpeed = !0 === _ ? 0.2 : 1);
          }
          stopDamping() {
            (this.sphericalDelta.theta = 0), (this.sphericalDelta.phi = 0);
          }
          getAutoRotationAngle() {
            return ((2 * Math.PI) / 60 / 60) * this.autoRotateSpeed;
          }
          getZoomScale() {
            return Math.pow(0.95, this.zoomSpeed);
          }
          rotateLeft(_) {
            this.sphericalDelta.theta -= _;
          }
          rotateUp(_) {
            this.sphericalDelta.phi -= _;
          }
          panLeft(_, I) {
            this.panLeftV.setFromMatrixColumn(I, 0),
              this.panLeftV.multiplyScalar(-_),
              this.panOffset.add(this.panLeftV);
          }
          panUp(_, I) {
            this.panUpV.setFromMatrixColumn(I, 1),
              this.panUpV.multiplyScalar(_),
              this.panOffset.add(this.panUpV);
          }
          pan(_, I) {
            let R = this.domElement;
            if (R && this.object.isPerspectiveCamera) {
              let B = this.object.position;
              this.panV.copy(B).sub(this.target);
              let z = this.panV.length();
              (z *= Math.tan(((this.object.fov / 2) * Math.PI) / 180)),
                this.panLeft(
                  (2 * _ * z) / R.clientHeight,
                  this.object.matrixWorld
                ),
                this.panUp(
                  (2 * I * z) / R.clientHeight,
                  this.object.matrixWorld
                );
            } else
              R &&
                this.object.isOrthographicCamera &&
                (this.panLeft(
                  (_ * (this.object.right - this.object.left)) /
                    this.object.zoom /
                    R.clientWidth,
                  this.object.matrixWorld
                ),
                this.panUp(
                  (I * (this.object.top - this.object.bottom)) /
                    this.object.zoom /
                    R.clientHeight,
                  this.object.matrixWorld
                ));
            this.dispatchEvent(Iv);
          }
          dollyOut(_) {
            this.object.isPerspectiveCamera
              ? (this.scale /= _)
              : this.object.isOrthographicCamera &&
                ((this.object.zoom *= _),
                this.zoomLimitsEnabled &&
                  (this.object.zoom = Math.max(
                    this.minZoom,
                    Math.min(this.maxZoom, this.object.zoom)
                  )),
                this.object.updateProjectionMatrix(),
                (this.zoomChanged = !0)),
              this.dispatchEvent(Ig);
          }
          dollyIn(_) {
            this.object.isPerspectiveCamera
              ? (this.scale *= _)
              : this.object.isOrthographicCamera &&
                ((this.object.zoom /= _),
                this.zoomLimitsEnabled &&
                  (this.object.zoom = Math.max(
                    this.minZoom,
                    Math.min(this.maxZoom, this.object.zoom)
                  )),
                this.object.updateProjectionMatrix(),
                (this.zoomChanged = !0)),
              this.dispatchEvent(Ig);
          }
          zoomOut(_ = this.getZoomScale()) {
            this.dispatchEvent(Iy), this.dollyOut(_), this.dispatchEvent(Ix);
          }
          zoomIn(_ = this.getZoomScale()) {
            this.dispatchEvent(Iy), this.dollyIn(_), this.dispatchEvent(Ix);
          }
          handleMouseDownRotate(_) {
            this.rotateStart.set(_.clientX, _.clientY);
          }
          handleMouseDownDolly(_) {
            this.dollyStart.set(_.clientX, _.clientY);
          }
          handleMouseDownPan(_) {
            this.panStart.set(_.clientX, _.clientY);
          }
          handleMouseMoveRotate(_, I = 1) {
            void 0 !== _.movementX
              ? this.rotateDelta.set(_.movementX, _.movementY)
              : (this.rotateEnd.set(_.clientX, _.clientY),
                this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart),
                this.rotateStart.copy(this.rotateEnd)),
              this.rotateDelta
                .multiplyScalar(this.rotateSpeed * I)
                .rotateAround(IS, -this.object.angleOffsetFromUp);
            let R = this.domElement,
              B = this.useWindowEvents ? window.innerHeight : R.clientHeight,
              z = (2 * Math.PI * this.rotateDelta.x) / B,
              k = (2 * Math.PI * this.rotateDelta.y) / B;
            this.rotateLeft(z), this.rotateUp(k), this.update();
          }
          handleMouseMoveDolly(_) {
            this.dollyEnd.set(_.clientX, _.clientY),
              this.dollyDelta.subVectors(this.dollyEnd, this.dollyStart),
              this.dollyDelta.y > 0
                ? this.dollyOut(this.getZoomScale())
                : this.dollyDelta.y < 0 && this.dollyIn(this.getZoomScale()),
              this.dollyStart.copy(this.dollyEnd),
              this.update();
          }
          handleMouseMovePan(_, I = 1) {
            void 0 !== _.movementX
              ? this.panDelta.set(_.movementX, _.movementY)
              : (this.panEnd.set(_.clientX, _.clientY),
                this.panDelta.subVectors(this.panEnd, this.panStart),
                this.panStart.copy(this.panEnd)),
              this.panDelta.multiplyScalar(this.panSpeed * I),
              this.pan(this.panDelta.x, this.panDelta.y),
              this.update();
          }
          handleMouseWheel(_) {
            if (
              !1 === ud &&
              !1 === Qp(_) &&
              !0 ==
                (0 === _.wheelDeltaY || 0 === _.deltaY
                  ? !(ul && _.shiftKey && Math.abs(_.wheelDeltaX) >= 120) &&
                    (_.wheelDeltaX
                      ? _.wheelDeltaX === -3 * _.deltaX ||
                        _.wheelDeltaX ===
                          -3 * window.devicePixelRatio * _.deltaX
                      : 0 === _.deltaMode)
                  : _.wheelDeltaY
                  ? _.wheelDeltaY === -3 * _.deltaY ||
                    _.wheelDeltaY === -3 * window.devicePixelRatio * _.deltaY
                  : 0 === _.deltaMode)
            )
              !1 !== this.enablePan &&
                (this.gesture
                  ? (this.panDelta
                      .set(-_.deltaX, -_.deltaY)
                      .multiplyScalar(this.panSpeed),
                    (this.panDelta.x =
                      Math.min(Math.abs(this.panDelta.x), 100) *
                      (this.panDelta.x < 0 ? -1 : 1)),
                    (this.panDelta.y =
                      Math.min(Math.abs(this.panDelta.y), 100) *
                      (this.panDelta.y < 0 ? -1 : 1)),
                    _.altKey
                      ? this.pan(0, this.panDelta.y)
                      : _.shiftKey
                      ? this.pan(this.panDelta.x, 0)
                      : this.pan(this.panDelta.x, this.panDelta.y),
                    this.update())
                  : ((this.gesture = !0), (this.isPointerDown = !0)),
                window.clearTimeout(this.timer),
                (this.timer = window.setTimeout(() => {
                  (this.gesture = !1), (this.isPointerDown = !1);
                }, 30)));
            else {
              if (!1 === this.enableZoom) return;
              0 === _.deltaY
                ? _.deltaX < 0
                  ? this.dollyIn(this.getZoomScale())
                  : _.deltaX > 0 && this.dollyOut(this.getZoomScale())
                : _.deltaY < 0
                ? this.dollyIn(this.getZoomScale())
                : _.deltaY > 0 && this.dollyOut(this.getZoomScale()),
                this.update(),
                (this.gesture = !1),
                (this.isPointerDown = !1);
            }
          }
          handleTouchStartRotate() {
            if (2 === um.length) {
              let _ = 0.5 * (um[0].pageX + um[1].pageX),
                I = 0.5 * (um[0].pageY + um[1].pageY);
              this.rotateStart.set(_, I);
            } else this.rotateStart.set(um[0].pageX, um[0].pageY);
          }
          handleTouchStartPan() {
            if (2 === um.length) {
              let _ = 0.5 * (um[0].pageX + um[1].pageX),
                I = 0.5 * (um[0].pageY + um[1].pageY);
              this.panStart.set(_, I);
            } else this.panStart.set(um[0].pageX, um[0].pageY);
          }
          handleTouchStartDolly() {
            let _ = um[0].pageX - um[1].pageX,
              I = um[0].pageY - um[1].pageY,
              R = Math.sqrt(_ * _ + I * I);
            this.dollyStart.set(0, R);
          }
          handleTouchStartDollyPan() {
            this.enableZoom &&
              !0 === this.isTouchZoom &&
              this.handleTouchStartDolly(),
              this.enablePan && this.handleTouchStartPan();
          }
          handleTouchStartDollyRotate() {
            this.enableZoom &&
              !0 === this.isTouchZoom &&
              this.handleTouchStartDolly(),
              this.enableRotate && this.handleTouchStartRotate();
          }
          handleTouchMoveRotate(_) {
            if (2 === um.length) {
              let I = Av(_),
                R = 0.5 * (_.pageX + I.x),
                B = 0.5 * (_.pageY + I.y);
              this.rotateEnd.set(R, B);
            } else {
              if (_.pointerId !== um[0].pointerId) return;
              this.rotateEnd.set(_.pageX, _.pageY);
            }
            this.rotateDelta
              .subVectors(this.rotateEnd, this.rotateStart)
              .multiplyScalar(this.rotateSpeed);
            let I = this.domElement;
            I &&
              (this.rotateLeft(
                (2 * Math.PI * this.rotateDelta.x) / I.clientHeight
              ),
              this.rotateUp(
                (2 * Math.PI * this.rotateDelta.y) / I.clientHeight
              )),
              this.rotateStart.copy(this.rotateEnd);
          }
          handleTouchMovePan(_) {
            if (2 === um.length) {
              let I = Av(_),
                R = 0.5 * (_.pageX + I.x),
                B = 0.5 * (_.pageY + I.y);
              this.panEnd.set(R, B);
            } else {
              if (_.pointerId !== um[0].pointerId) return;
              this.panEnd.set(_.pageX, _.pageY);
            }
            this.panDelta
              .subVectors(this.panEnd, this.panStart)
              .multiplyScalar(this.panSpeed),
              this.pan(this.panDelta.x, this.panDelta.y),
              this.panStart.copy(this.panEnd);
          }
          handleTouchMoveDolly(_) {
            let I = Av(_),
              R = _.pageX - I.x,
              B = _.pageY - I.y,
              z = Math.sqrt(R * R + B * B);
            this.dollyEnd.set(0, z),
              this.dollyDelta.set(
                0,
                Math.pow(this.dollyEnd.y / this.dollyStart.y, this.zoomSpeed)
              ),
              this.dollyOut(this.dollyDelta.y),
              this.dollyStart.copy(this.dollyEnd);
          }
          handleTouchMoveDollyPan(_) {
            this.enableZoom &&
              !0 === this.isTouchZoom &&
              this.handleTouchMoveDolly(_),
              this.enablePan && this.handleTouchMovePan(_);
          }
          handleTouchMoveDollyRotate(_) {
            this.enableZoom &&
              !0 === this.isTouchZoom &&
              this.handleTouchMoveDolly(_),
              this.enableRotate && this.handleTouchMoveRotate(_);
          }
          checkRaycastLock() {
            if (!this.object.data.raycastLock || this.options.isPlayMode)
              return !1;
            {
              let _ = this.options?.showCameraLock;
              return _ && _(), !0;
            }
          }
        };
      function la(_) {
        let I = 2 * Math.PI;
        for (; _ <= -Math.PI; ) _ += I;
        for (; _ > Math.PI; ) _ -= I;
        return _;
      }
      function VN(_) {
        return 1 - Math.pow(1 - _, 4);
      }
      var IR = class {
        constructor(_, I, R, B, z, k) {
          (this.id = _),
            (this.data = I),
            (this.object = R),
            (this.page = B),
            (this.currentIntersectedObjects = []),
            (this.disabled = !1),
            (this.alreadyPlayedNonTogglingActions = new Set()),
            (this.actions = Mr(I, I.actions, B, z, k, R)),
            (this.target = I.target),
            (this.useToggle = "Toggle" === I.runMode),
            (this.triggeringObjects = I.triggeringObjects.map((_) =>
              B.scene.find(_)
            ));
        }
        isValidTriggeringObject(_) {
          return (
            "all" === this.target ||
            this.triggeringObjects.some(
              (I) => I === _ || I.isAncestorOf(_.uuid) || _.isAncestorOf(I.uuid)
            )
          );
        }
        disconnect() {
          dr(this.actions);
        }
        dispatch() {
          this.disabled ||
            this.object.destroyedInAction ||
            (this.actions.Transition.forEach((_) => {
              _.object.currentTransitionEvent !== this
                ? ((_.object.currentTransitionEvent = this), _.init())
                : "Once" === this.data.runMode &&
                  this.alreadyPlayedNonTogglingActions.add(_);
            }),
            this.object.dispatchEvent({
              type: "beginEvent",
              eventName: "Trigger",
            }),
            this.useToggle
              ? (this.actions.Transition.forEach((_) => {
                  _.toggle();
                }),
                this.actions.SwitchCamera.forEach((_) => {
                  _.toggle();
                }))
              : (this.actions.Transition.forEach((_) => {
                  !1 === this.alreadyPlayedNonTogglingActions.has(_) &&
                    _.play();
                }),
                this.actions.SwitchCamera.forEach((_) => {
                  _.play();
                })),
            this.actions.Link.forEach((_) => {
              _.dispatch();
            }),
            this.actions.Reset.forEach((_) => {
              _.dispatch();
            }),
            this.actions.Create.forEach((_) => {
              _.dispatch();
            }),
            this.actions.Destroy.forEach((_) => {
              _.dispatch(!1);
            }),
            this.actions.Audio.forEach((_) => {
              _.dispatchBasic();
            }),
            this.actions.Particles.forEach((_) => {
              _.dispatchBasic();
            }),
            this.actions.Video.forEach((_) => {
              _.dispatchBasic();
            }),
            this.actions.SceneTransition.forEach((_) => {
              _.dispatch();
            }),
            this.actions.SetVariable.forEach((_) => _.checkConditions()),
            this.actions.SetVariable.forEach((_) => _.dispatch()),
            this.actions.DynamicVariablePlay.forEach((_) => _.dispatch()));
        }
      };
      uR.then((_) => (iw = _));
      var IL = new rF(),
        Iz = new rz(),
        IF = new rF(),
        Ik = new sg(0, 0, 0, "YXZ"),
        IV = new sg(0, 0, 0, "XYZ"),
        Ij = new rF(),
        IH = new rF(),
        IW = new rF(1, 1, 1),
        Iq = new rz(),
        IY = new sa(),
        IX = new sa(),
        IQ = { type: "updateMatrix" },
        IZ = new rz(),
        IK = new r5(),
        IJ = { type: "beginEvent", eventName: "Collision" },
        I$ = { type: "beginEvent", eventName: "Trigger" },
        Og = (_) =>
          _.states.some(
            (_) =>
              void 0 !== _.data.position ||
              void 0 !== _.data.rotation ||
              void 0 !== _.data.hiddenMatrix ||
              void 0 !== _.data.cloner ||
              void 0 !== _.data.pathSnapping
          ),
        I0 = class {
          constructor(_) {
            (this.eventContext = _),
              (this.isEnabled = !1),
              (this.gameControl = null),
              (this.joysticks = []),
              (this.joystickToGameControls = []),
              (this.sharedGameControlGlobals = {
                entitiesWithTransformAnim: [],
                entityToCollisionEvents: {},
                colliderToEntity: new Map(),
                triggers: [],
                gamePads: [],
                createdObjects: [],
                nCreatedPerAction: {},
              }),
              (this.sensorToTriggerEvent = {}),
              (this.eventManager = void 0),
              (this.needsCollisionDetection = !1),
              (this.initializationCounter = -1),
              (this.rigidBodyToMesh = new Map()),
              (this.nActiveRigidBodies = 0),
              (this.collisionEvents = []),
              (this.isExport = !1),
              (this.processRigidBody = (_) => {
                if (_.bodyType() !== iw.RigidBodyType.Dynamic) return;
                _.isSleeping() || this.nActiveRigidBodies++;
                let [I, R, B] = this.rigidBodyToMesh.get(_.handle);
                if (
                  (IL.copy(_.translation()).multiplyScalar(this.pixelsPerMeter),
                  Iz.copy(_.rotation()),
                  I.matrixWorld.compose(IL, Iz, R),
                  I.hasNonUniformScale && I.matrixWorld.multiply(I.shearScale),
                  I.dispatchEvent(IQ),
                  B)
                ) {
                  let _ = I.cloner;
                  if (_ && void 0 === _.objectForSample)
                    for (let R of (_.matrixWorld.copy(I.matrixWorld),
                    _.children))
                      R.updateMatrixWorld(!0);
                  for (let _ of I.children) _.updateMatrixWorld(!0);
                }
              }),
              (this.accumulator = 0),
              (this.handleCollisionEvents = (_, I, R) => {
                let B, z;
                if (!1 !== R) {
                  if (
                    (this.sensorToTriggerEvent[_]
                      ? ((B = this.sensorToTriggerEvent[_]),
                        (z =
                          this.sharedGameControlGlobals.colliderToEntity.get(
                            I
                          )))
                      : this.sensorToTriggerEvent[I] &&
                        ((B = this.sensorToTriggerEvent[I]),
                        (z =
                          this.sharedGameControlGlobals.colliderToEntity.get(
                            _
                          ))),
                    B && z && B.isValidTriggeringObject(z))
                  ) {
                    B.dispatch();
                    return;
                  }
                  for (
                    let R =
                      this.sharedGameControlGlobals.createdObjects.length - 1;
                    R >= 0;
                    R--
                  ) {
                    let B = this.sharedGameControlGlobals.createdObjects[R];
                    if (
                      B.userData.hasCollisionDestroy &&
                      (B.rigidBody?.collider(0).handle === _ ||
                        B.rigidBody?.collider(0).handle === I)
                    ) {
                      this.sharedGameControlGlobals.createdObjects.splice(R, 1),
                        B.removeFromParent(),
                        requestAnimationFrame(() =>
                          this.sharedGameControlGlobals.rapierWorld?.removeRigidBody(
                            B.rigidBody
                          )
                        );
                      break;
                    }
                  }
                  if (
                    this.gameControl?.object ===
                    this.sharedGameControlGlobals.colliderToEntity.get(_)
                  ) {
                    let _ =
                        this.sharedGameControlGlobals.colliderToEntity.get(I),
                      R =
                        this.sharedGameControlGlobals.entityToCollisionEvents[
                          _.uuid
                        ];
                    if (void 0 === R) return;
                    for (let B of R)
                      "character" === B.data.target &&
                        this.dispatchCollisionEvent(B, _, I);
                  } else if (
                    this.gameControl?.object ===
                    this.sharedGameControlGlobals.colliderToEntity.get(I)
                  ) {
                    let I =
                        this.sharedGameControlGlobals.colliderToEntity.get(_),
                      R =
                        this.sharedGameControlGlobals.entityToCollisionEvents[
                          I.uuid
                        ];
                    if (void 0 === R) return;
                    for (let B of R)
                      "character" === B.data.target &&
                        this.dispatchCollisionEvent(B, I, _);
                  } else {
                    let R =
                        this.sharedGameControlGlobals.colliderToEntity.get(_),
                      B =
                        this.sharedGameControlGlobals.entityToCollisionEvents[
                          R.uuid
                        ];
                    if (void 0 !== B)
                      for (let I of B)
                        "scene" === I.data.target &&
                          this.dispatchCollisionEvent(I, R, _);
                    let z =
                        this.sharedGameControlGlobals.colliderToEntity.get(I),
                      k =
                        this.sharedGameControlGlobals.entityToCollisionEvents[
                          z?.uuid
                        ];
                    if (void 0 !== k)
                      for (let _ of k)
                        "scene" === _.data.target &&
                          this.dispatchCollisionEvent(_, z, I);
                  }
                }
              }),
              (this.isExport = _.isExport),
              (this.sharedAssets = _.sharedAssets),
              (this.renderer = _.renderer),
              (this.requestRender = _.requestRender),
              (this.domElement = this.renderer.domElement),
              (this.pixelsPerMeter = 200),
              (this.gravity = this.page.data.globalPhysics.gravity);
          }
          get page() {
            return this.eventContext.page;
          }
          attachVRControllers(_) {
            _.forEach((_) => {
              _.addEventListener("connected", (_) => {
                "gamepad" in _.data &&
                  "axes" in _.data.gamepad &&
                  this.sharedGameControlGlobals.gamePads.push(_.data.gamepad);
              });
            });
          }
          markIsDestroyTarget() {
            this.page.traverseVisibleEntity((_) => {
              for (let I of _.dataPatched.events) {
                if (!0 === I.data.disabled) continue;
                let _ = I.data.actions?.find(
                  (_) => "Destroy" === _.data.type
                )?.data;
                if (_)
                  for (let I of _.objects) {
                    let _ = this.page.scene.find(I);
                    _ && (_.userData.hasDestroy = !0);
                  }
              }
            });
          }
          markIsDragObject() {
            this.page.traverseVisibleEntity((_) => {
              for (let I of _.dataPatched.events)
                if (!(!0 === I.data.disabled || "DragDrop" !== I.data.type))
                  for (let _ of I.data.objects) {
                    let I = this.page.scene.find(_);
                    I && (I.userData.hasDrag = !0);
                  }
            });
          }
          initBVH() {
            let _ = [];
            if (
              (this.page.traverseChildren((I) => {
                let R,
                  B = I instanceof A4,
                  z = I instanceof TP;
                if (I instanceof AI || B || z) return;
                let k = (R = I instanceof yj ? I.object : I).dataPatched;
                if (
                  k.physics?.enabled === "visibility"
                    ? !k.visible
                    : !k.physics?.enabled
                )
                  return !0;
                let V = I.geometry,
                  j = !0 === R.userData.hasDestroy,
                  G = !0 === R.userData.hasDrag;
                if (
                  Og(k) ||
                  j ||
                  G ||
                  R.dataPatched.events.some(
                    (_) =>
                      !0 !== _.data.disabled && "GameControl" === _.data.type
                  )
                )
                  return I.updateMatrixWorldSVD(), this.addBoundsTree(I), !0;
                V && _.push(yo(V, I.matrixWorld));
              }),
              _.length > 0)
            ) {
              let I = $s(_, !1);
              this.sharedGameControlGlobals.staticMeshBVH = new yw(I);
            }
          }
          addRigidBody(_, I, R) {
            let B = [],
              z = "geometry" in _ ? _.geometry : void 0,
              k = I.dataPatched;
            if (
              (z?.getAttribute("position") !== void 0 &&
                B.push(yo(z, _.shearScale)),
              k.physics.fusedBody)
            ) {
              let I = this.gatherChildrenGeom(_, B);
              _.traverseObject(I),
                _.children.forEach((_) => _.updateMatrixWorld(!0));
              let R = _.cloner;
              R &&
                void 0 === R.objectForSample &&
                "dynamic" === k.physics.rigidBody &&
                (R.traverseObject(I),
                R.children.forEach((_) => _.updateMatrixWorld(!0)));
            }
            if (B.length > 0) {
              let V,
                j =
                  (!R.fromCreate && "dynamic" === k.physics.rigidBody) ||
                  (R.fromCreate && R.dynamic);
              j
                ? (V = iw.RigidBodyDesc.dynamic())
                    .setLinearDamping(k.physics.damping)
                    .setAngularDamping(k.physics.damping)
                    .setAdditionalMass(1e-9)
                    .setGravityScale(k.physics.gravityScale)
                    .enabledRotations(...k.physics.enabledRotation)
                    .enabledTranslations(...k.physics.enabledTranslation)
                : (R.hasTransformAnim || R.hasFollow || R.hasDrag) &&
                  !R.fromCreate
                ? ((V = iw.RigidBodyDesc.kinematicPositionBased()),
                  this.sharedGameControlGlobals.entitiesWithTransformAnim.push(
                    _
                  ))
                : (V = iw.RigidBodyDesc.fixed());
              let G = $s(B);
              (_.hasNonUniformScale
                ? _.matrixWorldRigid
                : _.matrixWorld
              ).decompose(IL, Iz, IF),
                (_.position0 = IL.clone().divideScalar(this.pixelsPerMeter)),
                (_.rotation0 = Iz.clone()),
                IL.divideScalar(this.pixelsPerMeter),
                V.setTranslation(IL.x, IL.y, IL.z).setRotation(Iz),
                z
                  ? G?.scale(
                      1 / this.pixelsPerMeter,
                      1 / this.pixelsPerMeter,
                      1 / this.pixelsPerMeter
                    )
                  : G?.scale(
                      IF.x / this.pixelsPerMeter,
                      IF.y / this.pixelsPerMeter,
                      IF.z / this.pixelsPerMeter
                    );
              let q =
                this.sharedGameControlGlobals.rapierWorld.createRigidBody(V);
              j &&
                this.rigidBodyToMesh.set(q.handle, [
                  _,
                  IF.clone(),
                  k.physics.fusedBody,
                ]);
              let X = !(
                void 0 === k.geometry ||
                "SubdivGeometry" === k.geometry.type ||
                "NonParametricGeometry" === k.geometry.type ||
                "BooleanGeometry" === k.geometry.type ||
                "VectorGeometry" === k.geometry.type ||
                "StarGeometry" === k.geometry.type ||
                "RectangleGeometry" === k.geometry.type ||
                "EllipseGeometry" === k.geometry.type ||
                "TriangleGeometry" === k.geometry.type ||
                "TorusGeometry" === k.geometry.type ||
                "HelixGeometry" === k.geometry.type
              );
              try {
                this.addCollider(q, k.physics, G, I, X);
              } catch {
                try {
                  this.addCollider(q, k.physics, G, I, !1);
                } catch (_) {
                  console.error(_);
                }
              }
              _.rigidBody = q;
            }
          }
          addBoundsTree(_) {
            let I = [];
            if (
              (_.geometry?.getAttribute("position") !== void 0 &&
                _.geometry?.getAttribute("position").count > 0 &&
                I.push(yo(_.geometry, _.shearScale)),
              _.traverseObject(this.gatherChildrenGeom(_, I)),
              _.children.forEach((_) => _.updateMatrixWorld(!0)),
              I.length > 0)
            ) {
              let R = $s(I, !1);
              (_.bvhGeometry = R),
                (_.bvhGeometry.boundsTree = new yw(R)),
                this.sharedGameControlGlobals.entitiesWithTransformAnim.push(_);
            }
          }
          addCollider(_, I, R, B, z = !0) {
            let k;
            if (
              R?.getAttribute("position").count === 0 ||
              R?.getIndex()?.count === 0
            )
              return;
            R &&
              (k =
                "trimesh" === I.colliderType
                  ? iw.ColliderDesc.trimesh(
                      R.getAttribute("position").array,
                      R.getIndex().array
                    )
                  : iw.ColliderDesc.convexMesh(
                      R.getAttribute("position").array,
                      z ? R.getIndex().array : void 0
                    )),
              k
                .setFrictionCombineRule(iw.CoefficientCombineRule.Average)
                .setRestitutionCombineRule(iw.CoefficientCombineRule.Average)
                .setDensity(I.density)
                .setFriction(I.friction)
                .setRestitution(I.restitution);
            let V = this.sharedGameControlGlobals.rapierWorld.createCollider(
              k,
              _
            );
            this.sharedGameControlGlobals.colliderToEntity.set(V.handle, B),
              this.sharedGameControlGlobals.entityToCollisionEvents[
                B.uuid
              ]?.some((_) => "scene" === _.target) &&
                V.setActiveEvents(iw.ActiveEvents.COLLISION_EVENTS);
          }
          gatherChildrenGeom(_, I) {
            return (R, B) => {
              let z;
              if (0 === B) return;
              if (R instanceof AI) {
                if (!R.objectForSample)
                  return (
                    (!0 === R.object.dataPatched.physics.fusedBody &&
                      "dynamic" === R.object.dataPatched.physics.rigidBody) ||
                    void 0
                  );
                if (R.objectForSample.dataPatched.physics.fusedBody) return;
                z = R.object;
              } else if (R instanceof yj) z = R.object;
              else if (((z = R), z.dataPatched.cloner?.hideBase)) return !0;
              let k = z.dataPatched;
              if (
                "visibility" === k.physics.enabled
                  ? !k.visible
                  : !k.physics.enabled
              )
                return !0;
              1 === B
                ? _.hasNonUniformScale
                  ? R.matrixWorld.multiplyMatrices(_.shearScale, R.hiddenMatrix)
                  : R.matrixWorld.copy(R.hiddenMatrix)
                : R.matrixWorld.multiplyMatrices(
                    R.parent.matrixWorld,
                    R.hiddenMatrix
                  ),
                R.matrixWorld.multiply(R.matrix);
              let V = R.geometry;
              V?.getAttribute("position") !== void 0 &&
                I.push(yo(V, R.matrixWorld));
            };
          }
          activate(_) {
            if (this.isEnabled) return;
            (this.isEnabled = !0),
              (this.eventManager = _),
              (this.usePhysics = this.page.data.globalPhysics.usePhysics);
            let I = this.page.playCamera,
              R = !1,
              B = 5,
              z = 8,
              k = 9,
              V = "drag",
              j = this.page.data.publish.gameControlObject,
              G = null !== j ? this.page.find(j) : null,
              q = null;
            if (G)
              for (let _ of G.data.events) {
                if (_.data.disabled || "GameControl" !== _.data.type) break;
                let I = G;
                for (
                  ;
                  this.usePhysics &&
                  (I = I.parent)?.parent !== null &&
                  !I.data.physics?.fusedBody;

                );
                _.data.collisionEnabled && (this.needsCollisionDetection = !0),
                  null === q && (q = _.data);
              }
            if (
              (this.page.traverseEntity((_) => {
                for (let I of _.dataPatched.events)
                  if (!1 === I.data.disabled && "Trigger" === I.data.type)
                    return (this.needsCollisionDetection = !0), !0;
              }),
              G && q)
            ) {
              R = R || q.camera === I.uuid || G.uuid === I.uuid;
              let _ = new DG(
                G,
                this.renderer.domElement,
                q,
                this.eventContext.page.data.globalPhysics,
                this,
                G.uuid !== I.uuid && q.camera === I.uuid,
                I,
                this.page,
                this.sharedAssets
              );
              (this.gameControl = _),
                (B = q.joystickPosLoc),
                (z = q.joystickRotLoc),
                (k = q.jumpTouchButtonLoc),
                (V = q.rotByTouch),
                uu &&
                  q.touchControl &&
                  ((this.joystickToGameControls[B] = "pos"),
                  "walk" === q.moveMode &&
                    (this.joystickToGameControls[k] = "jmp"),
                  "joystick" === V && (this.joystickToGameControls[z] = "rot"));
            }
            if (this.gameControl && this.gameControl.data.navmesh.enabled) {
              let _ = this.gameControl.data;
              if (!this.navigationMeshWrapper) {
                let I;
                (this.navigationMeshWrapper = new Iu(
                  this.usePhysics,
                  this.isExport
                )),
                  (I = Math.floor(
                    (I =
                      "sphere" === _.collider.type
                        ? 2 * _.collider.radius
                        : _.collider.height) /
                      _.navmesh.ch -
                      1
                  )),
                  this.navigationMeshWrapper.init(
                    { ..._.navmesh, walkableHeight: I },
                    this.gameControl,
                    this.eventContext
                  );
              }
            }
            if (!1 === R) {
              let {
                enableRotate: _,
                enablePan: R,
                enableZoom: B,
                autoRotate: z,
                hoverRotatePanMode: k,
              } = this.eventManager.publish.orbitControls;
              (_ || R || B || z || 0 !== k) &&
                ((this.orbitControls = new II(I, this.renderer.domElement, {
                  isExport: this.isExport,
                  isPlayMode: !0,
                })),
                this.orbitControls.addEventListener(
                  "change",
                  this.requestRender
                ),
                this.orbitControls.addEventListener("end", this.requestRender),
                this.orbitControls.addEventListener(
                  "start",
                  this.requestRender
                ),
                this.orbitControls.fromJSON(
                  this.eventManager.publish.orbitControls,
                  this.eventManager.publish.mouseEventTarget
                ),
                (this.orbitControls.useKeyEvents = !1),
                this.orbitControls.addEventListenersToCamera(),
                this.orbitControls.connect(),
                this.orbitControls.update());
            }
            let X =
                this.renderer.domElement.width / this.renderer.getPixelRatio(),
              Q =
                this.renderer.domElement.height / this.renderer.getPixelRatio();
            this.joystickToGameControls.forEach((_, I) => {
              let R = document.body.appendChild(document.createElement("div")),
                [B, z, k] =
                  this.eventManager.eventContext.publish
                    .joystickSizeAndXYOffset[I],
                V = (X - 5 * B) / 4 + B,
                j = {},
                G = "jmp" === _,
                q = G ? 0 : B;
              for (let _ in (I < 10
                ? (I < 5 ? (j.top = q / 2) : (j.bottom = q / 2),
                  (j.left = q / 2 + (I % 5) * V))
                : (10 === I ? (j.left = q / 2) : (j.right = q / 2),
                  (j.top = Q / 2)),
              j.top ? (j.top -= z[1]) : (j.bottom += z[1]),
              j.left ? (j.left += z[0]) : (j.right -= z[0]),
              j))
                j[_] += "px";
              if (G) {
                let _ = R.appendChild(document.createElement("div"));
                Object.assign(_.style, j, {
                  position: "absolute",
                  width: B + "px",
                  height: B + "px",
                  backgroundColor: `rgba(255,255,255,${
                    "show" === k ? 0.4 : 0
                  })`,
                  zIndex: "9999",
                  borderRadius: B + "px",
                  border: "show" === k ? "solid 2px rgba(0, 0, 0, .1)" : "none",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  touchAction: "none",
                });
                let z = (B / 16) * 6.4;
                "show" === k &&
                  (_.innerHTML = `
						<svg width="${z}" height="${
                    0.4 * B
                  }" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
							<path d="M2 10L8 4L14 10" stroke="black" stroke-opacity="40%" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
						</svg>
					`),
                  _.addEventListener("pointerdown", () => {
                    (this.gameControl.movementState.jump = 1),
                      this.requestRender();
                  }),
                  _.addEventListener("touchend", (_) => _.preventDefault()),
                  (this.joysticks[I] = [void 0, R]);
                return;
              }
              let $ = { zone: R, mode: "static", position: j, size: B };
              "hide" === k && ($.restOpacity = 0);
              let et = Pg.create($);
              et.on("move", (I, R) => {
                let B = this.gameControl;
                "pos" === _
                  ? R.force < 0.2
                    ? (B.moveForce = 0)
                    : ((B.movementState.movePosZ = Math.sin(-R.angle.radian)),
                      (B.movementState.movePosX = Math.cos(-R.angle.radian)),
                      R.force > 1.2
                        ? (B.movementState.run = 1)
                        : (B.movementState.run = 0),
                      R.force < 0.3
                        ? (B.moveForce = (R.force - 0.2) / 0.1)
                        : (B.moveForce = 1))
                  : "rot" === _ &&
                    (R.force < 0.2
                      ? (B.rotForce = 0)
                      : ((B.movementState.rotPosX = R.vector.y),
                        (B.movementState.rotPosY = -R.vector.x),
                        R.force < 0.3
                          ? (B.rotForce = (R.force - 0.2) / 0.1)
                          : (B.rotForce = 1))),
                  this.requestRender();
              }),
                et.on("end", (I, R) => {
                  let B = this.gameControl;
                  "pos" === _
                    ? ((B.movementState.movePosZ = 0),
                      (B.movementState.movePosX = 0),
                      (B.moveForce = 1))
                    : "rot" === _ &&
                      ((B.movementState.rotPosX = 0),
                      (B.movementState.rotPosY = 0),
                      (B.rotForce = 1));
                }),
                (this.joysticks[I] = [et, R]);
            }),
              this.markIsDestroyTarget(),
              this.markIsDragObject(),
              this.rebuildBVH(),
              this.initializationCounter++,
              window.setTimeout(() => {
                this.collisionEvents.forEach((_) => (_.disabled = !1));
              }, 80);
          }
          initPhysics() {
            this.sharedGameControlGlobals.rapierWorld?.free(),
              (this.sharedGameControlGlobals.rapierWorld = new iw.World(
                new iw.Vector3(0, this.gravity, 0)
              )),
              (this.events = new iw.EventQueue(!0));
            let _ = [],
              I = [];
            if (
              (this.page.traverseChildren((R) => {
                let B;
                if (R instanceof AI) {
                  if (!R.objectForSample)
                    return (
                      (!0 === R.object.dataPatched.physics.fusedBody &&
                        "dynamic" === R.object.dataPatched.physics.rigidBody) ||
                      void 0
                    );
                  if (R.objectForSample.dataPatched.physics.fusedBody) return;
                  B = R.object;
                } else if (R instanceof yj) B = R.object;
                else {
                  if (R instanceof TP || R instanceof A4) return;
                  if (
                    ((B = R),
                    B.dataPatched.cloner?.disabled === !1 &&
                      B.dataPatched.cloner?.hideBase &&
                      B.dataPatched.physics?.fusedBody !== !0)
                  )
                    return !0;
                }
                let z = B.dataPatched,
                  k;
                for (let _ of z.events)
                  !0 !== _.data.disabled &&
                    "GameControl" === _.data.type &&
                    (k = _.data);
                if (
                  !z.physics ||
                  ("visibility" === z.physics.enabled
                    ? !z.visible
                    : !z.physics.enabled)
                )
                  return !0;
                R.updateMatrixWorldSVD();
                let V = Og(z),
                  j = !1,
                  G = B.userData.hasDestroy,
                  q = B.userData.hasDrag,
                  X = !1;
                for (let _ of z.events)
                  if (!0 !== _.data.disabled) {
                    if ("Collision" === _.data.type) {
                      j = !0;
                      let I = new O6(
                        _.id,
                        _.data,
                        B,
                        this.page,
                        this.sharedAssets,
                        this.eventManager
                      );
                      (I.disabled = !0),
                        this.collisionEvents.push(I),
                        this.sharedGameControlGlobals.entityToCollisionEvents[
                          B.uuid
                        ] &&
                        this.sharedGameControlGlobals.entityToCollisionEvents[
                          B.uuid
                        ].every((I) => I.id !== _.id)
                          ? this.sharedGameControlGlobals.entityToCollisionEvents[
                              B.uuid
                            ].push(I)
                          : (this.sharedGameControlGlobals.entityToCollisionEvents[
                              B.uuid
                            ] = [I]);
                    } else if ("Follow" === _.data.type) {
                      X = !0;
                      let I = _.data.target;
                      R.traverseVisible((_) => {
                        _.userData.isFollowingObj = I;
                      });
                    }
                  }
                "dynamic" === z.physics.rigidBody &&
                  !1 === z.physics.fusedBody &&
                  (R.matrixWorldFusedFalse = R.matrixWorld.clone());
                let Q = R.geometry;
                if (void 0 !== k) {
                  let _,
                    I = iw.RigidBodyDesc.kinematicPositionBased();
                  (R.hasNonUniformScale
                    ? R.matrixWorldRigid
                    : R.matrixWorld
                  ).decompose(IL, Iz, IF),
                    (R.position0 = IL.clone().divideScalar(
                      this.pixelsPerMeter
                    )),
                    (R.rotation0 = Iz.clone()),
                    IL.divideScalar(this.pixelsPerMeter),
                    I.setTranslation(IL.x, IL.y, IL.z).setRotation(Iz);
                  let V =
                    this.sharedGameControlGlobals.rapierWorld.createRigidBody(
                      I
                    );
                  (R.rigidBody = V),
                    (_ =
                      "sphere" === k.collider.type
                        ? iw.ColliderDesc.ball(
                            k.collider.radius / this.pixelsPerMeter
                          )
                        : "capsule" === k.collider.type
                        ? iw.ColliderDesc.capsule(
                            (k.collider.height / 2 - k.collider.radius) /
                              this.pixelsPerMeter,
                            k.collider.radius / this.pixelsPerMeter
                          )
                        : iw.ColliderDesc.cuboid(
                            k.collider.width / this.pixelsPerMeter / 2,
                            k.collider.height / this.pixelsPerMeter / 2,
                            k.collider.depth / this.pixelsPerMeter / 2
                          ))
                      .setFrictionCombineRule(iw.CoefficientCombineRule.Average)
                      .setRestitutionCombineRule(
                        iw.CoefficientCombineRule.Average
                      )
                      .setDensity(z.physics.density)
                      .setFriction(z.physics.friction)
                      .setRestitution(z.physics.restitution);
                  let j =
                    this.sharedGameControlGlobals.rapierWorld.createCollider(
                      _,
                      V
                    );
                  this.sharedGameControlGlobals.colliderToEntity.set(
                    j.handle,
                    B
                  ),
                    IL.fromArray(k.collider.position)
                      .multiply(IF.setFromMatrixScale(B.matrixWorld))
                      .divideScalar(this.pixelsPerMeter),
                    j.setTranslationWrtParent(IL);
                  let G = new rz().setFromEuler(
                    new sg().setFromVector3(
                      new rF().fromArray(k.collider.rotation)
                    )
                  );
                  j.setRotationWrtParent(G),
                    j.setActiveEvents(iw.ActiveEvents.COLLISION_EVENTS),
                    this.generateSensorColliderDescs(B, !0);
                } else
                  "dynamic" === z.physics.rigidBody || V || X || G || q || j
                    ? (this.addRigidBody(R, B, {
                        hasFollow: X,
                        hasTransformAnim: V,
                        hasDrag: q,
                      }),
                      this.generateSensorColliderDescs(B, z.physics.fusedBody))
                    : (Q && _.push(yo(Q, R.matrixWorld)),
                      z.physics.fusedBody &&
                        R.traverseObject((I, R) => {
                          let B;
                          if (0 === R) return;
                          if (I instanceof AI) {
                            if (!I.objectForSample)
                              return (
                                (!0 ===
                                  I.object.dataPatched.physics.fusedBody &&
                                  "dynamic" ===
                                    I.object.dataPatched.physics.rigidBody) ||
                                void 0
                              );
                            if (I.objectForSample.dataPatched.physics.fusedBody)
                              return;
                            B = I.object;
                          } else {
                            if (I instanceof TP || I instanceof A4) return;
                            if (I instanceof yj) B = I.object;
                            else if (((B = I), B.dataPatched.cloner?.hideBase))
                              return !0;
                          }
                          let z = B.dataPatched;
                          if (
                            "visibility" === z.physics.enabled
                              ? !z.visible
                              : !z.physics.enabled
                          )
                            return !0;
                          let k = I.geometry;
                          k?.getAttribute("position") !== void 0 &&
                            _.push(yo(k, I.matrixWorld));
                        }),
                      this.generateSensorColliderDescs(
                        B,
                        z.physics.fusedBody,
                        I
                      ));
                if (z.physics?.fusedBody === !0 || k) return !0;
              }),
              0 === _.length)
            )
              return;
            let R = $s(_);
            R.scale(
              1 / this.pixelsPerMeter,
              1 / this.pixelsPerMeter,
              1 / this.pixelsPerMeter
            );
            let B = iw.RigidBodyDesc.fixed(),
              z = this.sharedGameControlGlobals.rapierWorld.createRigidBody(B),
              k = iw.ColliderDesc.trimesh(
                R.getAttribute("position").array,
                R.getIndex().array
              )
                .setFrictionCombineRule(iw.CoefficientCombineRule.Multiply)
                .setRestitutionCombineRule(iw.CoefficientCombineRule.Multiply)
                .setFriction(1)
                .setRestitution(1);
            for (let [
              _,
              R,
            ] of (this.sharedGameControlGlobals.rapierWorld.createCollider(
              k,
              z
            ),
            I)) {
              let I = this.sharedGameControlGlobals.rapierWorld.createCollider(
                _,
                z
              );
              this.sensorToTriggerEvent[I.handle] = R;
            }
          }
          updatePositions() {
            return (
              (this.nActiveRigidBodies = 0),
              this.sharedGameControlGlobals.rapierWorld.forEachRigidBody(
                this.processRigidBody
              ),
              this.nActiveRigidBodies > 0
            );
          }
          rebuildBVH() {
            this.usePhysics
              ? this.initPhysics()
              : (this.page.traverseEntity((_) => {
                  for (let I of _.dataPatched.events)
                    if ("Trigger" === I.data.type && !0 !== I.data.disabled) {
                      let R = new IR(
                          I.id,
                          I.data,
                          _,
                          this.page,
                          this.sharedAssets,
                          this.eventManager
                        ),
                        B = new sa().compose(
                          Ij.fromArray(I.data.position),
                          Iq.setFromEuler(IV.fromArray(I.data.rotation)),
                          IW
                        );
                      if ("box" === I.data.triggerZone) {
                        let z = new rU();
                        z.min.fromArray(I.data.size).multiplyScalar(-0.5),
                          z.max.fromArray(I.data.size).multiplyScalar(0.5),
                          this.sharedGameControlGlobals.triggers.push([
                            z,
                            B,
                            _,
                            R,
                          ]);
                      } else
                        this.sharedGameControlGlobals.triggers.push([
                          I.data.radius,
                          B,
                          _,
                          R,
                        ]);
                    }
                }),
                this.needsCollisionDetection && this.initBVH());
          }
          disconnectEvents() {
            this.collisionEvents.forEach((_) => _.disconnect()),
              this.sharedGameControlGlobals.triggers.forEach((_) =>
                _[3].disconnect()
              ),
              (this.sharedGameControlGlobals.triggers.length = 0);
          }
          deactivate() {
            if (this.isEnabled) {
              for (let _ of ((this.isEnabled = !1),
              this.page.traverse((_) => {
                _.matrixWorldFusedFalse && (_.matrixWorldFusedFalse = void 0),
                  _.rigidBody && (_.rigidBody = void 0),
                  _.position0 && (_.position0 = void 0),
                  _.rotation0 && (_.rotation0 = void 0);
              }),
              this.sharedGameControlGlobals.rapierWorld?.free(),
              (this.sharedGameControlGlobals.rapierWorld = void 0),
              (this.sharedGameControlGlobals.staticMeshBVH = void 0),
              (this.accumulator = 0),
              (this.sharedGameControlGlobals.entitiesWithTransformAnim = []),
              this.disconnectEvents(),
              this.gameControl?.reset(),
              this.gameControl?.dispose(),
              (this.gameControl = null),
              (this.initializationCounter = -1),
              this.joysticks.forEach(([_, I]) => {
                _?.destroy(), I.remove();
              }),
              (this.joystickToGameControls = []),
              (this.joysticks = []),
              this.orbitControls &&
                (this.orbitControls.dispose(), (this.orbitControls = void 0)),
              this.navigationMeshWrapper?.dispose(),
              (this.navigationMeshWrapper = void 0),
              Object.values(
                this.sharedGameControlGlobals.entityToCollisionEvents
              )))
                _.forEach((_) => _.disconnect());
              (this.sharedGameControlGlobals.entityToCollisionEvents = {}),
                this.page.updateMatrixWorld(!0);
            }
          }
          update(_, I, R) {
            if (!this.isEnabled) return !0;
            let B = !0;
            if (
              (void 0 !== this.orbitControls &&
                this.orbitControls.needsUpdate &&
                (B = !this.orbitControls.update()),
              this.initializationCounter >= 0 && this.initializationCounter < 2
                ? (this.initializationCounter++, (B = !1))
                : 2 === this.initializationCounter &&
                  this.gameControl &&
                  (B = !this.gameControl.update(_, I, R) && B),
              !1 === this.usePhysics && this.checkTrigger(),
              this.usePhysics)
            ) {
              if (0 === _) B = this.stepPhysics() && B;
              else {
                let I = _ / 1e3;
                I < 0.016666666666666666 &&
                  I > 0.009166666666666667 &&
                  (I = 0.016666666666666666),
                  (this.accumulator += I);
                let R = performance.now(),
                  z = 0;
                for (
                  ;
                  this.accumulator >= 0.016666666666666666 &&
                  z < 6 &&
                  ((B = this.stepPhysics() && B),
                  (this.accumulator -= 0.016666666666666666),
                  z++,
                  !(performance.now() - R > 16.666666666666668));

                );
                this.accumulator = this.accumulator % 0.016666666666666666;
              }
            }
            return B;
          }
          stepPhysics() {
            for (let _ of this.sharedGameControlGlobals
              .entitiesWithTransformAnim)
              (_.hasNonUniformScale
                ? _.matrixWorldRigid
                : _.matrixWorld
              ).decompose(IL, Iz, IF),
                Ik.setFromQuaternion(Iz),
                void 0 === _.prevR
                  ? ((_.prevR = Ik.clone()), (_.prevT = IL.clone()))
                  : (_.prevR.copy(Ik), _.prevT.copy(IL)),
                _.rigidBody &&
                  (_.rigidBody.setNextKinematicTranslation(
                    IL.divideScalar(this.pixelsPerMeter)
                  ),
                  _.rigidBody.setNextKinematicRotation(Iz));
            return (
              this.sharedGameControlGlobals.rapierWorld.step(this.events),
              this.events?.drainCollisionEvents(this.handleCollisionEvents),
              !this.updatePositions()
            );
          }
          dispatchCollisionEvent(_, I, R) {
            let B =
                this.sharedGameControlGlobals.rapierWorld?.getCollider(
                  R
                )._parent,
              z;
            if (I.cloner) {
              for (let _ of I.cloner.children)
                if (_.rigidBody === B) {
                  z = _;
                  break;
                }
            }
            _.dispatch(z), I.dispatchEvent(IJ);
          }
          updateUseWindowEvents(_) {
            this.orbitControls?.updateUseWindowEvents(_);
          }
          generateSensorColliderDescs(_, I, R) {
            let B = IX.copy(_.matrixWorld).invert();
            _.traverseEntity((z, k) => {
              if (!1 === I && 1 === k) return !0;
              for (let I of z.dataPatched.events)
                if ("Trigger" === I.data.type && !0 !== I.data.disabled) {
                  let k = new IR(
                      I.id,
                      I.data,
                      z,
                      this.page,
                      this.sharedAssets,
                      this.eventManager
                    ),
                    V;
                  if (
                    ((V =
                      "box" === I.data.triggerZone
                        ? iw.ColliderDesc.cuboid(
                            ...I.data.size.map(
                              (_) => _ / (2 * this.pixelsPerMeter)
                            )
                          )
                        : iw.ColliderDesc.ball(
                            I.data.radius / this.pixelsPerMeter
                          ))
                      .setDensity(0)
                      .setSensor(!0)
                      .setActiveEvents(iw.ActiveEvents.COLLISION_EVENTS),
                    Ij.fromArray(I.data.position),
                    Iq.setFromEuler(IV.fromArray(I.data.rotation)),
                    IY.compose(Ij, Iq, IW).premultiply(z.matrixWorld),
                    R
                      ? (IY.decompose(Ij, Iq, IH),
                        V.setActiveCollisionTypes(
                          iw.ActiveCollisionTypes.KINEMATIC_FIXED |
                            iw.ActiveCollisionTypes.DYNAMIC_FIXED
                        ))
                      : (IY.premultiply(B).decompose(Ij, Iq, IH),
                        _.rigidBody.bodyType() === iw.RigidBodyType.Dynamic ||
                          (_.rigidBody.bodyType() === iw.RigidBodyType.Fixed
                            ? V.setActiveCollisionTypes(
                                iw.ActiveCollisionTypes.KINEMATIC_FIXED |
                                  iw.ActiveCollisionTypes.DYNAMIC_FIXED
                              )
                            : V.setActiveCollisionTypes(
                                iw.ActiveCollisionTypes.KINEMATIC_KINEMATIC |
                                  iw.ActiveCollisionTypes.DYNAMIC_KINEMATIC
                              ))),
                    Ij.divideScalar(this.pixelsPerMeter),
                    V.setTranslation(Ij.x, Ij.y, Ij.z),
                    V.setRotation(Iq),
                    R)
                  )
                    R.push([V, k]);
                  else {
                    let I =
                      this.sharedGameControlGlobals.rapierWorld.createCollider(
                        V,
                        _.rigidBody
                      );
                    this.sensorToTriggerEvent[I.handle] = k;
                  }
                }
            });
          }
          checkTrigger() {
            let _;
            for (
              let I = 0;
              I < this.sharedGameControlGlobals.triggers.length;
              I++
            ) {
              let [R, B, z, k] = this.sharedGameControlGlobals.triggers[I];
              for (
                let I = 0;
                I <
                this.sharedGameControlGlobals.entitiesWithTransformAnim.length;
                I++
              ) {
                let V =
                  this.sharedGameControlGlobals.entitiesWithTransformAnim[I];
                if (
                  z === V ||
                  !1 === k.isValidTriggeringObject(bG.is(V) ? V : V.object)
                )
                  continue;
                let j = IX.copy(z.matrixWorld)
                    .decompose(Ij, IZ, IH)
                    .compose(Ij, IZ, IW)
                    .multiply(B),
                  G = IY.copy(V.matrixWorld).invert().multiply(j);
                R instanceof rU
                  ? (_ = V.bvhGeometry.boundsTree.intersectsBox(R, G))
                  : ((IK.radius = R),
                    IK.center.setFromMatrixPosition(G),
                    (_ = V.bvhGeometry.boundsTree.intersectsSphere(IK))),
                  _
                    ? -1 === k.currentIntersectedObjects.indexOf(V) &&
                      (k.currentIntersectedObjects.push(V),
                      k.dispatch(),
                      z.dispatchEvent(I$))
                    : (k.currentIntersectedObjects =
                        k.currentIntersectedObjects.filter((_) => _ !== V));
              }
            }
          }
        };
      function HN(_) {
        let I = this._clip.duration,
          R = this._clip.start ?? 0,
          B = this.loop,
          z = this.time + _,
          k = this._loopCount,
          V = 2202 === B;
        if (0 === _) return -1 === k ? z : V && (1 & k) == 1 ? I - (z - R) : z;
        if (2200 === B) {
          -1 === k && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
          e: {
            if (z >= I) z = I;
            else if (z < 0) z = 0;
            else {
              this.time = z;
              break e;
            }
            this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
              (this.time = z),
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: _ < 0 ? -1 : 1,
              });
          }
        } else {
          if (
            (-1 === k &&
              (_ >= 0
                ? ((k = 0), this._setEndings(!0, 0 === this.repetitions, V))
                : this._setEndings(0 === this.repetitions, !0, V)),
            z >= I || z < R)
          ) {
            let B = Math.floor((z - R) / (I - R));
            (z -= (I - R) * B), (k += Math.abs(B));
            let j = this.repetitions - k;
            if (j <= 0)
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                V || ((z = _ > 0 ? I : R), 1 === this.repetitions && (z = I)),
                (this.time = z),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: _ > 0 ? 1 : -1,
                });
            else {
              if (1 === j) {
                let I = _ < 0;
                this._setEndings(I, !I, V);
              } else this._setEndings(!1, !1, V);
              (this._loopCount = k),
                (this.time = z),
                this._mixer.dispatchEvent({
                  type: "loop",
                  action: this,
                  loopDelta: B,
                });
            }
          } else this.time = z;
          if (V && (1 & k) == 1) return I - (z - R);
        }
        return z;
      }
      var I1 = !1,
        I3 = class {
          constructor(_, I, R, B) {
            (this.scene = _),
              (this.requestRender = I),
              (this.updateDisplayProgress = R),
              (this.animationInspectorState = B),
              (this.clipIdToAction = {}),
              (this.activeClip = null),
              (this.needsUpdate = !1),
              (this.addClip = (_) => {
                "Empty" === _.data.type &&
                  _.data.animations &&
                  _.data.animations.forEach((I, R) => {
                    let B = I[0] + "/";
                    if (
                      (Array.isArray(_.identity)
                        ? (B += _.identity[0])
                        : (B += _.uuid),
                      this.clipIdToAction[B])
                    )
                      return;
                    let z = o0.parse(JSON.parse(I[2]));
                    _.animations[R] = z;
                    let k = this.mixer.clipAction(z, _);
                    !1 === I1 &&
                      ((Object.getPrototypeOf(k)._updateTime = HN), (I1 = !0)),
                      (k.clampWhenFinished = !0),
                      (this.clipIdToAction[B] = k);
                  });
              }),
              (this.mixer = new lF(_)),
              this.scene.traverseEntity(this.addClip);
          }
          deleteClip(_, I) {
            let R = this.scene.find(I);
            if (!R) return;
            let B = R.animations.find((I) => I.uuid === _);
            if (!B) return;
            let z = this.clipIdToAction[_];
            z &&
              (z.stop(),
              this.mixer.uncacheClip(B),
              delete this.clipIdToAction[_],
              (R.animations = R.animations.filter((I) => I.uuid !== _)));
          }
          get isPlaying() {
            return Object.values(this.clipIdToAction).some((_) =>
              _.isRunning()
            );
          }
          playFromInspector(_) {
            this.mixer.stopAllAction();
            let I = this.clipIdToAction[_];
            I &&
              (I.play(), (this.activeClip = I.getClip()), this.requestRender());
          }
          onExitPlayMode() {
            Object.values(this.clipIdToAction).forEach((_) => {
              (_.repetitions = 1 / 0), (_.loop = 2201);
            }),
              this.mixer.stopAllAction(),
              this.requestRender();
          }
          play(_) {
            let I = _.clipId + "/" + _.object,
              R = this.clipIdToAction[I];
            if (R)
              return (
                _ &&
                  (_.repeat >= 0 && (R.repetitions = _.repeat + 1),
                  "pingpong" === _.direction &&
                    0 !== _.repeat &&
                    (R.loop = 2202)),
                R.play(),
                (R.paused = !1),
                this.requestRender(),
                R
              );
          }
          resumeFromInspector(_) {
            let I = this.clipIdToAction[_];
            I && (I.play(), (I.paused = !1), this.requestRender());
          }
          pauseFromInspector(_) {
            let I = this.clipIdToAction[_];
            I && (I.paused = !0);
          }
          stop() {
            this.mixer.stopAllAction(), this.requestRender();
          }
          update(_) {
            if (this.needsUpdate) this.needsUpdate = !1;
            else if (
              !1 === this.isPlaying ||
              this.animationInspectorState?.isScrubbing
            )
              return;
            this.mixer.update(_ / 1e3),
              this.activeClip &&
                this.updateDisplayProgress(
                  Math.round(
                    ((this.mixer.time / this.activeClip.duration) *
                      this.maxFrames) %
                      this.maxFrames
                  )
                ),
              this.requestRender();
          }
          get maxFrames() {
            return this.activeClip?.tracks[0]?.times.length ?? 0;
          }
          setProgressFromInspector(_, I) {
            if (!this.clipIdToAction[I]) return;
            this.activeClip !== this.clipIdToAction[I].getClip() &&
              this.playFromInspector(I);
            let R = this.clipIdToAction[I].paused;
            (this.clipIdToAction[I].paused = !1),
              this.mixer.setTime(
                Math.min(this.maxFrames ? _ / this.maxFrames : 0, 0.9999) *
                  this.activeClip.duration
              ),
              this.requestRender(),
              R && (this.clipIdToAction[I].paused = !0);
          }
        },
        I4 = new WeakMap(),
        I5 = class extends o4 {
          constructor(_) {
            super(_),
              (this.decoderPath = ""),
              (this.decoderConfig = {}),
              (this.decoderBinary = null),
              (this.decoderPending = null),
              (this.workerLimit = 4),
              (this.workerPool = []),
              (this.workerNextTaskID = 1),
              (this.workerSourceURL = ""),
              (this.defaultAttributeIDs = {
                position: "POSITION",
                normal: "NORMAL",
                color: "COLOR",
                uv: "TEX_COORD",
              }),
              (this.defaultAttributeTypes = {
                position: "Float32Array",
                normal: "Float32Array",
                color: "Float32Array",
                uv: "Float32Array",
              });
          }
          setDecoderPath(_) {
            return (this.decoderPath = _), this;
          }
          setDecoderConfig(_) {
            return (this.decoderConfig = _), this;
          }
          setWorkerLimit(_) {
            return (this.workerLimit = _), this;
          }
          load(_, I, R, B) {
            let z = new o8(this.manager);
            z.setPath(this.path),
              z.setResponseType("arraybuffer"),
              z.setRequestHeader(this.requestHeader),
              z.setWithCredentials(this.withCredentials),
              z.load(
                _,
                (_) => {
                  this.decodeDracoFile(_, I).catch(B);
                },
                R,
                B
              );
          }
          decodeDracoFile(_, I, R, B) {
            let z = {
              attributeIDs: R || this.defaultAttributeIDs,
              attributeTypes: B || this.defaultAttributeTypes,
              useUniqueIDs: !!R,
            };
            return this.decodeGeometry(_, z).then(I);
          }
          decodeGeometry(_, I) {
            let R = JSON.stringify(I);
            if (I4.has(_)) {
              let I = I4.get(_);
              if (I.key === R) return I.promise;
              if (0 === _.byteLength)
                throw Error(
                  "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
                );
            }
            let B,
              z = this.workerNextTaskID++,
              k = _.byteLength,
              V = this._getWorker(z, k)
                .then(
                  (R) => (
                    (B = R),
                    new Promise((R, k) => {
                      (B._callbacks[z] = { resolve: R, reject: k }),
                        B.postMessage(
                          { type: "decode", id: z, taskConfig: I, buffer: _ },
                          [_]
                        );
                    })
                  )
                )
                .then((_) => this._createGeometry(_.geometry));
            return (
              V.catch(() => !0).then(() => {
                B && z && this._releaseTask(B, z);
              }),
              I4.set(_, { key: R, promise: V }),
              V
            );
          }
          _createGeometry(_) {
            let I = new ai();
            _.index && I.setIndex(new s0(_.index.array, 1));
            for (let R = 0; R < _.attributes.length; R++) {
              let B = _.attributes[R],
                z = B.name,
                k = B.array,
                V = B.itemSize;
              I.setAttribute(z, new s0(k, V));
            }
            return I;
          }
          _loadLibrary(_, I) {
            let R = new o8(this.manager);
            return (
              R.setPath(this.decoderPath),
              R.setResponseType(I),
              R.setWithCredentials(this.withCredentials),
              new Promise((I, B) => {
                R.load(_, I, void 0, B);
              })
            );
          }
          preload() {
            return this._initDecoder(), this;
          }
          _initDecoder() {
            if (this.decoderPending) return this.decoderPending;
            let _ =
                "object" != typeof WebAssembly ||
                "js" === this.decoderConfig.type,
              I = [];
            return (
              _
                ? I.push(this._loadLibrary("draco_decoder.js", "text"))
                : (I.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
                  I.push(
                    this._loadLibrary("draco_decoder.wasm", "arraybuffer")
                  )),
              (this.decoderPending = Promise.all(I).then((I) => {
                let R = I[0];
                _ || (this.decoderConfig.wasmBinary = I[1]);
                let B = kJ.toString(),
                  z = [
                    "/* draco decoder */",
                    R,
                    "",
                    "/* worker */",
                    B.substring(B.indexOf("{") + 1, B.lastIndexOf("}")),
                  ].join(`
`);
                this.workerSourceURL = URL.createObjectURL(new Blob([z]));
              })),
              this.decoderPending
            );
          }
          _getWorker(_, I) {
            return this._initDecoder().then(() => {
              if (this.workerPool.length < this.workerLimit) {
                let _ = new Worker(this.workerSourceURL);
                (_._callbacks = {}),
                  (_._taskCosts = {}),
                  (_._taskLoad = 0),
                  _.postMessage({
                    type: "init",
                    decoderConfig: this.decoderConfig,
                  }),
                  (_.onmessage = function (I) {
                    let R = I.data;
                    switch (R.type) {
                      case "decode":
                        _._callbacks[R.id].resolve(R);
                        break;
                      case "error":
                        _._callbacks[R.id].reject(R);
                        break;
                      default:
                        console.error(
                          'THREE.DRACOLoader: Unexpected message, "' +
                            R.type +
                            '"'
                        );
                    }
                  }),
                  this.workerPool.push(_);
              } else
                this.workerPool.sort(function (_, I) {
                  return _._taskLoad > I._taskLoad ? -1 : 1;
                });
              let R = this.workerPool[this.workerPool.length - 1];
              return (R._taskCosts[_] = I), (R._taskLoad += I), R;
            });
          }
          _releaseTask(_, I) {
            (_._taskLoad -= _._taskCosts[I]),
              delete _._callbacks[I],
              delete _._taskCosts[I];
          }
          debug() {
            console.log(
              "Task load: ",
              this.workerPool.map((_) => _._taskLoad)
            );
          }
          dispose() {
            for (let _ = 0; _ < this.workerPool.length; ++_)
              this.workerPool[_].terminate();
            return (
              (this.workerPool.length = 0),
              "" !== this.workerSourceURL &&
                URL.revokeObjectURL(this.workerSourceURL),
              this
            );
          }
        };
      function kJ() {
        let _, I;
        onmessage = function (R) {
          let B = R.data;
          switch (B.type) {
            case "init":
              (_ = B.decoderConfig),
                (I = new Promise(function (I) {
                  (_.onModuleLoaded = function (_) {
                    I({ draco: _ });
                  }),
                    DracoDecoderModule(_);
                }));
              break;
            case "decode":
              let z = B.buffer,
                k = B.taskConfig;
              I.then((_) => {
                let I = _.draco,
                  R = new I.Decoder(),
                  V = new I.DecoderBuffer();
                V.Init(new Int8Array(z), z.byteLength);
                try {
                  let _ = (function (_, I, R, B) {
                      let z = B.attributeIDs,
                        k = B.attributeTypes,
                        V,
                        j,
                        G = I.GetEncodedGeometryType(R);
                      if (G === _.TRIANGULAR_MESH)
                        (V = new _.Mesh()), (j = I.DecodeBufferToMesh(R, V));
                      else if (G === _.POINT_CLOUD)
                        (V = new _.PointCloud()),
                          (j = I.DecodeBufferToPointCloud(R, V));
                      else
                        throw Error(
                          "THREE.DRACOLoader: Unexpected geometry type."
                        );
                      if (!j.ok() || 0 === V.ptr)
                        throw Error(
                          "THREE.DRACOLoader: Decoding failed: " + j.error_msg()
                        );
                      let q = { index: null, attributes: [] };
                      for (let R in z) {
                        let j = self[k[R]],
                          G,
                          X;
                        if (B.useUniqueIDs)
                          (X = z[R]), (G = I.GetAttributeByUniqueId(V, X));
                        else {
                          if (-1 === (X = I.GetAttributeId(V, _[z[R]])))
                            continue;
                          G = I.GetAttribute(V, X);
                        }
                        q.attributes.push(
                          (function (_, I, R, B, z, k) {
                            let V = k.num_components(),
                              j = R.num_points() * V,
                              G = j * z.BYTES_PER_ELEMENT,
                              q = (function (_, I) {
                                switch (I) {
                                  case Float32Array:
                                    return _.DT_FLOAT32;
                                  case Int8Array:
                                    return _.DT_INT8;
                                  case Int16Array:
                                    return _.DT_INT16;
                                  case Int32Array:
                                    return _.DT_INT32;
                                  case Uint8Array:
                                    return _.DT_UINT8;
                                  case Uint16Array:
                                    return _.DT_UINT16;
                                  case Uint32Array:
                                    return _.DT_UINT32;
                                }
                              })(_, z),
                              X = _._malloc(G);
                            I.GetAttributeDataArrayForAllPoints(R, k, q, G, X);
                            let Q = new z(_.HEAPF32.buffer, X, j).slice();
                            return (
                              _._free(X), { name: B, array: Q, itemSize: V }
                            );
                          })(_, I, V, R, j, G)
                        );
                      }
                      return (
                        G === _.TRIANGULAR_MESH &&
                          (q.index = (function (_, I, R) {
                            let B = 3 * R.num_faces(),
                              z = 4 * B,
                              k = _._malloc(z);
                            I.GetTrianglesUInt32Array(R, z, k);
                            let V = new Uint32Array(
                              _.HEAPF32.buffer,
                              k,
                              B
                            ).slice();
                            return _._free(k), { array: V, itemSize: 1 };
                          })(_, I, V)),
                        _.destroy(V),
                        q
                      );
                    })(I, R, V, k),
                    z = _.attributes.map((_) => _.array.buffer);
                  _.index && z.push(_.index.array.buffer),
                    self.postMessage(
                      { type: "decode", id: B.id, geometry: _ },
                      z
                    );
                } catch (_) {
                  console.error(_),
                    self.postMessage({
                      type: "error",
                      id: B.id,
                      error: _.message,
                    });
                } finally {
                  I.destroy(V), I.destroy(R);
                }
              });
          }
        };
      }
      async function zJ(_) {
        if (i_) {
          let I = {
              attributeIDs: i_.defaultAttributeIDs,
              attributeTypes: i_.defaultAttributeTypes,
              useUniqueIDs: !1,
            },
            R;
          try {
            R = await i_.decodeGeometry(new Int8Array(_).buffer, I);
          } catch (_) {
            console.error(_);
          }
          if (R)
            return {
              index: R.index ? { array: R.index.array } : void 0,
              attributes: Object.entries(R.attributes).map(([_, I]) => ({
                name: _,
                itemSize: I.itemSize,
                array: I.array,
              })),
            };
        }
        return null;
      }
      async function qN(_, I) {
        let [R, B] = n1(fc.deserialize(new Uint8Array(_)));
        c0(R);
        let z = [];
        for (let _ of (R.scene.objects.traverse((_, I) => {
          "Mesh" === I.type &&
            "NonParametricGeometry" === I.geometry.type &&
            void 0 !== I.geometry.data.draco &&
            z.push(I);
        }),
        z.length &&
          (await (i_ ||
            (i_ = new I5())
              .setDecoderPath(
                "https://www.gstatic.com/draco/versioned/decoders/1.5.2/"
              )
              .preload(),
          i_.decoderPending)),
        z)) {
          let I = await zJ(kr(_.geometry.data.draco));
          if (I) {
            I.index &&
              (_.geometry.data.index = {
                array: I.index.array,
                itemSize: 1,
                normalized: !1,
                type: "Uint32Array",
              });
            let R = {};
            I.attributes.forEach(({ name: _, array: I, itemSize: B }) => {
              R[_] = {
                array: I,
                itemSize: B,
                type: "Float32Array",
                normalized: !1,
              };
            }),
              (_.geometry.data.attributes = R),
              (_.geometry.data.draco = void 0);
          }
        }
        return I && I(R), B.result().data;
      }
      var I6 = class {
          constructor(_, I, R, B, z, k, V) {
            (this.id = _),
              (this.data = I),
              (this.dataEvent = R),
              (this.object = B),
              (this.stage = !1),
              (this.actions = Mr(R, I.actions, z, k, V, B));
          }
          disconnect() {
            dr(this.actions);
          }
          dispatchIn() {
            this.actions.Audio.forEach((_) => _.dispatchBasic()),
              this.actions.Particles.forEach((_) => _.dispatchBasic()),
              this.actions.Video.forEach((_) => _.dispatchBasic()),
              this.actions.Create.forEach((_) => _.dispatch()),
              this.actions.Destroy.forEach((_) => _.dispatch()),
              this.actions.Reset.forEach((_) => _.dispatch()),
              this.actions.Link.forEach((_) => _.dispatch()),
              this.actions.Transition.forEach((_) => {
                _.object.currentTransitionEvent !== this &&
                  ((_.object.currentTransitionEvent = this), _.init());
              }),
              this.actions.Transition.forEach((_) => _.toggle()),
              this.actions.Animation.forEach((_) => _.play()),
              this.actions.SwitchCamera.forEach((_) => _.play()),
              this.actions.SceneTransition.forEach((_) => _.dispatch()),
              this.actions.SetVariable.forEach((_) => _.checkConditions()),
              this.actions.SetVariable.forEach((_) => _.dispatch()),
              this.actions.DynamicVariablePlay.forEach((_) => _.dispatch());
          }
          dispatchOut() {
            this.actions.Transition.forEach((_) => {
              _.toggle();
            });
          }
        },
        I8 = class extends DZ {
          constructor(_, I) {
            super(_),
              (this.eventManager = I),
              (this.breakpoints = []),
              (this.resize = (_, I) => {
                this.breakpoints.forEach((R) => {
                  let B = mc.deviceToSize(R.data.size),
                    z = "horizontal" === R.dataEvent.orientation ? _ : I,
                    k;
                  switch (R.data.operator) {
                    case "<":
                      k = z < B[0];
                      break;
                    case ">":
                      k = z > B[0];
                      break;
                    case "<>":
                      k = z > B[0] && z < B[1];
                  }
                  R.stage !== k &&
                    ((R.stage = k), R.stage ? R.dispatchIn() : R.dispatchOut());
                });
              }),
              (this.onResizeObserver = new ResizeObserver((_) => {
                for (let I of _) {
                  let { width: _, height: R } = I.contentRect;
                  this.resize(_, R);
                }
              }));
          }
          connect() {
            let { page: _, sharedAssets: I, domElement: R } = this.eventContext;
            this.onResizeObserver.observe(R);
            let s = (R) => {
              if (!(!R.visible || !R.data?.events.length))
                for (let { data: B } of R.data.events)
                  B.disabled ||
                    ("Resize" === B.type &&
                      B.breakpoints.forEach(({ data: z, id: k }) => {
                        try {
                          let V = new I6(k, z, B, R, _, I, this.eventManager);
                          this.breakpoints.push(V);
                        } catch (_) {}
                      }));
            };
            _.traverseEntity((_) => {
              (_ instanceof Ti || _ instanceof C6) &&
                _.frame?.traverse((_) => {
                  s(_);
                }),
                s(_);
            });
          }
          disconnect() {
            this.onResizeObserver.disconnect(),
              this.breakpoints.forEach((_) => {
                _.disconnect();
              }),
              (this.breakpoints = []);
          }
        },
        I7 = class {
          constructor(_, I, R, B, z) {
            (this.publish = _),
              (this.controlsManager = I),
              (this.animationControls = R),
              (this.eventContext = B),
              (this.sharedVariables = z),
              (this.isEnabled = !1),
              (this.activateCount = 0),
              (this.needsMouse = !1),
              (this.needsRaycast = !1),
              (this.onTouchMovePreventScroll = (_) => {
                (_.touches.length > 1 || this.preventTouchScroll) &&
                  _.preventDefault();
              }),
              (this.onMouseWheelPreventScroll = (_) => {
                this.preventScroll && _.preventDefault();
              }),
              (this.onMouseMove = (_) => {
                this.eventContext.sharedAssets.mouseProperty = {
                  ...this.getMousePosition(_),
                  pressed: _.buttons > 0,
                };
              }),
              (this.onMouseDown = (_) => {
                this.eventContext.sharedAssets.mouseProperty = {
                  ...this.getMousePosition(_),
                  pressed: !0,
                };
              }),
              (this.onMouseUp = (_) => {
                this.eventContext.sharedAssets.mouseProperty = {
                  ...this.getMousePosition(_),
                  pressed: !1,
                };
              }),
              (this.getMousePosition = (_) => {
                let { domRect: I } = this.eventContext,
                  { pageX: R, pageY: B } =
                    _.touches?.length > 0 ? _.touches[0] : _;
                return {
                  x: R - (I.left + window.scrollX),
                  y: B - (I.top + window.scrollY),
                };
              }),
              (this.stopRaycast = _.stopRaycast),
              (this.preventScroll = _.preventScroll),
              (this.preventTouchScroll = _.preventTouchScroll),
              (this.hideCursor = _.hideCursor),
              (this.requestRender = B.requestRender);
          }
          activate() {
            if (this.isEnabled) return;
            (this.isEnabled = !0),
              this.initializeActionsDependentStates(),
              this.needsMouse &&
                (this.eventContext.domElement.addEventListener(
                  "pointermove",
                  this.onMouseMove
                ),
                this.eventContext.domElement.addEventListener(
                  "pointerdown",
                  this.onMouseDown
                )),
              (this.handlers = {
                Spline: new DJ(this.eventContext),
                DynamicVariable: new O8(
                  this.eventContext,
                  this.sharedVariables,
                  this,
                  this.needsMouse,
                  this.needsRaycast
                ),
                Conditional: new D8(this.eventContext, this),
                Start: new O5(this.eventContext, this),
                Basic: new D0(this.eventContext, this, this.needsRaycast),
                MouseHover: new O0(this.eventContext, this),
                Scroll: new O3(this.eventContext, this),
                Follow: new OD(this.eventContext, this),
                DragDrop: new Oy(this.eventContext, this),
                LookAt: new OQ(this.eventContext),
                Resize: new I8(this.eventContext, this),
              });
            let { page: _, domElement: I } = this.eventContext;
            this.hideCursor && (I.style.cursor = "none"),
              _.traverseEntity((_) => {
                _.addEventListener("requestRender", this.requestRender);
              }),
              Object.values(this.handlers).forEach((_) => _.connect()),
              I.addEventListener("wheel", this.onMouseWheelPreventScroll),
              I.addEventListener("touchmove", this.onTouchMovePreventScroll),
              this.activateCount++;
          }
          deactivate() {
            if (!this.isEnabled) return;
            (this.isEnabled = !1),
              this.eventContext.domElement.removeEventListener(
                "pointermove",
                this.onMouseMove
              ),
              this.eventContext.domElement.removeEventListener(
                "pointerdown",
                this.onMouseDown
              ),
              this.eventContext.domElement.removeEventListener(
                "pointerup",
                this.onMouseUp
              ),
              (this.eventContext.sharedAssets.mouseProperty = null),
              (this.eventContext.sharedAssets.raycastProperty = null);
            let { page: _, domElement: I } = this.eventContext;
            (I.style.cursor = ""),
              Object.values(this.handlers).forEach((_) => _.disconnect()),
              this.controlsManager.gameControl?.disposeActions(),
              this.controlsManager.disconnectEvents(),
              _.traverseEntity((_) => {
                _.removeEventListener("requestRender", this.requestRender),
                  (_.destroyedInAction = !1);
              }),
              I.removeEventListener("touchmove", this.onTouchMovePreventScroll),
              I.removeEventListener("wheel", this.onMouseWheelPreventScroll),
              this.animationControls.onExitPlayMode();
          }
          get isPaused() {
            return this.isEnabled;
          }
          pause() {
            this.deactivate();
          }
          resume() {
            this.activate();
          }
          reset() {
            this.deactivate(),
              this.activate(),
              this.controlsManager.page.updateMatrixWorld(!0),
              this.controlsManager.rebuildBVH();
          }
          updateUseWindowEvents(_) {
            let I = this.isEnabled;
            I && this.deactivate(),
              (this.eventContext.useWindowEvents = _),
              I && this.activate();
          }
          initializeActionsDependentStates() {
            let _ = this.eventContext.sharedAssets;
            _.resetDynamicVariablePlayState();
            let e = (I) => {
              if (
                ("Conditional" === I.data.type &&
                  (I.data.ifActions.forEach(e), I.data.elseActions.forEach(e)),
                "Conditional" === I.data.type || "SetVariable" === I.data.type)
              )
                for (let _ of "Conditional" === I.data.type
                  ? I.data.condition
                  : I.data.expression)
                  "id" in _ &&
                    Array.isArray(_.id) &&
                    ("mouse" === _.id[0] && (this.needsMouse = !0),
                    "raycast" === _.id[0] && (this.needsRaycast = !0));
              "DynamicVariablePlay" === I.data.type &&
                "" !== I.data.variableId &&
                ("Play" === I.data.mode ||
                  "PlayPause" === I.data.mode ||
                  "Toggle" === I.data.mode) &&
                _.setDynamicVariablePlayState(I.data.variableId, "Stopped");
            };
            this.eventContext.page.traverseEntity((_) => {
              if (_.data?.events.length) {
                for (let I of _.data.events)
                  if (!I.data.disabled) {
                    if (
                      ("VariableChange" === I.data.type &&
                        ("mouseProperty" === I.data.variableId &&
                          (this.needsMouse = !0),
                        "raycastProperty" === I.data.variableId &&
                          (this.needsRaycast = !0)),
                      "Conditional" === I.data.type)
                    )
                      for (let _ of ["inActions", "outActions"])
                        I.data[_].forEach(e);
                    else if ("DragDrop" === I.data.type)
                      for (let _ of ["drag", "drop"])
                        I.data.dragDropActions[_].forEach(e);
                    else if ("GameControl" === I.data.type)
                      for (let _ of ["idle", "move", "jump", "run"])
                        I.data.gameActions[_].forEach(e);
                    else if ("Resize" === I.data.type)
                      for (let _ of I.data.breakpoints)
                        _.data.actions.forEach(e);
                    else "LookAt" === I.data.type || I.data.actions.forEach(e);
                  }
              }
            });
          }
        },
        Re = class {
          constructor(_, I, R, B, z) {
            (this._aspect = 1),
              (this.enableResponsive = !1),
              (this._renderer = _),
              (this._camera = I),
              (this._frameSize = new rs().copy(R)),
              (this._editorSize = new rs().copy(B)),
              (this._aspect = I.aspect),
              (this._fov = z ?? I.fov);
          }
          set frameSize(_) {
            this._frameSize.copy(_);
          }
          updateRenderer() {
            this._renderer &&
              this._renderer.setSize(this._frameSize.x, this._frameSize.y);
          }
          updateViewport() {
            if (
              !this._renderer ||
              !this._camera ||
              "PerspectiveCamera" !== this._camera.cameraType
            )
              return;
            let _ = this._frameSize.x,
              I = this._frameSize.y,
              R = this._editorSize.y;
            (this._aspect = _ / I),
              I <= R && (this._camera.zoom *= R / I),
              this._renderer.setViewport(0, 0, _, I);
          }
          updateCamera(_ = !0) {
            if (this._camera) {
              if ("PerspectiveCamera" === this._camera.cameraType) {
                let I = this._frameSize.y,
                  R = this._editorSize.y,
                  B = this._fov;
                if (_ && I > R)
                  B *= (I / R) * (1 - (((I - 1080) / 1080) * 14 + 1) / 100);
                (this._camera.aspect = this._aspect),
                  (this._camera.fov = B),
                  this._camera.updateProjectionMatrix();
              } else
                this._camera.setViewplaneSize(
                  this._frameSize.x,
                  this._frameSize.y,
                  this.enableResponsive
                );
            }
          }
          setCamera(_) {
            (this._camera = _), (this._aspect = _.aspect), (this._fov = _.fov);
          }
          revert() {
            let _ = window.innerWidth,
              I = window.innerHeight;
            this._renderer &&
              (this._renderer.setViewport(0, 0, _, I),
              this._renderer.setSize(_, I)),
              this._camera &&
                ((this._camera.aspect = _ / I),
                (this._camera.fov = this._fov),
                this._camera.setViewplaneSize(_, I, this.enableResponsive),
                this._camera.updateProjectionMatrix());
          }
        },
        Ri = class {
          get sharedAssets() {
            return this.shared;
          }
          constructor(_, I = {}) {
            (this.shared = new SQ(_.shared, I)),
              (this.scene = new T7(_.scene, this.sharedAssets)),
              this.shared.setEntityOpContext({
                scene: this.scene,
                shared: this.shared,
              });
          }
          reset(_, I) {
            this.scene.clearScene(),
              this.sharedAssets.reset(_.shared),
              this.scene.resetAfterClear(_.scene, this.sharedAssets);
          }
          resetPersonalCameraFromDocumentData() {
            for (let _ of this.scene.children)
              _ instanceof C6 &&
                !_.uiScene &&
                _.personalCamera.updateState(_.data.camera, {
                  scene: this.scene,
                  shared: this.shared,
                });
          }
          dispose() {
            this.scene.dispose(), this.shared.dispose();
          }
          gc() {
            this.shared.geometryCache.startGc(),
              this.shared.geometryCache2.startGc(),
              this.scene.traverseEntity((_) => {
                _ instanceof S2 && _.markGeometryAsReachable(this.shared);
              }),
              this.shared.geometryCache.endGc(),
              this.shared.geometryCache2.endGc();
          }
        },
        Rr = class {
          constructor({ x: _ = 10, y: I = 10 }) {
            this._startTime = 0;
            let R = document.getElementById("spe-perfs");
            R
              ? (this.element = R)
              : ((this.element = document.createElement("div")),
                document.body.appendChild(this.element),
                (this.element.style.position = "absolute"),
                (this.element.style.zIndex = "10000"),
                (this.element.style.fontFamily = "monospace"),
                (this.element.style.background = "black"),
                (this.element.style.color = "white"),
                (this.element.style.padding = "10px"),
                (this.element.style.opacity = "0.5"),
                (this.element.style.fontSize = "11px"),
                this.element.setAttribute("id", "spe-perfs")),
              (this.element.style.left = `${_}px`),
              (this.element.style.top = `${I}px`);
          }
          dispose() {
            this.element.parentElement?.removeChild(this.element);
          }
          start() {
            this._startTime = performance.now();
          }
          end() {
            let _ = performance.now() - this._startTime;
            this.element.innerHTML = _.toFixed(3) + " ms";
          }
        };
      function Rg(_) {
        return _ instanceof S5
          ? "SubdivObject"
          : "NonParametricGeometry" === _.geometry.type
          ? "NonParametric"
          : "Mesh";
      }
      var Rs = pi(i2(), 1),
        Ro = new rs(),
        Rl = class {
          constructor(_, { renderOnDemand: I, renderMode: R = "auto" } = {}) {
            (this._viewportMode = 1),
              (this._viewportWidth = window.innerWidth),
              (this._viewportHeight = window.innerHeight),
              (this._proxyObjectCache = new Map()),
              (this._variablesCache = new Map()),
              (this._isPaused = !1),
              (this._renderRequested = !1),
              (this._skipRender = !1),
              (this.time = performance.now()),
              (this.dt = 0),
              (this.currentTAAFrame = 0),
              (this.disposed = !1),
              (this._requestRenderAutoMode = () => {
                this._skipRender = !1;
              }),
              (this.requestRender = () => {
                this._renderRequested = !0;
              }),
              (this.render = (_) => {
                if (
                  ((this.time = _),
                  this._lastTime && (this.dt = this.time - this._lastTime),
                  (this._lastTime = this.time),
                  this._perfs?.start(),
                  !this._renderer ||
                    (!this._isPaused &&
                      (("manual" === this.renderMode &&
                        !this._renderRequested) ||
                        ("auto" === this.renderMode && this._skipRender))))
                ) {
                  this._perfs?.end();
                  return;
                }
                if (
                  ((this._renderRequested = !1),
                  (this._skipRender = !0),
                  this._controls &&
                    (this._skipRender = this._controls.update(this.dt)),
                  this._eventManager &&
                    (this._eventManager.handlers?.Start.hasVideoAction ||
                      this._eventManager.handlers?.Basic.hasVideoAction ||
                      this._eventManager.handlers?.Conditional
                        .hasVideoAction) &&
                    (this._skipRender = !1),
                  this._animationControls?.update(this.dt),
                  this._skipRender
                    ? (this.currentTAAFrame++,
                      this.currentTAAFrame < 32
                        ? (this._skipRender = !1)
                        : (this.currentTAAFrame = 0))
                    : (this.currentTAAFrame = 0),
                  this._scene?.traverseVisibleEntity((_) => {
                    "ParticleSystem" === _.type &&
                      (_.update(this.dt), (this._skipRender = !1));
                  }),
                  this._scene &&
                    this._scene.activeCamera !== this._camera &&
                    (this._camera = this._scene.activeCamera),
                  this._eventManager?.isEnabled &&
                    (this._eventManager.handlers?.Follow.onAnimationFrameDamping(),
                    this._eventManager.handlers?.LookAt.onAnimationFrameDamping(),
                    this._eventManager.handlers?.DragDrop.onAnimationFrameDamping()),
                  this._scene && this._camera)
                ) {
                  if (
                    (this._scene.pathConstraints.applyConstraints(this._scene),
                    this._renderer.sceneTransitionTimeRemaining > 0)
                  ) {
                    this._renderer.sceneTransitionTimeRemaining -= this.dt;
                    let _ =
                      1 -
                      this._renderer.sceneTransitionTimeRemaining /
                        this._renderer.sceneTransitionDuration;
                    (this._renderer.pipeline.sceneTransitionPass.uniforms.mixRatio.value =
                      _),
                      (this._skipRender = !1);
                  } else
                    this._renderer.pipeline.sceneTransitionFromTexture = null;
                  this._renderer.renderSplineScene(this._scene, this._camera);
                }
                this.canvas.dispatchEvent(this._renderedEvent),
                  this._perfs?.end();
              }),
              (this._resize = () => {
                if (this._renderer) {
                  if (
                    (1 === this._viewportMode &&
                      this._frameView &&
                      (this._frameView.frameSize = Ro.set(
                        this._viewportWidth,
                        this._viewportHeight
                      )),
                    this._renderer.setSize(
                      this._viewportWidth,
                      this._viewportHeight,
                      !1
                    ),
                    (this._camera = this._scene?.activeCamera),
                    this._scene?.updateViewPlaneSize(
                      this._frameView?.frameSize?.x ?? this._viewportWidth,
                      this._frameView?.frameSize?.y ?? this._viewportHeight,
                      this._frameView?.enableResponsive ?? !1
                    ),
                    this._camera)
                  ) {
                    let _ =
                      Object.values(this._data?.frames ?? {})[0].preset ??
                      "fullscreen";
                    this._frameView?.setCamera(this._camera),
                      this._frameView?.updateCamera("fullscreen" !== _),
                      "PerspectiveCamera" === this._camera.cameraType &&
                        (this._camera.aspect =
                          this._viewportWidth / this._viewportHeight),
                      this._camera.updateProjectionMatrix();
                  }
                  this.eventManager &&
                    (this.eventManager.eventContext.domRect =
                      this.canvas.getBoundingClientRect()),
                    this._requestRenderAutoMode();
                }
              }),
              (this._debouncedResize = Nc(this._resize, 10)),
              (this._onScroll = (_) => {
                this.eventManager &&
                  (this.eventManager.eventContext.domRect =
                    this.canvas.getBoundingClientRect());
              }),
              (this.canvas = _),
              (this.renderMode = I ? "auto" : R),
              (this._renderedEvent = new CustomEvent("rendered", {
                bubbles: !0,
              })),
              Object.defineProperty(this._renderedEvent, "target", {
                writable: !1,
                value: this,
              }),
              window.location.search.includes("perfs") &&
                (this._perfs = new Rr({ x: 10, y: 10 })),
              _.addEventListener("pointerdown", V2, !0),
              _.addEventListener("pointerdown", wv, !0),
              _.addEventListener("pointermove", wv, !0),
              _.addEventListener("pointerup", Uh, !0),
              _.addEventListener("pointercancel", Uh, !0),
              _.addEventListener("pointerleave", Uh, !0),
              window.addEventListener("keydown", U2, !0),
              window.addEventListener("keyup", G2, !0);
          }
          async load(_, I, R) {
            let B;
            (B =
              "The Spline Runtime only accepts .splinecode files that are generated from Spline export panel."),
              _.endsWith(".spline")
                ? console.warn(
                    B +
                      " The .spline files are only meant to be used by the Editor."
                  )
                : _.endsWith(".splinecode") || console.warn(B),
              (this.disposed = !1);
            let z = await (await fetch(_, R)).arrayBuffer();
            await this.start(z, { variables: I });
          }
          async start(_, { interactive: I = !0, variables: B } = {}) {
            let z, k;
            if (this.disposed) return;
            let V = await qN(_);
            (this._data = V),
              V.version &&
                (0, Rs.default)(V.version, "1.0.53") > 0 &&
                console.warn(
                  "Your .splinecode file is more recent than the library. Please upgrade @splinetool/runtime to the latest version."
                ),
              await Promise.all(
                [
                  I_(V) &&
                    (_q ||
                      (_q = (async function () {
                        let _ = R.e(6669).then(R.bind(R, 76669)),
                          [I, B] = await Promise.all([
                            _,
                            fetch(
                              "https://unpkg.com/@splinetool/boolean-wasm@1.0.53/build/boolean.wasm"
                            ).then((_) => _.arrayBuffer()),
                          ]),
                          z = I.default,
                          k = await z({ wasmBinary: B });
                        _G(k);
                      })())),
                  ((z = !1),
                  V.scene.objects.traverse((_, I) => {
                    "Mesh" === I.type &&
                      "SubdivGeometry" === I.geometry.type &&
                      (z = !0);
                  }),
                  z &&
                    (function () {
                      if (!bZ) return b$ || (b$ = n());
                      async function n() {
                        let _ = R.e(6256).then(R.bind(R, 86256)),
                          [I, B] = await Promise.all([
                            _,
                            fetch(
                              "https://unpkg.com/@splinetool/modelling-wasm@1.0.53/build/process.wasm"
                            ).then((_) => _.arrayBuffer()),
                          ]),
                          z = I.default,
                          k = await z({ wasmBinary: B });
                        bq(k), (bZ = !0);
                      }
                    })()),
                  vM.physicsEnabled(V.scene.objects) &&
                    (uk ||
                      (uk = (async function () {
                        let _ = await R.e(6122).then(R.bind(R, 20330));
                        await _.init(), uO(_);
                      })())),
                  __(V) &&
                    (function () {
                      if (((SN = !0), !SV)) return Ap || (Ap = n());
                      async function n() {
                        let _ = await R.e(7934).then(R.bind(R, 856));
                        SI(_), (SV = !0);
                      }
                    })(),
                  H_(V) &&
                    (function () {
                      if (!Cz) return Ck || (Ck = n());
                      async function n() {
                        let _ = await R.e(4778).then(R.bind(R, 44778));
                        CT(_.default ?? _), (Cz = !0);
                      }
                    })(),
                  ((k = !1),
                  V.scene.objects.forEach((_) => {
                    "Page" === _.data.type &&
                      !k &&
                      _.data.publish.gameControlObject &&
                      vM.traverseModuleInstances(V, _.id, (_, I, R) => {
                        for (let _ of R)
                          "GameControl" === _.data.type &&
                            _.data.navmesh.enabled &&
                            (k = !0);
                      });
                  }),
                  k &&
                    (uP ||
                      (uP = (async function () {
                        let _ = R.e(2275).then(R.bind(R, 72275)),
                          [I, B] = await Promise.all([
                            _,
                            fetch(
                              "https://unpkg.com/@splinetool/navmesh-wasm@1.0.53/build/navmesh.wasm"
                            ).then((_) => _.arrayBuffer()),
                          ]),
                          z = I.default,
                          k = await z({ wasmBinary: B });
                        uT(k);
                      })()))),
                ].filter(Boolean)
              ),
              this._eventManager?.deactivate(),
              this._controls?.deactivate(),
              this._scene?.dispose();
            let j = new Ri(V);
            if (
              (j.resetPersonalCameraFromDocumentData(),
              (this._scene = j.scene),
              (this._sharedAssetsManager = j.sharedAssets),
              (this._camera = this._scene.activeCamera),
              window.location.search.includes("merge-geometries"))
            ) {
              let _ = performance.now();
              !(function (_, I) {
                let R, B;
                let z =
                    ((R = {}),
                    I.traverseEntity((I) => {
                      if (
                        !I.visible ||
                        !(I instanceof wp) ||
                        "Mesh" !== I.type ||
                        Array.isArray(I.material) ||
                        (I.states && Object.keys(I.states).length)
                      )
                        return;
                      let B = I.parent;
                      for (; B; ) {
                        if (
                          B instanceof wp &&
                          I.states &&
                          Object.keys(I.states).length
                        )
                          return;
                        B = B.parent;
                      }
                      let z = I.material.uuid,
                        k = _.shared.materials[z];
                      if (k) {
                        if (!gG.isMergable(k)) return;
                      } else {
                        let R = _.scene.objects.get(I.uuid)?.data;
                        if (
                          R &&
                          "material" in R &&
                          "string" != typeof R.material
                        ) {
                          if (!gG.isMergable(R.material)) return;
                          z = gG.getHash(R.material);
                        }
                      }
                      R[z] || (R[z] = {});
                      let V = R[z][Rg(I)];
                      if (V) {
                        if ((V.push(I), I.cloner))
                          for (let _ of I.cloner.children) V.push(_);
                      } else if (((R[z][Rg(I)] = [I]), I.cloner))
                        for (let _ of I.cloner.children) R[z][Rg(I)].push(_);
                    }),
                    R),
                  k =
                    ((B = 0),
                    Object.values(z).forEach((_) => {
                      Object.values(_).forEach((_) => {
                        let I = _.length;
                        I > B && (B = I);
                      });
                    }),
                    B),
                  V = Array(k),
                  j = 0,
                  G = Array(k),
                  q = 0,
                  X = Array(k),
                  Q = 0,
                  $ = Array(k),
                  et = 0;
                for (let [_, R] of Object.entries(z))
                  for (let B of Object.values(R)) {
                    if (
                      ((q = 0),
                      (Q = 0),
                      B.forEach((_) => {
                        _ instanceof wp &&
                          ((G[q++] = _.geometry.clone()), (X[Q++] = _));
                      }),
                      Q < 2)
                    )
                      continue;
                    for (let _ = 0; _ < Q; _++)
                      X[_].updateWorldMatrix(!0, !1),
                        G[_].applyMatrix4(X[_].matrixWorld),
                        0 > X[_].matrixWorld.determinant() &&
                          (function (_) {
                            let I;
                            if (_.index)
                              for (let R = 0; R < _.index.array.length; R += 3)
                                (I = _.index.array[R]),
                                  (_.index.array[R] = _.index.array[R + 2]),
                                  (_.index.array[R + 2] = I);
                          })(G[_]);
                    let R = $s(G.slice(0, q), !1);
                    if (R) {
                      let B;
                      "SubdivObject" === _ &&
                        console.warn("Turning subdiv object into mesh"),
                        ((B = new aw(R, X[0].material)).castShadow =
                          X[0].castShadow),
                        (B.receiveShadow = X[0].receiveShadow),
                        I.add(B);
                      let y = (_) => {
                        for (let I of ((et = 0), _))
                          I.children && y(I.children),
                            I instanceof wp &&
                              (Array.isArray(I.material) ||
                                (z[I.material.uuid] &&
                                  z[I.material.uuid][Rg(I)] &&
                                  z[I.material.uuid][Rg(I)].length > 1) ||
                                ($[et++] = I));
                        for (let _ = 0; _ < et; _++) I.attach($[_]);
                      };
                      for (let _ = 0; _ < Q; _++) {
                        let I = X[_];
                        y(I.children), (V[j++] = I);
                      }
                    }
                  }
                for (let _ = 0; _ < j; _++) V[_].removeFromParent();
              })(V, j.scene),
                console.log(
                  "Merged geometries in ",
                  performance.now() - _,
                  " ms"
                );
            }
            I_(V) &&
              this._scene.traverse((_) => {
                Rn(_) && _.recomputeBoolean();
              }),
              this._sharedAssetsManager.setRequestRender(() => {
                this._requestRenderAutoMode(),
                  this._scene?.traverse((_) => {
                    _ instanceof AI && _.pendingMediaLoad && _.update();
                  });
              }),
              this._scene?.traverse((_) => {
                "ParticleSystem" === _.type &&
                  (_.wakeUp(), _.data.autoPlay ? _.start() : _.stop());
              });
            let G = Object.keys(V.shared.fonts).map(
              (_) => this._sharedAssetsManager.getFont(_).loadingPromise
            );
            if (
              (Promise.all(G).then(() => {
                j.scene.markNeedsUpdateRendererDirty(),
                  this._requestRenderAutoMode();
              }),
              __(V) &&
                (function (_) {
                  if (vM.physicsEnabled(_.scene.objects)) return !0;
                  let I = !1;
                  return (
                    _.scene.objects.traverse((_, R) => {
                      if (R.events) {
                        if (Array.isArray(R.events)) {
                          for (let _ of R.events)
                            if (
                              !0 !== _.data.disabled &&
                              "GameControl" === _.data.type &&
                              _.data.collisionEnabled
                            ) {
                              I = !0;
                              break;
                            }
                        } else
                          for (let _ of Object.values(R.events))
                            if (
                              !0 !== _.disabled &&
                              "GameControl" === _.type &&
                              _.collisionEnabled
                            ) {
                              I = !0;
                              break;
                            }
                      }
                    }),
                    I
                  );
                })(V) &&
                (await Promise.all(G)),
              H_(V))
            ) {
              let _ = [];
              this._scene.traverseEntity((I) => {
                (I instanceof Ti || I instanceof C6) &&
                  I.uiCanvas &&
                  _.push(I.uiCanvas);
              }),
                await Promise.all(_.map((_) => _.promise));
            }
            this._scene.rewriteEventsBeforeGoToPlayMode(),
              qf(this._scene.activePage, this._sharedAssetsManager),
              this._renderer ||
                ((this._renderer = new Cl({
                  canvas: this.canvas,
                  antialias: !1,
                  alpha: !0,
                  stencil: !1,
                  depth: !1,
                  powerPreference: "high-performance",
                })),
                (this._renderer.hdTransmission =
                  !0 === V.scene.publish.hdTransmission),
                this._renderer.setPixelRatio(window.devicePixelRatio),
                this._renderer.pipeline.enableUIOverlay(),
                this._renderer.pipeline.addEventListener(
                  "smaaloaded",
                  this._requestRenderAutoMode
                )),
              this._scene.initializeSplatViewer(this._renderer),
              void 0 !== V.scene.blueNoiseTextureData &&
                this._renderer.pipeline.updateBlueNoiseTexture(
                  V.scene.blueNoiseTextureData
                );
            let q = Object.values(V.frames)[0];
            if (
              (this._frameView
                ? this._frameView.setCamera(this._camera)
                : ("fullscreen" === q.preset
                    ? ((this._viewportMode = 1),
                      (this.canvas.style.display = "block"),
                      this.canvas.parentElement &&
                        ((this._viewportWidth =
                          this.canvas.parentElement.clientWidth || 300),
                        (this.canvas.style.width = "100%")),
                      this.canvas.parentElement &&
                        ((this._viewportHeight =
                          this.canvas.parentElement.clientHeight || 150),
                        (this.canvas.style.height = "100%")))
                    : ((this._viewportMode = 2),
                      (this._viewportWidth = q.size[0]),
                      (this._viewportHeight = q.size[1]),
                      (this.canvas.style.width = `${this._viewportWidth}px`),
                      (this.canvas.style.height = `${this._viewportHeight}px`)),
                  this._renderer.setSize(
                    this._viewportWidth,
                    this._viewportHeight,
                    !1
                  ),
                  (this._frameView = new Re(
                    this._renderer,
                    this._camera,
                    new rs(this._viewportWidth, this._viewportHeight),
                    new rs(window.innerWidth, window.innerHeight)
                  )),
                  (this._frameView.enableResponsive =
                    (q.allowResponsive ?? !1) && "fullscreen" === q.preset)),
              I)
            ) {
              let _ = new DQ(
                this._renderer,
                this.data.scene.publish,
                this._scene,
                () => this._scene.activeCamera,
                this._sharedAssetsManager,
                this._requestRenderAutoMode,
                !0,
                q
              );
              this._scene.updateMatrixWorld(!0),
                (this._controls = new I0(_)),
                (this._animationControls = new I3(
                  this._scene,
                  this._requestRenderAutoMode
                )),
                (this._eventManager = new I7(
                  V.scene.publish,
                  this._controls,
                  this._animationControls,
                  _,
                  V.shared.variables
                )),
                this._eventManager.activate(),
                this._controls.activate(this._eventManager);
            }
            this._resize(),
              void 0 !== B && this.setVariables(B),
              0 === this.dt &&
                (this.render(performance.now()),
                setTimeout(() => {
                  this._renderer?.setAnimationLoop(this.render);
                }, 0)),
              (this._resizeObserverTimeout = setTimeout(() => {
                !this._resizeObserver &&
                  this.canvas.parentElement &&
                  ((this._resizeObserver = new ResizeObserver(() => {
                    (this._viewportWidth = this.canvas.clientWidth),
                      (this._viewportHeight = this.canvas.clientHeight),
                      this._debouncedResize();
                  })),
                  this._resizeObserver.observe(this.canvas.parentElement));
              }, 300)),
              document.addEventListener("scroll", this._onScroll);
          }
          setVariables(_) {
            if (void 0 !== this._data)
              for (let [I, R] of Object.entries(_)) this.setVariable(I, R);
          }
          setVariable(_, I) {
            let R = this._getVariableByName(_);
            if (!R || "dynamicVariableType" in R.data)
              void 0 === R
                ? console.warn(
                    `No variable named ${_} was found in your Spline file. Make sure to create it from Spline editor.`
                  )
                : "dynamicVariableType" in R.data &&
                  console.warn(
                    `Dynamic variables like ${_} cannot be updated from code.`
                  );
            else {
              let _ = I;
              "number" == typeof R.data.value
                ? (_ =
                    "number" == typeof I
                      ? I
                      : "boolean" == typeof I
                      ? !0 === I
                        ? 1
                        : 0
                      : parseFloat(I))
                : "boolean" == typeof R.data.value
                ? (_ =
                    "number" == typeof I
                      ? !!I
                      : "boolean" == typeof I
                      ? I
                      : "false" !== I.toLocaleLowerCase() && !!I)
                : "string" != typeof R.data.value &&
                  void 0 !== R.data.value.textValue &&
                  (_ = I.toString());
              let B = "string" == typeof _ ? { textValue: _ } : _;
              this._sharedAssetsManager?.updateVariable(R.id, B),
                this.requestRender(),
                this._requestRenderAutoMode();
            }
          }
          getVariables() {
            let _ = {};
            return (
              this._data &&
                this._data.shared.variables.forEach((I) => {
                  void 0 === _[I.data.name] &&
                    (_[I.data.name] = this._getVariableValue(
                      this._sharedAssetsManager.getVariable(I.id)
                    ));
                }),
              _
            );
          }
          getVariable(_) {
            let I = this._getVariableByName(_);
            if (I) {
              let _ = this._sharedAssetsManager.getVariable(I.id);
              return this._getVariableValue(_);
            }
          }
          _getVariableValue(_) {
            return "string" != typeof _ && vR.isTextValue(_)
              ? vR.getDisplayedValue(_)
              : _;
          }
          _getVariableByName(_) {
            if (this._data) {
              if (this._variablesCache.has(_))
                return this._variablesCache.get(_);
              let I = this._data.shared.variables.find(
                (I) => I.data.name === _
              );
              return I && this._variablesCache.set(_, I), I;
            }
          }
          findObjectById(_) {
            let I = this._scene?.getObjectByProperty("uuid", _);
            return this._createProxyObject(I);
          }
          findObjectByName(_) {
            let I = this._scene?.getObjectByName(_);
            return this._createProxyObject(I);
          }
          getAllObjects() {
            let _ = [];
            return (
              this._scene?.traverseEntity((I) => {
                if (
                  I.uuid !== fx &&
                  !this._scene.isInvisibleObjects(I) &&
                  !(I instanceof C6)
                ) {
                  let R = this._createProxyObject(I);
                  R && _.push(R);
                }
              }),
              _
            );
          }
          getSplineEvents() {
            return this._eventManager?.handlers?.Spline.splineEvents;
          }
          emitEvent(_, I) {
            (this.findObjectById(I) || this.findObjectByName(I))?.emitEvent(_);
          }
          emitEventReverse(_, I) {
            (
              this.findObjectById(I) || this.findObjectByName(I)
            )?.emitEventReverse(_);
          }
          addEventListener(_, I) {
            this.canvas.addEventListener(_, I);
          }
          removeEventListener(_, I) {
            this.canvas.removeEventListener(_, I);
          }
          setZoom(_) {
            this._controls?.orbitControls instanceof II &&
              this._controls?.orbitControls.zoomOut(_);
          }
          get eventManager() {
            return this._eventManager;
          }
          get controls() {
            return this._controls;
          }
          setSize(_, I) {
            (this._viewportWidth = _),
              (this._viewportHeight = I),
              (this._viewportMode = 2),
              this._resize();
          }
          setBackgroundColor(_) {
            let { r: I, g: R, b: B, a: z } = { r: 0, g: 0, b: 0, a: 1 },
              k = new wA(I, R, B, z);
            try {
              k.setStyle(_);
            } catch {
              console.error("This is not a valid css color", _);
            }
            this._scene?.activePage.setBackgroundColor(k),
              this._requestRenderAutoMode();
          }
          dispose() {
            var _;
            (this.disposed = !0),
              this._eventManager?.deactivate(),
              this._scene?.dispose(),
              this._sharedAssetsManager?.dispose(),
              this._proxyObjectCache.forEach((_) => {
                Gw.unsubscribe(_);
              }),
              this._variablesCache.clear(),
              this._renderer?.setAnimationLoop(null),
              this._renderer?.dispose(),
              (this._renderer = void 0),
              this._sharedAssetsManager?.dispose(),
              this._resizeObserver &&
                (this._resizeObserver.disconnect(),
                (this._resizeObserver = void 0)),
              void 0 !== this._resizeObserverTimeout &&
                clearTimeout(this._resizeObserverTimeout),
              (this.canvas.style.width = ""),
              (this.canvas.style.height = ""),
              this.canvas.removeAttribute("width"),
              this.canvas.removeAttribute("height"),
              this._frameView && (this._frameView = void 0),
              this._controls?.deactivate(),
              (_ = this.canvas).removeEventListener("pointerdown", V2, !0),
              _.removeEventListener("pointerdown", wv, !0),
              _.removeEventListener("pointermove", wv, !0),
              _.removeEventListener("pointerup", Uh, !0),
              _.removeEventListener("pointercancel", Uh, !0),
              _.removeEventListener("pointerleave", Uh, !0),
              window.removeEventListener("keydown", U2, !0),
              window.removeEventListener("keyup", G2, !0),
              document.removeEventListener("scroll", this._onScroll);
          }
          get isStopped() {
            return this._isPaused;
          }
          stop() {
            this._isPaused ||
              (this._renderer?.setAnimationLoop(null),
              (this._isPaused = !0),
              this._eventManager?.pause(),
              this._controls?.orbitControls &&
                (this._controls.orbitControls.enabled = !1));
          }
          play() {
            this._isPaused &&
              ((this._isPaused = !1),
              this._eventManager?.resume(),
              this._controls?.orbitControls &&
                (this._controls.orbitControls.enabled = !0),
              this._renderer?.setAnimationLoop(this.render));
          }
          setGlobalEvents(_) {
            this._eventManager?.updateUseWindowEvents(_);
          }
          get data() {
            return this._data;
          }
          _createProxyObject(_) {
            let I;
            if (null == _) return;
            if (this._proxyObjectCache.has(_.uuid))
              return this._proxyObjectCache.get(_.uuid);
            _.traverseAncestors((_) => {
              _ instanceof C6 && (I = _.name);
            });
            let R = Gw(
              {
                name: _.name,
                uuid: _.uuid,
                visible: _.visible,
                intensity: _.intensity,
                position: _.position,
                rotation: _.rotation,
                scale: _.scale,
                type: _.data.type,
                page: I,
                parentUuid:
                  _.parent instanceof C6 || _ instanceof T7
                    ? void 0
                    : _.parent?.uuid,
                emitEvent(I) {
                  _.dispatchEvent({ type: "userEvent", eventName: I });
                },
                emitEventReverse(I) {
                  _.dispatchEvent({
                    type: "userEvent",
                    eventName: I,
                    reverse: !0,
                  });
                },
              },
              (I, R) => {
                "object" != typeof _[I] &&
                  Object.getOwnPropertyDescriptor(_, I)?.writable &&
                  (_[I] = R),
                  this._requestRenderAutoMode(),
                  _.updateMatrix();
              }
            );
            return this._proxyObjectCache.set(_.uuid, R), R;
          }
          setUIWasmUrl(_) {
            _Z.skiaWasmUrl = _;
          }
        };
    },
  },
]);
